/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/app.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/diff/dist/diff.js":
/*!****************************************!*\
  !*** ./node_modules/diff/dist/diff.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("(function (global, factory) {\n   true ? factory(exports) :\n  undefined;\n}(this, (function (exports) { 'use strict';\n\n  function Diff() {}\n  Diff.prototype = {\n    diff: function diff(oldString, newString) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var callback = options.callback;\n\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n\n      this.options = options;\n      var self = this;\n\n      function done(value) {\n        if (callback) {\n          setTimeout(function () {\n            callback(undefined, value);\n          }, 0);\n          return true;\n        } else {\n          return value;\n        }\n      } // Allow subclasses to massage the input prior to running\n\n\n      oldString = this.castInput(oldString);\n      newString = this.castInput(newString);\n      oldString = this.removeEmpty(this.tokenize(oldString));\n      newString = this.removeEmpty(this.tokenize(newString));\n      var newLen = newString.length,\n          oldLen = oldString.length;\n      var editLength = 1;\n      var maxEditLength = newLen + oldLen;\n      var bestPath = [{\n        newPos: -1,\n        components: []\n      }]; // Seed editLength = 0, i.e. the content starts with the same values\n\n      var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);\n\n      if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\n        // Identity per the equality and tokenizer\n        return done([{\n          value: this.join(newString),\n          count: newString.length\n        }]);\n      } // Main worker method. checks all permutations of a given edit length for acceptance.\n\n\n      function execEditLength() {\n        for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {\n          var basePath = void 0;\n\n          var addPath = bestPath[diagonalPath - 1],\n              removePath = bestPath[diagonalPath + 1],\n              _oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;\n\n          if (addPath) {\n            // No one else is going to attempt to use this value, clear it\n            bestPath[diagonalPath - 1] = undefined;\n          }\n\n          var canAdd = addPath && addPath.newPos + 1 < newLen,\n              canRemove = removePath && 0 <= _oldPos && _oldPos < oldLen;\n\n          if (!canAdd && !canRemove) {\n            // If this path is a terminal then prune\n            bestPath[diagonalPath] = undefined;\n            continue;\n          } // Select the diagonal that we want to branch from. We select the prior\n          // path whose position in the new string is the farthest from the origin\n          // and does not pass the bounds of the diff graph\n\n\n          if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {\n            basePath = clonePath(removePath);\n            self.pushComponent(basePath.components, undefined, true);\n          } else {\n            basePath = addPath; // No need to clone, we've pulled it from the list\n\n            basePath.newPos++;\n            self.pushComponent(basePath.components, true, undefined);\n          }\n\n          _oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath); // If we have hit the end of both strings, then we are done\n\n          if (basePath.newPos + 1 >= newLen && _oldPos + 1 >= oldLen) {\n            return done(buildValues(self, basePath.components, newString, oldString, self.useLongestToken));\n          } else {\n            // Otherwise track this path as a potential candidate and continue.\n            bestPath[diagonalPath] = basePath;\n          }\n        }\n\n        editLength++;\n      } // Performs the length of edit iteration. Is a bit fugly as this has to support the\n      // sync and async mode which is never fun. Loops over execEditLength until a value\n      // is produced.\n\n\n      if (callback) {\n        (function exec() {\n          setTimeout(function () {\n            // This should not happen, but we want to be safe.\n\n            /* istanbul ignore next */\n            if (editLength > maxEditLength) {\n              return callback();\n            }\n\n            if (!execEditLength()) {\n              exec();\n            }\n          }, 0);\n        })();\n      } else {\n        while (editLength <= maxEditLength) {\n          var ret = execEditLength();\n\n          if (ret) {\n            return ret;\n          }\n        }\n      }\n    },\n    pushComponent: function pushComponent(components, added, removed) {\n      var last = components[components.length - 1];\n\n      if (last && last.added === added && last.removed === removed) {\n        // We need to clone here as the component clone operation is just\n        // as shallow array clone\n        components[components.length - 1] = {\n          count: last.count + 1,\n          added: added,\n          removed: removed\n        };\n      } else {\n        components.push({\n          count: 1,\n          added: added,\n          removed: removed\n        });\n      }\n    },\n    extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {\n      var newLen = newString.length,\n          oldLen = oldString.length,\n          newPos = basePath.newPos,\n          oldPos = newPos - diagonalPath,\n          commonCount = 0;\n\n      while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {\n        newPos++;\n        oldPos++;\n        commonCount++;\n      }\n\n      if (commonCount) {\n        basePath.components.push({\n          count: commonCount\n        });\n      }\n\n      basePath.newPos = newPos;\n      return oldPos;\n    },\n    equals: function equals(left, right) {\n      if (this.options.comparator) {\n        return this.options.comparator(left, right);\n      } else {\n        return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();\n      }\n    },\n    removeEmpty: function removeEmpty(array) {\n      var ret = [];\n\n      for (var i = 0; i < array.length; i++) {\n        if (array[i]) {\n          ret.push(array[i]);\n        }\n      }\n\n      return ret;\n    },\n    castInput: function castInput(value) {\n      return value;\n    },\n    tokenize: function tokenize(value) {\n      return value.split('');\n    },\n    join: function join(chars) {\n      return chars.join('');\n    }\n  };\n\n  function buildValues(diff, components, newString, oldString, useLongestToken) {\n    var componentPos = 0,\n        componentLen = components.length,\n        newPos = 0,\n        oldPos = 0;\n\n    for (; componentPos < componentLen; componentPos++) {\n      var component = components[componentPos];\n\n      if (!component.removed) {\n        if (!component.added && useLongestToken) {\n          var value = newString.slice(newPos, newPos + component.count);\n          value = value.map(function (value, i) {\n            var oldValue = oldString[oldPos + i];\n            return oldValue.length > value.length ? oldValue : value;\n          });\n          component.value = diff.join(value);\n        } else {\n          component.value = diff.join(newString.slice(newPos, newPos + component.count));\n        }\n\n        newPos += component.count; // Common case\n\n        if (!component.added) {\n          oldPos += component.count;\n        }\n      } else {\n        component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));\n        oldPos += component.count; // Reverse add and remove so removes are output first to match common convention\n        // The diffing algorithm is tied to add then remove output and this is the simplest\n        // route to get the desired output with minimal overhead.\n\n        if (componentPos && components[componentPos - 1].added) {\n          var tmp = components[componentPos - 1];\n          components[componentPos - 1] = components[componentPos];\n          components[componentPos] = tmp;\n        }\n      }\n    } // Special case handle for when one terminal is ignored (i.e. whitespace).\n    // For this case we merge the terminal into the prior string and drop the change.\n    // This is only available for string mode.\n\n\n    var lastComponent = components[componentLen - 1];\n\n    if (componentLen > 1 && typeof lastComponent.value === 'string' && (lastComponent.added || lastComponent.removed) && diff.equals('', lastComponent.value)) {\n      components[componentLen - 2].value += lastComponent.value;\n      components.pop();\n    }\n\n    return components;\n  }\n\n  function clonePath(path) {\n    return {\n      newPos: path.newPos,\n      components: path.components.slice(0)\n    };\n  }\n\n  var characterDiff = new Diff();\n  function diffChars(oldStr, newStr, options) {\n    return characterDiff.diff(oldStr, newStr, options);\n  }\n\n  function generateOptions(options, defaults) {\n    if (typeof options === 'function') {\n      defaults.callback = options;\n    } else if (options) {\n      for (var name in options) {\n        /* istanbul ignore else */\n        if (options.hasOwnProperty(name)) {\n          defaults[name] = options[name];\n        }\n      }\n    }\n\n    return defaults;\n  }\n\n  //\n  // Ranges and exceptions:\n  // Latin-1 Supplement, 0080–00FF\n  //  - U+00D7  × Multiplication sign\n  //  - U+00F7  ÷ Division sign\n  // Latin Extended-A, 0100–017F\n  // Latin Extended-B, 0180–024F\n  // IPA Extensions, 0250–02AF\n  // Spacing Modifier Letters, 02B0–02FF\n  //  - U+02C7  ˇ &#711;  Caron\n  //  - U+02D8  ˘ &#728;  Breve\n  //  - U+02D9  ˙ &#729;  Dot Above\n  //  - U+02DA  ˚ &#730;  Ring Above\n  //  - U+02DB  ˛ &#731;  Ogonek\n  //  - U+02DC  ˜ &#732;  Small Tilde\n  //  - U+02DD  ˝ &#733;  Double Acute Accent\n  // Latin Extended Additional, 1E00–1EFF\n\n  var extendedWordChars = /^[A-Za-z\\xC0-\\u02C6\\u02C8-\\u02D7\\u02DE-\\u02FF\\u1E00-\\u1EFF]+$/;\n  var reWhitespace = /\\S/;\n  var wordDiff = new Diff();\n\n  wordDiff.equals = function (left, right) {\n    if (this.options.ignoreCase) {\n      left = left.toLowerCase();\n      right = right.toLowerCase();\n    }\n\n    return left === right || this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right);\n  };\n\n  wordDiff.tokenize = function (value) {\n    // All whitespace symbols except newline group into one token, each newline - in separate token\n    var tokens = value.split(/([^\\S\\r\\n]+|[()[\\]{}'\"\\r\\n]|\\b)/); // Join the boundary splits that we do not consider to be boundaries. This is primarily the extended Latin character set.\n\n    for (var i = 0; i < tokens.length - 1; i++) {\n      // If we have an empty string in the next field and we have only word chars before and after, merge\n      if (!tokens[i + 1] && tokens[i + 2] && extendedWordChars.test(tokens[i]) && extendedWordChars.test(tokens[i + 2])) {\n        tokens[i] += tokens[i + 2];\n        tokens.splice(i + 1, 2);\n        i--;\n      }\n    }\n\n    return tokens;\n  };\n\n  function diffWords(oldStr, newStr, options) {\n    options = generateOptions(options, {\n      ignoreWhitespace: true\n    });\n    return wordDiff.diff(oldStr, newStr, options);\n  }\n  function diffWordsWithSpace(oldStr, newStr, options) {\n    return wordDiff.diff(oldStr, newStr, options);\n  }\n\n  var lineDiff = new Diff();\n\n  lineDiff.tokenize = function (value) {\n    var retLines = [],\n        linesAndNewlines = value.split(/(\\n|\\r\\n)/); // Ignore the final empty token that occurs if the string ends with a new line\n\n    if (!linesAndNewlines[linesAndNewlines.length - 1]) {\n      linesAndNewlines.pop();\n    } // Merge the content and line separators into single tokens\n\n\n    for (var i = 0; i < linesAndNewlines.length; i++) {\n      var line = linesAndNewlines[i];\n\n      if (i % 2 && !this.options.newlineIsToken) {\n        retLines[retLines.length - 1] += line;\n      } else {\n        if (this.options.ignoreWhitespace) {\n          line = line.trim();\n        }\n\n        retLines.push(line);\n      }\n    }\n\n    return retLines;\n  };\n\n  function diffLines(oldStr, newStr, callback) {\n    return lineDiff.diff(oldStr, newStr, callback);\n  }\n  function diffTrimmedLines(oldStr, newStr, callback) {\n    var options = generateOptions(callback, {\n      ignoreWhitespace: true\n    });\n    return lineDiff.diff(oldStr, newStr, options);\n  }\n\n  var sentenceDiff = new Diff();\n\n  sentenceDiff.tokenize = function (value) {\n    return value.split(/(\\S.+?[.!?])(?=\\s+|$)/);\n  };\n\n  function diffSentences(oldStr, newStr, callback) {\n    return sentenceDiff.diff(oldStr, newStr, callback);\n  }\n\n  var cssDiff = new Diff();\n\n  cssDiff.tokenize = function (value) {\n    return value.split(/([{}:;,]|\\s+)/);\n  };\n\n  function diffCss(oldStr, newStr, callback) {\n    return cssDiff.diff(oldStr, newStr, callback);\n  }\n\n  function _typeof(obj) {\n    \"@babel/helpers - typeof\";\n\n    if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n      _typeof = function (obj) {\n        return typeof obj;\n      };\n    } else {\n      _typeof = function (obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n      };\n    }\n\n    return _typeof(obj);\n  }\n\n  function _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n  }\n\n  function _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n  }\n\n  function _iterableToArray(iter) {\n    if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n  }\n\n  function _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n  }\n\n  function _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n\n    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n    return arr2;\n  }\n\n  function _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var objectPrototypeToString = Object.prototype.toString;\n  var jsonDiff = new Diff(); // Discriminate between two lines of pretty-printed, serialized JSON where one of them has a\n  // dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:\n\n  jsonDiff.useLongestToken = true;\n  jsonDiff.tokenize = lineDiff.tokenize;\n\n  jsonDiff.castInput = function (value) {\n    var _this$options = this.options,\n        undefinedReplacement = _this$options.undefinedReplacement,\n        _this$options$stringi = _this$options.stringifyReplacer,\n        stringifyReplacer = _this$options$stringi === void 0 ? function (k, v) {\n      return typeof v === 'undefined' ? undefinedReplacement : v;\n    } : _this$options$stringi;\n    return typeof value === 'string' ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, '  ');\n  };\n\n  jsonDiff.equals = function (left, right) {\n    return Diff.prototype.equals.call(jsonDiff, left.replace(/,([\\r\\n])/g, '$1'), right.replace(/,([\\r\\n])/g, '$1'));\n  };\n\n  function diffJson(oldObj, newObj, options) {\n    return jsonDiff.diff(oldObj, newObj, options);\n  } // This function handles the presence of circular references by bailing out when encountering an\n  // object that is already on the \"stack\" of items being processed. Accepts an optional replacer\n\n  function canonicalize(obj, stack, replacementStack, replacer, key) {\n    stack = stack || [];\n    replacementStack = replacementStack || [];\n\n    if (replacer) {\n      obj = replacer(key, obj);\n    }\n\n    var i;\n\n    for (i = 0; i < stack.length; i += 1) {\n      if (stack[i] === obj) {\n        return replacementStack[i];\n      }\n    }\n\n    var canonicalizedObj;\n\n    if ('[object Array]' === objectPrototypeToString.call(obj)) {\n      stack.push(obj);\n      canonicalizedObj = new Array(obj.length);\n      replacementStack.push(canonicalizedObj);\n\n      for (i = 0; i < obj.length; i += 1) {\n        canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);\n      }\n\n      stack.pop();\n      replacementStack.pop();\n      return canonicalizedObj;\n    }\n\n    if (obj && obj.toJSON) {\n      obj = obj.toJSON();\n    }\n\n    if (_typeof(obj) === 'object' && obj !== null) {\n      stack.push(obj);\n      canonicalizedObj = {};\n      replacementStack.push(canonicalizedObj);\n\n      var sortedKeys = [],\n          _key;\n\n      for (_key in obj) {\n        /* istanbul ignore else */\n        if (obj.hasOwnProperty(_key)) {\n          sortedKeys.push(_key);\n        }\n      }\n\n      sortedKeys.sort();\n\n      for (i = 0; i < sortedKeys.length; i += 1) {\n        _key = sortedKeys[i];\n        canonicalizedObj[_key] = canonicalize(obj[_key], stack, replacementStack, replacer, _key);\n      }\n\n      stack.pop();\n      replacementStack.pop();\n    } else {\n      canonicalizedObj = obj;\n    }\n\n    return canonicalizedObj;\n  }\n\n  var arrayDiff = new Diff();\n\n  arrayDiff.tokenize = function (value) {\n    return value.slice();\n  };\n\n  arrayDiff.join = arrayDiff.removeEmpty = function (value) {\n    return value;\n  };\n\n  function diffArrays(oldArr, newArr, callback) {\n    return arrayDiff.diff(oldArr, newArr, callback);\n  }\n\n  function parsePatch(uniDiff) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var diffstr = uniDiff.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/),\n        delimiters = uniDiff.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g) || [],\n        list = [],\n        i = 0;\n\n    function parseIndex() {\n      var index = {};\n      list.push(index); // Parse diff metadata\n\n      while (i < diffstr.length) {\n        var line = diffstr[i]; // File header found, end parsing diff metadata\n\n        if (/^(\\-\\-\\-|\\+\\+\\+|@@)\\s/.test(line)) {\n          break;\n        } // Diff index\n\n\n        var header = /^(?:Index:|diff(?: -r \\w+)+)\\s+(.+?)\\s*$/.exec(line);\n\n        if (header) {\n          index.index = header[1];\n        }\n\n        i++;\n      } // Parse file headers if they are defined. Unified diff requires them, but\n      // there's no technical issues to have an isolated hunk without file header\n\n\n      parseFileHeader(index);\n      parseFileHeader(index); // Parse hunks\n\n      index.hunks = [];\n\n      while (i < diffstr.length) {\n        var _line = diffstr[i];\n\n        if (/^(Index:|diff|\\-\\-\\-|\\+\\+\\+)\\s/.test(_line)) {\n          break;\n        } else if (/^@@/.test(_line)) {\n          index.hunks.push(parseHunk());\n        } else if (_line && options.strict) {\n          // Ignore unexpected content unless in strict mode\n          throw new Error('Unknown line ' + (i + 1) + ' ' + JSON.stringify(_line));\n        } else {\n          i++;\n        }\n      }\n    } // Parses the --- and +++ headers, if none are found, no lines\n    // are consumed.\n\n\n    function parseFileHeader(index) {\n      var fileHeader = /^(---|\\+\\+\\+)\\s+(.*)$/.exec(diffstr[i]);\n\n      if (fileHeader) {\n        var keyPrefix = fileHeader[1] === '---' ? 'old' : 'new';\n        var data = fileHeader[2].split('\\t', 2);\n        var fileName = data[0].replace(/\\\\\\\\/g, '\\\\');\n\n        if (/^\".*\"$/.test(fileName)) {\n          fileName = fileName.substr(1, fileName.length - 2);\n        }\n\n        index[keyPrefix + 'FileName'] = fileName;\n        index[keyPrefix + 'Header'] = (data[1] || '').trim();\n        i++;\n      }\n    } // Parses a hunk\n    // This assumes that we are at the start of a hunk.\n\n\n    function parseHunk() {\n      var chunkHeaderIndex = i,\n          chunkHeaderLine = diffstr[i++],\n          chunkHeader = chunkHeaderLine.split(/@@ -(\\d+)(?:,(\\d+))? \\+(\\d+)(?:,(\\d+))? @@/);\n      var hunk = {\n        oldStart: +chunkHeader[1],\n        oldLines: typeof chunkHeader[2] === 'undefined' ? 1 : +chunkHeader[2],\n        newStart: +chunkHeader[3],\n        newLines: typeof chunkHeader[4] === 'undefined' ? 1 : +chunkHeader[4],\n        lines: [],\n        linedelimiters: []\n      }; // Unified Diff Format quirk: If the chunk size is 0,\n      // the first number is one lower than one would expect.\n      // https://www.artima.com/weblogs/viewpost.jsp?thread=164293\n\n      if (hunk.oldLines === 0) {\n        hunk.oldStart += 1;\n      }\n\n      if (hunk.newLines === 0) {\n        hunk.newStart += 1;\n      }\n\n      var addCount = 0,\n          removeCount = 0;\n\n      for (; i < diffstr.length; i++) {\n        // Lines starting with '---' could be mistaken for the \"remove line\" operation\n        // But they could be the header for the next file. Therefore prune such cases out.\n        if (diffstr[i].indexOf('--- ') === 0 && i + 2 < diffstr.length && diffstr[i + 1].indexOf('+++ ') === 0 && diffstr[i + 2].indexOf('@@') === 0) {\n          break;\n        }\n\n        var operation = diffstr[i].length == 0 && i != diffstr.length - 1 ? ' ' : diffstr[i][0];\n\n        if (operation === '+' || operation === '-' || operation === ' ' || operation === '\\\\') {\n          hunk.lines.push(diffstr[i]);\n          hunk.linedelimiters.push(delimiters[i] || '\\n');\n\n          if (operation === '+') {\n            addCount++;\n          } else if (operation === '-') {\n            removeCount++;\n          } else if (operation === ' ') {\n            addCount++;\n            removeCount++;\n          }\n        } else {\n          break;\n        }\n      } // Handle the empty block count case\n\n\n      if (!addCount && hunk.newLines === 1) {\n        hunk.newLines = 0;\n      }\n\n      if (!removeCount && hunk.oldLines === 1) {\n        hunk.oldLines = 0;\n      } // Perform optional sanity checking\n\n\n      if (options.strict) {\n        if (addCount !== hunk.newLines) {\n          throw new Error('Added line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\n        }\n\n        if (removeCount !== hunk.oldLines) {\n          throw new Error('Removed line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\n        }\n      }\n\n      return hunk;\n    }\n\n    while (i < diffstr.length) {\n      parseIndex();\n    }\n\n    return list;\n  }\n\n  // Iterator that traverses in the range of [min, max], stepping\n  // by distance from a given start position. I.e. for [0, 4], with\n  // start of 2, this will iterate 2, 3, 1, 4, 0.\n  function distanceIterator (start, minLine, maxLine) {\n    var wantForward = true,\n        backwardExhausted = false,\n        forwardExhausted = false,\n        localOffset = 1;\n    return function iterator() {\n      if (wantForward && !forwardExhausted) {\n        if (backwardExhausted) {\n          localOffset++;\n        } else {\n          wantForward = false;\n        } // Check if trying to fit beyond text length, and if not, check it fits\n        // after offset location (or desired location on first iteration)\n\n\n        if (start + localOffset <= maxLine) {\n          return localOffset;\n        }\n\n        forwardExhausted = true;\n      }\n\n      if (!backwardExhausted) {\n        if (!forwardExhausted) {\n          wantForward = true;\n        } // Check if trying to fit before text beginning, and if not, check it fits\n        // before offset location\n\n\n        if (minLine <= start - localOffset) {\n          return -localOffset++;\n        }\n\n        backwardExhausted = true;\n        return iterator();\n      } // We tried to fit hunk before text beginning and beyond text length, then\n      // hunk can't fit on the text. Return undefined\n\n    };\n  }\n\n  function applyPatch(source, uniDiff) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (typeof uniDiff === 'string') {\n      uniDiff = parsePatch(uniDiff);\n    }\n\n    if (Array.isArray(uniDiff)) {\n      if (uniDiff.length > 1) {\n        throw new Error('applyPatch only works with a single input.');\n      }\n\n      uniDiff = uniDiff[0];\n    } // Apply the diff to the input\n\n\n    var lines = source.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/),\n        delimiters = source.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g) || [],\n        hunks = uniDiff.hunks,\n        compareLine = options.compareLine || function (lineNumber, line, operation, patchContent) {\n      return line === patchContent;\n    },\n        errorCount = 0,\n        fuzzFactor = options.fuzzFactor || 0,\n        minLine = 0,\n        offset = 0,\n        removeEOFNL,\n        addEOFNL;\n    /**\n     * Checks if the hunk exactly fits on the provided location\n     */\n\n\n    function hunkFits(hunk, toPos) {\n      for (var j = 0; j < hunk.lines.length; j++) {\n        var line = hunk.lines[j],\n            operation = line.length > 0 ? line[0] : ' ',\n            content = line.length > 0 ? line.substr(1) : line;\n\n        if (operation === ' ' || operation === '-') {\n          // Context sanity check\n          if (!compareLine(toPos + 1, lines[toPos], operation, content)) {\n            errorCount++;\n\n            if (errorCount > fuzzFactor) {\n              return false;\n            }\n          }\n\n          toPos++;\n        }\n      }\n\n      return true;\n    } // Search best fit offsets for each hunk based on the previous ones\n\n\n    for (var i = 0; i < hunks.length; i++) {\n      var hunk = hunks[i],\n          maxLine = lines.length - hunk.oldLines,\n          localOffset = 0,\n          toPos = offset + hunk.oldStart - 1;\n      var iterator = distanceIterator(toPos, minLine, maxLine);\n\n      for (; localOffset !== undefined; localOffset = iterator()) {\n        if (hunkFits(hunk, toPos + localOffset)) {\n          hunk.offset = offset += localOffset;\n          break;\n        }\n      }\n\n      if (localOffset === undefined) {\n        return false;\n      } // Set lower text limit to end of the current hunk, so next ones don't try\n      // to fit over already patched text\n\n\n      minLine = hunk.offset + hunk.oldStart + hunk.oldLines;\n    } // Apply patch hunks\n\n\n    var diffOffset = 0;\n\n    for (var _i = 0; _i < hunks.length; _i++) {\n      var _hunk = hunks[_i],\n          _toPos = _hunk.oldStart + _hunk.offset + diffOffset - 1;\n\n      diffOffset += _hunk.newLines - _hunk.oldLines;\n\n      for (var j = 0; j < _hunk.lines.length; j++) {\n        var line = _hunk.lines[j],\n            operation = line.length > 0 ? line[0] : ' ',\n            content = line.length > 0 ? line.substr(1) : line,\n            delimiter = _hunk.linedelimiters[j];\n\n        if (operation === ' ') {\n          _toPos++;\n        } else if (operation === '-') {\n          lines.splice(_toPos, 1);\n          delimiters.splice(_toPos, 1);\n          /* istanbul ignore else */\n        } else if (operation === '+') {\n          lines.splice(_toPos, 0, content);\n          delimiters.splice(_toPos, 0, delimiter);\n          _toPos++;\n        } else if (operation === '\\\\') {\n          var previousOperation = _hunk.lines[j - 1] ? _hunk.lines[j - 1][0] : null;\n\n          if (previousOperation === '+') {\n            removeEOFNL = true;\n          } else if (previousOperation === '-') {\n            addEOFNL = true;\n          }\n        }\n      }\n    } // Handle EOFNL insertion/removal\n\n\n    if (removeEOFNL) {\n      while (!lines[lines.length - 1]) {\n        lines.pop();\n        delimiters.pop();\n      }\n    } else if (addEOFNL) {\n      lines.push('');\n      delimiters.push('\\n');\n    }\n\n    for (var _k = 0; _k < lines.length - 1; _k++) {\n      lines[_k] = lines[_k] + delimiters[_k];\n    }\n\n    return lines.join('');\n  } // Wrapper that supports multiple file patches via callbacks.\n\n  function applyPatches(uniDiff, options) {\n    if (typeof uniDiff === 'string') {\n      uniDiff = parsePatch(uniDiff);\n    }\n\n    var currentIndex = 0;\n\n    function processIndex() {\n      var index = uniDiff[currentIndex++];\n\n      if (!index) {\n        return options.complete();\n      }\n\n      options.loadFile(index, function (err, data) {\n        if (err) {\n          return options.complete(err);\n        }\n\n        var updatedContent = applyPatch(data, index, options);\n        options.patched(index, updatedContent, function (err) {\n          if (err) {\n            return options.complete(err);\n          }\n\n          processIndex();\n        });\n      });\n    }\n\n    processIndex();\n  }\n\n  function structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n    if (!options) {\n      options = {};\n    }\n\n    if (typeof options.context === 'undefined') {\n      options.context = 4;\n    }\n\n    var diff = diffLines(oldStr, newStr, options);\n    diff.push({\n      value: '',\n      lines: []\n    }); // Append an empty value to make cleanup easier\n\n    function contextLines(lines) {\n      return lines.map(function (entry) {\n        return ' ' + entry;\n      });\n    }\n\n    var hunks = [];\n    var oldRangeStart = 0,\n        newRangeStart = 0,\n        curRange = [],\n        oldLine = 1,\n        newLine = 1;\n\n    var _loop = function _loop(i) {\n      var current = diff[i],\n          lines = current.lines || current.value.replace(/\\n$/, '').split('\\n');\n      current.lines = lines;\n\n      if (current.added || current.removed) {\n        var _curRange;\n\n        // If we have previous context, start with that\n        if (!oldRangeStart) {\n          var prev = diff[i - 1];\n          oldRangeStart = oldLine;\n          newRangeStart = newLine;\n\n          if (prev) {\n            curRange = options.context > 0 ? contextLines(prev.lines.slice(-options.context)) : [];\n            oldRangeStart -= curRange.length;\n            newRangeStart -= curRange.length;\n          }\n        } // Output our changes\n\n\n        (_curRange = curRange).push.apply(_curRange, _toConsumableArray(lines.map(function (entry) {\n          return (current.added ? '+' : '-') + entry;\n        }))); // Track the updated file position\n\n\n        if (current.added) {\n          newLine += lines.length;\n        } else {\n          oldLine += lines.length;\n        }\n      } else {\n        // Identical context lines. Track line changes\n        if (oldRangeStart) {\n          // Close out any changes that have been output (or join overlapping)\n          if (lines.length <= options.context * 2 && i < diff.length - 2) {\n            var _curRange2;\n\n            // Overlapping\n            (_curRange2 = curRange).push.apply(_curRange2, _toConsumableArray(contextLines(lines)));\n          } else {\n            var _curRange3;\n\n            // end the range and output\n            var contextSize = Math.min(lines.length, options.context);\n\n            (_curRange3 = curRange).push.apply(_curRange3, _toConsumableArray(contextLines(lines.slice(0, contextSize))));\n\n            var hunk = {\n              oldStart: oldRangeStart,\n              oldLines: oldLine - oldRangeStart + contextSize,\n              newStart: newRangeStart,\n              newLines: newLine - newRangeStart + contextSize,\n              lines: curRange\n            };\n\n            if (i >= diff.length - 2 && lines.length <= options.context) {\n              // EOF is inside this hunk\n              var oldEOFNewline = /\\n$/.test(oldStr);\n              var newEOFNewline = /\\n$/.test(newStr);\n              var noNlBeforeAdds = lines.length == 0 && curRange.length > hunk.oldLines;\n\n              if (!oldEOFNewline && noNlBeforeAdds && oldStr.length > 0) {\n                // special case: old has no eol and no trailing context; no-nl can end up before adds\n                // however, if the old file is empty, do not output the no-nl line\n                curRange.splice(hunk.oldLines, 0, '\\\\ No newline at end of file');\n              }\n\n              if (!oldEOFNewline && !noNlBeforeAdds || !newEOFNewline) {\n                curRange.push('\\\\ No newline at end of file');\n              }\n            }\n\n            hunks.push(hunk);\n            oldRangeStart = 0;\n            newRangeStart = 0;\n            curRange = [];\n          }\n        }\n\n        oldLine += lines.length;\n        newLine += lines.length;\n      }\n    };\n\n    for (var i = 0; i < diff.length; i++) {\n      _loop(i);\n    }\n\n    return {\n      oldFileName: oldFileName,\n      newFileName: newFileName,\n      oldHeader: oldHeader,\n      newHeader: newHeader,\n      hunks: hunks\n    };\n  }\n  function formatPatch(diff) {\n    var ret = [];\n\n    if (diff.oldFileName == diff.newFileName) {\n      ret.push('Index: ' + diff.oldFileName);\n    }\n\n    ret.push('===================================================================');\n    ret.push('--- ' + diff.oldFileName + (typeof diff.oldHeader === 'undefined' ? '' : '\\t' + diff.oldHeader));\n    ret.push('+++ ' + diff.newFileName + (typeof diff.newHeader === 'undefined' ? '' : '\\t' + diff.newHeader));\n\n    for (var i = 0; i < diff.hunks.length; i++) {\n      var hunk = diff.hunks[i]; // Unified Diff Format quirk: If the chunk size is 0,\n      // the first number is one lower than one would expect.\n      // https://www.artima.com/weblogs/viewpost.jsp?thread=164293\n\n      if (hunk.oldLines === 0) {\n        hunk.oldStart -= 1;\n      }\n\n      if (hunk.newLines === 0) {\n        hunk.newStart -= 1;\n      }\n\n      ret.push('@@ -' + hunk.oldStart + ',' + hunk.oldLines + ' +' + hunk.newStart + ',' + hunk.newLines + ' @@');\n      ret.push.apply(ret, hunk.lines);\n    }\n\n    return ret.join('\\n') + '\\n';\n  }\n  function createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n    return formatPatch(structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options));\n  }\n  function createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options) {\n    return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options);\n  }\n\n  function arrayEqual(a, b) {\n    if (a.length !== b.length) {\n      return false;\n    }\n\n    return arrayStartsWith(a, b);\n  }\n  function arrayStartsWith(array, start) {\n    if (start.length > array.length) {\n      return false;\n    }\n\n    for (var i = 0; i < start.length; i++) {\n      if (start[i] !== array[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  function calcLineCount(hunk) {\n    var _calcOldNewLineCount = calcOldNewLineCount(hunk.lines),\n        oldLines = _calcOldNewLineCount.oldLines,\n        newLines = _calcOldNewLineCount.newLines;\n\n    if (oldLines !== undefined) {\n      hunk.oldLines = oldLines;\n    } else {\n      delete hunk.oldLines;\n    }\n\n    if (newLines !== undefined) {\n      hunk.newLines = newLines;\n    } else {\n      delete hunk.newLines;\n    }\n  }\n  function merge(mine, theirs, base) {\n    mine = loadPatch(mine, base);\n    theirs = loadPatch(theirs, base);\n    var ret = {}; // For index we just let it pass through as it doesn't have any necessary meaning.\n    // Leaving sanity checks on this to the API consumer that may know more about the\n    // meaning in their own context.\n\n    if (mine.index || theirs.index) {\n      ret.index = mine.index || theirs.index;\n    }\n\n    if (mine.newFileName || theirs.newFileName) {\n      if (!fileNameChanged(mine)) {\n        // No header or no change in ours, use theirs (and ours if theirs does not exist)\n        ret.oldFileName = theirs.oldFileName || mine.oldFileName;\n        ret.newFileName = theirs.newFileName || mine.newFileName;\n        ret.oldHeader = theirs.oldHeader || mine.oldHeader;\n        ret.newHeader = theirs.newHeader || mine.newHeader;\n      } else if (!fileNameChanged(theirs)) {\n        // No header or no change in theirs, use ours\n        ret.oldFileName = mine.oldFileName;\n        ret.newFileName = mine.newFileName;\n        ret.oldHeader = mine.oldHeader;\n        ret.newHeader = mine.newHeader;\n      } else {\n        // Both changed... figure it out\n        ret.oldFileName = selectField(ret, mine.oldFileName, theirs.oldFileName);\n        ret.newFileName = selectField(ret, mine.newFileName, theirs.newFileName);\n        ret.oldHeader = selectField(ret, mine.oldHeader, theirs.oldHeader);\n        ret.newHeader = selectField(ret, mine.newHeader, theirs.newHeader);\n      }\n    }\n\n    ret.hunks = [];\n    var mineIndex = 0,\n        theirsIndex = 0,\n        mineOffset = 0,\n        theirsOffset = 0;\n\n    while (mineIndex < mine.hunks.length || theirsIndex < theirs.hunks.length) {\n      var mineCurrent = mine.hunks[mineIndex] || {\n        oldStart: Infinity\n      },\n          theirsCurrent = theirs.hunks[theirsIndex] || {\n        oldStart: Infinity\n      };\n\n      if (hunkBefore(mineCurrent, theirsCurrent)) {\n        // This patch does not overlap with any of the others, yay.\n        ret.hunks.push(cloneHunk(mineCurrent, mineOffset));\n        mineIndex++;\n        theirsOffset += mineCurrent.newLines - mineCurrent.oldLines;\n      } else if (hunkBefore(theirsCurrent, mineCurrent)) {\n        // This patch does not overlap with any of the others, yay.\n        ret.hunks.push(cloneHunk(theirsCurrent, theirsOffset));\n        theirsIndex++;\n        mineOffset += theirsCurrent.newLines - theirsCurrent.oldLines;\n      } else {\n        // Overlap, merge as best we can\n        var mergedHunk = {\n          oldStart: Math.min(mineCurrent.oldStart, theirsCurrent.oldStart),\n          oldLines: 0,\n          newStart: Math.min(mineCurrent.newStart + mineOffset, theirsCurrent.oldStart + theirsOffset),\n          newLines: 0,\n          lines: []\n        };\n        mergeLines(mergedHunk, mineCurrent.oldStart, mineCurrent.lines, theirsCurrent.oldStart, theirsCurrent.lines);\n        theirsIndex++;\n        mineIndex++;\n        ret.hunks.push(mergedHunk);\n      }\n    }\n\n    return ret;\n  }\n\n  function loadPatch(param, base) {\n    if (typeof param === 'string') {\n      if (/^@@/m.test(param) || /^Index:/m.test(param)) {\n        return parsePatch(param)[0];\n      }\n\n      if (!base) {\n        throw new Error('Must provide a base reference or pass in a patch');\n      }\n\n      return structuredPatch(undefined, undefined, base, param);\n    }\n\n    return param;\n  }\n\n  function fileNameChanged(patch) {\n    return patch.newFileName && patch.newFileName !== patch.oldFileName;\n  }\n\n  function selectField(index, mine, theirs) {\n    if (mine === theirs) {\n      return mine;\n    } else {\n      index.conflict = true;\n      return {\n        mine: mine,\n        theirs: theirs\n      };\n    }\n  }\n\n  function hunkBefore(test, check) {\n    return test.oldStart < check.oldStart && test.oldStart + test.oldLines < check.oldStart;\n  }\n\n  function cloneHunk(hunk, offset) {\n    return {\n      oldStart: hunk.oldStart,\n      oldLines: hunk.oldLines,\n      newStart: hunk.newStart + offset,\n      newLines: hunk.newLines,\n      lines: hunk.lines\n    };\n  }\n\n  function mergeLines(hunk, mineOffset, mineLines, theirOffset, theirLines) {\n    // This will generally result in a conflicted hunk, but there are cases where the context\n    // is the only overlap where we can successfully merge the content here.\n    var mine = {\n      offset: mineOffset,\n      lines: mineLines,\n      index: 0\n    },\n        their = {\n      offset: theirOffset,\n      lines: theirLines,\n      index: 0\n    }; // Handle any leading content\n\n    insertLeading(hunk, mine, their);\n    insertLeading(hunk, their, mine); // Now in the overlap content. Scan through and select the best changes from each.\n\n    while (mine.index < mine.lines.length && their.index < their.lines.length) {\n      var mineCurrent = mine.lines[mine.index],\n          theirCurrent = their.lines[their.index];\n\n      if ((mineCurrent[0] === '-' || mineCurrent[0] === '+') && (theirCurrent[0] === '-' || theirCurrent[0] === '+')) {\n        // Both modified ...\n        mutualChange(hunk, mine, their);\n      } else if (mineCurrent[0] === '+' && theirCurrent[0] === ' ') {\n        var _hunk$lines;\n\n        // Mine inserted\n        (_hunk$lines = hunk.lines).push.apply(_hunk$lines, _toConsumableArray(collectChange(mine)));\n      } else if (theirCurrent[0] === '+' && mineCurrent[0] === ' ') {\n        var _hunk$lines2;\n\n        // Theirs inserted\n        (_hunk$lines2 = hunk.lines).push.apply(_hunk$lines2, _toConsumableArray(collectChange(their)));\n      } else if (mineCurrent[0] === '-' && theirCurrent[0] === ' ') {\n        // Mine removed or edited\n        removal(hunk, mine, their);\n      } else if (theirCurrent[0] === '-' && mineCurrent[0] === ' ') {\n        // Their removed or edited\n        removal(hunk, their, mine, true);\n      } else if (mineCurrent === theirCurrent) {\n        // Context identity\n        hunk.lines.push(mineCurrent);\n        mine.index++;\n        their.index++;\n      } else {\n        // Context mismatch\n        conflict(hunk, collectChange(mine), collectChange(their));\n      }\n    } // Now push anything that may be remaining\n\n\n    insertTrailing(hunk, mine);\n    insertTrailing(hunk, their);\n    calcLineCount(hunk);\n  }\n\n  function mutualChange(hunk, mine, their) {\n    var myChanges = collectChange(mine),\n        theirChanges = collectChange(their);\n\n    if (allRemoves(myChanges) && allRemoves(theirChanges)) {\n      // Special case for remove changes that are supersets of one another\n      if (arrayStartsWith(myChanges, theirChanges) && skipRemoveSuperset(their, myChanges, myChanges.length - theirChanges.length)) {\n        var _hunk$lines3;\n\n        (_hunk$lines3 = hunk.lines).push.apply(_hunk$lines3, _toConsumableArray(myChanges));\n\n        return;\n      } else if (arrayStartsWith(theirChanges, myChanges) && skipRemoveSuperset(mine, theirChanges, theirChanges.length - myChanges.length)) {\n        var _hunk$lines4;\n\n        (_hunk$lines4 = hunk.lines).push.apply(_hunk$lines4, _toConsumableArray(theirChanges));\n\n        return;\n      }\n    } else if (arrayEqual(myChanges, theirChanges)) {\n      var _hunk$lines5;\n\n      (_hunk$lines5 = hunk.lines).push.apply(_hunk$lines5, _toConsumableArray(myChanges));\n\n      return;\n    }\n\n    conflict(hunk, myChanges, theirChanges);\n  }\n\n  function removal(hunk, mine, their, swap) {\n    var myChanges = collectChange(mine),\n        theirChanges = collectContext(their, myChanges);\n\n    if (theirChanges.merged) {\n      var _hunk$lines6;\n\n      (_hunk$lines6 = hunk.lines).push.apply(_hunk$lines6, _toConsumableArray(theirChanges.merged));\n    } else {\n      conflict(hunk, swap ? theirChanges : myChanges, swap ? myChanges : theirChanges);\n    }\n  }\n\n  function conflict(hunk, mine, their) {\n    hunk.conflict = true;\n    hunk.lines.push({\n      conflict: true,\n      mine: mine,\n      theirs: their\n    });\n  }\n\n  function insertLeading(hunk, insert, their) {\n    while (insert.offset < their.offset && insert.index < insert.lines.length) {\n      var line = insert.lines[insert.index++];\n      hunk.lines.push(line);\n      insert.offset++;\n    }\n  }\n\n  function insertTrailing(hunk, insert) {\n    while (insert.index < insert.lines.length) {\n      var line = insert.lines[insert.index++];\n      hunk.lines.push(line);\n    }\n  }\n\n  function collectChange(state) {\n    var ret = [],\n        operation = state.lines[state.index][0];\n\n    while (state.index < state.lines.length) {\n      var line = state.lines[state.index]; // Group additions that are immediately after subtractions and treat them as one \"atomic\" modify change.\n\n      if (operation === '-' && line[0] === '+') {\n        operation = '+';\n      }\n\n      if (operation === line[0]) {\n        ret.push(line);\n        state.index++;\n      } else {\n        break;\n      }\n    }\n\n    return ret;\n  }\n\n  function collectContext(state, matchChanges) {\n    var changes = [],\n        merged = [],\n        matchIndex = 0,\n        contextChanges = false,\n        conflicted = false;\n\n    while (matchIndex < matchChanges.length && state.index < state.lines.length) {\n      var change = state.lines[state.index],\n          match = matchChanges[matchIndex]; // Once we've hit our add, then we are done\n\n      if (match[0] === '+') {\n        break;\n      }\n\n      contextChanges = contextChanges || change[0] !== ' ';\n      merged.push(match);\n      matchIndex++; // Consume any additions in the other block as a conflict to attempt\n      // to pull in the remaining context after this\n\n      if (change[0] === '+') {\n        conflicted = true;\n\n        while (change[0] === '+') {\n          changes.push(change);\n          change = state.lines[++state.index];\n        }\n      }\n\n      if (match.substr(1) === change.substr(1)) {\n        changes.push(change);\n        state.index++;\n      } else {\n        conflicted = true;\n      }\n    }\n\n    if ((matchChanges[matchIndex] || '')[0] === '+' && contextChanges) {\n      conflicted = true;\n    }\n\n    if (conflicted) {\n      return changes;\n    }\n\n    while (matchIndex < matchChanges.length) {\n      merged.push(matchChanges[matchIndex++]);\n    }\n\n    return {\n      merged: merged,\n      changes: changes\n    };\n  }\n\n  function allRemoves(changes) {\n    return changes.reduce(function (prev, change) {\n      return prev && change[0] === '-';\n    }, true);\n  }\n\n  function skipRemoveSuperset(state, removeChanges, delta) {\n    for (var i = 0; i < delta; i++) {\n      var changeContent = removeChanges[removeChanges.length - delta + i].substr(1);\n\n      if (state.lines[state.index + i] !== ' ' + changeContent) {\n        return false;\n      }\n    }\n\n    state.index += delta;\n    return true;\n  }\n\n  function calcOldNewLineCount(lines) {\n    var oldLines = 0;\n    var newLines = 0;\n    lines.forEach(function (line) {\n      if (typeof line !== 'string') {\n        var myCount = calcOldNewLineCount(line.mine);\n        var theirCount = calcOldNewLineCount(line.theirs);\n\n        if (oldLines !== undefined) {\n          if (myCount.oldLines === theirCount.oldLines) {\n            oldLines += myCount.oldLines;\n          } else {\n            oldLines = undefined;\n          }\n        }\n\n        if (newLines !== undefined) {\n          if (myCount.newLines === theirCount.newLines) {\n            newLines += myCount.newLines;\n          } else {\n            newLines = undefined;\n          }\n        }\n      } else {\n        if (newLines !== undefined && (line[0] === '+' || line[0] === ' ')) {\n          newLines++;\n        }\n\n        if (oldLines !== undefined && (line[0] === '-' || line[0] === ' ')) {\n          oldLines++;\n        }\n      }\n    });\n    return {\n      oldLines: oldLines,\n      newLines: newLines\n    };\n  }\n\n  // See: http://code.google.com/p/google-diff-match-patch/wiki/API\n  function convertChangesToDMP(changes) {\n    var ret = [],\n        change,\n        operation;\n\n    for (var i = 0; i < changes.length; i++) {\n      change = changes[i];\n\n      if (change.added) {\n        operation = 1;\n      } else if (change.removed) {\n        operation = -1;\n      } else {\n        operation = 0;\n      }\n\n      ret.push([operation, change.value]);\n    }\n\n    return ret;\n  }\n\n  function convertChangesToXML(changes) {\n    var ret = [];\n\n    for (var i = 0; i < changes.length; i++) {\n      var change = changes[i];\n\n      if (change.added) {\n        ret.push('<ins>');\n      } else if (change.removed) {\n        ret.push('<del>');\n      }\n\n      ret.push(escapeHTML(change.value));\n\n      if (change.added) {\n        ret.push('</ins>');\n      } else if (change.removed) {\n        ret.push('</del>');\n      }\n    }\n\n    return ret.join('');\n  }\n\n  function escapeHTML(s) {\n    var n = s;\n    n = n.replace(/&/g, '&amp;');\n    n = n.replace(/</g, '&lt;');\n    n = n.replace(/>/g, '&gt;');\n    n = n.replace(/\"/g, '&quot;');\n    return n;\n  }\n\n  exports.Diff = Diff;\n  exports.applyPatch = applyPatch;\n  exports.applyPatches = applyPatches;\n  exports.canonicalize = canonicalize;\n  exports.convertChangesToDMP = convertChangesToDMP;\n  exports.convertChangesToXML = convertChangesToXML;\n  exports.createPatch = createPatch;\n  exports.createTwoFilesPatch = createTwoFilesPatch;\n  exports.diffArrays = diffArrays;\n  exports.diffChars = diffChars;\n  exports.diffCss = diffCss;\n  exports.diffJson = diffJson;\n  exports.diffLines = diffLines;\n  exports.diffSentences = diffSentences;\n  exports.diffTrimmedLines = diffTrimmedLines;\n  exports.diffWords = diffWords;\n  exports.diffWordsWithSpace = diffWordsWithSpace;\n  exports.merge = merge;\n  exports.parsePatch = parsePatch;\n  exports.structuredPatch = structuredPatch;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n\n\n//# sourceURL=webpack:///./node_modules/diff/dist/diff.js?");

/***/ }),

/***/ "./node_modules/lodash/lodash.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/lodash.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, module) {var __WEBPACK_AMD_DEFINE_RESULT__;/**\n * @license\n * Lodash <https://lodash.com/>\n * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n;(function() {\n\n  /** Used as a safe reference for `undefined` in pre-ES5 environments. */\n  var undefined;\n\n  /** Used as the semantic version number. */\n  var VERSION = '4.17.21';\n\n  /** Used as the size to enable large array optimizations. */\n  var LARGE_ARRAY_SIZE = 200;\n\n  /** Error message constants. */\n  var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',\n      FUNC_ERROR_TEXT = 'Expected a function',\n      INVALID_TEMPL_VAR_ERROR_TEXT = 'Invalid `variable` option passed into `_.template`';\n\n  /** Used to stand-in for `undefined` hash values. */\n  var HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n  /** Used as the maximum memoize cache size. */\n  var MAX_MEMOIZE_SIZE = 500;\n\n  /** Used as the internal argument placeholder. */\n  var PLACEHOLDER = '__lodash_placeholder__';\n\n  /** Used to compose bitmasks for cloning. */\n  var CLONE_DEEP_FLAG = 1,\n      CLONE_FLAT_FLAG = 2,\n      CLONE_SYMBOLS_FLAG = 4;\n\n  /** Used to compose bitmasks for value comparisons. */\n  var COMPARE_PARTIAL_FLAG = 1,\n      COMPARE_UNORDERED_FLAG = 2;\n\n  /** Used to compose bitmasks for function metadata. */\n  var WRAP_BIND_FLAG = 1,\n      WRAP_BIND_KEY_FLAG = 2,\n      WRAP_CURRY_BOUND_FLAG = 4,\n      WRAP_CURRY_FLAG = 8,\n      WRAP_CURRY_RIGHT_FLAG = 16,\n      WRAP_PARTIAL_FLAG = 32,\n      WRAP_PARTIAL_RIGHT_FLAG = 64,\n      WRAP_ARY_FLAG = 128,\n      WRAP_REARG_FLAG = 256,\n      WRAP_FLIP_FLAG = 512;\n\n  /** Used as default options for `_.truncate`. */\n  var DEFAULT_TRUNC_LENGTH = 30,\n      DEFAULT_TRUNC_OMISSION = '...';\n\n  /** Used to detect hot functions by number of calls within a span of milliseconds. */\n  var HOT_COUNT = 800,\n      HOT_SPAN = 16;\n\n  /** Used to indicate the type of lazy iteratees. */\n  var LAZY_FILTER_FLAG = 1,\n      LAZY_MAP_FLAG = 2,\n      LAZY_WHILE_FLAG = 3;\n\n  /** Used as references for various `Number` constants. */\n  var INFINITY = 1 / 0,\n      MAX_SAFE_INTEGER = 9007199254740991,\n      MAX_INTEGER = 1.7976931348623157e+308,\n      NAN = 0 / 0;\n\n  /** Used as references for the maximum length and index of an array. */\n  var MAX_ARRAY_LENGTH = 4294967295,\n      MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,\n      HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;\n\n  /** Used to associate wrap methods with their bit flags. */\n  var wrapFlags = [\n    ['ary', WRAP_ARY_FLAG],\n    ['bind', WRAP_BIND_FLAG],\n    ['bindKey', WRAP_BIND_KEY_FLAG],\n    ['curry', WRAP_CURRY_FLAG],\n    ['curryRight', WRAP_CURRY_RIGHT_FLAG],\n    ['flip', WRAP_FLIP_FLAG],\n    ['partial', WRAP_PARTIAL_FLAG],\n    ['partialRight', WRAP_PARTIAL_RIGHT_FLAG],\n    ['rearg', WRAP_REARG_FLAG]\n  ];\n\n  /** `Object#toString` result references. */\n  var argsTag = '[object Arguments]',\n      arrayTag = '[object Array]',\n      asyncTag = '[object AsyncFunction]',\n      boolTag = '[object Boolean]',\n      dateTag = '[object Date]',\n      domExcTag = '[object DOMException]',\n      errorTag = '[object Error]',\n      funcTag = '[object Function]',\n      genTag = '[object GeneratorFunction]',\n      mapTag = '[object Map]',\n      numberTag = '[object Number]',\n      nullTag = '[object Null]',\n      objectTag = '[object Object]',\n      promiseTag = '[object Promise]',\n      proxyTag = '[object Proxy]',\n      regexpTag = '[object RegExp]',\n      setTag = '[object Set]',\n      stringTag = '[object String]',\n      symbolTag = '[object Symbol]',\n      undefinedTag = '[object Undefined]',\n      weakMapTag = '[object WeakMap]',\n      weakSetTag = '[object WeakSet]';\n\n  var arrayBufferTag = '[object ArrayBuffer]',\n      dataViewTag = '[object DataView]',\n      float32Tag = '[object Float32Array]',\n      float64Tag = '[object Float64Array]',\n      int8Tag = '[object Int8Array]',\n      int16Tag = '[object Int16Array]',\n      int32Tag = '[object Int32Array]',\n      uint8Tag = '[object Uint8Array]',\n      uint8ClampedTag = '[object Uint8ClampedArray]',\n      uint16Tag = '[object Uint16Array]',\n      uint32Tag = '[object Uint32Array]';\n\n  /** Used to match empty string literals in compiled template source. */\n  var reEmptyStringLeading = /\\b__p \\+= '';/g,\n      reEmptyStringMiddle = /\\b(__p \\+=) '' \\+/g,\n      reEmptyStringTrailing = /(__e\\(.*?\\)|\\b__t\\)) \\+\\n'';/g;\n\n  /** Used to match HTML entities and HTML characters. */\n  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,\n      reUnescapedHtml = /[&<>\"']/g,\n      reHasEscapedHtml = RegExp(reEscapedHtml.source),\n      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);\n\n  /** Used to match template delimiters. */\n  var reEscape = /<%-([\\s\\S]+?)%>/g,\n      reEvaluate = /<%([\\s\\S]+?)%>/g,\n      reInterpolate = /<%=([\\s\\S]+?)%>/g;\n\n  /** Used to match property names within property paths. */\n  var reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n      reIsPlainProp = /^\\w*$/,\n      rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n  /**\n   * Used to match `RegExp`\n   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n   */\n  var reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g,\n      reHasRegExpChar = RegExp(reRegExpChar.source);\n\n  /** Used to match leading whitespace. */\n  var reTrimStart = /^\\s+/;\n\n  /** Used to match a single whitespace character. */\n  var reWhitespace = /\\s/;\n\n  /** Used to match wrap detail comments. */\n  var reWrapComment = /\\{(?:\\n\\/\\* \\[wrapped with .+\\] \\*\\/)?\\n?/,\n      reWrapDetails = /\\{\\n\\/\\* \\[wrapped with (.+)\\] \\*/,\n      reSplitDetails = /,? & /;\n\n  /** Used to match words composed of alphanumeric characters. */\n  var reAsciiWord = /[^\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\x7f]+/g;\n\n  /**\n   * Used to validate the `validate` option in `_.template` variable.\n   *\n   * Forbids characters which could potentially change the meaning of the function argument definition:\n   * - \"(),\" (modification of function parameters)\n   * - \"=\" (default value)\n   * - \"[]{}\" (destructuring of function parameters)\n   * - \"/\" (beginning of a comment)\n   * - whitespace\n   */\n  var reForbiddenIdentifierChars = /[()=,{}\\[\\]\\/\\s]/;\n\n  /** Used to match backslashes in property paths. */\n  var reEscapeChar = /\\\\(\\\\)?/g;\n\n  /**\n   * Used to match\n   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).\n   */\n  var reEsTemplate = /\\$\\{([^\\\\}]*(?:\\\\.[^\\\\}]*)*)\\}/g;\n\n  /** Used to match `RegExp` flags from their coerced string values. */\n  var reFlags = /\\w*$/;\n\n  /** Used to detect bad signed hexadecimal string values. */\n  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n  /** Used to detect binary string values. */\n  var reIsBinary = /^0b[01]+$/i;\n\n  /** Used to detect host constructors (Safari). */\n  var reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n  /** Used to detect octal string values. */\n  var reIsOctal = /^0o[0-7]+$/i;\n\n  /** Used to detect unsigned integer values. */\n  var reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n  /** Used to match Latin Unicode letters (excluding mathematical operators). */\n  var reLatin = /[\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\xff\\u0100-\\u017f]/g;\n\n  /** Used to ensure capturing order of template delimiters. */\n  var reNoMatch = /($^)/;\n\n  /** Used to match unescaped characters in compiled string literals. */\n  var reUnescapedString = /['\\n\\r\\u2028\\u2029\\\\]/g;\n\n  /** Used to compose unicode character classes. */\n  var rsAstralRange = '\\\\ud800-\\\\udfff',\n      rsComboMarksRange = '\\\\u0300-\\\\u036f',\n      reComboHalfMarksRange = '\\\\ufe20-\\\\ufe2f',\n      rsComboSymbolsRange = '\\\\u20d0-\\\\u20ff',\n      rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,\n      rsDingbatRange = '\\\\u2700-\\\\u27bf',\n      rsLowerRange = 'a-z\\\\xdf-\\\\xf6\\\\xf8-\\\\xff',\n      rsMathOpRange = '\\\\xac\\\\xb1\\\\xd7\\\\xf7',\n      rsNonCharRange = '\\\\x00-\\\\x2f\\\\x3a-\\\\x40\\\\x5b-\\\\x60\\\\x7b-\\\\xbf',\n      rsPunctuationRange = '\\\\u2000-\\\\u206f',\n      rsSpaceRange = ' \\\\t\\\\x0b\\\\f\\\\xa0\\\\ufeff\\\\n\\\\r\\\\u2028\\\\u2029\\\\u1680\\\\u180e\\\\u2000\\\\u2001\\\\u2002\\\\u2003\\\\u2004\\\\u2005\\\\u2006\\\\u2007\\\\u2008\\\\u2009\\\\u200a\\\\u202f\\\\u205f\\\\u3000',\n      rsUpperRange = 'A-Z\\\\xc0-\\\\xd6\\\\xd8-\\\\xde',\n      rsVarRange = '\\\\ufe0e\\\\ufe0f',\n      rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;\n\n  /** Used to compose unicode capture groups. */\n  var rsApos = \"['\\u2019]\",\n      rsAstral = '[' + rsAstralRange + ']',\n      rsBreak = '[' + rsBreakRange + ']',\n      rsCombo = '[' + rsComboRange + ']',\n      rsDigits = '\\\\d+',\n      rsDingbat = '[' + rsDingbatRange + ']',\n      rsLower = '[' + rsLowerRange + ']',\n      rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',\n      rsFitz = '\\\\ud83c[\\\\udffb-\\\\udfff]',\n      rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',\n      rsNonAstral = '[^' + rsAstralRange + ']',\n      rsRegional = '(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}',\n      rsSurrPair = '[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]',\n      rsUpper = '[' + rsUpperRange + ']',\n      rsZWJ = '\\\\u200d';\n\n  /** Used to compose unicode regexes. */\n  var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',\n      rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',\n      rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',\n      rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',\n      reOptMod = rsModifier + '?',\n      rsOptVar = '[' + rsVarRange + ']?',\n      rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',\n      rsOrdLower = '\\\\d*(?:1st|2nd|3rd|(?![123])\\\\dth)(?=\\\\b|[A-Z_])',\n      rsOrdUpper = '\\\\d*(?:1ST|2ND|3RD|(?![123])\\\\dTH)(?=\\\\b|[a-z_])',\n      rsSeq = rsOptVar + reOptMod + rsOptJoin,\n      rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,\n      rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';\n\n  /** Used to match apostrophes. */\n  var reApos = RegExp(rsApos, 'g');\n\n  /**\n   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and\n   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).\n   */\n  var reComboMark = RegExp(rsCombo, 'g');\n\n  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */\n  var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');\n\n  /** Used to match complex or compound words. */\n  var reUnicodeWord = RegExp([\n    rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',\n    rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',\n    rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,\n    rsUpper + '+' + rsOptContrUpper,\n    rsOrdUpper,\n    rsOrdLower,\n    rsDigits,\n    rsEmoji\n  ].join('|'), 'g');\n\n  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */\n  var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');\n\n  /** Used to detect strings that need a more robust regexp to match words. */\n  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;\n\n  /** Used to assign default `context` object properties. */\n  var contextProps = [\n    'Array', 'Buffer', 'DataView', 'Date', 'Error', 'Float32Array', 'Float64Array',\n    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object',\n    'Promise', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError', 'Uint8Array',\n    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap',\n    '_', 'clearTimeout', 'isFinite', 'parseInt', 'setTimeout'\n  ];\n\n  /** Used to make template sourceURLs easier to identify. */\n  var templateCounter = -1;\n\n  /** Used to identify `toStringTag` values of typed arrays. */\n  var typedArrayTags = {};\n  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\n  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\n  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\n  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\n  typedArrayTags[uint32Tag] = true;\n  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =\n  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\n  typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\n  typedArrayTags[errorTag] = typedArrayTags[funcTag] =\n  typedArrayTags[mapTag] = typedArrayTags[numberTag] =\n  typedArrayTags[objectTag] = typedArrayTags[regexpTag] =\n  typedArrayTags[setTag] = typedArrayTags[stringTag] =\n  typedArrayTags[weakMapTag] = false;\n\n  /** Used to identify `toStringTag` values supported by `_.clone`. */\n  var cloneableTags = {};\n  cloneableTags[argsTag] = cloneableTags[arrayTag] =\n  cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =\n  cloneableTags[boolTag] = cloneableTags[dateTag] =\n  cloneableTags[float32Tag] = cloneableTags[float64Tag] =\n  cloneableTags[int8Tag] = cloneableTags[int16Tag] =\n  cloneableTags[int32Tag] = cloneableTags[mapTag] =\n  cloneableTags[numberTag] = cloneableTags[objectTag] =\n  cloneableTags[regexpTag] = cloneableTags[setTag] =\n  cloneableTags[stringTag] = cloneableTags[symbolTag] =\n  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =\n  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\n  cloneableTags[errorTag] = cloneableTags[funcTag] =\n  cloneableTags[weakMapTag] = false;\n\n  /** Used to map Latin Unicode letters to basic Latin letters. */\n  var deburredLetters = {\n    // Latin-1 Supplement block.\n    '\\xc0': 'A',  '\\xc1': 'A', '\\xc2': 'A', '\\xc3': 'A', '\\xc4': 'A', '\\xc5': 'A',\n    '\\xe0': 'a',  '\\xe1': 'a', '\\xe2': 'a', '\\xe3': 'a', '\\xe4': 'a', '\\xe5': 'a',\n    '\\xc7': 'C',  '\\xe7': 'c',\n    '\\xd0': 'D',  '\\xf0': 'd',\n    '\\xc8': 'E',  '\\xc9': 'E', '\\xca': 'E', '\\xcb': 'E',\n    '\\xe8': 'e',  '\\xe9': 'e', '\\xea': 'e', '\\xeb': 'e',\n    '\\xcc': 'I',  '\\xcd': 'I', '\\xce': 'I', '\\xcf': 'I',\n    '\\xec': 'i',  '\\xed': 'i', '\\xee': 'i', '\\xef': 'i',\n    '\\xd1': 'N',  '\\xf1': 'n',\n    '\\xd2': 'O',  '\\xd3': 'O', '\\xd4': 'O', '\\xd5': 'O', '\\xd6': 'O', '\\xd8': 'O',\n    '\\xf2': 'o',  '\\xf3': 'o', '\\xf4': 'o', '\\xf5': 'o', '\\xf6': 'o', '\\xf8': 'o',\n    '\\xd9': 'U',  '\\xda': 'U', '\\xdb': 'U', '\\xdc': 'U',\n    '\\xf9': 'u',  '\\xfa': 'u', '\\xfb': 'u', '\\xfc': 'u',\n    '\\xdd': 'Y',  '\\xfd': 'y', '\\xff': 'y',\n    '\\xc6': 'Ae', '\\xe6': 'ae',\n    '\\xde': 'Th', '\\xfe': 'th',\n    '\\xdf': 'ss',\n    // Latin Extended-A block.\n    '\\u0100': 'A',  '\\u0102': 'A', '\\u0104': 'A',\n    '\\u0101': 'a',  '\\u0103': 'a', '\\u0105': 'a',\n    '\\u0106': 'C',  '\\u0108': 'C', '\\u010a': 'C', '\\u010c': 'C',\n    '\\u0107': 'c',  '\\u0109': 'c', '\\u010b': 'c', '\\u010d': 'c',\n    '\\u010e': 'D',  '\\u0110': 'D', '\\u010f': 'd', '\\u0111': 'd',\n    '\\u0112': 'E',  '\\u0114': 'E', '\\u0116': 'E', '\\u0118': 'E', '\\u011a': 'E',\n    '\\u0113': 'e',  '\\u0115': 'e', '\\u0117': 'e', '\\u0119': 'e', '\\u011b': 'e',\n    '\\u011c': 'G',  '\\u011e': 'G', '\\u0120': 'G', '\\u0122': 'G',\n    '\\u011d': 'g',  '\\u011f': 'g', '\\u0121': 'g', '\\u0123': 'g',\n    '\\u0124': 'H',  '\\u0126': 'H', '\\u0125': 'h', '\\u0127': 'h',\n    '\\u0128': 'I',  '\\u012a': 'I', '\\u012c': 'I', '\\u012e': 'I', '\\u0130': 'I',\n    '\\u0129': 'i',  '\\u012b': 'i', '\\u012d': 'i', '\\u012f': 'i', '\\u0131': 'i',\n    '\\u0134': 'J',  '\\u0135': 'j',\n    '\\u0136': 'K',  '\\u0137': 'k', '\\u0138': 'k',\n    '\\u0139': 'L',  '\\u013b': 'L', '\\u013d': 'L', '\\u013f': 'L', '\\u0141': 'L',\n    '\\u013a': 'l',  '\\u013c': 'l', '\\u013e': 'l', '\\u0140': 'l', '\\u0142': 'l',\n    '\\u0143': 'N',  '\\u0145': 'N', '\\u0147': 'N', '\\u014a': 'N',\n    '\\u0144': 'n',  '\\u0146': 'n', '\\u0148': 'n', '\\u014b': 'n',\n    '\\u014c': 'O',  '\\u014e': 'O', '\\u0150': 'O',\n    '\\u014d': 'o',  '\\u014f': 'o', '\\u0151': 'o',\n    '\\u0154': 'R',  '\\u0156': 'R', '\\u0158': 'R',\n    '\\u0155': 'r',  '\\u0157': 'r', '\\u0159': 'r',\n    '\\u015a': 'S',  '\\u015c': 'S', '\\u015e': 'S', '\\u0160': 'S',\n    '\\u015b': 's',  '\\u015d': 's', '\\u015f': 's', '\\u0161': 's',\n    '\\u0162': 'T',  '\\u0164': 'T', '\\u0166': 'T',\n    '\\u0163': 't',  '\\u0165': 't', '\\u0167': 't',\n    '\\u0168': 'U',  '\\u016a': 'U', '\\u016c': 'U', '\\u016e': 'U', '\\u0170': 'U', '\\u0172': 'U',\n    '\\u0169': 'u',  '\\u016b': 'u', '\\u016d': 'u', '\\u016f': 'u', '\\u0171': 'u', '\\u0173': 'u',\n    '\\u0174': 'W',  '\\u0175': 'w',\n    '\\u0176': 'Y',  '\\u0177': 'y', '\\u0178': 'Y',\n    '\\u0179': 'Z',  '\\u017b': 'Z', '\\u017d': 'Z',\n    '\\u017a': 'z',  '\\u017c': 'z', '\\u017e': 'z',\n    '\\u0132': 'IJ', '\\u0133': 'ij',\n    '\\u0152': 'Oe', '\\u0153': 'oe',\n    '\\u0149': \"'n\", '\\u017f': 's'\n  };\n\n  /** Used to map characters to HTML entities. */\n  var htmlEscapes = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#39;'\n  };\n\n  /** Used to map HTML entities to characters. */\n  var htmlUnescapes = {\n    '&amp;': '&',\n    '&lt;': '<',\n    '&gt;': '>',\n    '&quot;': '\"',\n    '&#39;': \"'\"\n  };\n\n  /** Used to escape characters for inclusion in compiled string literals. */\n  var stringEscapes = {\n    '\\\\': '\\\\',\n    \"'\": \"'\",\n    '\\n': 'n',\n    '\\r': 'r',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n  };\n\n  /** Built-in method references without a dependency on `root`. */\n  var freeParseFloat = parseFloat,\n      freeParseInt = parseInt;\n\n  /** Detect free variable `global` from Node.js. */\n  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n  /** Detect free variable `self`. */\n  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n  /** Used as a reference to the global object. */\n  var root = freeGlobal || freeSelf || Function('return this')();\n\n  /** Detect free variable `exports`. */\n  var freeExports =  true && exports && !exports.nodeType && exports;\n\n  /** Detect free variable `module`. */\n  var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n  /** Detect the popular CommonJS extension `module.exports`. */\n  var moduleExports = freeModule && freeModule.exports === freeExports;\n\n  /** Detect free variable `process` from Node.js. */\n  var freeProcess = moduleExports && freeGlobal.process;\n\n  /** Used to access faster Node.js helpers. */\n  var nodeUtil = (function() {\n    try {\n      // Use `util.types` for Node.js 10+.\n      var types = freeModule && freeModule.require && freeModule.require('util').types;\n\n      if (types) {\n        return types;\n      }\n\n      // Legacy `process.binding('util')` for Node.js < 10.\n      return freeProcess && freeProcess.binding && freeProcess.binding('util');\n    } catch (e) {}\n  }());\n\n  /* Node.js helper references. */\n  var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,\n      nodeIsDate = nodeUtil && nodeUtil.isDate,\n      nodeIsMap = nodeUtil && nodeUtil.isMap,\n      nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,\n      nodeIsSet = nodeUtil && nodeUtil.isSet,\n      nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * A faster alternative to `Function#apply`, this function invokes `func`\n   * with the `this` binding of `thisArg` and the arguments of `args`.\n   *\n   * @private\n   * @param {Function} func The function to invoke.\n   * @param {*} thisArg The `this` binding of `func`.\n   * @param {Array} args The arguments to invoke `func` with.\n   * @returns {*} Returns the result of `func`.\n   */\n  function apply(func, thisArg, args) {\n    switch (args.length) {\n      case 0: return func.call(thisArg);\n      case 1: return func.call(thisArg, args[0]);\n      case 2: return func.call(thisArg, args[0], args[1]);\n      case 3: return func.call(thisArg, args[0], args[1], args[2]);\n    }\n    return func.apply(thisArg, args);\n  }\n\n  /**\n   * A specialized version of `baseAggregator` for arrays.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} setter The function to set `accumulator` values.\n   * @param {Function} iteratee The iteratee to transform keys.\n   * @param {Object} accumulator The initial aggregated object.\n   * @returns {Function} Returns `accumulator`.\n   */\n  function arrayAggregator(array, setter, iteratee, accumulator) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    while (++index < length) {\n      var value = array[index];\n      setter(accumulator, value, iteratee(value), array);\n    }\n    return accumulator;\n  }\n\n  /**\n   * A specialized version of `_.forEach` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns `array`.\n   */\n  function arrayEach(array, iteratee) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    while (++index < length) {\n      if (iteratee(array[index], index, array) === false) {\n        break;\n      }\n    }\n    return array;\n  }\n\n  /**\n   * A specialized version of `_.forEachRight` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns `array`.\n   */\n  function arrayEachRight(array, iteratee) {\n    var length = array == null ? 0 : array.length;\n\n    while (length--) {\n      if (iteratee(array[length], length, array) === false) {\n        break;\n      }\n    }\n    return array;\n  }\n\n  /**\n   * A specialized version of `_.every` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {boolean} Returns `true` if all elements pass the predicate check,\n   *  else `false`.\n   */\n  function arrayEvery(array, predicate) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    while (++index < length) {\n      if (!predicate(array[index], index, array)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * A specialized version of `_.filter` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {Array} Returns the new filtered array.\n   */\n  function arrayFilter(array, predicate) {\n    var index = -1,\n        length = array == null ? 0 : array.length,\n        resIndex = 0,\n        result = [];\n\n    while (++index < length) {\n      var value = array[index];\n      if (predicate(value, index, array)) {\n        result[resIndex++] = value;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * A specialized version of `_.includes` for arrays without support for\n   * specifying an index to search from.\n   *\n   * @private\n   * @param {Array} [array] The array to inspect.\n   * @param {*} target The value to search for.\n   * @returns {boolean} Returns `true` if `target` is found, else `false`.\n   */\n  function arrayIncludes(array, value) {\n    var length = array == null ? 0 : array.length;\n    return !!length && baseIndexOf(array, value, 0) > -1;\n  }\n\n  /**\n   * This function is like `arrayIncludes` except that it accepts a comparator.\n   *\n   * @private\n   * @param {Array} [array] The array to inspect.\n   * @param {*} target The value to search for.\n   * @param {Function} comparator The comparator invoked per element.\n   * @returns {boolean} Returns `true` if `target` is found, else `false`.\n   */\n  function arrayIncludesWith(array, value, comparator) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    while (++index < length) {\n      if (comparator(value, array[index])) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * A specialized version of `_.map` for arrays without support for iteratee\n   * shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns the new mapped array.\n   */\n  function arrayMap(array, iteratee) {\n    var index = -1,\n        length = array == null ? 0 : array.length,\n        result = Array(length);\n\n    while (++index < length) {\n      result[index] = iteratee(array[index], index, array);\n    }\n    return result;\n  }\n\n  /**\n   * Appends the elements of `values` to `array`.\n   *\n   * @private\n   * @param {Array} array The array to modify.\n   * @param {Array} values The values to append.\n   * @returns {Array} Returns `array`.\n   */\n  function arrayPush(array, values) {\n    var index = -1,\n        length = values.length,\n        offset = array.length;\n\n    while (++index < length) {\n      array[offset + index] = values[index];\n    }\n    return array;\n  }\n\n  /**\n   * A specialized version of `_.reduce` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @param {*} [accumulator] The initial value.\n   * @param {boolean} [initAccum] Specify using the first element of `array` as\n   *  the initial value.\n   * @returns {*} Returns the accumulated value.\n   */\n  function arrayReduce(array, iteratee, accumulator, initAccum) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    if (initAccum && length) {\n      accumulator = array[++index];\n    }\n    while (++index < length) {\n      accumulator = iteratee(accumulator, array[index], index, array);\n    }\n    return accumulator;\n  }\n\n  /**\n   * A specialized version of `_.reduceRight` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @param {*} [accumulator] The initial value.\n   * @param {boolean} [initAccum] Specify using the last element of `array` as\n   *  the initial value.\n   * @returns {*} Returns the accumulated value.\n   */\n  function arrayReduceRight(array, iteratee, accumulator, initAccum) {\n    var length = array == null ? 0 : array.length;\n    if (initAccum && length) {\n      accumulator = array[--length];\n    }\n    while (length--) {\n      accumulator = iteratee(accumulator, array[length], length, array);\n    }\n    return accumulator;\n  }\n\n  /**\n   * A specialized version of `_.some` for arrays without support for iteratee\n   * shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {boolean} Returns `true` if any element passes the predicate check,\n   *  else `false`.\n   */\n  function arraySome(array, predicate) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    while (++index < length) {\n      if (predicate(array[index], index, array)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Gets the size of an ASCII `string`.\n   *\n   * @private\n   * @param {string} string The string inspect.\n   * @returns {number} Returns the string size.\n   */\n  var asciiSize = baseProperty('length');\n\n  /**\n   * Converts an ASCII `string` to an array.\n   *\n   * @private\n   * @param {string} string The string to convert.\n   * @returns {Array} Returns the converted array.\n   */\n  function asciiToArray(string) {\n    return string.split('');\n  }\n\n  /**\n   * Splits an ASCII `string` into an array of its words.\n   *\n   * @private\n   * @param {string} The string to inspect.\n   * @returns {Array} Returns the words of `string`.\n   */\n  function asciiWords(string) {\n    return string.match(reAsciiWord) || [];\n  }\n\n  /**\n   * The base implementation of methods like `_.findKey` and `_.findLastKey`,\n   * without support for iteratee shorthands, which iterates over `collection`\n   * using `eachFunc`.\n   *\n   * @private\n   * @param {Array|Object} collection The collection to inspect.\n   * @param {Function} predicate The function invoked per iteration.\n   * @param {Function} eachFunc The function to iterate over `collection`.\n   * @returns {*} Returns the found element or its key, else `undefined`.\n   */\n  function baseFindKey(collection, predicate, eachFunc) {\n    var result;\n    eachFunc(collection, function(value, key, collection) {\n      if (predicate(value, key, collection)) {\n        result = key;\n        return false;\n      }\n    });\n    return result;\n  }\n\n  /**\n   * The base implementation of `_.findIndex` and `_.findLastIndex` without\n   * support for iteratee shorthands.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {Function} predicate The function invoked per iteration.\n   * @param {number} fromIndex The index to search from.\n   * @param {boolean} [fromRight] Specify iterating from right to left.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function baseFindIndex(array, predicate, fromIndex, fromRight) {\n    var length = array.length,\n        index = fromIndex + (fromRight ? 1 : -1);\n\n    while ((fromRight ? index-- : ++index < length)) {\n      if (predicate(array[index], index, array)) {\n        return index;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} value The value to search for.\n   * @param {number} fromIndex The index to search from.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function baseIndexOf(array, value, fromIndex) {\n    return value === value\n      ? strictIndexOf(array, value, fromIndex)\n      : baseFindIndex(array, baseIsNaN, fromIndex);\n  }\n\n  /**\n   * This function is like `baseIndexOf` except that it accepts a comparator.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} value The value to search for.\n   * @param {number} fromIndex The index to search from.\n   * @param {Function} comparator The comparator invoked per element.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function baseIndexOfWith(array, value, fromIndex, comparator) {\n    var index = fromIndex - 1,\n        length = array.length;\n\n    while (++index < length) {\n      if (comparator(array[index], value)) {\n        return index;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * The base implementation of `_.isNaN` without support for number objects.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n   */\n  function baseIsNaN(value) {\n    return value !== value;\n  }\n\n  /**\n   * The base implementation of `_.mean` and `_.meanBy` without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} array The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {number} Returns the mean.\n   */\n  function baseMean(array, iteratee) {\n    var length = array == null ? 0 : array.length;\n    return length ? (baseSum(array, iteratee) / length) : NAN;\n  }\n\n  /**\n   * The base implementation of `_.property` without support for deep paths.\n   *\n   * @private\n   * @param {string} key The key of the property to get.\n   * @returns {Function} Returns the new accessor function.\n   */\n  function baseProperty(key) {\n    return function(object) {\n      return object == null ? undefined : object[key];\n    };\n  }\n\n  /**\n   * The base implementation of `_.propertyOf` without support for deep paths.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @returns {Function} Returns the new accessor function.\n   */\n  function basePropertyOf(object) {\n    return function(key) {\n      return object == null ? undefined : object[key];\n    };\n  }\n\n  /**\n   * The base implementation of `_.reduce` and `_.reduceRight`, without support\n   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.\n   *\n   * @private\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @param {*} accumulator The initial value.\n   * @param {boolean} initAccum Specify using the first or last element of\n   *  `collection` as the initial value.\n   * @param {Function} eachFunc The function to iterate over `collection`.\n   * @returns {*} Returns the accumulated value.\n   */\n  function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {\n    eachFunc(collection, function(value, index, collection) {\n      accumulator = initAccum\n        ? (initAccum = false, value)\n        : iteratee(accumulator, value, index, collection);\n    });\n    return accumulator;\n  }\n\n  /**\n   * The base implementation of `_.sortBy` which uses `comparer` to define the\n   * sort order of `array` and replaces criteria objects with their corresponding\n   * values.\n   *\n   * @private\n   * @param {Array} array The array to sort.\n   * @param {Function} comparer The function to define sort order.\n   * @returns {Array} Returns `array`.\n   */\n  function baseSortBy(array, comparer) {\n    var length = array.length;\n\n    array.sort(comparer);\n    while (length--) {\n      array[length] = array[length].value;\n    }\n    return array;\n  }\n\n  /**\n   * The base implementation of `_.sum` and `_.sumBy` without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} array The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {number} Returns the sum.\n   */\n  function baseSum(array, iteratee) {\n    var result,\n        index = -1,\n        length = array.length;\n\n    while (++index < length) {\n      var current = iteratee(array[index]);\n      if (current !== undefined) {\n        result = result === undefined ? current : (result + current);\n      }\n    }\n    return result;\n  }\n\n  /**\n   * The base implementation of `_.times` without support for iteratee shorthands\n   * or max array length checks.\n   *\n   * @private\n   * @param {number} n The number of times to invoke `iteratee`.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns the array of results.\n   */\n  function baseTimes(n, iteratee) {\n    var index = -1,\n        result = Array(n);\n\n    while (++index < n) {\n      result[index] = iteratee(index);\n    }\n    return result;\n  }\n\n  /**\n   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array\n   * of key-value pairs for `object` corresponding to the property names of `props`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {Array} props The property names to get values for.\n   * @returns {Object} Returns the key-value pairs.\n   */\n  function baseToPairs(object, props) {\n    return arrayMap(props, function(key) {\n      return [key, object[key]];\n    });\n  }\n\n  /**\n   * The base implementation of `_.trim`.\n   *\n   * @private\n   * @param {string} string The string to trim.\n   * @returns {string} Returns the trimmed string.\n   */\n  function baseTrim(string) {\n    return string\n      ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')\n      : string;\n  }\n\n  /**\n   * The base implementation of `_.unary` without support for storing metadata.\n   *\n   * @private\n   * @param {Function} func The function to cap arguments for.\n   * @returns {Function} Returns the new capped function.\n   */\n  function baseUnary(func) {\n    return function(value) {\n      return func(value);\n    };\n  }\n\n  /**\n   * The base implementation of `_.values` and `_.valuesIn` which creates an\n   * array of `object` property values corresponding to the property names\n   * of `props`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {Array} props The property names to get values for.\n   * @returns {Object} Returns the array of property values.\n   */\n  function baseValues(object, props) {\n    return arrayMap(props, function(key) {\n      return object[key];\n    });\n  }\n\n  /**\n   * Checks if a `cache` value for `key` exists.\n   *\n   * @private\n   * @param {Object} cache The cache to query.\n   * @param {string} key The key of the entry to check.\n   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n   */\n  function cacheHas(cache, key) {\n    return cache.has(key);\n  }\n\n  /**\n   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol\n   * that is not found in the character symbols.\n   *\n   * @private\n   * @param {Array} strSymbols The string symbols to inspect.\n   * @param {Array} chrSymbols The character symbols to find.\n   * @returns {number} Returns the index of the first unmatched string symbol.\n   */\n  function charsStartIndex(strSymbols, chrSymbols) {\n    var index = -1,\n        length = strSymbols.length;\n\n    while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}\n    return index;\n  }\n\n  /**\n   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol\n   * that is not found in the character symbols.\n   *\n   * @private\n   * @param {Array} strSymbols The string symbols to inspect.\n   * @param {Array} chrSymbols The character symbols to find.\n   * @returns {number} Returns the index of the last unmatched string symbol.\n   */\n  function charsEndIndex(strSymbols, chrSymbols) {\n    var index = strSymbols.length;\n\n    while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}\n    return index;\n  }\n\n  /**\n   * Gets the number of `placeholder` occurrences in `array`.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} placeholder The placeholder to search for.\n   * @returns {number} Returns the placeholder count.\n   */\n  function countHolders(array, placeholder) {\n    var length = array.length,\n        result = 0;\n\n    while (length--) {\n      if (array[length] === placeholder) {\n        ++result;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A\n   * letters to basic Latin letters.\n   *\n   * @private\n   * @param {string} letter The matched letter to deburr.\n   * @returns {string} Returns the deburred letter.\n   */\n  var deburrLetter = basePropertyOf(deburredLetters);\n\n  /**\n   * Used by `_.escape` to convert characters to HTML entities.\n   *\n   * @private\n   * @param {string} chr The matched character to escape.\n   * @returns {string} Returns the escaped character.\n   */\n  var escapeHtmlChar = basePropertyOf(htmlEscapes);\n\n  /**\n   * Used by `_.template` to escape characters for inclusion in compiled string literals.\n   *\n   * @private\n   * @param {string} chr The matched character to escape.\n   * @returns {string} Returns the escaped character.\n   */\n  function escapeStringChar(chr) {\n    return '\\\\' + stringEscapes[chr];\n  }\n\n  /**\n   * Gets the value at `key` of `object`.\n   *\n   * @private\n   * @param {Object} [object] The object to query.\n   * @param {string} key The key of the property to get.\n   * @returns {*} Returns the property value.\n   */\n  function getValue(object, key) {\n    return object == null ? undefined : object[key];\n  }\n\n  /**\n   * Checks if `string` contains Unicode symbols.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @returns {boolean} Returns `true` if a symbol is found, else `false`.\n   */\n  function hasUnicode(string) {\n    return reHasUnicode.test(string);\n  }\n\n  /**\n   * Checks if `string` contains a word composed of Unicode symbols.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @returns {boolean} Returns `true` if a word is found, else `false`.\n   */\n  function hasUnicodeWord(string) {\n    return reHasUnicodeWord.test(string);\n  }\n\n  /**\n   * Converts `iterator` to an array.\n   *\n   * @private\n   * @param {Object} iterator The iterator to convert.\n   * @returns {Array} Returns the converted array.\n   */\n  function iteratorToArray(iterator) {\n    var data,\n        result = [];\n\n    while (!(data = iterator.next()).done) {\n      result.push(data.value);\n    }\n    return result;\n  }\n\n  /**\n   * Converts `map` to its key-value pairs.\n   *\n   * @private\n   * @param {Object} map The map to convert.\n   * @returns {Array} Returns the key-value pairs.\n   */\n  function mapToArray(map) {\n    var index = -1,\n        result = Array(map.size);\n\n    map.forEach(function(value, key) {\n      result[++index] = [key, value];\n    });\n    return result;\n  }\n\n  /**\n   * Creates a unary function that invokes `func` with its argument transformed.\n   *\n   * @private\n   * @param {Function} func The function to wrap.\n   * @param {Function} transform The argument transform.\n   * @returns {Function} Returns the new function.\n   */\n  function overArg(func, transform) {\n    return function(arg) {\n      return func(transform(arg));\n    };\n  }\n\n  /**\n   * Replaces all `placeholder` elements in `array` with an internal placeholder\n   * and returns an array of their indexes.\n   *\n   * @private\n   * @param {Array} array The array to modify.\n   * @param {*} placeholder The placeholder to replace.\n   * @returns {Array} Returns the new array of placeholder indexes.\n   */\n  function replaceHolders(array, placeholder) {\n    var index = -1,\n        length = array.length,\n        resIndex = 0,\n        result = [];\n\n    while (++index < length) {\n      var value = array[index];\n      if (value === placeholder || value === PLACEHOLDER) {\n        array[index] = PLACEHOLDER;\n        result[resIndex++] = index;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Converts `set` to an array of its values.\n   *\n   * @private\n   * @param {Object} set The set to convert.\n   * @returns {Array} Returns the values.\n   */\n  function setToArray(set) {\n    var index = -1,\n        result = Array(set.size);\n\n    set.forEach(function(value) {\n      result[++index] = value;\n    });\n    return result;\n  }\n\n  /**\n   * Converts `set` to its value-value pairs.\n   *\n   * @private\n   * @param {Object} set The set to convert.\n   * @returns {Array} Returns the value-value pairs.\n   */\n  function setToPairs(set) {\n    var index = -1,\n        result = Array(set.size);\n\n    set.forEach(function(value) {\n      result[++index] = [value, value];\n    });\n    return result;\n  }\n\n  /**\n   * A specialized version of `_.indexOf` which performs strict equality\n   * comparisons of values, i.e. `===`.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} value The value to search for.\n   * @param {number} fromIndex The index to search from.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function strictIndexOf(array, value, fromIndex) {\n    var index = fromIndex - 1,\n        length = array.length;\n\n    while (++index < length) {\n      if (array[index] === value) {\n        return index;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * A specialized version of `_.lastIndexOf` which performs strict equality\n   * comparisons of values, i.e. `===`.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} value The value to search for.\n   * @param {number} fromIndex The index to search from.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function strictLastIndexOf(array, value, fromIndex) {\n    var index = fromIndex + 1;\n    while (index--) {\n      if (array[index] === value) {\n        return index;\n      }\n    }\n    return index;\n  }\n\n  /**\n   * Gets the number of symbols in `string`.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @returns {number} Returns the string size.\n   */\n  function stringSize(string) {\n    return hasUnicode(string)\n      ? unicodeSize(string)\n      : asciiSize(string);\n  }\n\n  /**\n   * Converts `string` to an array.\n   *\n   * @private\n   * @param {string} string The string to convert.\n   * @returns {Array} Returns the converted array.\n   */\n  function stringToArray(string) {\n    return hasUnicode(string)\n      ? unicodeToArray(string)\n      : asciiToArray(string);\n  }\n\n  /**\n   * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace\n   * character of `string`.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @returns {number} Returns the index of the last non-whitespace character.\n   */\n  function trimmedEndIndex(string) {\n    var index = string.length;\n\n    while (index-- && reWhitespace.test(string.charAt(index))) {}\n    return index;\n  }\n\n  /**\n   * Used by `_.unescape` to convert HTML entities to characters.\n   *\n   * @private\n   * @param {string} chr The matched character to unescape.\n   * @returns {string} Returns the unescaped character.\n   */\n  var unescapeHtmlChar = basePropertyOf(htmlUnescapes);\n\n  /**\n   * Gets the size of a Unicode `string`.\n   *\n   * @private\n   * @param {string} string The string inspect.\n   * @returns {number} Returns the string size.\n   */\n  function unicodeSize(string) {\n    var result = reUnicode.lastIndex = 0;\n    while (reUnicode.test(string)) {\n      ++result;\n    }\n    return result;\n  }\n\n  /**\n   * Converts a Unicode `string` to an array.\n   *\n   * @private\n   * @param {string} string The string to convert.\n   * @returns {Array} Returns the converted array.\n   */\n  function unicodeToArray(string) {\n    return string.match(reUnicode) || [];\n  }\n\n  /**\n   * Splits a Unicode `string` into an array of its words.\n   *\n   * @private\n   * @param {string} The string to inspect.\n   * @returns {Array} Returns the words of `string`.\n   */\n  function unicodeWords(string) {\n    return string.match(reUnicodeWord) || [];\n  }\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * Create a new pristine `lodash` function using the `context` object.\n   *\n   * @static\n   * @memberOf _\n   * @since 1.1.0\n   * @category Util\n   * @param {Object} [context=root] The context object.\n   * @returns {Function} Returns a new `lodash` function.\n   * @example\n   *\n   * _.mixin({ 'foo': _.constant('foo') });\n   *\n   * var lodash = _.runInContext();\n   * lodash.mixin({ 'bar': lodash.constant('bar') });\n   *\n   * _.isFunction(_.foo);\n   * // => true\n   * _.isFunction(_.bar);\n   * // => false\n   *\n   * lodash.isFunction(lodash.foo);\n   * // => false\n   * lodash.isFunction(lodash.bar);\n   * // => true\n   *\n   * // Create a suped-up `defer` in Node.js.\n   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;\n   */\n  var runInContext = (function runInContext(context) {\n    context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));\n\n    /** Built-in constructor references. */\n    var Array = context.Array,\n        Date = context.Date,\n        Error = context.Error,\n        Function = context.Function,\n        Math = context.Math,\n        Object = context.Object,\n        RegExp = context.RegExp,\n        String = context.String,\n        TypeError = context.TypeError;\n\n    /** Used for built-in method references. */\n    var arrayProto = Array.prototype,\n        funcProto = Function.prototype,\n        objectProto = Object.prototype;\n\n    /** Used to detect overreaching core-js shims. */\n    var coreJsData = context['__core-js_shared__'];\n\n    /** Used to resolve the decompiled source of functions. */\n    var funcToString = funcProto.toString;\n\n    /** Used to check objects for own properties. */\n    var hasOwnProperty = objectProto.hasOwnProperty;\n\n    /** Used to generate unique IDs. */\n    var idCounter = 0;\n\n    /** Used to detect methods masquerading as native. */\n    var maskSrcKey = (function() {\n      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n      return uid ? ('Symbol(src)_1.' + uid) : '';\n    }());\n\n    /**\n     * Used to resolve the\n     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n     * of values.\n     */\n    var nativeObjectToString = objectProto.toString;\n\n    /** Used to infer the `Object` constructor. */\n    var objectCtorString = funcToString.call(Object);\n\n    /** Used to restore the original `_` reference in `_.noConflict`. */\n    var oldDash = root._;\n\n    /** Used to detect if a method is native. */\n    var reIsNative = RegExp('^' +\n      funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n      .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n    );\n\n    /** Built-in value references. */\n    var Buffer = moduleExports ? context.Buffer : undefined,\n        Symbol = context.Symbol,\n        Uint8Array = context.Uint8Array,\n        allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,\n        getPrototype = overArg(Object.getPrototypeOf, Object),\n        objectCreate = Object.create,\n        propertyIsEnumerable = objectProto.propertyIsEnumerable,\n        splice = arrayProto.splice,\n        spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined,\n        symIterator = Symbol ? Symbol.iterator : undefined,\n        symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n    var defineProperty = (function() {\n      try {\n        var func = getNative(Object, 'defineProperty');\n        func({}, '', {});\n        return func;\n      } catch (e) {}\n    }());\n\n    /** Mocked built-ins. */\n    var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout,\n        ctxNow = Date && Date.now !== root.Date.now && Date.now,\n        ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;\n\n    /* Built-in method references for those with the same name as other `lodash` methods. */\n    var nativeCeil = Math.ceil,\n        nativeFloor = Math.floor,\n        nativeGetSymbols = Object.getOwnPropertySymbols,\n        nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,\n        nativeIsFinite = context.isFinite,\n        nativeJoin = arrayProto.join,\n        nativeKeys = overArg(Object.keys, Object),\n        nativeMax = Math.max,\n        nativeMin = Math.min,\n        nativeNow = Date.now,\n        nativeParseInt = context.parseInt,\n        nativeRandom = Math.random,\n        nativeReverse = arrayProto.reverse;\n\n    /* Built-in method references that are verified to be native. */\n    var DataView = getNative(context, 'DataView'),\n        Map = getNative(context, 'Map'),\n        Promise = getNative(context, 'Promise'),\n        Set = getNative(context, 'Set'),\n        WeakMap = getNative(context, 'WeakMap'),\n        nativeCreate = getNative(Object, 'create');\n\n    /** Used to store function metadata. */\n    var metaMap = WeakMap && new WeakMap;\n\n    /** Used to lookup unminified function names. */\n    var realNames = {};\n\n    /** Used to detect maps, sets, and weakmaps. */\n    var dataViewCtorString = toSource(DataView),\n        mapCtorString = toSource(Map),\n        promiseCtorString = toSource(Promise),\n        setCtorString = toSource(Set),\n        weakMapCtorString = toSource(WeakMap);\n\n    /** Used to convert symbols to primitives and strings. */\n    var symbolProto = Symbol ? Symbol.prototype : undefined,\n        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,\n        symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a `lodash` object which wraps `value` to enable implicit method\n     * chain sequences. Methods that operate on and return arrays, collections,\n     * and functions can be chained together. Methods that retrieve a single value\n     * or may return a primitive value will automatically end the chain sequence\n     * and return the unwrapped value. Otherwise, the value must be unwrapped\n     * with `_#value`.\n     *\n     * Explicit chain sequences, which must be unwrapped with `_#value`, may be\n     * enabled using `_.chain`.\n     *\n     * The execution of chained methods is lazy, that is, it's deferred until\n     * `_#value` is implicitly or explicitly called.\n     *\n     * Lazy evaluation allows several methods to support shortcut fusion.\n     * Shortcut fusion is an optimization to merge iteratee calls; this avoids\n     * the creation of intermediate arrays and can greatly reduce the number of\n     * iteratee executions. Sections of a chain sequence qualify for shortcut\n     * fusion if the section is applied to an array and iteratees accept only\n     * one argument. The heuristic for whether a section qualifies for shortcut\n     * fusion is subject to change.\n     *\n     * Chaining is supported in custom builds as long as the `_#value` method is\n     * directly or indirectly included in the build.\n     *\n     * In addition to lodash methods, wrappers have `Array` and `String` methods.\n     *\n     * The wrapper `Array` methods are:\n     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`\n     *\n     * The wrapper `String` methods are:\n     * `replace` and `split`\n     *\n     * The wrapper methods that support shortcut fusion are:\n     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,\n     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,\n     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`\n     *\n     * The chainable wrapper methods are:\n     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,\n     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,\n     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,\n     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,\n     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,\n     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,\n     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,\n     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,\n     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,\n     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,\n     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,\n     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,\n     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,\n     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,\n     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,\n     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,\n     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,\n     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,\n     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,\n     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,\n     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,\n     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,\n     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,\n     * `zipObject`, `zipObjectDeep`, and `zipWith`\n     *\n     * The wrapper methods that are **not** chainable by default are:\n     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,\n     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,\n     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,\n     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,\n     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,\n     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,\n     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,\n     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,\n     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,\n     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,\n     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,\n     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,\n     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,\n     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,\n     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,\n     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,\n     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,\n     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,\n     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,\n     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,\n     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,\n     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,\n     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,\n     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,\n     * `upperFirst`, `value`, and `words`\n     *\n     * @name _\n     * @constructor\n     * @category Seq\n     * @param {*} value The value to wrap in a `lodash` instance.\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var wrapped = _([1, 2, 3]);\n     *\n     * // Returns an unwrapped value.\n     * wrapped.reduce(_.add);\n     * // => 6\n     *\n     * // Returns a wrapped value.\n     * var squares = wrapped.map(square);\n     *\n     * _.isArray(squares);\n     * // => false\n     *\n     * _.isArray(squares.value());\n     * // => true\n     */\n    function lodash(value) {\n      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {\n        if (value instanceof LodashWrapper) {\n          return value;\n        }\n        if (hasOwnProperty.call(value, '__wrapped__')) {\n          return wrapperClone(value);\n        }\n      }\n      return new LodashWrapper(value);\n    }\n\n    /**\n     * The base implementation of `_.create` without support for assigning\n     * properties to the created object.\n     *\n     * @private\n     * @param {Object} proto The object to inherit from.\n     * @returns {Object} Returns the new object.\n     */\n    var baseCreate = (function() {\n      function object() {}\n      return function(proto) {\n        if (!isObject(proto)) {\n          return {};\n        }\n        if (objectCreate) {\n          return objectCreate(proto);\n        }\n        object.prototype = proto;\n        var result = new object;\n        object.prototype = undefined;\n        return result;\n      };\n    }());\n\n    /**\n     * The function whose prototype chain sequence wrappers inherit from.\n     *\n     * @private\n     */\n    function baseLodash() {\n      // No operation performed.\n    }\n\n    /**\n     * The base constructor for creating `lodash` wrapper objects.\n     *\n     * @private\n     * @param {*} value The value to wrap.\n     * @param {boolean} [chainAll] Enable explicit method chain sequences.\n     */\n    function LodashWrapper(value, chainAll) {\n      this.__wrapped__ = value;\n      this.__actions__ = [];\n      this.__chain__ = !!chainAll;\n      this.__index__ = 0;\n      this.__values__ = undefined;\n    }\n\n    /**\n     * By default, the template delimiters used by lodash are like those in\n     * embedded Ruby (ERB) as well as ES2015 template strings. Change the\n     * following template settings to use alternative delimiters.\n     *\n     * @static\n     * @memberOf _\n     * @type {Object}\n     */\n    lodash.templateSettings = {\n\n      /**\n       * Used to detect `data` property values to be HTML-escaped.\n       *\n       * @memberOf _.templateSettings\n       * @type {RegExp}\n       */\n      'escape': reEscape,\n\n      /**\n       * Used to detect code to be evaluated.\n       *\n       * @memberOf _.templateSettings\n       * @type {RegExp}\n       */\n      'evaluate': reEvaluate,\n\n      /**\n       * Used to detect `data` property values to inject.\n       *\n       * @memberOf _.templateSettings\n       * @type {RegExp}\n       */\n      'interpolate': reInterpolate,\n\n      /**\n       * Used to reference the data object in the template text.\n       *\n       * @memberOf _.templateSettings\n       * @type {string}\n       */\n      'variable': '',\n\n      /**\n       * Used to import variables into the compiled template.\n       *\n       * @memberOf _.templateSettings\n       * @type {Object}\n       */\n      'imports': {\n\n        /**\n         * A reference to the `lodash` function.\n         *\n         * @memberOf _.templateSettings.imports\n         * @type {Function}\n         */\n        '_': lodash\n      }\n    };\n\n    // Ensure wrappers are instances of `baseLodash`.\n    lodash.prototype = baseLodash.prototype;\n    lodash.prototype.constructor = lodash;\n\n    LodashWrapper.prototype = baseCreate(baseLodash.prototype);\n    LodashWrapper.prototype.constructor = LodashWrapper;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.\n     *\n     * @private\n     * @constructor\n     * @param {*} value The value to wrap.\n     */\n    function LazyWrapper(value) {\n      this.__wrapped__ = value;\n      this.__actions__ = [];\n      this.__dir__ = 1;\n      this.__filtered__ = false;\n      this.__iteratees__ = [];\n      this.__takeCount__ = MAX_ARRAY_LENGTH;\n      this.__views__ = [];\n    }\n\n    /**\n     * Creates a clone of the lazy wrapper object.\n     *\n     * @private\n     * @name clone\n     * @memberOf LazyWrapper\n     * @returns {Object} Returns the cloned `LazyWrapper` object.\n     */\n    function lazyClone() {\n      var result = new LazyWrapper(this.__wrapped__);\n      result.__actions__ = copyArray(this.__actions__);\n      result.__dir__ = this.__dir__;\n      result.__filtered__ = this.__filtered__;\n      result.__iteratees__ = copyArray(this.__iteratees__);\n      result.__takeCount__ = this.__takeCount__;\n      result.__views__ = copyArray(this.__views__);\n      return result;\n    }\n\n    /**\n     * Reverses the direction of lazy iteration.\n     *\n     * @private\n     * @name reverse\n     * @memberOf LazyWrapper\n     * @returns {Object} Returns the new reversed `LazyWrapper` object.\n     */\n    function lazyReverse() {\n      if (this.__filtered__) {\n        var result = new LazyWrapper(this);\n        result.__dir__ = -1;\n        result.__filtered__ = true;\n      } else {\n        result = this.clone();\n        result.__dir__ *= -1;\n      }\n      return result;\n    }\n\n    /**\n     * Extracts the unwrapped value from its lazy wrapper.\n     *\n     * @private\n     * @name value\n     * @memberOf LazyWrapper\n     * @returns {*} Returns the unwrapped value.\n     */\n    function lazyValue() {\n      var array = this.__wrapped__.value(),\n          dir = this.__dir__,\n          isArr = isArray(array),\n          isRight = dir < 0,\n          arrLength = isArr ? array.length : 0,\n          view = getView(0, arrLength, this.__views__),\n          start = view.start,\n          end = view.end,\n          length = end - start,\n          index = isRight ? end : (start - 1),\n          iteratees = this.__iteratees__,\n          iterLength = iteratees.length,\n          resIndex = 0,\n          takeCount = nativeMin(length, this.__takeCount__);\n\n      if (!isArr || (!isRight && arrLength == length && takeCount == length)) {\n        return baseWrapperValue(array, this.__actions__);\n      }\n      var result = [];\n\n      outer:\n      while (length-- && resIndex < takeCount) {\n        index += dir;\n\n        var iterIndex = -1,\n            value = array[index];\n\n        while (++iterIndex < iterLength) {\n          var data = iteratees[iterIndex],\n              iteratee = data.iteratee,\n              type = data.type,\n              computed = iteratee(value);\n\n          if (type == LAZY_MAP_FLAG) {\n            value = computed;\n          } else if (!computed) {\n            if (type == LAZY_FILTER_FLAG) {\n              continue outer;\n            } else {\n              break outer;\n            }\n          }\n        }\n        result[resIndex++] = value;\n      }\n      return result;\n    }\n\n    // Ensure `LazyWrapper` is an instance of `baseLodash`.\n    LazyWrapper.prototype = baseCreate(baseLodash.prototype);\n    LazyWrapper.prototype.constructor = LazyWrapper;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a hash object.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [entries] The key-value pairs to cache.\n     */\n    function Hash(entries) {\n      var index = -1,\n          length = entries == null ? 0 : entries.length;\n\n      this.clear();\n      while (++index < length) {\n        var entry = entries[index];\n        this.set(entry[0], entry[1]);\n      }\n    }\n\n    /**\n     * Removes all key-value entries from the hash.\n     *\n     * @private\n     * @name clear\n     * @memberOf Hash\n     */\n    function hashClear() {\n      this.__data__ = nativeCreate ? nativeCreate(null) : {};\n      this.size = 0;\n    }\n\n    /**\n     * Removes `key` and its value from the hash.\n     *\n     * @private\n     * @name delete\n     * @memberOf Hash\n     * @param {Object} hash The hash to modify.\n     * @param {string} key The key of the value to remove.\n     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n     */\n    function hashDelete(key) {\n      var result = this.has(key) && delete this.__data__[key];\n      this.size -= result ? 1 : 0;\n      return result;\n    }\n\n    /**\n     * Gets the hash value for `key`.\n     *\n     * @private\n     * @name get\n     * @memberOf Hash\n     * @param {string} key The key of the value to get.\n     * @returns {*} Returns the entry value.\n     */\n    function hashGet(key) {\n      var data = this.__data__;\n      if (nativeCreate) {\n        var result = data[key];\n        return result === HASH_UNDEFINED ? undefined : result;\n      }\n      return hasOwnProperty.call(data, key) ? data[key] : undefined;\n    }\n\n    /**\n     * Checks if a hash value for `key` exists.\n     *\n     * @private\n     * @name has\n     * @memberOf Hash\n     * @param {string} key The key of the entry to check.\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n     */\n    function hashHas(key) {\n      var data = this.__data__;\n      return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n    }\n\n    /**\n     * Sets the hash `key` to `value`.\n     *\n     * @private\n     * @name set\n     * @memberOf Hash\n     * @param {string} key The key of the value to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns the hash instance.\n     */\n    function hashSet(key, value) {\n      var data = this.__data__;\n      this.size += this.has(key) ? 0 : 1;\n      data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n      return this;\n    }\n\n    // Add methods to `Hash`.\n    Hash.prototype.clear = hashClear;\n    Hash.prototype['delete'] = hashDelete;\n    Hash.prototype.get = hashGet;\n    Hash.prototype.has = hashHas;\n    Hash.prototype.set = hashSet;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates an list cache object.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [entries] The key-value pairs to cache.\n     */\n    function ListCache(entries) {\n      var index = -1,\n          length = entries == null ? 0 : entries.length;\n\n      this.clear();\n      while (++index < length) {\n        var entry = entries[index];\n        this.set(entry[0], entry[1]);\n      }\n    }\n\n    /**\n     * Removes all key-value entries from the list cache.\n     *\n     * @private\n     * @name clear\n     * @memberOf ListCache\n     */\n    function listCacheClear() {\n      this.__data__ = [];\n      this.size = 0;\n    }\n\n    /**\n     * Removes `key` and its value from the list cache.\n     *\n     * @private\n     * @name delete\n     * @memberOf ListCache\n     * @param {string} key The key of the value to remove.\n     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n     */\n    function listCacheDelete(key) {\n      var data = this.__data__,\n          index = assocIndexOf(data, key);\n\n      if (index < 0) {\n        return false;\n      }\n      var lastIndex = data.length - 1;\n      if (index == lastIndex) {\n        data.pop();\n      } else {\n        splice.call(data, index, 1);\n      }\n      --this.size;\n      return true;\n    }\n\n    /**\n     * Gets the list cache value for `key`.\n     *\n     * @private\n     * @name get\n     * @memberOf ListCache\n     * @param {string} key The key of the value to get.\n     * @returns {*} Returns the entry value.\n     */\n    function listCacheGet(key) {\n      var data = this.__data__,\n          index = assocIndexOf(data, key);\n\n      return index < 0 ? undefined : data[index][1];\n    }\n\n    /**\n     * Checks if a list cache value for `key` exists.\n     *\n     * @private\n     * @name has\n     * @memberOf ListCache\n     * @param {string} key The key of the entry to check.\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n     */\n    function listCacheHas(key) {\n      return assocIndexOf(this.__data__, key) > -1;\n    }\n\n    /**\n     * Sets the list cache `key` to `value`.\n     *\n     * @private\n     * @name set\n     * @memberOf ListCache\n     * @param {string} key The key of the value to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns the list cache instance.\n     */\n    function listCacheSet(key, value) {\n      var data = this.__data__,\n          index = assocIndexOf(data, key);\n\n      if (index < 0) {\n        ++this.size;\n        data.push([key, value]);\n      } else {\n        data[index][1] = value;\n      }\n      return this;\n    }\n\n    // Add methods to `ListCache`.\n    ListCache.prototype.clear = listCacheClear;\n    ListCache.prototype['delete'] = listCacheDelete;\n    ListCache.prototype.get = listCacheGet;\n    ListCache.prototype.has = listCacheHas;\n    ListCache.prototype.set = listCacheSet;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a map cache object to store key-value pairs.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [entries] The key-value pairs to cache.\n     */\n    function MapCache(entries) {\n      var index = -1,\n          length = entries == null ? 0 : entries.length;\n\n      this.clear();\n      while (++index < length) {\n        var entry = entries[index];\n        this.set(entry[0], entry[1]);\n      }\n    }\n\n    /**\n     * Removes all key-value entries from the map.\n     *\n     * @private\n     * @name clear\n     * @memberOf MapCache\n     */\n    function mapCacheClear() {\n      this.size = 0;\n      this.__data__ = {\n        'hash': new Hash,\n        'map': new (Map || ListCache),\n        'string': new Hash\n      };\n    }\n\n    /**\n     * Removes `key` and its value from the map.\n     *\n     * @private\n     * @name delete\n     * @memberOf MapCache\n     * @param {string} key The key of the value to remove.\n     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n     */\n    function mapCacheDelete(key) {\n      var result = getMapData(this, key)['delete'](key);\n      this.size -= result ? 1 : 0;\n      return result;\n    }\n\n    /**\n     * Gets the map value for `key`.\n     *\n     * @private\n     * @name get\n     * @memberOf MapCache\n     * @param {string} key The key of the value to get.\n     * @returns {*} Returns the entry value.\n     */\n    function mapCacheGet(key) {\n      return getMapData(this, key).get(key);\n    }\n\n    /**\n     * Checks if a map value for `key` exists.\n     *\n     * @private\n     * @name has\n     * @memberOf MapCache\n     * @param {string} key The key of the entry to check.\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n     */\n    function mapCacheHas(key) {\n      return getMapData(this, key).has(key);\n    }\n\n    /**\n     * Sets the map `key` to `value`.\n     *\n     * @private\n     * @name set\n     * @memberOf MapCache\n     * @param {string} key The key of the value to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns the map cache instance.\n     */\n    function mapCacheSet(key, value) {\n      var data = getMapData(this, key),\n          size = data.size;\n\n      data.set(key, value);\n      this.size += data.size == size ? 0 : 1;\n      return this;\n    }\n\n    // Add methods to `MapCache`.\n    MapCache.prototype.clear = mapCacheClear;\n    MapCache.prototype['delete'] = mapCacheDelete;\n    MapCache.prototype.get = mapCacheGet;\n    MapCache.prototype.has = mapCacheHas;\n    MapCache.prototype.set = mapCacheSet;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     *\n     * Creates an array cache object to store unique values.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [values] The values to cache.\n     */\n    function SetCache(values) {\n      var index = -1,\n          length = values == null ? 0 : values.length;\n\n      this.__data__ = new MapCache;\n      while (++index < length) {\n        this.add(values[index]);\n      }\n    }\n\n    /**\n     * Adds `value` to the array cache.\n     *\n     * @private\n     * @name add\n     * @memberOf SetCache\n     * @alias push\n     * @param {*} value The value to cache.\n     * @returns {Object} Returns the cache instance.\n     */\n    function setCacheAdd(value) {\n      this.__data__.set(value, HASH_UNDEFINED);\n      return this;\n    }\n\n    /**\n     * Checks if `value` is in the array cache.\n     *\n     * @private\n     * @name has\n     * @memberOf SetCache\n     * @param {*} value The value to search for.\n     * @returns {number} Returns `true` if `value` is found, else `false`.\n     */\n    function setCacheHas(value) {\n      return this.__data__.has(value);\n    }\n\n    // Add methods to `SetCache`.\n    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\n    SetCache.prototype.has = setCacheHas;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a stack cache object to store key-value pairs.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [entries] The key-value pairs to cache.\n     */\n    function Stack(entries) {\n      var data = this.__data__ = new ListCache(entries);\n      this.size = data.size;\n    }\n\n    /**\n     * Removes all key-value entries from the stack.\n     *\n     * @private\n     * @name clear\n     * @memberOf Stack\n     */\n    function stackClear() {\n      this.__data__ = new ListCache;\n      this.size = 0;\n    }\n\n    /**\n     * Removes `key` and its value from the stack.\n     *\n     * @private\n     * @name delete\n     * @memberOf Stack\n     * @param {string} key The key of the value to remove.\n     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n     */\n    function stackDelete(key) {\n      var data = this.__data__,\n          result = data['delete'](key);\n\n      this.size = data.size;\n      return result;\n    }\n\n    /**\n     * Gets the stack value for `key`.\n     *\n     * @private\n     * @name get\n     * @memberOf Stack\n     * @param {string} key The key of the value to get.\n     * @returns {*} Returns the entry value.\n     */\n    function stackGet(key) {\n      return this.__data__.get(key);\n    }\n\n    /**\n     * Checks if a stack value for `key` exists.\n     *\n     * @private\n     * @name has\n     * @memberOf Stack\n     * @param {string} key The key of the entry to check.\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n     */\n    function stackHas(key) {\n      return this.__data__.has(key);\n    }\n\n    /**\n     * Sets the stack `key` to `value`.\n     *\n     * @private\n     * @name set\n     * @memberOf Stack\n     * @param {string} key The key of the value to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns the stack cache instance.\n     */\n    function stackSet(key, value) {\n      var data = this.__data__;\n      if (data instanceof ListCache) {\n        var pairs = data.__data__;\n        if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n          pairs.push([key, value]);\n          this.size = ++data.size;\n          return this;\n        }\n        data = this.__data__ = new MapCache(pairs);\n      }\n      data.set(key, value);\n      this.size = data.size;\n      return this;\n    }\n\n    // Add methods to `Stack`.\n    Stack.prototype.clear = stackClear;\n    Stack.prototype['delete'] = stackDelete;\n    Stack.prototype.get = stackGet;\n    Stack.prototype.has = stackHas;\n    Stack.prototype.set = stackSet;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates an array of the enumerable property names of the array-like `value`.\n     *\n     * @private\n     * @param {*} value The value to query.\n     * @param {boolean} inherited Specify returning inherited property names.\n     * @returns {Array} Returns the array of property names.\n     */\n    function arrayLikeKeys(value, inherited) {\n      var isArr = isArray(value),\n          isArg = !isArr && isArguments(value),\n          isBuff = !isArr && !isArg && isBuffer(value),\n          isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n          skipIndexes = isArr || isArg || isBuff || isType,\n          result = skipIndexes ? baseTimes(value.length, String) : [],\n          length = result.length;\n\n      for (var key in value) {\n        if ((inherited || hasOwnProperty.call(value, key)) &&\n            !(skipIndexes && (\n               // Safari 9 has enumerable `arguments.length` in strict mode.\n               key == 'length' ||\n               // Node.js 0.10 has enumerable non-index properties on buffers.\n               (isBuff && (key == 'offset' || key == 'parent')) ||\n               // PhantomJS 2 has enumerable non-index properties on typed arrays.\n               (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n               // Skip index properties.\n               isIndex(key, length)\n            ))) {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * A specialized version of `_.sample` for arrays.\n     *\n     * @private\n     * @param {Array} array The array to sample.\n     * @returns {*} Returns the random element.\n     */\n    function arraySample(array) {\n      var length = array.length;\n      return length ? array[baseRandom(0, length - 1)] : undefined;\n    }\n\n    /**\n     * A specialized version of `_.sampleSize` for arrays.\n     *\n     * @private\n     * @param {Array} array The array to sample.\n     * @param {number} n The number of elements to sample.\n     * @returns {Array} Returns the random elements.\n     */\n    function arraySampleSize(array, n) {\n      return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));\n    }\n\n    /**\n     * A specialized version of `_.shuffle` for arrays.\n     *\n     * @private\n     * @param {Array} array The array to shuffle.\n     * @returns {Array} Returns the new shuffled array.\n     */\n    function arrayShuffle(array) {\n      return shuffleSelf(copyArray(array));\n    }\n\n    /**\n     * This function is like `assignValue` except that it doesn't assign\n     * `undefined` values.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {string} key The key of the property to assign.\n     * @param {*} value The value to assign.\n     */\n    function assignMergeValue(object, key, value) {\n      if ((value !== undefined && !eq(object[key], value)) ||\n          (value === undefined && !(key in object))) {\n        baseAssignValue(object, key, value);\n      }\n    }\n\n    /**\n     * Assigns `value` to `key` of `object` if the existing value is not equivalent\n     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {string} key The key of the property to assign.\n     * @param {*} value The value to assign.\n     */\n    function assignValue(object, key, value) {\n      var objValue = object[key];\n      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\n          (value === undefined && !(key in object))) {\n        baseAssignValue(object, key, value);\n      }\n    }\n\n    /**\n     * Gets the index at which the `key` is found in `array` of key-value pairs.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {*} key The key to search for.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     */\n    function assocIndexOf(array, key) {\n      var length = array.length;\n      while (length--) {\n        if (eq(array[length][0], key)) {\n          return length;\n        }\n      }\n      return -1;\n    }\n\n    /**\n     * Aggregates elements of `collection` on `accumulator` with keys transformed\n     * by `iteratee` and values set by `setter`.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} setter The function to set `accumulator` values.\n     * @param {Function} iteratee The iteratee to transform keys.\n     * @param {Object} accumulator The initial aggregated object.\n     * @returns {Function} Returns `accumulator`.\n     */\n    function baseAggregator(collection, setter, iteratee, accumulator) {\n      baseEach(collection, function(value, key, collection) {\n        setter(accumulator, value, iteratee(value), collection);\n      });\n      return accumulator;\n    }\n\n    /**\n     * The base implementation of `_.assign` without support for multiple sources\n     * or `customizer` functions.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @returns {Object} Returns `object`.\n     */\n    function baseAssign(object, source) {\n      return object && copyObject(source, keys(source), object);\n    }\n\n    /**\n     * The base implementation of `_.assignIn` without support for multiple sources\n     * or `customizer` functions.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @returns {Object} Returns `object`.\n     */\n    function baseAssignIn(object, source) {\n      return object && copyObject(source, keysIn(source), object);\n    }\n\n    /**\n     * The base implementation of `assignValue` and `assignMergeValue` without\n     * value checks.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {string} key The key of the property to assign.\n     * @param {*} value The value to assign.\n     */\n    function baseAssignValue(object, key, value) {\n      if (key == '__proto__' && defineProperty) {\n        defineProperty(object, key, {\n          'configurable': true,\n          'enumerable': true,\n          'value': value,\n          'writable': true\n        });\n      } else {\n        object[key] = value;\n      }\n    }\n\n    /**\n     * The base implementation of `_.at` without support for individual paths.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {string[]} paths The property paths to pick.\n     * @returns {Array} Returns the picked elements.\n     */\n    function baseAt(object, paths) {\n      var index = -1,\n          length = paths.length,\n          result = Array(length),\n          skip = object == null;\n\n      while (++index < length) {\n        result[index] = skip ? undefined : get(object, paths[index]);\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.clamp` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {number} number The number to clamp.\n     * @param {number} [lower] The lower bound.\n     * @param {number} upper The upper bound.\n     * @returns {number} Returns the clamped number.\n     */\n    function baseClamp(number, lower, upper) {\n      if (number === number) {\n        if (upper !== undefined) {\n          number = number <= upper ? number : upper;\n        }\n        if (lower !== undefined) {\n          number = number >= lower ? number : lower;\n        }\n      }\n      return number;\n    }\n\n    /**\n     * The base implementation of `_.clone` and `_.cloneDeep` which tracks\n     * traversed objects.\n     *\n     * @private\n     * @param {*} value The value to clone.\n     * @param {boolean} bitmask The bitmask flags.\n     *  1 - Deep clone\n     *  2 - Flatten inherited properties\n     *  4 - Clone symbols\n     * @param {Function} [customizer] The function to customize cloning.\n     * @param {string} [key] The key of `value`.\n     * @param {Object} [object] The parent object of `value`.\n     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.\n     * @returns {*} Returns the cloned value.\n     */\n    function baseClone(value, bitmask, customizer, key, object, stack) {\n      var result,\n          isDeep = bitmask & CLONE_DEEP_FLAG,\n          isFlat = bitmask & CLONE_FLAT_FLAG,\n          isFull = bitmask & CLONE_SYMBOLS_FLAG;\n\n      if (customizer) {\n        result = object ? customizer(value, key, object, stack) : customizer(value);\n      }\n      if (result !== undefined) {\n        return result;\n      }\n      if (!isObject(value)) {\n        return value;\n      }\n      var isArr = isArray(value);\n      if (isArr) {\n        result = initCloneArray(value);\n        if (!isDeep) {\n          return copyArray(value, result);\n        }\n      } else {\n        var tag = getTag(value),\n            isFunc = tag == funcTag || tag == genTag;\n\n        if (isBuffer(value)) {\n          return cloneBuffer(value, isDeep);\n        }\n        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\n          result = (isFlat || isFunc) ? {} : initCloneObject(value);\n          if (!isDeep) {\n            return isFlat\n              ? copySymbolsIn(value, baseAssignIn(result, value))\n              : copySymbols(value, baseAssign(result, value));\n          }\n        } else {\n          if (!cloneableTags[tag]) {\n            return object ? value : {};\n          }\n          result = initCloneByTag(value, tag, isDeep);\n        }\n      }\n      // Check for circular references and return its corresponding clone.\n      stack || (stack = new Stack);\n      var stacked = stack.get(value);\n      if (stacked) {\n        return stacked;\n      }\n      stack.set(value, result);\n\n      if (isSet(value)) {\n        value.forEach(function(subValue) {\n          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));\n        });\n      } else if (isMap(value)) {\n        value.forEach(function(subValue, key) {\n          result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));\n        });\n      }\n\n      var keysFunc = isFull\n        ? (isFlat ? getAllKeysIn : getAllKeys)\n        : (isFlat ? keysIn : keys);\n\n      var props = isArr ? undefined : keysFunc(value);\n      arrayEach(props || value, function(subValue, key) {\n        if (props) {\n          key = subValue;\n          subValue = value[key];\n        }\n        // Recursively populate clone (susceptible to call stack limits).\n        assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.conforms` which doesn't clone `source`.\n     *\n     * @private\n     * @param {Object} source The object of property predicates to conform to.\n     * @returns {Function} Returns the new spec function.\n     */\n    function baseConforms(source) {\n      var props = keys(source);\n      return function(object) {\n        return baseConformsTo(object, source, props);\n      };\n    }\n\n    /**\n     * The base implementation of `_.conformsTo` which accepts `props` to check.\n     *\n     * @private\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property predicates to conform to.\n     * @returns {boolean} Returns `true` if `object` conforms, else `false`.\n     */\n    function baseConformsTo(object, source, props) {\n      var length = props.length;\n      if (object == null) {\n        return !length;\n      }\n      object = Object(object);\n      while (length--) {\n        var key = props[length],\n            predicate = source[key],\n            value = object[key];\n\n        if ((value === undefined && !(key in object)) || !predicate(value)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    /**\n     * The base implementation of `_.delay` and `_.defer` which accepts `args`\n     * to provide to `func`.\n     *\n     * @private\n     * @param {Function} func The function to delay.\n     * @param {number} wait The number of milliseconds to delay invocation.\n     * @param {Array} args The arguments to provide to `func`.\n     * @returns {number|Object} Returns the timer id or timeout object.\n     */\n    function baseDelay(func, wait, args) {\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      return setTimeout(function() { func.apply(undefined, args); }, wait);\n    }\n\n    /**\n     * The base implementation of methods like `_.difference` without support\n     * for excluding multiple arrays or iteratee shorthands.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {Array} values The values to exclude.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     */\n    function baseDifference(array, values, iteratee, comparator) {\n      var index = -1,\n          includes = arrayIncludes,\n          isCommon = true,\n          length = array.length,\n          result = [],\n          valuesLength = values.length;\n\n      if (!length) {\n        return result;\n      }\n      if (iteratee) {\n        values = arrayMap(values, baseUnary(iteratee));\n      }\n      if (comparator) {\n        includes = arrayIncludesWith;\n        isCommon = false;\n      }\n      else if (values.length >= LARGE_ARRAY_SIZE) {\n        includes = cacheHas;\n        isCommon = false;\n        values = new SetCache(values);\n      }\n      outer:\n      while (++index < length) {\n        var value = array[index],\n            computed = iteratee == null ? value : iteratee(value);\n\n        value = (comparator || value !== 0) ? value : 0;\n        if (isCommon && computed === computed) {\n          var valuesIndex = valuesLength;\n          while (valuesIndex--) {\n            if (values[valuesIndex] === computed) {\n              continue outer;\n            }\n          }\n          result.push(value);\n        }\n        else if (!includes(values, computed, comparator)) {\n          result.push(value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.forEach` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array|Object} Returns `collection`.\n     */\n    var baseEach = createBaseEach(baseForOwn);\n\n    /**\n     * The base implementation of `_.forEachRight` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array|Object} Returns `collection`.\n     */\n    var baseEachRight = createBaseEach(baseForOwnRight, true);\n\n    /**\n     * The base implementation of `_.every` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {boolean} Returns `true` if all elements pass the predicate check,\n     *  else `false`\n     */\n    function baseEvery(collection, predicate) {\n      var result = true;\n      baseEach(collection, function(value, index, collection) {\n        result = !!predicate(value, index, collection);\n        return result;\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of methods like `_.max` and `_.min` which accepts a\n     * `comparator` to determine the extremum value.\n     *\n     * @private\n     * @param {Array} array The array to iterate over.\n     * @param {Function} iteratee The iteratee invoked per iteration.\n     * @param {Function} comparator The comparator used to compare values.\n     * @returns {*} Returns the extremum value.\n     */\n    function baseExtremum(array, iteratee, comparator) {\n      var index = -1,\n          length = array.length;\n\n      while (++index < length) {\n        var value = array[index],\n            current = iteratee(value);\n\n        if (current != null && (computed === undefined\n              ? (current === current && !isSymbol(current))\n              : comparator(current, computed)\n            )) {\n          var computed = current,\n              result = value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.fill` without an iteratee call guard.\n     *\n     * @private\n     * @param {Array} array The array to fill.\n     * @param {*} value The value to fill `array` with.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns `array`.\n     */\n    function baseFill(array, value, start, end) {\n      var length = array.length;\n\n      start = toInteger(start);\n      if (start < 0) {\n        start = -start > length ? 0 : (length + start);\n      }\n      end = (end === undefined || end > length) ? length : toInteger(end);\n      if (end < 0) {\n        end += length;\n      }\n      end = start > end ? 0 : toLength(end);\n      while (start < end) {\n        array[start++] = value;\n      }\n      return array;\n    }\n\n    /**\n     * The base implementation of `_.filter` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {Array} Returns the new filtered array.\n     */\n    function baseFilter(collection, predicate) {\n      var result = [];\n      baseEach(collection, function(value, index, collection) {\n        if (predicate(value, index, collection)) {\n          result.push(value);\n        }\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.flatten` with support for restricting flattening.\n     *\n     * @private\n     * @param {Array} array The array to flatten.\n     * @param {number} depth The maximum recursion depth.\n     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.\n     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.\n     * @param {Array} [result=[]] The initial result value.\n     * @returns {Array} Returns the new flattened array.\n     */\n    function baseFlatten(array, depth, predicate, isStrict, result) {\n      var index = -1,\n          length = array.length;\n\n      predicate || (predicate = isFlattenable);\n      result || (result = []);\n\n      while (++index < length) {\n        var value = array[index];\n        if (depth > 0 && predicate(value)) {\n          if (depth > 1) {\n            // Recursively flatten arrays (susceptible to call stack limits).\n            baseFlatten(value, depth - 1, predicate, isStrict, result);\n          } else {\n            arrayPush(result, value);\n          }\n        } else if (!isStrict) {\n          result[result.length] = value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `baseForOwn` which iterates over `object`\n     * properties returned by `keysFunc` and invokes `iteratee` for each property.\n     * Iteratee functions may exit iteration early by explicitly returning `false`.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @param {Function} keysFunc The function to get the keys of `object`.\n     * @returns {Object} Returns `object`.\n     */\n    var baseFor = createBaseFor();\n\n    /**\n     * This function is like `baseFor` except that it iterates over properties\n     * in the opposite order.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @param {Function} keysFunc The function to get the keys of `object`.\n     * @returns {Object} Returns `object`.\n     */\n    var baseForRight = createBaseFor(true);\n\n    /**\n     * The base implementation of `_.forOwn` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     */\n    function baseForOwn(object, iteratee) {\n      return object && baseFor(object, iteratee, keys);\n    }\n\n    /**\n     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     */\n    function baseForOwnRight(object, iteratee) {\n      return object && baseForRight(object, iteratee, keys);\n    }\n\n    /**\n     * The base implementation of `_.functions` which creates an array of\n     * `object` function property names filtered from `props`.\n     *\n     * @private\n     * @param {Object} object The object to inspect.\n     * @param {Array} props The property names to filter.\n     * @returns {Array} Returns the function names.\n     */\n    function baseFunctions(object, props) {\n      return arrayFilter(props, function(key) {\n        return isFunction(object[key]);\n      });\n    }\n\n    /**\n     * The base implementation of `_.get` without support for default values.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the property to get.\n     * @returns {*} Returns the resolved value.\n     */\n    function baseGet(object, path) {\n      path = castPath(path, object);\n\n      var index = 0,\n          length = path.length;\n\n      while (object != null && index < length) {\n        object = object[toKey(path[index++])];\n      }\n      return (index && index == length) ? object : undefined;\n    }\n\n    /**\n     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n     * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n     * symbols of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Function} keysFunc The function to get the keys of `object`.\n     * @param {Function} symbolsFunc The function to get the symbols of `object`.\n     * @returns {Array} Returns the array of property names and symbols.\n     */\n    function baseGetAllKeys(object, keysFunc, symbolsFunc) {\n      var result = keysFunc(object);\n      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n    }\n\n    /**\n     * The base implementation of `getTag` without fallbacks for buggy environments.\n     *\n     * @private\n     * @param {*} value The value to query.\n     * @returns {string} Returns the `toStringTag`.\n     */\n    function baseGetTag(value) {\n      if (value == null) {\n        return value === undefined ? undefinedTag : nullTag;\n      }\n      return (symToStringTag && symToStringTag in Object(value))\n        ? getRawTag(value)\n        : objectToString(value);\n    }\n\n    /**\n     * The base implementation of `_.gt` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is greater than `other`,\n     *  else `false`.\n     */\n    function baseGt(value, other) {\n      return value > other;\n    }\n\n    /**\n     * The base implementation of `_.has` without support for deep paths.\n     *\n     * @private\n     * @param {Object} [object] The object to query.\n     * @param {Array|string} key The key to check.\n     * @returns {boolean} Returns `true` if `key` exists, else `false`.\n     */\n    function baseHas(object, key) {\n      return object != null && hasOwnProperty.call(object, key);\n    }\n\n    /**\n     * The base implementation of `_.hasIn` without support for deep paths.\n     *\n     * @private\n     * @param {Object} [object] The object to query.\n     * @param {Array|string} key The key to check.\n     * @returns {boolean} Returns `true` if `key` exists, else `false`.\n     */\n    function baseHasIn(object, key) {\n      return object != null && key in Object(object);\n    }\n\n    /**\n     * The base implementation of `_.inRange` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {number} number The number to check.\n     * @param {number} start The start of the range.\n     * @param {number} end The end of the range.\n     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.\n     */\n    function baseInRange(number, start, end) {\n      return number >= nativeMin(start, end) && number < nativeMax(start, end);\n    }\n\n    /**\n     * The base implementation of methods like `_.intersection`, without support\n     * for iteratee shorthands, that accepts an array of arrays to inspect.\n     *\n     * @private\n     * @param {Array} arrays The arrays to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of shared values.\n     */\n    function baseIntersection(arrays, iteratee, comparator) {\n      var includes = comparator ? arrayIncludesWith : arrayIncludes,\n          length = arrays[0].length,\n          othLength = arrays.length,\n          othIndex = othLength,\n          caches = Array(othLength),\n          maxLength = Infinity,\n          result = [];\n\n      while (othIndex--) {\n        var array = arrays[othIndex];\n        if (othIndex && iteratee) {\n          array = arrayMap(array, baseUnary(iteratee));\n        }\n        maxLength = nativeMin(array.length, maxLength);\n        caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))\n          ? new SetCache(othIndex && array)\n          : undefined;\n      }\n      array = arrays[0];\n\n      var index = -1,\n          seen = caches[0];\n\n      outer:\n      while (++index < length && result.length < maxLength) {\n        var value = array[index],\n            computed = iteratee ? iteratee(value) : value;\n\n        value = (comparator || value !== 0) ? value : 0;\n        if (!(seen\n              ? cacheHas(seen, computed)\n              : includes(result, computed, comparator)\n            )) {\n          othIndex = othLength;\n          while (--othIndex) {\n            var cache = caches[othIndex];\n            if (!(cache\n                  ? cacheHas(cache, computed)\n                  : includes(arrays[othIndex], computed, comparator))\n                ) {\n              continue outer;\n            }\n          }\n          if (seen) {\n            seen.push(computed);\n          }\n          result.push(value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.invert` and `_.invertBy` which inverts\n     * `object` with values transformed by `iteratee` and set by `setter`.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} setter The function to set `accumulator` values.\n     * @param {Function} iteratee The iteratee to transform values.\n     * @param {Object} accumulator The initial inverted object.\n     * @returns {Function} Returns `accumulator`.\n     */\n    function baseInverter(object, setter, iteratee, accumulator) {\n      baseForOwn(object, function(value, key, object) {\n        setter(accumulator, iteratee(value), key, object);\n      });\n      return accumulator;\n    }\n\n    /**\n     * The base implementation of `_.invoke` without support for individual\n     * method arguments.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the method to invoke.\n     * @param {Array} args The arguments to invoke the method with.\n     * @returns {*} Returns the result of the invoked method.\n     */\n    function baseInvoke(object, path, args) {\n      path = castPath(path, object);\n      object = parent(object, path);\n      var func = object == null ? object : object[toKey(last(path))];\n      return func == null ? undefined : apply(func, object, args);\n    }\n\n    /**\n     * The base implementation of `_.isArguments`.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n     */\n    function baseIsArguments(value) {\n      return isObjectLike(value) && baseGetTag(value) == argsTag;\n    }\n\n    /**\n     * The base implementation of `_.isArrayBuffer` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.\n     */\n    function baseIsArrayBuffer(value) {\n      return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;\n    }\n\n    /**\n     * The base implementation of `_.isDate` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.\n     */\n    function baseIsDate(value) {\n      return isObjectLike(value) && baseGetTag(value) == dateTag;\n    }\n\n    /**\n     * The base implementation of `_.isEqual` which supports partial comparisons\n     * and tracks traversed objects.\n     *\n     * @private\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @param {boolean} bitmask The bitmask flags.\n     *  1 - Unordered comparison\n     *  2 - Partial comparison\n     * @param {Function} [customizer] The function to customize comparisons.\n     * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     */\n    function baseIsEqual(value, other, bitmask, customizer, stack) {\n      if (value === other) {\n        return true;\n      }\n      if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {\n        return value !== value && other !== other;\n      }\n      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n    }\n\n    /**\n     * A specialized version of `baseIsEqual` for arrays and objects which performs\n     * deep comparisons and tracks traversed objects enabling objects with circular\n     * references to be compared.\n     *\n     * @private\n     * @param {Object} object The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n     * @param {Function} customizer The function to customize comparisons.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n     */\n    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n      var objIsArr = isArray(object),\n          othIsArr = isArray(other),\n          objTag = objIsArr ? arrayTag : getTag(object),\n          othTag = othIsArr ? arrayTag : getTag(other);\n\n      objTag = objTag == argsTag ? objectTag : objTag;\n      othTag = othTag == argsTag ? objectTag : othTag;\n\n      var objIsObj = objTag == objectTag,\n          othIsObj = othTag == objectTag,\n          isSameTag = objTag == othTag;\n\n      if (isSameTag && isBuffer(object)) {\n        if (!isBuffer(other)) {\n          return false;\n        }\n        objIsArr = true;\n        objIsObj = false;\n      }\n      if (isSameTag && !objIsObj) {\n        stack || (stack = new Stack);\n        return (objIsArr || isTypedArray(object))\n          ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)\n          : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n      }\n      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {\n        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n        if (objIsWrapped || othIsWrapped) {\n          var objUnwrapped = objIsWrapped ? object.value() : object,\n              othUnwrapped = othIsWrapped ? other.value() : other;\n\n          stack || (stack = new Stack);\n          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n        }\n      }\n      if (!isSameTag) {\n        return false;\n      }\n      stack || (stack = new Stack);\n      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n    }\n\n    /**\n     * The base implementation of `_.isMap` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n     */\n    function baseIsMap(value) {\n      return isObjectLike(value) && getTag(value) == mapTag;\n    }\n\n    /**\n     * The base implementation of `_.isMatch` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property values to match.\n     * @param {Array} matchData The property names, values, and compare flags to match.\n     * @param {Function} [customizer] The function to customize comparisons.\n     * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n     */\n    function baseIsMatch(object, source, matchData, customizer) {\n      var index = matchData.length,\n          length = index,\n          noCustomizer = !customizer;\n\n      if (object == null) {\n        return !length;\n      }\n      object = Object(object);\n      while (index--) {\n        var data = matchData[index];\n        if ((noCustomizer && data[2])\n              ? data[1] !== object[data[0]]\n              : !(data[0] in object)\n            ) {\n          return false;\n        }\n      }\n      while (++index < length) {\n        data = matchData[index];\n        var key = data[0],\n            objValue = object[key],\n            srcValue = data[1];\n\n        if (noCustomizer && data[2]) {\n          if (objValue === undefined && !(key in object)) {\n            return false;\n          }\n        } else {\n          var stack = new Stack;\n          if (customizer) {\n            var result = customizer(objValue, srcValue, key, object, source, stack);\n          }\n          if (!(result === undefined\n                ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)\n                : result\n              )) {\n            return false;\n          }\n        }\n      }\n      return true;\n    }\n\n    /**\n     * The base implementation of `_.isNative` without bad shim checks.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a native function,\n     *  else `false`.\n     */\n    function baseIsNative(value) {\n      if (!isObject(value) || isMasked(value)) {\n        return false;\n      }\n      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n      return pattern.test(toSource(value));\n    }\n\n    /**\n     * The base implementation of `_.isRegExp` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.\n     */\n    function baseIsRegExp(value) {\n      return isObjectLike(value) && baseGetTag(value) == regexpTag;\n    }\n\n    /**\n     * The base implementation of `_.isSet` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n     */\n    function baseIsSet(value) {\n      return isObjectLike(value) && getTag(value) == setTag;\n    }\n\n    /**\n     * The base implementation of `_.isTypedArray` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n     */\n    function baseIsTypedArray(value) {\n      return isObjectLike(value) &&\n        isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n    }\n\n    /**\n     * The base implementation of `_.iteratee`.\n     *\n     * @private\n     * @param {*} [value=_.identity] The value to convert to an iteratee.\n     * @returns {Function} Returns the iteratee.\n     */\n    function baseIteratee(value) {\n      // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\n      // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\n      if (typeof value == 'function') {\n        return value;\n      }\n      if (value == null) {\n        return identity;\n      }\n      if (typeof value == 'object') {\n        return isArray(value)\n          ? baseMatchesProperty(value[0], value[1])\n          : baseMatches(value);\n      }\n      return property(value);\n    }\n\n    /**\n     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     */\n    function baseKeys(object) {\n      if (!isPrototype(object)) {\n        return nativeKeys(object);\n      }\n      var result = [];\n      for (var key in Object(object)) {\n        if (hasOwnProperty.call(object, key) && key != 'constructor') {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     */\n    function baseKeysIn(object) {\n      if (!isObject(object)) {\n        return nativeKeysIn(object);\n      }\n      var isProto = isPrototype(object),\n          result = [];\n\n      for (var key in object) {\n        if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.lt` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is less than `other`,\n     *  else `false`.\n     */\n    function baseLt(value, other) {\n      return value < other;\n    }\n\n    /**\n     * The base implementation of `_.map` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array} Returns the new mapped array.\n     */\n    function baseMap(collection, iteratee) {\n      var index = -1,\n          result = isArrayLike(collection) ? Array(collection.length) : [];\n\n      baseEach(collection, function(value, key, collection) {\n        result[++index] = iteratee(value, key, collection);\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.matches` which doesn't clone `source`.\n     *\n     * @private\n     * @param {Object} source The object of property values to match.\n     * @returns {Function} Returns the new spec function.\n     */\n    function baseMatches(source) {\n      var matchData = getMatchData(source);\n      if (matchData.length == 1 && matchData[0][2]) {\n        return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n      }\n      return function(object) {\n        return object === source || baseIsMatch(object, source, matchData);\n      };\n    }\n\n    /**\n     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\n     *\n     * @private\n     * @param {string} path The path of the property to get.\n     * @param {*} srcValue The value to match.\n     * @returns {Function} Returns the new spec function.\n     */\n    function baseMatchesProperty(path, srcValue) {\n      if (isKey(path) && isStrictComparable(srcValue)) {\n        return matchesStrictComparable(toKey(path), srcValue);\n      }\n      return function(object) {\n        var objValue = get(object, path);\n        return (objValue === undefined && objValue === srcValue)\n          ? hasIn(object, path)\n          : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);\n      };\n    }\n\n    /**\n     * The base implementation of `_.merge` without support for multiple sources.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @param {number} srcIndex The index of `source`.\n     * @param {Function} [customizer] The function to customize merged values.\n     * @param {Object} [stack] Tracks traversed source values and their merged\n     *  counterparts.\n     */\n    function baseMerge(object, source, srcIndex, customizer, stack) {\n      if (object === source) {\n        return;\n      }\n      baseFor(source, function(srcValue, key) {\n        stack || (stack = new Stack);\n        if (isObject(srcValue)) {\n          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);\n        }\n        else {\n          var newValue = customizer\n            ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)\n            : undefined;\n\n          if (newValue === undefined) {\n            newValue = srcValue;\n          }\n          assignMergeValue(object, key, newValue);\n        }\n      }, keysIn);\n    }\n\n    /**\n     * A specialized version of `baseMerge` for arrays and objects which performs\n     * deep merges and tracks traversed objects enabling objects with circular\n     * references to be merged.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @param {string} key The key of the value to merge.\n     * @param {number} srcIndex The index of `source`.\n     * @param {Function} mergeFunc The function to merge values.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @param {Object} [stack] Tracks traversed source values and their merged\n     *  counterparts.\n     */\n    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {\n      var objValue = safeGet(object, key),\n          srcValue = safeGet(source, key),\n          stacked = stack.get(srcValue);\n\n      if (stacked) {\n        assignMergeValue(object, key, stacked);\n        return;\n      }\n      var newValue = customizer\n        ? customizer(objValue, srcValue, (key + ''), object, source, stack)\n        : undefined;\n\n      var isCommon = newValue === undefined;\n\n      if (isCommon) {\n        var isArr = isArray(srcValue),\n            isBuff = !isArr && isBuffer(srcValue),\n            isTyped = !isArr && !isBuff && isTypedArray(srcValue);\n\n        newValue = srcValue;\n        if (isArr || isBuff || isTyped) {\n          if (isArray(objValue)) {\n            newValue = objValue;\n          }\n          else if (isArrayLikeObject(objValue)) {\n            newValue = copyArray(objValue);\n          }\n          else if (isBuff) {\n            isCommon = false;\n            newValue = cloneBuffer(srcValue, true);\n          }\n          else if (isTyped) {\n            isCommon = false;\n            newValue = cloneTypedArray(srcValue, true);\n          }\n          else {\n            newValue = [];\n          }\n        }\n        else if (isPlainObject(srcValue) || isArguments(srcValue)) {\n          newValue = objValue;\n          if (isArguments(objValue)) {\n            newValue = toPlainObject(objValue);\n          }\n          else if (!isObject(objValue) || isFunction(objValue)) {\n            newValue = initCloneObject(srcValue);\n          }\n        }\n        else {\n          isCommon = false;\n        }\n      }\n      if (isCommon) {\n        // Recursively merge objects and arrays (susceptible to call stack limits).\n        stack.set(srcValue, newValue);\n        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);\n        stack['delete'](srcValue);\n      }\n      assignMergeValue(object, key, newValue);\n    }\n\n    /**\n     * The base implementation of `_.nth` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {Array} array The array to query.\n     * @param {number} n The index of the element to return.\n     * @returns {*} Returns the nth element of `array`.\n     */\n    function baseNth(array, n) {\n      var length = array.length;\n      if (!length) {\n        return;\n      }\n      n += n < 0 ? length : 0;\n      return isIndex(n, length) ? array[n] : undefined;\n    }\n\n    /**\n     * The base implementation of `_.orderBy` without param guards.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.\n     * @param {string[]} orders The sort orders of `iteratees`.\n     * @returns {Array} Returns the new sorted array.\n     */\n    function baseOrderBy(collection, iteratees, orders) {\n      if (iteratees.length) {\n        iteratees = arrayMap(iteratees, function(iteratee) {\n          if (isArray(iteratee)) {\n            return function(value) {\n              return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);\n            }\n          }\n          return iteratee;\n        });\n      } else {\n        iteratees = [identity];\n      }\n\n      var index = -1;\n      iteratees = arrayMap(iteratees, baseUnary(getIteratee()));\n\n      var result = baseMap(collection, function(value, key, collection) {\n        var criteria = arrayMap(iteratees, function(iteratee) {\n          return iteratee(value);\n        });\n        return { 'criteria': criteria, 'index': ++index, 'value': value };\n      });\n\n      return baseSortBy(result, function(object, other) {\n        return compareMultiple(object, other, orders);\n      });\n    }\n\n    /**\n     * The base implementation of `_.pick` without support for individual\n     * property identifiers.\n     *\n     * @private\n     * @param {Object} object The source object.\n     * @param {string[]} paths The property paths to pick.\n     * @returns {Object} Returns the new object.\n     */\n    function basePick(object, paths) {\n      return basePickBy(object, paths, function(value, path) {\n        return hasIn(object, path);\n      });\n    }\n\n    /**\n     * The base implementation of  `_.pickBy` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Object} object The source object.\n     * @param {string[]} paths The property paths to pick.\n     * @param {Function} predicate The function invoked per property.\n     * @returns {Object} Returns the new object.\n     */\n    function basePickBy(object, paths, predicate) {\n      var index = -1,\n          length = paths.length,\n          result = {};\n\n      while (++index < length) {\n        var path = paths[index],\n            value = baseGet(object, path);\n\n        if (predicate(value, path)) {\n          baseSet(result, castPath(path, object), value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * A specialized version of `baseProperty` which supports deep paths.\n     *\n     * @private\n     * @param {Array|string} path The path of the property to get.\n     * @returns {Function} Returns the new accessor function.\n     */\n    function basePropertyDeep(path) {\n      return function(object) {\n        return baseGet(object, path);\n      };\n    }\n\n    /**\n     * The base implementation of `_.pullAllBy` without support for iteratee\n     * shorthands.\n     *\n     * @private\n     * @param {Array} array The array to modify.\n     * @param {Array} values The values to remove.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns `array`.\n     */\n    function basePullAll(array, values, iteratee, comparator) {\n      var indexOf = comparator ? baseIndexOfWith : baseIndexOf,\n          index = -1,\n          length = values.length,\n          seen = array;\n\n      if (array === values) {\n        values = copyArray(values);\n      }\n      if (iteratee) {\n        seen = arrayMap(array, baseUnary(iteratee));\n      }\n      while (++index < length) {\n        var fromIndex = 0,\n            value = values[index],\n            computed = iteratee ? iteratee(value) : value;\n\n        while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {\n          if (seen !== array) {\n            splice.call(seen, fromIndex, 1);\n          }\n          splice.call(array, fromIndex, 1);\n        }\n      }\n      return array;\n    }\n\n    /**\n     * The base implementation of `_.pullAt` without support for individual\n     * indexes or capturing the removed elements.\n     *\n     * @private\n     * @param {Array} array The array to modify.\n     * @param {number[]} indexes The indexes of elements to remove.\n     * @returns {Array} Returns `array`.\n     */\n    function basePullAt(array, indexes) {\n      var length = array ? indexes.length : 0,\n          lastIndex = length - 1;\n\n      while (length--) {\n        var index = indexes[length];\n        if (length == lastIndex || index !== previous) {\n          var previous = index;\n          if (isIndex(index)) {\n            splice.call(array, index, 1);\n          } else {\n            baseUnset(array, index);\n          }\n        }\n      }\n      return array;\n    }\n\n    /**\n     * The base implementation of `_.random` without support for returning\n     * floating-point numbers.\n     *\n     * @private\n     * @param {number} lower The lower bound.\n     * @param {number} upper The upper bound.\n     * @returns {number} Returns the random number.\n     */\n    function baseRandom(lower, upper) {\n      return lower + nativeFloor(nativeRandom() * (upper - lower + 1));\n    }\n\n    /**\n     * The base implementation of `_.range` and `_.rangeRight` which doesn't\n     * coerce arguments.\n     *\n     * @private\n     * @param {number} start The start of the range.\n     * @param {number} end The end of the range.\n     * @param {number} step The value to increment or decrement by.\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Array} Returns the range of numbers.\n     */\n    function baseRange(start, end, step, fromRight) {\n      var index = -1,\n          length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),\n          result = Array(length);\n\n      while (length--) {\n        result[fromRight ? length : ++index] = start;\n        start += step;\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.repeat` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {string} string The string to repeat.\n     * @param {number} n The number of times to repeat the string.\n     * @returns {string} Returns the repeated string.\n     */\n    function baseRepeat(string, n) {\n      var result = '';\n      if (!string || n < 1 || n > MAX_SAFE_INTEGER) {\n        return result;\n      }\n      // Leverage the exponentiation by squaring algorithm for a faster repeat.\n      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.\n      do {\n        if (n % 2) {\n          result += string;\n        }\n        n = nativeFloor(n / 2);\n        if (n) {\n          string += string;\n        }\n      } while (n);\n\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.rest` which doesn't validate or coerce arguments.\n     *\n     * @private\n     * @param {Function} func The function to apply a rest parameter to.\n     * @param {number} [start=func.length-1] The start position of the rest parameter.\n     * @returns {Function} Returns the new function.\n     */\n    function baseRest(func, start) {\n      return setToString(overRest(func, start, identity), func + '');\n    }\n\n    /**\n     * The base implementation of `_.sample`.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to sample.\n     * @returns {*} Returns the random element.\n     */\n    function baseSample(collection) {\n      return arraySample(values(collection));\n    }\n\n    /**\n     * The base implementation of `_.sampleSize` without param guards.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to sample.\n     * @param {number} n The number of elements to sample.\n     * @returns {Array} Returns the random elements.\n     */\n    function baseSampleSize(collection, n) {\n      var array = values(collection);\n      return shuffleSelf(array, baseClamp(n, 0, array.length));\n    }\n\n    /**\n     * The base implementation of `_.set`.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {*} value The value to set.\n     * @param {Function} [customizer] The function to customize path creation.\n     * @returns {Object} Returns `object`.\n     */\n    function baseSet(object, path, value, customizer) {\n      if (!isObject(object)) {\n        return object;\n      }\n      path = castPath(path, object);\n\n      var index = -1,\n          length = path.length,\n          lastIndex = length - 1,\n          nested = object;\n\n      while (nested != null && ++index < length) {\n        var key = toKey(path[index]),\n            newValue = value;\n\n        if (key === '__proto__' || key === 'constructor' || key === 'prototype') {\n          return object;\n        }\n\n        if (index != lastIndex) {\n          var objValue = nested[key];\n          newValue = customizer ? customizer(objValue, key, nested) : undefined;\n          if (newValue === undefined) {\n            newValue = isObject(objValue)\n              ? objValue\n              : (isIndex(path[index + 1]) ? [] : {});\n          }\n        }\n        assignValue(nested, key, newValue);\n        nested = nested[key];\n      }\n      return object;\n    }\n\n    /**\n     * The base implementation of `setData` without support for hot loop shorting.\n     *\n     * @private\n     * @param {Function} func The function to associate metadata with.\n     * @param {*} data The metadata.\n     * @returns {Function} Returns `func`.\n     */\n    var baseSetData = !metaMap ? identity : function(func, data) {\n      metaMap.set(func, data);\n      return func;\n    };\n\n    /**\n     * The base implementation of `setToString` without support for hot loop shorting.\n     *\n     * @private\n     * @param {Function} func The function to modify.\n     * @param {Function} string The `toString` result.\n     * @returns {Function} Returns `func`.\n     */\n    var baseSetToString = !defineProperty ? identity : function(func, string) {\n      return defineProperty(func, 'toString', {\n        'configurable': true,\n        'enumerable': false,\n        'value': constant(string),\n        'writable': true\n      });\n    };\n\n    /**\n     * The base implementation of `_.shuffle`.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to shuffle.\n     * @returns {Array} Returns the new shuffled array.\n     */\n    function baseShuffle(collection) {\n      return shuffleSelf(values(collection));\n    }\n\n    /**\n     * The base implementation of `_.slice` without an iteratee call guard.\n     *\n     * @private\n     * @param {Array} array The array to slice.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns the slice of `array`.\n     */\n    function baseSlice(array, start, end) {\n      var index = -1,\n          length = array.length;\n\n      if (start < 0) {\n        start = -start > length ? 0 : (length + start);\n      }\n      end = end > length ? length : end;\n      if (end < 0) {\n        end += length;\n      }\n      length = start > end ? 0 : ((end - start) >>> 0);\n      start >>>= 0;\n\n      var result = Array(length);\n      while (++index < length) {\n        result[index] = array[index + start];\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.some` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {boolean} Returns `true` if any element passes the predicate check,\n     *  else `false`.\n     */\n    function baseSome(collection, predicate) {\n      var result;\n\n      baseEach(collection, function(value, index, collection) {\n        result = predicate(value, index, collection);\n        return !result;\n      });\n      return !!result;\n    }\n\n    /**\n     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which\n     * performs a binary search of `array` to determine the index at which `value`\n     * should be inserted into `array` in order to maintain its sort order.\n     *\n     * @private\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {boolean} [retHighest] Specify returning the highest qualified index.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     */\n    function baseSortedIndex(array, value, retHighest) {\n      var low = 0,\n          high = array == null ? low : array.length;\n\n      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {\n        while (low < high) {\n          var mid = (low + high) >>> 1,\n              computed = array[mid];\n\n          if (computed !== null && !isSymbol(computed) &&\n              (retHighest ? (computed <= value) : (computed < value))) {\n            low = mid + 1;\n          } else {\n            high = mid;\n          }\n        }\n        return high;\n      }\n      return baseSortedIndexBy(array, value, identity, retHighest);\n    }\n\n    /**\n     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`\n     * which invokes `iteratee` for `value` and each element of `array` to compute\n     * their sort ranking. The iteratee is invoked with one argument; (value).\n     *\n     * @private\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {Function} iteratee The iteratee invoked per element.\n     * @param {boolean} [retHighest] Specify returning the highest qualified index.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     */\n    function baseSortedIndexBy(array, value, iteratee, retHighest) {\n      var low = 0,\n          high = array == null ? 0 : array.length;\n      if (high === 0) {\n        return 0;\n      }\n\n      value = iteratee(value);\n      var valIsNaN = value !== value,\n          valIsNull = value === null,\n          valIsSymbol = isSymbol(value),\n          valIsUndefined = value === undefined;\n\n      while (low < high) {\n        var mid = nativeFloor((low + high) / 2),\n            computed = iteratee(array[mid]),\n            othIsDefined = computed !== undefined,\n            othIsNull = computed === null,\n            othIsReflexive = computed === computed,\n            othIsSymbol = isSymbol(computed);\n\n        if (valIsNaN) {\n          var setLow = retHighest || othIsReflexive;\n        } else if (valIsUndefined) {\n          setLow = othIsReflexive && (retHighest || othIsDefined);\n        } else if (valIsNull) {\n          setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);\n        } else if (valIsSymbol) {\n          setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);\n        } else if (othIsNull || othIsSymbol) {\n          setLow = false;\n        } else {\n          setLow = retHighest ? (computed <= value) : (computed < value);\n        }\n        if (setLow) {\n          low = mid + 1;\n        } else {\n          high = mid;\n        }\n      }\n      return nativeMin(high, MAX_ARRAY_INDEX);\n    }\n\n    /**\n     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without\n     * support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     */\n    function baseSortedUniq(array, iteratee) {\n      var index = -1,\n          length = array.length,\n          resIndex = 0,\n          result = [];\n\n      while (++index < length) {\n        var value = array[index],\n            computed = iteratee ? iteratee(value) : value;\n\n        if (!index || !eq(computed, seen)) {\n          var seen = computed;\n          result[resIndex++] = value === 0 ? 0 : value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.toNumber` which doesn't ensure correct\n     * conversions of binary, hexadecimal, or octal string values.\n     *\n     * @private\n     * @param {*} value The value to process.\n     * @returns {number} Returns the number.\n     */\n    function baseToNumber(value) {\n      if (typeof value == 'number') {\n        return value;\n      }\n      if (isSymbol(value)) {\n        return NAN;\n      }\n      return +value;\n    }\n\n    /**\n     * The base implementation of `_.toString` which doesn't convert nullish\n     * values to empty strings.\n     *\n     * @private\n     * @param {*} value The value to process.\n     * @returns {string} Returns the string.\n     */\n    function baseToString(value) {\n      // Exit early for strings to avoid a performance hit in some environments.\n      if (typeof value == 'string') {\n        return value;\n      }\n      if (isArray(value)) {\n        // Recursively convert values (susceptible to call stack limits).\n        return arrayMap(value, baseToString) + '';\n      }\n      if (isSymbol(value)) {\n        return symbolToString ? symbolToString.call(value) : '';\n      }\n      var result = (value + '');\n      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n    }\n\n    /**\n     * The base implementation of `_.uniqBy` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     */\n    function baseUniq(array, iteratee, comparator) {\n      var index = -1,\n          includes = arrayIncludes,\n          length = array.length,\n          isCommon = true,\n          result = [],\n          seen = result;\n\n      if (comparator) {\n        isCommon = false;\n        includes = arrayIncludesWith;\n      }\n      else if (length >= LARGE_ARRAY_SIZE) {\n        var set = iteratee ? null : createSet(array);\n        if (set) {\n          return setToArray(set);\n        }\n        isCommon = false;\n        includes = cacheHas;\n        seen = new SetCache;\n      }\n      else {\n        seen = iteratee ? [] : result;\n      }\n      outer:\n      while (++index < length) {\n        var value = array[index],\n            computed = iteratee ? iteratee(value) : value;\n\n        value = (comparator || value !== 0) ? value : 0;\n        if (isCommon && computed === computed) {\n          var seenIndex = seen.length;\n          while (seenIndex--) {\n            if (seen[seenIndex] === computed) {\n              continue outer;\n            }\n          }\n          if (iteratee) {\n            seen.push(computed);\n          }\n          result.push(value);\n        }\n        else if (!includes(seen, computed, comparator)) {\n          if (seen !== result) {\n            seen.push(computed);\n          }\n          result.push(value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.unset`.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The property path to unset.\n     * @returns {boolean} Returns `true` if the property is deleted, else `false`.\n     */\n    function baseUnset(object, path) {\n      path = castPath(path, object);\n      object = parent(object, path);\n      return object == null || delete object[toKey(last(path))];\n    }\n\n    /**\n     * The base implementation of `_.update`.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to update.\n     * @param {Function} updater The function to produce the updated value.\n     * @param {Function} [customizer] The function to customize path creation.\n     * @returns {Object} Returns `object`.\n     */\n    function baseUpdate(object, path, updater, customizer) {\n      return baseSet(object, path, updater(baseGet(object, path)), customizer);\n    }\n\n    /**\n     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`\n     * without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array} array The array to query.\n     * @param {Function} predicate The function invoked per iteration.\n     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Array} Returns the slice of `array`.\n     */\n    function baseWhile(array, predicate, isDrop, fromRight) {\n      var length = array.length,\n          index = fromRight ? length : -1;\n\n      while ((fromRight ? index-- : ++index < length) &&\n        predicate(array[index], index, array)) {}\n\n      return isDrop\n        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))\n        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));\n    }\n\n    /**\n     * The base implementation of `wrapperValue` which returns the result of\n     * performing a sequence of actions on the unwrapped `value`, where each\n     * successive action is supplied the return value of the previous.\n     *\n     * @private\n     * @param {*} value The unwrapped value.\n     * @param {Array} actions Actions to perform to resolve the unwrapped value.\n     * @returns {*} Returns the resolved value.\n     */\n    function baseWrapperValue(value, actions) {\n      var result = value;\n      if (result instanceof LazyWrapper) {\n        result = result.value();\n      }\n      return arrayReduce(actions, function(result, action) {\n        return action.func.apply(action.thisArg, arrayPush([result], action.args));\n      }, result);\n    }\n\n    /**\n     * The base implementation of methods like `_.xor`, without support for\n     * iteratee shorthands, that accepts an array of arrays to inspect.\n     *\n     * @private\n     * @param {Array} arrays The arrays to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of values.\n     */\n    function baseXor(arrays, iteratee, comparator) {\n      var length = arrays.length;\n      if (length < 2) {\n        return length ? baseUniq(arrays[0]) : [];\n      }\n      var index = -1,\n          result = Array(length);\n\n      while (++index < length) {\n        var array = arrays[index],\n            othIndex = -1;\n\n        while (++othIndex < length) {\n          if (othIndex != index) {\n            result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);\n          }\n        }\n      }\n      return baseUniq(baseFlatten(result, 1), iteratee, comparator);\n    }\n\n    /**\n     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.\n     *\n     * @private\n     * @param {Array} props The property identifiers.\n     * @param {Array} values The property values.\n     * @param {Function} assignFunc The function to assign values.\n     * @returns {Object} Returns the new object.\n     */\n    function baseZipObject(props, values, assignFunc) {\n      var index = -1,\n          length = props.length,\n          valsLength = values.length,\n          result = {};\n\n      while (++index < length) {\n        var value = index < valsLength ? values[index] : undefined;\n        assignFunc(result, props[index], value);\n      }\n      return result;\n    }\n\n    /**\n     * Casts `value` to an empty array if it's not an array like object.\n     *\n     * @private\n     * @param {*} value The value to inspect.\n     * @returns {Array|Object} Returns the cast array-like object.\n     */\n    function castArrayLikeObject(value) {\n      return isArrayLikeObject(value) ? value : [];\n    }\n\n    /**\n     * Casts `value` to `identity` if it's not a function.\n     *\n     * @private\n     * @param {*} value The value to inspect.\n     * @returns {Function} Returns cast function.\n     */\n    function castFunction(value) {\n      return typeof value == 'function' ? value : identity;\n    }\n\n    /**\n     * Casts `value` to a path array if it's not one.\n     *\n     * @private\n     * @param {*} value The value to inspect.\n     * @param {Object} [object] The object to query keys on.\n     * @returns {Array} Returns the cast property path array.\n     */\n    function castPath(value, object) {\n      if (isArray(value)) {\n        return value;\n      }\n      return isKey(value, object) ? [value] : stringToPath(toString(value));\n    }\n\n    /**\n     * A `baseRest` alias which can be replaced with `identity` by module\n     * replacement plugins.\n     *\n     * @private\n     * @type {Function}\n     * @param {Function} func The function to apply a rest parameter to.\n     * @returns {Function} Returns the new function.\n     */\n    var castRest = baseRest;\n\n    /**\n     * Casts `array` to a slice if it's needed.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {number} start The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns the cast slice.\n     */\n    function castSlice(array, start, end) {\n      var length = array.length;\n      end = end === undefined ? length : end;\n      return (!start && end >= length) ? array : baseSlice(array, start, end);\n    }\n\n    /**\n     * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).\n     *\n     * @private\n     * @param {number|Object} id The timer id or timeout object of the timer to clear.\n     */\n    var clearTimeout = ctxClearTimeout || function(id) {\n      return root.clearTimeout(id);\n    };\n\n    /**\n     * Creates a clone of  `buffer`.\n     *\n     * @private\n     * @param {Buffer} buffer The buffer to clone.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @returns {Buffer} Returns the cloned buffer.\n     */\n    function cloneBuffer(buffer, isDeep) {\n      if (isDeep) {\n        return buffer.slice();\n      }\n      var length = buffer.length,\n          result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);\n\n      buffer.copy(result);\n      return result;\n    }\n\n    /**\n     * Creates a clone of `arrayBuffer`.\n     *\n     * @private\n     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n     * @returns {ArrayBuffer} Returns the cloned array buffer.\n     */\n    function cloneArrayBuffer(arrayBuffer) {\n      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n      new Uint8Array(result).set(new Uint8Array(arrayBuffer));\n      return result;\n    }\n\n    /**\n     * Creates a clone of `dataView`.\n     *\n     * @private\n     * @param {Object} dataView The data view to clone.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @returns {Object} Returns the cloned data view.\n     */\n    function cloneDataView(dataView, isDeep) {\n      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;\n      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n    }\n\n    /**\n     * Creates a clone of `regexp`.\n     *\n     * @private\n     * @param {Object} regexp The regexp to clone.\n     * @returns {Object} Returns the cloned regexp.\n     */\n    function cloneRegExp(regexp) {\n      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));\n      result.lastIndex = regexp.lastIndex;\n      return result;\n    }\n\n    /**\n     * Creates a clone of the `symbol` object.\n     *\n     * @private\n     * @param {Object} symbol The symbol object to clone.\n     * @returns {Object} Returns the cloned symbol object.\n     */\n    function cloneSymbol(symbol) {\n      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};\n    }\n\n    /**\n     * Creates a clone of `typedArray`.\n     *\n     * @private\n     * @param {Object} typedArray The typed array to clone.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @returns {Object} Returns the cloned typed array.\n     */\n    function cloneTypedArray(typedArray, isDeep) {\n      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n    }\n\n    /**\n     * Compares values to sort them in ascending order.\n     *\n     * @private\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {number} Returns the sort order indicator for `value`.\n     */\n    function compareAscending(value, other) {\n      if (value !== other) {\n        var valIsDefined = value !== undefined,\n            valIsNull = value === null,\n            valIsReflexive = value === value,\n            valIsSymbol = isSymbol(value);\n\n        var othIsDefined = other !== undefined,\n            othIsNull = other === null,\n            othIsReflexive = other === other,\n            othIsSymbol = isSymbol(other);\n\n        if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||\n            (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||\n            (valIsNull && othIsDefined && othIsReflexive) ||\n            (!valIsDefined && othIsReflexive) ||\n            !valIsReflexive) {\n          return 1;\n        }\n        if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||\n            (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||\n            (othIsNull && valIsDefined && valIsReflexive) ||\n            (!othIsDefined && valIsReflexive) ||\n            !othIsReflexive) {\n          return -1;\n        }\n      }\n      return 0;\n    }\n\n    /**\n     * Used by `_.orderBy` to compare multiple properties of a value to another\n     * and stable sort them.\n     *\n     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,\n     * specify an order of \"desc\" for descending or \"asc\" for ascending sort order\n     * of corresponding values.\n     *\n     * @private\n     * @param {Object} object The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {boolean[]|string[]} orders The order to sort by for each property.\n     * @returns {number} Returns the sort order indicator for `object`.\n     */\n    function compareMultiple(object, other, orders) {\n      var index = -1,\n          objCriteria = object.criteria,\n          othCriteria = other.criteria,\n          length = objCriteria.length,\n          ordersLength = orders.length;\n\n      while (++index < length) {\n        var result = compareAscending(objCriteria[index], othCriteria[index]);\n        if (result) {\n          if (index >= ordersLength) {\n            return result;\n          }\n          var order = orders[index];\n          return result * (order == 'desc' ? -1 : 1);\n        }\n      }\n      // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications\n      // that causes it, under certain circumstances, to provide the same value for\n      // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247\n      // for more details.\n      //\n      // This also ensures a stable sort in V8 and other engines.\n      // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.\n      return object.index - other.index;\n    }\n\n    /**\n     * Creates an array that is the composition of partially applied arguments,\n     * placeholders, and provided arguments into a single array of arguments.\n     *\n     * @private\n     * @param {Array} args The provided arguments.\n     * @param {Array} partials The arguments to prepend to those provided.\n     * @param {Array} holders The `partials` placeholder indexes.\n     * @params {boolean} [isCurried] Specify composing for a curried function.\n     * @returns {Array} Returns the new array of composed arguments.\n     */\n    function composeArgs(args, partials, holders, isCurried) {\n      var argsIndex = -1,\n          argsLength = args.length,\n          holdersLength = holders.length,\n          leftIndex = -1,\n          leftLength = partials.length,\n          rangeLength = nativeMax(argsLength - holdersLength, 0),\n          result = Array(leftLength + rangeLength),\n          isUncurried = !isCurried;\n\n      while (++leftIndex < leftLength) {\n        result[leftIndex] = partials[leftIndex];\n      }\n      while (++argsIndex < holdersLength) {\n        if (isUncurried || argsIndex < argsLength) {\n          result[holders[argsIndex]] = args[argsIndex];\n        }\n      }\n      while (rangeLength--) {\n        result[leftIndex++] = args[argsIndex++];\n      }\n      return result;\n    }\n\n    /**\n     * This function is like `composeArgs` except that the arguments composition\n     * is tailored for `_.partialRight`.\n     *\n     * @private\n     * @param {Array} args The provided arguments.\n     * @param {Array} partials The arguments to append to those provided.\n     * @param {Array} holders The `partials` placeholder indexes.\n     * @params {boolean} [isCurried] Specify composing for a curried function.\n     * @returns {Array} Returns the new array of composed arguments.\n     */\n    function composeArgsRight(args, partials, holders, isCurried) {\n      var argsIndex = -1,\n          argsLength = args.length,\n          holdersIndex = -1,\n          holdersLength = holders.length,\n          rightIndex = -1,\n          rightLength = partials.length,\n          rangeLength = nativeMax(argsLength - holdersLength, 0),\n          result = Array(rangeLength + rightLength),\n          isUncurried = !isCurried;\n\n      while (++argsIndex < rangeLength) {\n        result[argsIndex] = args[argsIndex];\n      }\n      var offset = argsIndex;\n      while (++rightIndex < rightLength) {\n        result[offset + rightIndex] = partials[rightIndex];\n      }\n      while (++holdersIndex < holdersLength) {\n        if (isUncurried || argsIndex < argsLength) {\n          result[offset + holders[holdersIndex]] = args[argsIndex++];\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Copies the values of `source` to `array`.\n     *\n     * @private\n     * @param {Array} source The array to copy values from.\n     * @param {Array} [array=[]] The array to copy values to.\n     * @returns {Array} Returns `array`.\n     */\n    function copyArray(source, array) {\n      var index = -1,\n          length = source.length;\n\n      array || (array = Array(length));\n      while (++index < length) {\n        array[index] = source[index];\n      }\n      return array;\n    }\n\n    /**\n     * Copies properties of `source` to `object`.\n     *\n     * @private\n     * @param {Object} source The object to copy properties from.\n     * @param {Array} props The property identifiers to copy.\n     * @param {Object} [object={}] The object to copy properties to.\n     * @param {Function} [customizer] The function to customize copied values.\n     * @returns {Object} Returns `object`.\n     */\n    function copyObject(source, props, object, customizer) {\n      var isNew = !object;\n      object || (object = {});\n\n      var index = -1,\n          length = props.length;\n\n      while (++index < length) {\n        var key = props[index];\n\n        var newValue = customizer\n          ? customizer(object[key], source[key], key, object, source)\n          : undefined;\n\n        if (newValue === undefined) {\n          newValue = source[key];\n        }\n        if (isNew) {\n          baseAssignValue(object, key, newValue);\n        } else {\n          assignValue(object, key, newValue);\n        }\n      }\n      return object;\n    }\n\n    /**\n     * Copies own symbols of `source` to `object`.\n     *\n     * @private\n     * @param {Object} source The object to copy symbols from.\n     * @param {Object} [object={}] The object to copy symbols to.\n     * @returns {Object} Returns `object`.\n     */\n    function copySymbols(source, object) {\n      return copyObject(source, getSymbols(source), object);\n    }\n\n    /**\n     * Copies own and inherited symbols of `source` to `object`.\n     *\n     * @private\n     * @param {Object} source The object to copy symbols from.\n     * @param {Object} [object={}] The object to copy symbols to.\n     * @returns {Object} Returns `object`.\n     */\n    function copySymbolsIn(source, object) {\n      return copyObject(source, getSymbolsIn(source), object);\n    }\n\n    /**\n     * Creates a function like `_.groupBy`.\n     *\n     * @private\n     * @param {Function} setter The function to set accumulator values.\n     * @param {Function} [initializer] The accumulator object initializer.\n     * @returns {Function} Returns the new aggregator function.\n     */\n    function createAggregator(setter, initializer) {\n      return function(collection, iteratee) {\n        var func = isArray(collection) ? arrayAggregator : baseAggregator,\n            accumulator = initializer ? initializer() : {};\n\n        return func(collection, setter, getIteratee(iteratee, 2), accumulator);\n      };\n    }\n\n    /**\n     * Creates a function like `_.assign`.\n     *\n     * @private\n     * @param {Function} assigner The function to assign values.\n     * @returns {Function} Returns the new assigner function.\n     */\n    function createAssigner(assigner) {\n      return baseRest(function(object, sources) {\n        var index = -1,\n            length = sources.length,\n            customizer = length > 1 ? sources[length - 1] : undefined,\n            guard = length > 2 ? sources[2] : undefined;\n\n        customizer = (assigner.length > 3 && typeof customizer == 'function')\n          ? (length--, customizer)\n          : undefined;\n\n        if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n          customizer = length < 3 ? undefined : customizer;\n          length = 1;\n        }\n        object = Object(object);\n        while (++index < length) {\n          var source = sources[index];\n          if (source) {\n            assigner(object, source, index, customizer);\n          }\n        }\n        return object;\n      });\n    }\n\n    /**\n     * Creates a `baseEach` or `baseEachRight` function.\n     *\n     * @private\n     * @param {Function} eachFunc The function to iterate over a collection.\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new base function.\n     */\n    function createBaseEach(eachFunc, fromRight) {\n      return function(collection, iteratee) {\n        if (collection == null) {\n          return collection;\n        }\n        if (!isArrayLike(collection)) {\n          return eachFunc(collection, iteratee);\n        }\n        var length = collection.length,\n            index = fromRight ? length : -1,\n            iterable = Object(collection);\n\n        while ((fromRight ? index-- : ++index < length)) {\n          if (iteratee(iterable[index], index, iterable) === false) {\n            break;\n          }\n        }\n        return collection;\n      };\n    }\n\n    /**\n     * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n     *\n     * @private\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new base function.\n     */\n    function createBaseFor(fromRight) {\n      return function(object, iteratee, keysFunc) {\n        var index = -1,\n            iterable = Object(object),\n            props = keysFunc(object),\n            length = props.length;\n\n        while (length--) {\n          var key = props[fromRight ? length : ++index];\n          if (iteratee(iterable[key], key, iterable) === false) {\n            break;\n          }\n        }\n        return object;\n      };\n    }\n\n    /**\n     * Creates a function that wraps `func` to invoke it with the optional `this`\n     * binding of `thisArg`.\n     *\n     * @private\n     * @param {Function} func The function to wrap.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createBind(func, bitmask, thisArg) {\n      var isBind = bitmask & WRAP_BIND_FLAG,\n          Ctor = createCtor(func);\n\n      function wrapper() {\n        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;\n        return fn.apply(isBind ? thisArg : this, arguments);\n      }\n      return wrapper;\n    }\n\n    /**\n     * Creates a function like `_.lowerFirst`.\n     *\n     * @private\n     * @param {string} methodName The name of the `String` case method to use.\n     * @returns {Function} Returns the new case function.\n     */\n    function createCaseFirst(methodName) {\n      return function(string) {\n        string = toString(string);\n\n        var strSymbols = hasUnicode(string)\n          ? stringToArray(string)\n          : undefined;\n\n        var chr = strSymbols\n          ? strSymbols[0]\n          : string.charAt(0);\n\n        var trailing = strSymbols\n          ? castSlice(strSymbols, 1).join('')\n          : string.slice(1);\n\n        return chr[methodName]() + trailing;\n      };\n    }\n\n    /**\n     * Creates a function like `_.camelCase`.\n     *\n     * @private\n     * @param {Function} callback The function to combine each word.\n     * @returns {Function} Returns the new compounder function.\n     */\n    function createCompounder(callback) {\n      return function(string) {\n        return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');\n      };\n    }\n\n    /**\n     * Creates a function that produces an instance of `Ctor` regardless of\n     * whether it was invoked as part of a `new` expression or by `call` or `apply`.\n     *\n     * @private\n     * @param {Function} Ctor The constructor to wrap.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createCtor(Ctor) {\n      return function() {\n        // Use a `switch` statement to work with class constructors. See\n        // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist\n        // for more details.\n        var args = arguments;\n        switch (args.length) {\n          case 0: return new Ctor;\n          case 1: return new Ctor(args[0]);\n          case 2: return new Ctor(args[0], args[1]);\n          case 3: return new Ctor(args[0], args[1], args[2]);\n          case 4: return new Ctor(args[0], args[1], args[2], args[3]);\n          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);\n          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);\n          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);\n        }\n        var thisBinding = baseCreate(Ctor.prototype),\n            result = Ctor.apply(thisBinding, args);\n\n        // Mimic the constructor's `return` behavior.\n        // See https://es5.github.io/#x13.2.2 for more details.\n        return isObject(result) ? result : thisBinding;\n      };\n    }\n\n    /**\n     * Creates a function that wraps `func` to enable currying.\n     *\n     * @private\n     * @param {Function} func The function to wrap.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @param {number} arity The arity of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createCurry(func, bitmask, arity) {\n      var Ctor = createCtor(func);\n\n      function wrapper() {\n        var length = arguments.length,\n            args = Array(length),\n            index = length,\n            placeholder = getHolder(wrapper);\n\n        while (index--) {\n          args[index] = arguments[index];\n        }\n        var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)\n          ? []\n          : replaceHolders(args, placeholder);\n\n        length -= holders.length;\n        if (length < arity) {\n          return createRecurry(\n            func, bitmask, createHybrid, wrapper.placeholder, undefined,\n            args, holders, undefined, undefined, arity - length);\n        }\n        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;\n        return apply(fn, this, args);\n      }\n      return wrapper;\n    }\n\n    /**\n     * Creates a `_.find` or `_.findLast` function.\n     *\n     * @private\n     * @param {Function} findIndexFunc The function to find the collection index.\n     * @returns {Function} Returns the new find function.\n     */\n    function createFind(findIndexFunc) {\n      return function(collection, predicate, fromIndex) {\n        var iterable = Object(collection);\n        if (!isArrayLike(collection)) {\n          var iteratee = getIteratee(predicate, 3);\n          collection = keys(collection);\n          predicate = function(key) { return iteratee(iterable[key], key, iterable); };\n        }\n        var index = findIndexFunc(collection, predicate, fromIndex);\n        return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;\n      };\n    }\n\n    /**\n     * Creates a `_.flow` or `_.flowRight` function.\n     *\n     * @private\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new flow function.\n     */\n    function createFlow(fromRight) {\n      return flatRest(function(funcs) {\n        var length = funcs.length,\n            index = length,\n            prereq = LodashWrapper.prototype.thru;\n\n        if (fromRight) {\n          funcs.reverse();\n        }\n        while (index--) {\n          var func = funcs[index];\n          if (typeof func != 'function') {\n            throw new TypeError(FUNC_ERROR_TEXT);\n          }\n          if (prereq && !wrapper && getFuncName(func) == 'wrapper') {\n            var wrapper = new LodashWrapper([], true);\n          }\n        }\n        index = wrapper ? index : length;\n        while (++index < length) {\n          func = funcs[index];\n\n          var funcName = getFuncName(func),\n              data = funcName == 'wrapper' ? getData(func) : undefined;\n\n          if (data && isLaziable(data[0]) &&\n                data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) &&\n                !data[4].length && data[9] == 1\n              ) {\n            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);\n          } else {\n            wrapper = (func.length == 1 && isLaziable(func))\n              ? wrapper[funcName]()\n              : wrapper.thru(func);\n          }\n        }\n        return function() {\n          var args = arguments,\n              value = args[0];\n\n          if (wrapper && args.length == 1 && isArray(value)) {\n            return wrapper.plant(value).value();\n          }\n          var index = 0,\n              result = length ? funcs[index].apply(this, args) : value;\n\n          while (++index < length) {\n            result = funcs[index].call(this, result);\n          }\n          return result;\n        };\n      });\n    }\n\n    /**\n     * Creates a function that wraps `func` to invoke it with optional `this`\n     * binding of `thisArg`, partial application, and currying.\n     *\n     * @private\n     * @param {Function|string} func The function or method name to wrap.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @param {Array} [partials] The arguments to prepend to those provided to\n     *  the new function.\n     * @param {Array} [holders] The `partials` placeholder indexes.\n     * @param {Array} [partialsRight] The arguments to append to those provided\n     *  to the new function.\n     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.\n     * @param {Array} [argPos] The argument positions of the new function.\n     * @param {number} [ary] The arity cap of `func`.\n     * @param {number} [arity] The arity of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {\n      var isAry = bitmask & WRAP_ARY_FLAG,\n          isBind = bitmask & WRAP_BIND_FLAG,\n          isBindKey = bitmask & WRAP_BIND_KEY_FLAG,\n          isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),\n          isFlip = bitmask & WRAP_FLIP_FLAG,\n          Ctor = isBindKey ? undefined : createCtor(func);\n\n      function wrapper() {\n        var length = arguments.length,\n            args = Array(length),\n            index = length;\n\n        while (index--) {\n          args[index] = arguments[index];\n        }\n        if (isCurried) {\n          var placeholder = getHolder(wrapper),\n              holdersCount = countHolders(args, placeholder);\n        }\n        if (partials) {\n          args = composeArgs(args, partials, holders, isCurried);\n        }\n        if (partialsRight) {\n          args = composeArgsRight(args, partialsRight, holdersRight, isCurried);\n        }\n        length -= holdersCount;\n        if (isCurried && length < arity) {\n          var newHolders = replaceHolders(args, placeholder);\n          return createRecurry(\n            func, bitmask, createHybrid, wrapper.placeholder, thisArg,\n            args, newHolders, argPos, ary, arity - length\n          );\n        }\n        var thisBinding = isBind ? thisArg : this,\n            fn = isBindKey ? thisBinding[func] : func;\n\n        length = args.length;\n        if (argPos) {\n          args = reorder(args, argPos);\n        } else if (isFlip && length > 1) {\n          args.reverse();\n        }\n        if (isAry && ary < length) {\n          args.length = ary;\n        }\n        if (this && this !== root && this instanceof wrapper) {\n          fn = Ctor || createCtor(fn);\n        }\n        return fn.apply(thisBinding, args);\n      }\n      return wrapper;\n    }\n\n    /**\n     * Creates a function like `_.invertBy`.\n     *\n     * @private\n     * @param {Function} setter The function to set accumulator values.\n     * @param {Function} toIteratee The function to resolve iteratees.\n     * @returns {Function} Returns the new inverter function.\n     */\n    function createInverter(setter, toIteratee) {\n      return function(object, iteratee) {\n        return baseInverter(object, setter, toIteratee(iteratee), {});\n      };\n    }\n\n    /**\n     * Creates a function that performs a mathematical operation on two values.\n     *\n     * @private\n     * @param {Function} operator The function to perform the operation.\n     * @param {number} [defaultValue] The value used for `undefined` arguments.\n     * @returns {Function} Returns the new mathematical operation function.\n     */\n    function createMathOperation(operator, defaultValue) {\n      return function(value, other) {\n        var result;\n        if (value === undefined && other === undefined) {\n          return defaultValue;\n        }\n        if (value !== undefined) {\n          result = value;\n        }\n        if (other !== undefined) {\n          if (result === undefined) {\n            return other;\n          }\n          if (typeof value == 'string' || typeof other == 'string') {\n            value = baseToString(value);\n            other = baseToString(other);\n          } else {\n            value = baseToNumber(value);\n            other = baseToNumber(other);\n          }\n          result = operator(value, other);\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Creates a function like `_.over`.\n     *\n     * @private\n     * @param {Function} arrayFunc The function to iterate over iteratees.\n     * @returns {Function} Returns the new over function.\n     */\n    function createOver(arrayFunc) {\n      return flatRest(function(iteratees) {\n        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));\n        return baseRest(function(args) {\n          var thisArg = this;\n          return arrayFunc(iteratees, function(iteratee) {\n            return apply(iteratee, thisArg, args);\n          });\n        });\n      });\n    }\n\n    /**\n     * Creates the padding for `string` based on `length`. The `chars` string\n     * is truncated if the number of characters exceeds `length`.\n     *\n     * @private\n     * @param {number} length The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padding for `string`.\n     */\n    function createPadding(length, chars) {\n      chars = chars === undefined ? ' ' : baseToString(chars);\n\n      var charsLength = chars.length;\n      if (charsLength < 2) {\n        return charsLength ? baseRepeat(chars, length) : chars;\n      }\n      var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));\n      return hasUnicode(chars)\n        ? castSlice(stringToArray(result), 0, length).join('')\n        : result.slice(0, length);\n    }\n\n    /**\n     * Creates a function that wraps `func` to invoke it with the `this` binding\n     * of `thisArg` and `partials` prepended to the arguments it receives.\n     *\n     * @private\n     * @param {Function} func The function to wrap.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @param {*} thisArg The `this` binding of `func`.\n     * @param {Array} partials The arguments to prepend to those provided to\n     *  the new function.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createPartial(func, bitmask, thisArg, partials) {\n      var isBind = bitmask & WRAP_BIND_FLAG,\n          Ctor = createCtor(func);\n\n      function wrapper() {\n        var argsIndex = -1,\n            argsLength = arguments.length,\n            leftIndex = -1,\n            leftLength = partials.length,\n            args = Array(leftLength + argsLength),\n            fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;\n\n        while (++leftIndex < leftLength) {\n          args[leftIndex] = partials[leftIndex];\n        }\n        while (argsLength--) {\n          args[leftIndex++] = arguments[++argsIndex];\n        }\n        return apply(fn, isBind ? thisArg : this, args);\n      }\n      return wrapper;\n    }\n\n    /**\n     * Creates a `_.range` or `_.rangeRight` function.\n     *\n     * @private\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new range function.\n     */\n    function createRange(fromRight) {\n      return function(start, end, step) {\n        if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {\n          end = step = undefined;\n        }\n        // Ensure the sign of `-0` is preserved.\n        start = toFinite(start);\n        if (end === undefined) {\n          end = start;\n          start = 0;\n        } else {\n          end = toFinite(end);\n        }\n        step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);\n        return baseRange(start, end, step, fromRight);\n      };\n    }\n\n    /**\n     * Creates a function that performs a relational operation on two values.\n     *\n     * @private\n     * @param {Function} operator The function to perform the operation.\n     * @returns {Function} Returns the new relational operation function.\n     */\n    function createRelationalOperation(operator) {\n      return function(value, other) {\n        if (!(typeof value == 'string' && typeof other == 'string')) {\n          value = toNumber(value);\n          other = toNumber(other);\n        }\n        return operator(value, other);\n      };\n    }\n\n    /**\n     * Creates a function that wraps `func` to continue currying.\n     *\n     * @private\n     * @param {Function} func The function to wrap.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @param {Function} wrapFunc The function to create the `func` wrapper.\n     * @param {*} placeholder The placeholder value.\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @param {Array} [partials] The arguments to prepend to those provided to\n     *  the new function.\n     * @param {Array} [holders] The `partials` placeholder indexes.\n     * @param {Array} [argPos] The argument positions of the new function.\n     * @param {number} [ary] The arity cap of `func`.\n     * @param {number} [arity] The arity of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {\n      var isCurry = bitmask & WRAP_CURRY_FLAG,\n          newHolders = isCurry ? holders : undefined,\n          newHoldersRight = isCurry ? undefined : holders,\n          newPartials = isCurry ? partials : undefined,\n          newPartialsRight = isCurry ? undefined : partials;\n\n      bitmask |= (isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG);\n      bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);\n\n      if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {\n        bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);\n      }\n      var newData = [\n        func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,\n        newHoldersRight, argPos, ary, arity\n      ];\n\n      var result = wrapFunc.apply(undefined, newData);\n      if (isLaziable(func)) {\n        setData(result, newData);\n      }\n      result.placeholder = placeholder;\n      return setWrapToString(result, func, bitmask);\n    }\n\n    /**\n     * Creates a function like `_.round`.\n     *\n     * @private\n     * @param {string} methodName The name of the `Math` method to use when rounding.\n     * @returns {Function} Returns the new round function.\n     */\n    function createRound(methodName) {\n      var func = Math[methodName];\n      return function(number, precision) {\n        number = toNumber(number);\n        precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);\n        if (precision && nativeIsFinite(number)) {\n          // Shift with exponential notation to avoid floating-point issues.\n          // See [MDN](https://mdn.io/round#Examples) for more details.\n          var pair = (toString(number) + 'e').split('e'),\n              value = func(pair[0] + 'e' + (+pair[1] + precision));\n\n          pair = (toString(value) + 'e').split('e');\n          return +(pair[0] + 'e' + (+pair[1] - precision));\n        }\n        return func(number);\n      };\n    }\n\n    /**\n     * Creates a set object of `values`.\n     *\n     * @private\n     * @param {Array} values The values to add to the set.\n     * @returns {Object} Returns the new set.\n     */\n    var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {\n      return new Set(values);\n    };\n\n    /**\n     * Creates a `_.toPairs` or `_.toPairsIn` function.\n     *\n     * @private\n     * @param {Function} keysFunc The function to get the keys of a given object.\n     * @returns {Function} Returns the new pairs function.\n     */\n    function createToPairs(keysFunc) {\n      return function(object) {\n        var tag = getTag(object);\n        if (tag == mapTag) {\n          return mapToArray(object);\n        }\n        if (tag == setTag) {\n          return setToPairs(object);\n        }\n        return baseToPairs(object, keysFunc(object));\n      };\n    }\n\n    /**\n     * Creates a function that either curries or invokes `func` with optional\n     * `this` binding and partially applied arguments.\n     *\n     * @private\n     * @param {Function|string} func The function or method name to wrap.\n     * @param {number} bitmask The bitmask flags.\n     *    1 - `_.bind`\n     *    2 - `_.bindKey`\n     *    4 - `_.curry` or `_.curryRight` of a bound function\n     *    8 - `_.curry`\n     *   16 - `_.curryRight`\n     *   32 - `_.partial`\n     *   64 - `_.partialRight`\n     *  128 - `_.rearg`\n     *  256 - `_.ary`\n     *  512 - `_.flip`\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @param {Array} [partials] The arguments to be partially applied.\n     * @param {Array} [holders] The `partials` placeholder indexes.\n     * @param {Array} [argPos] The argument positions of the new function.\n     * @param {number} [ary] The arity cap of `func`.\n     * @param {number} [arity] The arity of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {\n      var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;\n      if (!isBindKey && typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      var length = partials ? partials.length : 0;\n      if (!length) {\n        bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);\n        partials = holders = undefined;\n      }\n      ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);\n      arity = arity === undefined ? arity : toInteger(arity);\n      length -= holders ? holders.length : 0;\n\n      if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {\n        var partialsRight = partials,\n            holdersRight = holders;\n\n        partials = holders = undefined;\n      }\n      var data = isBindKey ? undefined : getData(func);\n\n      var newData = [\n        func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,\n        argPos, ary, arity\n      ];\n\n      if (data) {\n        mergeData(newData, data);\n      }\n      func = newData[0];\n      bitmask = newData[1];\n      thisArg = newData[2];\n      partials = newData[3];\n      holders = newData[4];\n      arity = newData[9] = newData[9] === undefined\n        ? (isBindKey ? 0 : func.length)\n        : nativeMax(newData[9] - length, 0);\n\n      if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {\n        bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);\n      }\n      if (!bitmask || bitmask == WRAP_BIND_FLAG) {\n        var result = createBind(func, bitmask, thisArg);\n      } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {\n        result = createCurry(func, bitmask, arity);\n      } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {\n        result = createPartial(func, bitmask, thisArg, partials);\n      } else {\n        result = createHybrid.apply(undefined, newData);\n      }\n      var setter = data ? baseSetData : setData;\n      return setWrapToString(setter(result, newData), func, bitmask);\n    }\n\n    /**\n     * Used by `_.defaults` to customize its `_.assignIn` use to assign properties\n     * of source objects to the destination object for all destination properties\n     * that resolve to `undefined`.\n     *\n     * @private\n     * @param {*} objValue The destination value.\n     * @param {*} srcValue The source value.\n     * @param {string} key The key of the property to assign.\n     * @param {Object} object The parent object of `objValue`.\n     * @returns {*} Returns the value to assign.\n     */\n    function customDefaultsAssignIn(objValue, srcValue, key, object) {\n      if (objValue === undefined ||\n          (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {\n        return srcValue;\n      }\n      return objValue;\n    }\n\n    /**\n     * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source\n     * objects into destination objects that are passed thru.\n     *\n     * @private\n     * @param {*} objValue The destination value.\n     * @param {*} srcValue The source value.\n     * @param {string} key The key of the property to merge.\n     * @param {Object} object The parent object of `objValue`.\n     * @param {Object} source The parent object of `srcValue`.\n     * @param {Object} [stack] Tracks traversed source values and their merged\n     *  counterparts.\n     * @returns {*} Returns the value to assign.\n     */\n    function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {\n      if (isObject(objValue) && isObject(srcValue)) {\n        // Recursively merge objects and arrays (susceptible to call stack limits).\n        stack.set(srcValue, objValue);\n        baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);\n        stack['delete'](srcValue);\n      }\n      return objValue;\n    }\n\n    /**\n     * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain\n     * objects.\n     *\n     * @private\n     * @param {*} value The value to inspect.\n     * @param {string} key The key of the property to inspect.\n     * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.\n     */\n    function customOmitClone(value) {\n      return isPlainObject(value) ? undefined : value;\n    }\n\n    /**\n     * A specialized version of `baseIsEqualDeep` for arrays with support for\n     * partial deep comparisons.\n     *\n     * @private\n     * @param {Array} array The array to compare.\n     * @param {Array} other The other array to compare.\n     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n     * @param {Function} customizer The function to customize comparisons.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Object} stack Tracks traversed `array` and `other` objects.\n     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n     */\n    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n          arrLength = array.length,\n          othLength = other.length;\n\n      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n        return false;\n      }\n      // Check that cyclic values are equal.\n      var arrStacked = stack.get(array);\n      var othStacked = stack.get(other);\n      if (arrStacked && othStacked) {\n        return arrStacked == other && othStacked == array;\n      }\n      var index = -1,\n          result = true,\n          seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;\n\n      stack.set(array, other);\n      stack.set(other, array);\n\n      // Ignore non-index properties.\n      while (++index < arrLength) {\n        var arrValue = array[index],\n            othValue = other[index];\n\n        if (customizer) {\n          var compared = isPartial\n            ? customizer(othValue, arrValue, index, other, array, stack)\n            : customizer(arrValue, othValue, index, array, other, stack);\n        }\n        if (compared !== undefined) {\n          if (compared) {\n            continue;\n          }\n          result = false;\n          break;\n        }\n        // Recursively compare arrays (susceptible to call stack limits).\n        if (seen) {\n          if (!arraySome(other, function(othValue, othIndex) {\n                if (!cacheHas(seen, othIndex) &&\n                    (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n                  return seen.push(othIndex);\n                }\n              })) {\n            result = false;\n            break;\n          }\n        } else if (!(\n              arrValue === othValue ||\n                equalFunc(arrValue, othValue, bitmask, customizer, stack)\n            )) {\n          result = false;\n          break;\n        }\n      }\n      stack['delete'](array);\n      stack['delete'](other);\n      return result;\n    }\n\n    /**\n     * A specialized version of `baseIsEqualDeep` for comparing objects of\n     * the same `toStringTag`.\n     *\n     * **Note:** This function only supports comparing values with tags of\n     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n     *\n     * @private\n     * @param {Object} object The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {string} tag The `toStringTag` of the objects to compare.\n     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n     * @param {Function} customizer The function to customize comparisons.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Object} stack Tracks traversed `object` and `other` objects.\n     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n     */\n    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n      switch (tag) {\n        case dataViewTag:\n          if ((object.byteLength != other.byteLength) ||\n              (object.byteOffset != other.byteOffset)) {\n            return false;\n          }\n          object = object.buffer;\n          other = other.buffer;\n\n        case arrayBufferTag:\n          if ((object.byteLength != other.byteLength) ||\n              !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n            return false;\n          }\n          return true;\n\n        case boolTag:\n        case dateTag:\n        case numberTag:\n          // Coerce booleans to `1` or `0` and dates to milliseconds.\n          // Invalid dates are coerced to `NaN`.\n          return eq(+object, +other);\n\n        case errorTag:\n          return object.name == other.name && object.message == other.message;\n\n        case regexpTag:\n        case stringTag:\n          // Coerce regexes to strings and treat strings, primitives and objects,\n          // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n          // for more details.\n          return object == (other + '');\n\n        case mapTag:\n          var convert = mapToArray;\n\n        case setTag:\n          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;\n          convert || (convert = setToArray);\n\n          if (object.size != other.size && !isPartial) {\n            return false;\n          }\n          // Assume cyclic values are equal.\n          var stacked = stack.get(object);\n          if (stacked) {\n            return stacked == other;\n          }\n          bitmask |= COMPARE_UNORDERED_FLAG;\n\n          // Recursively compare objects (susceptible to call stack limits).\n          stack.set(object, other);\n          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n          stack['delete'](object);\n          return result;\n\n        case symbolTag:\n          if (symbolValueOf) {\n            return symbolValueOf.call(object) == symbolValueOf.call(other);\n          }\n      }\n      return false;\n    }\n\n    /**\n     * A specialized version of `baseIsEqualDeep` for objects with support for\n     * partial deep comparisons.\n     *\n     * @private\n     * @param {Object} object The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n     * @param {Function} customizer The function to customize comparisons.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Object} stack Tracks traversed `object` and `other` objects.\n     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n     */\n    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n          objProps = getAllKeys(object),\n          objLength = objProps.length,\n          othProps = getAllKeys(other),\n          othLength = othProps.length;\n\n      if (objLength != othLength && !isPartial) {\n        return false;\n      }\n      var index = objLength;\n      while (index--) {\n        var key = objProps[index];\n        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n          return false;\n        }\n      }\n      // Check that cyclic values are equal.\n      var objStacked = stack.get(object);\n      var othStacked = stack.get(other);\n      if (objStacked && othStacked) {\n        return objStacked == other && othStacked == object;\n      }\n      var result = true;\n      stack.set(object, other);\n      stack.set(other, object);\n\n      var skipCtor = isPartial;\n      while (++index < objLength) {\n        key = objProps[index];\n        var objValue = object[key],\n            othValue = other[key];\n\n        if (customizer) {\n          var compared = isPartial\n            ? customizer(othValue, objValue, key, other, object, stack)\n            : customizer(objValue, othValue, key, object, other, stack);\n        }\n        // Recursively compare objects (susceptible to call stack limits).\n        if (!(compared === undefined\n              ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))\n              : compared\n            )) {\n          result = false;\n          break;\n        }\n        skipCtor || (skipCtor = key == 'constructor');\n      }\n      if (result && !skipCtor) {\n        var objCtor = object.constructor,\n            othCtor = other.constructor;\n\n        // Non `Object` object instances with different constructors are not equal.\n        if (objCtor != othCtor &&\n            ('constructor' in object && 'constructor' in other) &&\n            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n              typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n          result = false;\n        }\n      }\n      stack['delete'](object);\n      stack['delete'](other);\n      return result;\n    }\n\n    /**\n     * A specialized version of `baseRest` which flattens the rest array.\n     *\n     * @private\n     * @param {Function} func The function to apply a rest parameter to.\n     * @returns {Function} Returns the new function.\n     */\n    function flatRest(func) {\n      return setToString(overRest(func, undefined, flatten), func + '');\n    }\n\n    /**\n     * Creates an array of own enumerable property names and symbols of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names and symbols.\n     */\n    function getAllKeys(object) {\n      return baseGetAllKeys(object, keys, getSymbols);\n    }\n\n    /**\n     * Creates an array of own and inherited enumerable property names and\n     * symbols of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names and symbols.\n     */\n    function getAllKeysIn(object) {\n      return baseGetAllKeys(object, keysIn, getSymbolsIn);\n    }\n\n    /**\n     * Gets metadata for `func`.\n     *\n     * @private\n     * @param {Function} func The function to query.\n     * @returns {*} Returns the metadata for `func`.\n     */\n    var getData = !metaMap ? noop : function(func) {\n      return metaMap.get(func);\n    };\n\n    /**\n     * Gets the name of `func`.\n     *\n     * @private\n     * @param {Function} func The function to query.\n     * @returns {string} Returns the function name.\n     */\n    function getFuncName(func) {\n      var result = (func.name + ''),\n          array = realNames[result],\n          length = hasOwnProperty.call(realNames, result) ? array.length : 0;\n\n      while (length--) {\n        var data = array[length],\n            otherFunc = data.func;\n        if (otherFunc == null || otherFunc == func) {\n          return data.name;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Gets the argument placeholder value for `func`.\n     *\n     * @private\n     * @param {Function} func The function to inspect.\n     * @returns {*} Returns the placeholder value.\n     */\n    function getHolder(func) {\n      var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;\n      return object.placeholder;\n    }\n\n    /**\n     * Gets the appropriate \"iteratee\" function. If `_.iteratee` is customized,\n     * this function returns the custom method, otherwise it returns `baseIteratee`.\n     * If arguments are provided, the chosen function is invoked with them and\n     * its result is returned.\n     *\n     * @private\n     * @param {*} [value] The value to convert to an iteratee.\n     * @param {number} [arity] The arity of the created iteratee.\n     * @returns {Function} Returns the chosen function or its result.\n     */\n    function getIteratee() {\n      var result = lodash.iteratee || iteratee;\n      result = result === iteratee ? baseIteratee : result;\n      return arguments.length ? result(arguments[0], arguments[1]) : result;\n    }\n\n    /**\n     * Gets the data for `map`.\n     *\n     * @private\n     * @param {Object} map The map to query.\n     * @param {string} key The reference key.\n     * @returns {*} Returns the map data.\n     */\n    function getMapData(map, key) {\n      var data = map.__data__;\n      return isKeyable(key)\n        ? data[typeof key == 'string' ? 'string' : 'hash']\n        : data.map;\n    }\n\n    /**\n     * Gets the property names, values, and compare flags of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the match data of `object`.\n     */\n    function getMatchData(object) {\n      var result = keys(object),\n          length = result.length;\n\n      while (length--) {\n        var key = result[length],\n            value = object[key];\n\n        result[length] = [key, value, isStrictComparable(value)];\n      }\n      return result;\n    }\n\n    /**\n     * Gets the native function at `key` of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {string} key The key of the method to get.\n     * @returns {*} Returns the function if it's native, else `undefined`.\n     */\n    function getNative(object, key) {\n      var value = getValue(object, key);\n      return baseIsNative(value) ? value : undefined;\n    }\n\n    /**\n     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n     *\n     * @private\n     * @param {*} value The value to query.\n     * @returns {string} Returns the raw `toStringTag`.\n     */\n    function getRawTag(value) {\n      var isOwn = hasOwnProperty.call(value, symToStringTag),\n          tag = value[symToStringTag];\n\n      try {\n        value[symToStringTag] = undefined;\n        var unmasked = true;\n      } catch (e) {}\n\n      var result = nativeObjectToString.call(value);\n      if (unmasked) {\n        if (isOwn) {\n          value[symToStringTag] = tag;\n        } else {\n          delete value[symToStringTag];\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Creates an array of the own enumerable symbols of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of symbols.\n     */\n    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {\n      if (object == null) {\n        return [];\n      }\n      object = Object(object);\n      return arrayFilter(nativeGetSymbols(object), function(symbol) {\n        return propertyIsEnumerable.call(object, symbol);\n      });\n    };\n\n    /**\n     * Creates an array of the own and inherited enumerable symbols of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of symbols.\n     */\n    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {\n      var result = [];\n      while (object) {\n        arrayPush(result, getSymbols(object));\n        object = getPrototype(object);\n      }\n      return result;\n    };\n\n    /**\n     * Gets the `toStringTag` of `value`.\n     *\n     * @private\n     * @param {*} value The value to query.\n     * @returns {string} Returns the `toStringTag`.\n     */\n    var getTag = baseGetTag;\n\n    // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\n    if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n        (Map && getTag(new Map) != mapTag) ||\n        (Promise && getTag(Promise.resolve()) != promiseTag) ||\n        (Set && getTag(new Set) != setTag) ||\n        (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n      getTag = function(value) {\n        var result = baseGetTag(value),\n            Ctor = result == objectTag ? value.constructor : undefined,\n            ctorString = Ctor ? toSource(Ctor) : '';\n\n        if (ctorString) {\n          switch (ctorString) {\n            case dataViewCtorString: return dataViewTag;\n            case mapCtorString: return mapTag;\n            case promiseCtorString: return promiseTag;\n            case setCtorString: return setTag;\n            case weakMapCtorString: return weakMapTag;\n          }\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Gets the view, applying any `transforms` to the `start` and `end` positions.\n     *\n     * @private\n     * @param {number} start The start of the view.\n     * @param {number} end The end of the view.\n     * @param {Array} transforms The transformations to apply to the view.\n     * @returns {Object} Returns an object containing the `start` and `end`\n     *  positions of the view.\n     */\n    function getView(start, end, transforms) {\n      var index = -1,\n          length = transforms.length;\n\n      while (++index < length) {\n        var data = transforms[index],\n            size = data.size;\n\n        switch (data.type) {\n          case 'drop':      start += size; break;\n          case 'dropRight': end -= size; break;\n          case 'take':      end = nativeMin(end, start + size); break;\n          case 'takeRight': start = nativeMax(start, end - size); break;\n        }\n      }\n      return { 'start': start, 'end': end };\n    }\n\n    /**\n     * Extracts wrapper details from the `source` body comment.\n     *\n     * @private\n     * @param {string} source The source to inspect.\n     * @returns {Array} Returns the wrapper details.\n     */\n    function getWrapDetails(source) {\n      var match = source.match(reWrapDetails);\n      return match ? match[1].split(reSplitDetails) : [];\n    }\n\n    /**\n     * Checks if `path` exists on `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path to check.\n     * @param {Function} hasFunc The function to check properties.\n     * @returns {boolean} Returns `true` if `path` exists, else `false`.\n     */\n    function hasPath(object, path, hasFunc) {\n      path = castPath(path, object);\n\n      var index = -1,\n          length = path.length,\n          result = false;\n\n      while (++index < length) {\n        var key = toKey(path[index]);\n        if (!(result = object != null && hasFunc(object, key))) {\n          break;\n        }\n        object = object[key];\n      }\n      if (result || ++index != length) {\n        return result;\n      }\n      length = object == null ? 0 : object.length;\n      return !!length && isLength(length) && isIndex(key, length) &&\n        (isArray(object) || isArguments(object));\n    }\n\n    /**\n     * Initializes an array clone.\n     *\n     * @private\n     * @param {Array} array The array to clone.\n     * @returns {Array} Returns the initialized clone.\n     */\n    function initCloneArray(array) {\n      var length = array.length,\n          result = new array.constructor(length);\n\n      // Add properties assigned by `RegExp#exec`.\n      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {\n        result.index = array.index;\n        result.input = array.input;\n      }\n      return result;\n    }\n\n    /**\n     * Initializes an object clone.\n     *\n     * @private\n     * @param {Object} object The object to clone.\n     * @returns {Object} Returns the initialized clone.\n     */\n    function initCloneObject(object) {\n      return (typeof object.constructor == 'function' && !isPrototype(object))\n        ? baseCreate(getPrototype(object))\n        : {};\n    }\n\n    /**\n     * Initializes an object clone based on its `toStringTag`.\n     *\n     * **Note:** This function only supports cloning values with tags of\n     * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.\n     *\n     * @private\n     * @param {Object} object The object to clone.\n     * @param {string} tag The `toStringTag` of the object to clone.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @returns {Object} Returns the initialized clone.\n     */\n    function initCloneByTag(object, tag, isDeep) {\n      var Ctor = object.constructor;\n      switch (tag) {\n        case arrayBufferTag:\n          return cloneArrayBuffer(object);\n\n        case boolTag:\n        case dateTag:\n          return new Ctor(+object);\n\n        case dataViewTag:\n          return cloneDataView(object, isDeep);\n\n        case float32Tag: case float64Tag:\n        case int8Tag: case int16Tag: case int32Tag:\n        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:\n          return cloneTypedArray(object, isDeep);\n\n        case mapTag:\n          return new Ctor;\n\n        case numberTag:\n        case stringTag:\n          return new Ctor(object);\n\n        case regexpTag:\n          return cloneRegExp(object);\n\n        case setTag:\n          return new Ctor;\n\n        case symbolTag:\n          return cloneSymbol(object);\n      }\n    }\n\n    /**\n     * Inserts wrapper `details` in a comment at the top of the `source` body.\n     *\n     * @private\n     * @param {string} source The source to modify.\n     * @returns {Array} details The details to insert.\n     * @returns {string} Returns the modified source.\n     */\n    function insertWrapDetails(source, details) {\n      var length = details.length;\n      if (!length) {\n        return source;\n      }\n      var lastIndex = length - 1;\n      details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];\n      details = details.join(length > 2 ? ', ' : ' ');\n      return source.replace(reWrapComment, '{\\n/* [wrapped with ' + details + '] */\\n');\n    }\n\n    /**\n     * Checks if `value` is a flattenable `arguments` object or array.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.\n     */\n    function isFlattenable(value) {\n      return isArray(value) || isArguments(value) ||\n        !!(spreadableSymbol && value && value[spreadableSymbol]);\n    }\n\n    /**\n     * Checks if `value` is a valid array-like index.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n     */\n    function isIndex(value, length) {\n      var type = typeof value;\n      length = length == null ? MAX_SAFE_INTEGER : length;\n\n      return !!length &&\n        (type == 'number' ||\n          (type != 'symbol' && reIsUint.test(value))) &&\n            (value > -1 && value % 1 == 0 && value < length);\n    }\n\n    /**\n     * Checks if the given arguments are from an iteratee call.\n     *\n     * @private\n     * @param {*} value The potential iteratee value argument.\n     * @param {*} index The potential iteratee index or key argument.\n     * @param {*} object The potential iteratee object argument.\n     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,\n     *  else `false`.\n     */\n    function isIterateeCall(value, index, object) {\n      if (!isObject(object)) {\n        return false;\n      }\n      var type = typeof index;\n      if (type == 'number'\n            ? (isArrayLike(object) && isIndex(index, object.length))\n            : (type == 'string' && index in object)\n          ) {\n        return eq(object[index], value);\n      }\n      return false;\n    }\n\n    /**\n     * Checks if `value` is a property name and not a property path.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @param {Object} [object] The object to query keys on.\n     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n     */\n    function isKey(value, object) {\n      if (isArray(value)) {\n        return false;\n      }\n      var type = typeof value;\n      if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n          value == null || isSymbol(value)) {\n        return true;\n      }\n      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n        (object != null && value in Object(object));\n    }\n\n    /**\n     * Checks if `value` is suitable for use as unique object key.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n     */\n    function isKeyable(value) {\n      var type = typeof value;\n      return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n        ? (value !== '__proto__')\n        : (value === null);\n    }\n\n    /**\n     * Checks if `func` has a lazy counterpart.\n     *\n     * @private\n     * @param {Function} func The function to check.\n     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,\n     *  else `false`.\n     */\n    function isLaziable(func) {\n      var funcName = getFuncName(func),\n          other = lodash[funcName];\n\n      if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {\n        return false;\n      }\n      if (func === other) {\n        return true;\n      }\n      var data = getData(other);\n      return !!data && func === data[0];\n    }\n\n    /**\n     * Checks if `func` has its source masked.\n     *\n     * @private\n     * @param {Function} func The function to check.\n     * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n     */\n    function isMasked(func) {\n      return !!maskSrcKey && (maskSrcKey in func);\n    }\n\n    /**\n     * Checks if `func` is capable of being masked.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `func` is maskable, else `false`.\n     */\n    var isMaskable = coreJsData ? isFunction : stubFalse;\n\n    /**\n     * Checks if `value` is likely a prototype object.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n     */\n    function isPrototype(value) {\n      var Ctor = value && value.constructor,\n          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n      return value === proto;\n    }\n\n    /**\n     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` if suitable for strict\n     *  equality comparisons, else `false`.\n     */\n    function isStrictComparable(value) {\n      return value === value && !isObject(value);\n    }\n\n    /**\n     * A specialized version of `matchesProperty` for source values suitable\n     * for strict equality comparisons, i.e. `===`.\n     *\n     * @private\n     * @param {string} key The key of the property to get.\n     * @param {*} srcValue The value to match.\n     * @returns {Function} Returns the new spec function.\n     */\n    function matchesStrictComparable(key, srcValue) {\n      return function(object) {\n        if (object == null) {\n          return false;\n        }\n        return object[key] === srcValue &&\n          (srcValue !== undefined || (key in Object(object)));\n      };\n    }\n\n    /**\n     * A specialized version of `_.memoize` which clears the memoized function's\n     * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n     *\n     * @private\n     * @param {Function} func The function to have its output memoized.\n     * @returns {Function} Returns the new memoized function.\n     */\n    function memoizeCapped(func) {\n      var result = memoize(func, function(key) {\n        if (cache.size === MAX_MEMOIZE_SIZE) {\n          cache.clear();\n        }\n        return key;\n      });\n\n      var cache = result.cache;\n      return result;\n    }\n\n    /**\n     * Merges the function metadata of `source` into `data`.\n     *\n     * Merging metadata reduces the number of wrappers used to invoke a function.\n     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`\n     * may be applied regardless of execution order. Methods like `_.ary` and\n     * `_.rearg` modify function arguments, making the order in which they are\n     * executed important, preventing the merging of metadata. However, we make\n     * an exception for a safe combined case where curried functions have `_.ary`\n     * and or `_.rearg` applied.\n     *\n     * @private\n     * @param {Array} data The destination metadata.\n     * @param {Array} source The source metadata.\n     * @returns {Array} Returns `data`.\n     */\n    function mergeData(data, source) {\n      var bitmask = data[1],\n          srcBitmask = source[1],\n          newBitmask = bitmask | srcBitmask,\n          isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);\n\n      var isCombo =\n        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_CURRY_FLAG)) ||\n        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_REARG_FLAG) && (data[7].length <= source[8])) ||\n        ((srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == WRAP_CURRY_FLAG));\n\n      // Exit early if metadata can't be merged.\n      if (!(isCommon || isCombo)) {\n        return data;\n      }\n      // Use source `thisArg` if available.\n      if (srcBitmask & WRAP_BIND_FLAG) {\n        data[2] = source[2];\n        // Set when currying a bound function.\n        newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;\n      }\n      // Compose partial arguments.\n      var value = source[3];\n      if (value) {\n        var partials = data[3];\n        data[3] = partials ? composeArgs(partials, value, source[4]) : value;\n        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];\n      }\n      // Compose partial right arguments.\n      value = source[5];\n      if (value) {\n        partials = data[5];\n        data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;\n        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];\n      }\n      // Use source `argPos` if available.\n      value = source[7];\n      if (value) {\n        data[7] = value;\n      }\n      // Use source `ary` if it's smaller.\n      if (srcBitmask & WRAP_ARY_FLAG) {\n        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);\n      }\n      // Use source `arity` if one is not provided.\n      if (data[9] == null) {\n        data[9] = source[9];\n      }\n      // Use source `func` and merge bitmasks.\n      data[0] = source[0];\n      data[1] = newBitmask;\n\n      return data;\n    }\n\n    /**\n     * This function is like\n     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n     * except that it includes inherited enumerable properties.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     */\n    function nativeKeysIn(object) {\n      var result = [];\n      if (object != null) {\n        for (var key in Object(object)) {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Converts `value` to a string using `Object.prototype.toString`.\n     *\n     * @private\n     * @param {*} value The value to convert.\n     * @returns {string} Returns the converted string.\n     */\n    function objectToString(value) {\n      return nativeObjectToString.call(value);\n    }\n\n    /**\n     * A specialized version of `baseRest` which transforms the rest array.\n     *\n     * @private\n     * @param {Function} func The function to apply a rest parameter to.\n     * @param {number} [start=func.length-1] The start position of the rest parameter.\n     * @param {Function} transform The rest array transform.\n     * @returns {Function} Returns the new function.\n     */\n    function overRest(func, start, transform) {\n      start = nativeMax(start === undefined ? (func.length - 1) : start, 0);\n      return function() {\n        var args = arguments,\n            index = -1,\n            length = nativeMax(args.length - start, 0),\n            array = Array(length);\n\n        while (++index < length) {\n          array[index] = args[start + index];\n        }\n        index = -1;\n        var otherArgs = Array(start + 1);\n        while (++index < start) {\n          otherArgs[index] = args[index];\n        }\n        otherArgs[start] = transform(array);\n        return apply(func, this, otherArgs);\n      };\n    }\n\n    /**\n     * Gets the parent value at `path` of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array} path The path to get the parent value of.\n     * @returns {*} Returns the parent value.\n     */\n    function parent(object, path) {\n      return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));\n    }\n\n    /**\n     * Reorder `array` according to the specified indexes where the element at\n     * the first index is assigned as the first element, the element at\n     * the second index is assigned as the second element, and so on.\n     *\n     * @private\n     * @param {Array} array The array to reorder.\n     * @param {Array} indexes The arranged array indexes.\n     * @returns {Array} Returns `array`.\n     */\n    function reorder(array, indexes) {\n      var arrLength = array.length,\n          length = nativeMin(indexes.length, arrLength),\n          oldArray = copyArray(array);\n\n      while (length--) {\n        var index = indexes[length];\n        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;\n      }\n      return array;\n    }\n\n    /**\n     * Gets the value at `key`, unless `key` is \"__proto__\" or \"constructor\".\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {string} key The key of the property to get.\n     * @returns {*} Returns the property value.\n     */\n    function safeGet(object, key) {\n      if (key === 'constructor' && typeof object[key] === 'function') {\n        return;\n      }\n\n      if (key == '__proto__') {\n        return;\n      }\n\n      return object[key];\n    }\n\n    /**\n     * Sets metadata for `func`.\n     *\n     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short\n     * period of time, it will trip its breaker and transition to an identity\n     * function to avoid garbage collection pauses in V8. See\n     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)\n     * for more details.\n     *\n     * @private\n     * @param {Function} func The function to associate metadata with.\n     * @param {*} data The metadata.\n     * @returns {Function} Returns `func`.\n     */\n    var setData = shortOut(baseSetData);\n\n    /**\n     * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).\n     *\n     * @private\n     * @param {Function} func The function to delay.\n     * @param {number} wait The number of milliseconds to delay invocation.\n     * @returns {number|Object} Returns the timer id or timeout object.\n     */\n    var setTimeout = ctxSetTimeout || function(func, wait) {\n      return root.setTimeout(func, wait);\n    };\n\n    /**\n     * Sets the `toString` method of `func` to return `string`.\n     *\n     * @private\n     * @param {Function} func The function to modify.\n     * @param {Function} string The `toString` result.\n     * @returns {Function} Returns `func`.\n     */\n    var setToString = shortOut(baseSetToString);\n\n    /**\n     * Sets the `toString` method of `wrapper` to mimic the source of `reference`\n     * with wrapper details in a comment at the top of the source body.\n     *\n     * @private\n     * @param {Function} wrapper The function to modify.\n     * @param {Function} reference The reference function.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @returns {Function} Returns `wrapper`.\n     */\n    function setWrapToString(wrapper, reference, bitmask) {\n      var source = (reference + '');\n      return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));\n    }\n\n    /**\n     * Creates a function that'll short out and invoke `identity` instead\n     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`\n     * milliseconds.\n     *\n     * @private\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new shortable function.\n     */\n    function shortOut(func) {\n      var count = 0,\n          lastCalled = 0;\n\n      return function() {\n        var stamp = nativeNow(),\n            remaining = HOT_SPAN - (stamp - lastCalled);\n\n        lastCalled = stamp;\n        if (remaining > 0) {\n          if (++count >= HOT_COUNT) {\n            return arguments[0];\n          }\n        } else {\n          count = 0;\n        }\n        return func.apply(undefined, arguments);\n      };\n    }\n\n    /**\n     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.\n     *\n     * @private\n     * @param {Array} array The array to shuffle.\n     * @param {number} [size=array.length] The size of `array`.\n     * @returns {Array} Returns `array`.\n     */\n    function shuffleSelf(array, size) {\n      var index = -1,\n          length = array.length,\n          lastIndex = length - 1;\n\n      size = size === undefined ? length : size;\n      while (++index < size) {\n        var rand = baseRandom(index, lastIndex),\n            value = array[rand];\n\n        array[rand] = array[index];\n        array[index] = value;\n      }\n      array.length = size;\n      return array;\n    }\n\n    /**\n     * Converts `string` to a property path array.\n     *\n     * @private\n     * @param {string} string The string to convert.\n     * @returns {Array} Returns the property path array.\n     */\n    var stringToPath = memoizeCapped(function(string) {\n      var result = [];\n      if (string.charCodeAt(0) === 46 /* . */) {\n        result.push('');\n      }\n      string.replace(rePropName, function(match, number, quote, subString) {\n        result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));\n      });\n      return result;\n    });\n\n    /**\n     * Converts `value` to a string key if it's not a string or symbol.\n     *\n     * @private\n     * @param {*} value The value to inspect.\n     * @returns {string|symbol} Returns the key.\n     */\n    function toKey(value) {\n      if (typeof value == 'string' || isSymbol(value)) {\n        return value;\n      }\n      var result = (value + '');\n      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n    }\n\n    /**\n     * Converts `func` to its source code.\n     *\n     * @private\n     * @param {Function} func The function to convert.\n     * @returns {string} Returns the source code.\n     */\n    function toSource(func) {\n      if (func != null) {\n        try {\n          return funcToString.call(func);\n        } catch (e) {}\n        try {\n          return (func + '');\n        } catch (e) {}\n      }\n      return '';\n    }\n\n    /**\n     * Updates wrapper `details` based on `bitmask` flags.\n     *\n     * @private\n     * @returns {Array} details The details to modify.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @returns {Array} Returns `details`.\n     */\n    function updateWrapDetails(details, bitmask) {\n      arrayEach(wrapFlags, function(pair) {\n        var value = '_.' + pair[0];\n        if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {\n          details.push(value);\n        }\n      });\n      return details.sort();\n    }\n\n    /**\n     * Creates a clone of `wrapper`.\n     *\n     * @private\n     * @param {Object} wrapper The wrapper to clone.\n     * @returns {Object} Returns the cloned wrapper.\n     */\n    function wrapperClone(wrapper) {\n      if (wrapper instanceof LazyWrapper) {\n        return wrapper.clone();\n      }\n      var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);\n      result.__actions__ = copyArray(wrapper.__actions__);\n      result.__index__  = wrapper.__index__;\n      result.__values__ = wrapper.__values__;\n      return result;\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates an array of elements split into groups the length of `size`.\n     * If `array` can't be split evenly, the final chunk will be the remaining\n     * elements.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to process.\n     * @param {number} [size=1] The length of each chunk\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the new array of chunks.\n     * @example\n     *\n     * _.chunk(['a', 'b', 'c', 'd'], 2);\n     * // => [['a', 'b'], ['c', 'd']]\n     *\n     * _.chunk(['a', 'b', 'c', 'd'], 3);\n     * // => [['a', 'b', 'c'], ['d']]\n     */\n    function chunk(array, size, guard) {\n      if ((guard ? isIterateeCall(array, size, guard) : size === undefined)) {\n        size = 1;\n      } else {\n        size = nativeMax(toInteger(size), 0);\n      }\n      var length = array == null ? 0 : array.length;\n      if (!length || size < 1) {\n        return [];\n      }\n      var index = 0,\n          resIndex = 0,\n          result = Array(nativeCeil(length / size));\n\n      while (index < length) {\n        result[resIndex++] = baseSlice(array, index, (index += size));\n      }\n      return result;\n    }\n\n    /**\n     * Creates an array with all falsey values removed. The values `false`, `null`,\n     * `0`, `\"\"`, `undefined`, and `NaN` are falsey.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to compact.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * _.compact([0, 1, false, 2, '', 3]);\n     * // => [1, 2, 3]\n     */\n    function compact(array) {\n      var index = -1,\n          length = array == null ? 0 : array.length,\n          resIndex = 0,\n          result = [];\n\n      while (++index < length) {\n        var value = array[index];\n        if (value) {\n          result[resIndex++] = value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Creates a new array concatenating `array` with any additional arrays\n     * and/or values.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to concatenate.\n     * @param {...*} [values] The values to concatenate.\n     * @returns {Array} Returns the new concatenated array.\n     * @example\n     *\n     * var array = [1];\n     * var other = _.concat(array, 2, [3], [[4]]);\n     *\n     * console.log(other);\n     * // => [1, 2, 3, [4]]\n     *\n     * console.log(array);\n     * // => [1]\n     */\n    function concat() {\n      var length = arguments.length;\n      if (!length) {\n        return [];\n      }\n      var args = Array(length - 1),\n          array = arguments[0],\n          index = length;\n\n      while (index--) {\n        args[index - 1] = arguments[index];\n      }\n      return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));\n    }\n\n    /**\n     * Creates an array of `array` values not included in the other given arrays\n     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons. The order and references of result values are\n     * determined by the first array.\n     *\n     * **Note:** Unlike `_.pullAll`, this method returns a new array.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {...Array} [values] The values to exclude.\n     * @returns {Array} Returns the new array of filtered values.\n     * @see _.without, _.xor\n     * @example\n     *\n     * _.difference([2, 1], [2, 3]);\n     * // => [1]\n     */\n    var difference = baseRest(function(array, values) {\n      return isArrayLikeObject(array)\n        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))\n        : [];\n    });\n\n    /**\n     * This method is like `_.difference` except that it accepts `iteratee` which\n     * is invoked for each element of `array` and `values` to generate the criterion\n     * by which they're compared. The order and references of result values are\n     * determined by the first array. The iteratee is invoked with one argument:\n     * (value).\n     *\n     * **Note:** Unlike `_.pullAllBy`, this method returns a new array.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {...Array} [values] The values to exclude.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);\n     * // => [1.2]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');\n     * // => [{ 'x': 2 }]\n     */\n    var differenceBy = baseRest(function(array, values) {\n      var iteratee = last(values);\n      if (isArrayLikeObject(iteratee)) {\n        iteratee = undefined;\n      }\n      return isArrayLikeObject(array)\n        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2))\n        : [];\n    });\n\n    /**\n     * This method is like `_.difference` except that it accepts `comparator`\n     * which is invoked to compare elements of `array` to `values`. The order and\n     * references of result values are determined by the first array. The comparator\n     * is invoked with two arguments: (arrVal, othVal).\n     *\n     * **Note:** Unlike `_.pullAllWith`, this method returns a new array.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {...Array} [values] The values to exclude.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n     *\n     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);\n     * // => [{ 'x': 2, 'y': 1 }]\n     */\n    var differenceWith = baseRest(function(array, values) {\n      var comparator = last(values);\n      if (isArrayLikeObject(comparator)) {\n        comparator = undefined;\n      }\n      return isArrayLikeObject(array)\n        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator)\n        : [];\n    });\n\n    /**\n     * Creates a slice of `array` with `n` elements dropped from the beginning.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.5.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to drop.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.drop([1, 2, 3]);\n     * // => [2, 3]\n     *\n     * _.drop([1, 2, 3], 2);\n     * // => [3]\n     *\n     * _.drop([1, 2, 3], 5);\n     * // => []\n     *\n     * _.drop([1, 2, 3], 0);\n     * // => [1, 2, 3]\n     */\n    function drop(array, n, guard) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      n = (guard || n === undefined) ? 1 : toInteger(n);\n      return baseSlice(array, n < 0 ? 0 : n, length);\n    }\n\n    /**\n     * Creates a slice of `array` with `n` elements dropped from the end.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to drop.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.dropRight([1, 2, 3]);\n     * // => [1, 2]\n     *\n     * _.dropRight([1, 2, 3], 2);\n     * // => [1]\n     *\n     * _.dropRight([1, 2, 3], 5);\n     * // => []\n     *\n     * _.dropRight([1, 2, 3], 0);\n     * // => [1, 2, 3]\n     */\n    function dropRight(array, n, guard) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      n = (guard || n === undefined) ? 1 : toInteger(n);\n      n = length - n;\n      return baseSlice(array, 0, n < 0 ? 0 : n);\n    }\n\n    /**\n     * Creates a slice of `array` excluding elements dropped from the end.\n     * Elements are dropped until `predicate` returns falsey. The predicate is\n     * invoked with three arguments: (value, index, array).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': true },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': false }\n     * ];\n     *\n     * _.dropRightWhile(users, function(o) { return !o.active; });\n     * // => objects for ['barney']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });\n     * // => objects for ['barney', 'fred']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.dropRightWhile(users, ['active', false]);\n     * // => objects for ['barney']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.dropRightWhile(users, 'active');\n     * // => objects for ['barney', 'fred', 'pebbles']\n     */\n    function dropRightWhile(array, predicate) {\n      return (array && array.length)\n        ? baseWhile(array, getIteratee(predicate, 3), true, true)\n        : [];\n    }\n\n    /**\n     * Creates a slice of `array` excluding elements dropped from the beginning.\n     * Elements are dropped until `predicate` returns falsey. The predicate is\n     * invoked with three arguments: (value, index, array).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': false },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': true }\n     * ];\n     *\n     * _.dropWhile(users, function(o) { return !o.active; });\n     * // => objects for ['pebbles']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.dropWhile(users, { 'user': 'barney', 'active': false });\n     * // => objects for ['fred', 'pebbles']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.dropWhile(users, ['active', false]);\n     * // => objects for ['pebbles']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.dropWhile(users, 'active');\n     * // => objects for ['barney', 'fred', 'pebbles']\n     */\n    function dropWhile(array, predicate) {\n      return (array && array.length)\n        ? baseWhile(array, getIteratee(predicate, 3), true)\n        : [];\n    }\n\n    /**\n     * Fills elements of `array` with `value` from `start` up to, but not\n     * including, `end`.\n     *\n     * **Note:** This method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.2.0\n     * @category Array\n     * @param {Array} array The array to fill.\n     * @param {*} value The value to fill `array` with.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [1, 2, 3];\n     *\n     * _.fill(array, 'a');\n     * console.log(array);\n     * // => ['a', 'a', 'a']\n     *\n     * _.fill(Array(3), 2);\n     * // => [2, 2, 2]\n     *\n     * _.fill([4, 6, 8, 10], '*', 1, 3);\n     * // => [4, '*', '*', 10]\n     */\n    function fill(array, value, start, end) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {\n        start = 0;\n        end = length;\n      }\n      return baseFill(array, value, start, end);\n    }\n\n    /**\n     * This method is like `_.find` except that it returns the index of the first\n     * element `predicate` returns truthy for instead of the element itself.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param {number} [fromIndex=0] The index to search from.\n     * @returns {number} Returns the index of the found element, else `-1`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': false },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': true }\n     * ];\n     *\n     * _.findIndex(users, function(o) { return o.user == 'barney'; });\n     * // => 0\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.findIndex(users, { 'user': 'fred', 'active': false });\n     * // => 1\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.findIndex(users, ['active', false]);\n     * // => 0\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.findIndex(users, 'active');\n     * // => 2\n     */\n    function findIndex(array, predicate, fromIndex) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return -1;\n      }\n      var index = fromIndex == null ? 0 : toInteger(fromIndex);\n      if (index < 0) {\n        index = nativeMax(length + index, 0);\n      }\n      return baseFindIndex(array, getIteratee(predicate, 3), index);\n    }\n\n    /**\n     * This method is like `_.findIndex` except that it iterates over elements\n     * of `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param {number} [fromIndex=array.length-1] The index to search from.\n     * @returns {number} Returns the index of the found element, else `-1`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': true },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': false }\n     * ];\n     *\n     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });\n     * // => 2\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.findLastIndex(users, { 'user': 'barney', 'active': true });\n     * // => 0\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.findLastIndex(users, ['active', false]);\n     * // => 2\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.findLastIndex(users, 'active');\n     * // => 0\n     */\n    function findLastIndex(array, predicate, fromIndex) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return -1;\n      }\n      var index = length - 1;\n      if (fromIndex !== undefined) {\n        index = toInteger(fromIndex);\n        index = fromIndex < 0\n          ? nativeMax(length + index, 0)\n          : nativeMin(index, length - 1);\n      }\n      return baseFindIndex(array, getIteratee(predicate, 3), index, true);\n    }\n\n    /**\n     * Flattens `array` a single level deep.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to flatten.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * _.flatten([1, [2, [3, [4]], 5]]);\n     * // => [1, 2, [3, [4]], 5]\n     */\n    function flatten(array) {\n      var length = array == null ? 0 : array.length;\n      return length ? baseFlatten(array, 1) : [];\n    }\n\n    /**\n     * Recursively flattens `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to flatten.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * _.flattenDeep([1, [2, [3, [4]], 5]]);\n     * // => [1, 2, 3, 4, 5]\n     */\n    function flattenDeep(array) {\n      var length = array == null ? 0 : array.length;\n      return length ? baseFlatten(array, INFINITY) : [];\n    }\n\n    /**\n     * Recursively flatten `array` up to `depth` times.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.4.0\n     * @category Array\n     * @param {Array} array The array to flatten.\n     * @param {number} [depth=1] The maximum recursion depth.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * var array = [1, [2, [3, [4]], 5]];\n     *\n     * _.flattenDepth(array, 1);\n     * // => [1, 2, [3, [4]], 5]\n     *\n     * _.flattenDepth(array, 2);\n     * // => [1, 2, 3, [4], 5]\n     */\n    function flattenDepth(array, depth) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      depth = depth === undefined ? 1 : toInteger(depth);\n      return baseFlatten(array, depth);\n    }\n\n    /**\n     * The inverse of `_.toPairs`; this method returns an object composed\n     * from key-value `pairs`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} pairs The key-value pairs.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * _.fromPairs([['a', 1], ['b', 2]]);\n     * // => { 'a': 1, 'b': 2 }\n     */\n    function fromPairs(pairs) {\n      var index = -1,\n          length = pairs == null ? 0 : pairs.length,\n          result = {};\n\n      while (++index < length) {\n        var pair = pairs[index];\n        result[pair[0]] = pair[1];\n      }\n      return result;\n    }\n\n    /**\n     * Gets the first element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @alias first\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {*} Returns the first element of `array`.\n     * @example\n     *\n     * _.head([1, 2, 3]);\n     * // => 1\n     *\n     * _.head([]);\n     * // => undefined\n     */\n    function head(array) {\n      return (array && array.length) ? array[0] : undefined;\n    }\n\n    /**\n     * Gets the index at which the first occurrence of `value` is found in `array`\n     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons. If `fromIndex` is negative, it's used as the\n     * offset from the end of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {*} value The value to search for.\n     * @param {number} [fromIndex=0] The index to search from.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     * @example\n     *\n     * _.indexOf([1, 2, 1, 2], 2);\n     * // => 1\n     *\n     * // Search from the `fromIndex`.\n     * _.indexOf([1, 2, 1, 2], 2, 2);\n     * // => 3\n     */\n    function indexOf(array, value, fromIndex) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return -1;\n      }\n      var index = fromIndex == null ? 0 : toInteger(fromIndex);\n      if (index < 0) {\n        index = nativeMax(length + index, 0);\n      }\n      return baseIndexOf(array, value, index);\n    }\n\n    /**\n     * Gets all but the last element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.initial([1, 2, 3]);\n     * // => [1, 2]\n     */\n    function initial(array) {\n      var length = array == null ? 0 : array.length;\n      return length ? baseSlice(array, 0, -1) : [];\n    }\n\n    /**\n     * Creates an array of unique values that are included in all given arrays\n     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons. The order and references of result values are\n     * determined by the first array.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @returns {Array} Returns the new array of intersecting values.\n     * @example\n     *\n     * _.intersection([2, 1], [2, 3]);\n     * // => [2]\n     */\n    var intersection = baseRest(function(arrays) {\n      var mapped = arrayMap(arrays, castArrayLikeObject);\n      return (mapped.length && mapped[0] === arrays[0])\n        ? baseIntersection(mapped)\n        : [];\n    });\n\n    /**\n     * This method is like `_.intersection` except that it accepts `iteratee`\n     * which is invoked for each element of each `arrays` to generate the criterion\n     * by which they're compared. The order and references of result values are\n     * determined by the first array. The iteratee is invoked with one argument:\n     * (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new array of intersecting values.\n     * @example\n     *\n     * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);\n     * // => [2.1]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\n     * // => [{ 'x': 1 }]\n     */\n    var intersectionBy = baseRest(function(arrays) {\n      var iteratee = last(arrays),\n          mapped = arrayMap(arrays, castArrayLikeObject);\n\n      if (iteratee === last(mapped)) {\n        iteratee = undefined;\n      } else {\n        mapped.pop();\n      }\n      return (mapped.length && mapped[0] === arrays[0])\n        ? baseIntersection(mapped, getIteratee(iteratee, 2))\n        : [];\n    });\n\n    /**\n     * This method is like `_.intersection` except that it accepts `comparator`\n     * which is invoked to compare elements of `arrays`. The order and references\n     * of result values are determined by the first array. The comparator is\n     * invoked with two arguments: (arrVal, othVal).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of intersecting values.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\n     *\n     * _.intersectionWith(objects, others, _.isEqual);\n     * // => [{ 'x': 1, 'y': 2 }]\n     */\n    var intersectionWith = baseRest(function(arrays) {\n      var comparator = last(arrays),\n          mapped = arrayMap(arrays, castArrayLikeObject);\n\n      comparator = typeof comparator == 'function' ? comparator : undefined;\n      if (comparator) {\n        mapped.pop();\n      }\n      return (mapped.length && mapped[0] === arrays[0])\n        ? baseIntersection(mapped, undefined, comparator)\n        : [];\n    });\n\n    /**\n     * Converts all elements in `array` into a string separated by `separator`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to convert.\n     * @param {string} [separator=','] The element separator.\n     * @returns {string} Returns the joined string.\n     * @example\n     *\n     * _.join(['a', 'b', 'c'], '~');\n     * // => 'a~b~c'\n     */\n    function join(array, separator) {\n      return array == null ? '' : nativeJoin.call(array, separator);\n    }\n\n    /**\n     * Gets the last element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {*} Returns the last element of `array`.\n     * @example\n     *\n     * _.last([1, 2, 3]);\n     * // => 3\n     */\n    function last(array) {\n      var length = array == null ? 0 : array.length;\n      return length ? array[length - 1] : undefined;\n    }\n\n    /**\n     * This method is like `_.indexOf` except that it iterates over elements of\n     * `array` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {*} value The value to search for.\n     * @param {number} [fromIndex=array.length-1] The index to search from.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     * @example\n     *\n     * _.lastIndexOf([1, 2, 1, 2], 2);\n     * // => 3\n     *\n     * // Search from the `fromIndex`.\n     * _.lastIndexOf([1, 2, 1, 2], 2, 2);\n     * // => 1\n     */\n    function lastIndexOf(array, value, fromIndex) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return -1;\n      }\n      var index = length;\n      if (fromIndex !== undefined) {\n        index = toInteger(fromIndex);\n        index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);\n      }\n      return value === value\n        ? strictLastIndexOf(array, value, index)\n        : baseFindIndex(array, baseIsNaN, index, true);\n    }\n\n    /**\n     * Gets the element at index `n` of `array`. If `n` is negative, the nth\n     * element from the end is returned.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.11.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=0] The index of the element to return.\n     * @returns {*} Returns the nth element of `array`.\n     * @example\n     *\n     * var array = ['a', 'b', 'c', 'd'];\n     *\n     * _.nth(array, 1);\n     * // => 'b'\n     *\n     * _.nth(array, -2);\n     * // => 'c';\n     */\n    function nth(array, n) {\n      return (array && array.length) ? baseNth(array, toInteger(n)) : undefined;\n    }\n\n    /**\n     * Removes all given values from `array` using\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons.\n     *\n     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`\n     * to remove elements from an array by predicate.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {...*} [values] The values to remove.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];\n     *\n     * _.pull(array, 'a', 'c');\n     * console.log(array);\n     * // => ['b', 'b']\n     */\n    var pull = baseRest(pullAll);\n\n    /**\n     * This method is like `_.pull` except that it accepts an array of values to remove.\n     *\n     * **Note:** Unlike `_.difference`, this method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {Array} values The values to remove.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];\n     *\n     * _.pullAll(array, ['a', 'c']);\n     * console.log(array);\n     * // => ['b', 'b']\n     */\n    function pullAll(array, values) {\n      return (array && array.length && values && values.length)\n        ? basePullAll(array, values)\n        : array;\n    }\n\n    /**\n     * This method is like `_.pullAll` except that it accepts `iteratee` which is\n     * invoked for each element of `array` and `values` to generate the criterion\n     * by which they're compared. The iteratee is invoked with one argument: (value).\n     *\n     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {Array} values The values to remove.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];\n     *\n     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');\n     * console.log(array);\n     * // => [{ 'x': 2 }]\n     */\n    function pullAllBy(array, values, iteratee) {\n      return (array && array.length && values && values.length)\n        ? basePullAll(array, values, getIteratee(iteratee, 2))\n        : array;\n    }\n\n    /**\n     * This method is like `_.pullAll` except that it accepts `comparator` which\n     * is invoked to compare elements of `array` to `values`. The comparator is\n     * invoked with two arguments: (arrVal, othVal).\n     *\n     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.6.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {Array} values The values to remove.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];\n     *\n     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);\n     * console.log(array);\n     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]\n     */\n    function pullAllWith(array, values, comparator) {\n      return (array && array.length && values && values.length)\n        ? basePullAll(array, values, undefined, comparator)\n        : array;\n    }\n\n    /**\n     * Removes elements from `array` corresponding to `indexes` and returns an\n     * array of removed elements.\n     *\n     * **Note:** Unlike `_.at`, this method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {...(number|number[])} [indexes] The indexes of elements to remove.\n     * @returns {Array} Returns the new array of removed elements.\n     * @example\n     *\n     * var array = ['a', 'b', 'c', 'd'];\n     * var pulled = _.pullAt(array, [1, 3]);\n     *\n     * console.log(array);\n     * // => ['a', 'c']\n     *\n     * console.log(pulled);\n     * // => ['b', 'd']\n     */\n    var pullAt = flatRest(function(array, indexes) {\n      var length = array == null ? 0 : array.length,\n          result = baseAt(array, indexes);\n\n      basePullAt(array, arrayMap(indexes, function(index) {\n        return isIndex(index, length) ? +index : index;\n      }).sort(compareAscending));\n\n      return result;\n    });\n\n    /**\n     * Removes all elements from `array` that `predicate` returns truthy for\n     * and returns an array of the removed elements. The predicate is invoked\n     * with three arguments: (value, index, array).\n     *\n     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`\n     * to pull elements from an array by value.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new array of removed elements.\n     * @example\n     *\n     * var array = [1, 2, 3, 4];\n     * var evens = _.remove(array, function(n) {\n     *   return n % 2 == 0;\n     * });\n     *\n     * console.log(array);\n     * // => [1, 3]\n     *\n     * console.log(evens);\n     * // => [2, 4]\n     */\n    function remove(array, predicate) {\n      var result = [];\n      if (!(array && array.length)) {\n        return result;\n      }\n      var index = -1,\n          indexes = [],\n          length = array.length;\n\n      predicate = getIteratee(predicate, 3);\n      while (++index < length) {\n        var value = array[index];\n        if (predicate(value, index, array)) {\n          result.push(value);\n          indexes.push(index);\n        }\n      }\n      basePullAt(array, indexes);\n      return result;\n    }\n\n    /**\n     * Reverses `array` so that the first element becomes the last, the second\n     * element becomes the second to last, and so on.\n     *\n     * **Note:** This method mutates `array` and is based on\n     * [`Array#reverse`](https://mdn.io/Array/reverse).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [1, 2, 3];\n     *\n     * _.reverse(array);\n     * // => [3, 2, 1]\n     *\n     * console.log(array);\n     * // => [3, 2, 1]\n     */\n    function reverse(array) {\n      return array == null ? array : nativeReverse.call(array);\n    }\n\n    /**\n     * Creates a slice of `array` from `start` up to, but not including, `end`.\n     *\n     * **Note:** This method is used instead of\n     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are\n     * returned.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to slice.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns the slice of `array`.\n     */\n    function slice(array, start, end) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {\n        start = 0;\n        end = length;\n      }\n      else {\n        start = start == null ? 0 : toInteger(start);\n        end = end === undefined ? length : toInteger(end);\n      }\n      return baseSlice(array, start, end);\n    }\n\n    /**\n     * Uses a binary search to determine the lowest index at which `value`\n     * should be inserted into `array` in order to maintain its sort order.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     * @example\n     *\n     * _.sortedIndex([30, 50], 40);\n     * // => 1\n     */\n    function sortedIndex(array, value) {\n      return baseSortedIndex(array, value);\n    }\n\n    /**\n     * This method is like `_.sortedIndex` except that it accepts `iteratee`\n     * which is invoked for `value` and each element of `array` to compute their\n     * sort ranking. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     * @example\n     *\n     * var objects = [{ 'x': 4 }, { 'x': 5 }];\n     *\n     * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });\n     * // => 0\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.sortedIndexBy(objects, { 'x': 4 }, 'x');\n     * // => 0\n     */\n    function sortedIndexBy(array, value, iteratee) {\n      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));\n    }\n\n    /**\n     * This method is like `_.indexOf` except that it performs a binary\n     * search on a sorted `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {*} value The value to search for.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     * @example\n     *\n     * _.sortedIndexOf([4, 5, 5, 5, 6], 5);\n     * // => 1\n     */\n    function sortedIndexOf(array, value) {\n      var length = array == null ? 0 : array.length;\n      if (length) {\n        var index = baseSortedIndex(array, value);\n        if (index < length && eq(array[index], value)) {\n          return index;\n        }\n      }\n      return -1;\n    }\n\n    /**\n     * This method is like `_.sortedIndex` except that it returns the highest\n     * index at which `value` should be inserted into `array` in order to\n     * maintain its sort order.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     * @example\n     *\n     * _.sortedLastIndex([4, 5, 5, 5, 6], 5);\n     * // => 4\n     */\n    function sortedLastIndex(array, value) {\n      return baseSortedIndex(array, value, true);\n    }\n\n    /**\n     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`\n     * which is invoked for `value` and each element of `array` to compute their\n     * sort ranking. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     * @example\n     *\n     * var objects = [{ 'x': 4 }, { 'x': 5 }];\n     *\n     * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });\n     * // => 1\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');\n     * // => 1\n     */\n    function sortedLastIndexBy(array, value, iteratee) {\n      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);\n    }\n\n    /**\n     * This method is like `_.lastIndexOf` except that it performs a binary\n     * search on a sorted `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {*} value The value to search for.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     * @example\n     *\n     * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);\n     * // => 3\n     */\n    function sortedLastIndexOf(array, value) {\n      var length = array == null ? 0 : array.length;\n      if (length) {\n        var index = baseSortedIndex(array, value, true) - 1;\n        if (eq(array[index], value)) {\n          return index;\n        }\n      }\n      return -1;\n    }\n\n    /**\n     * This method is like `_.uniq` except that it's designed and optimized\n     * for sorted arrays.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * _.sortedUniq([1, 1, 2]);\n     * // => [1, 2]\n     */\n    function sortedUniq(array) {\n      return (array && array.length)\n        ? baseSortedUniq(array)\n        : [];\n    }\n\n    /**\n     * This method is like `_.uniqBy` except that it's designed and optimized\n     * for sorted arrays.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);\n     * // => [1.1, 2.3]\n     */\n    function sortedUniqBy(array, iteratee) {\n      return (array && array.length)\n        ? baseSortedUniq(array, getIteratee(iteratee, 2))\n        : [];\n    }\n\n    /**\n     * Gets all but the first element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.tail([1, 2, 3]);\n     * // => [2, 3]\n     */\n    function tail(array) {\n      var length = array == null ? 0 : array.length;\n      return length ? baseSlice(array, 1, length) : [];\n    }\n\n    /**\n     * Creates a slice of `array` with `n` elements taken from the beginning.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to take.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.take([1, 2, 3]);\n     * // => [1]\n     *\n     * _.take([1, 2, 3], 2);\n     * // => [1, 2]\n     *\n     * _.take([1, 2, 3], 5);\n     * // => [1, 2, 3]\n     *\n     * _.take([1, 2, 3], 0);\n     * // => []\n     */\n    function take(array, n, guard) {\n      if (!(array && array.length)) {\n        return [];\n      }\n      n = (guard || n === undefined) ? 1 : toInteger(n);\n      return baseSlice(array, 0, n < 0 ? 0 : n);\n    }\n\n    /**\n     * Creates a slice of `array` with `n` elements taken from the end.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to take.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.takeRight([1, 2, 3]);\n     * // => [3]\n     *\n     * _.takeRight([1, 2, 3], 2);\n     * // => [2, 3]\n     *\n     * _.takeRight([1, 2, 3], 5);\n     * // => [1, 2, 3]\n     *\n     * _.takeRight([1, 2, 3], 0);\n     * // => []\n     */\n    function takeRight(array, n, guard) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      n = (guard || n === undefined) ? 1 : toInteger(n);\n      n = length - n;\n      return baseSlice(array, n < 0 ? 0 : n, length);\n    }\n\n    /**\n     * Creates a slice of `array` with elements taken from the end. Elements are\n     * taken until `predicate` returns falsey. The predicate is invoked with\n     * three arguments: (value, index, array).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': true },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': false }\n     * ];\n     *\n     * _.takeRightWhile(users, function(o) { return !o.active; });\n     * // => objects for ['fred', 'pebbles']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });\n     * // => objects for ['pebbles']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.takeRightWhile(users, ['active', false]);\n     * // => objects for ['fred', 'pebbles']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.takeRightWhile(users, 'active');\n     * // => []\n     */\n    function takeRightWhile(array, predicate) {\n      return (array && array.length)\n        ? baseWhile(array, getIteratee(predicate, 3), false, true)\n        : [];\n    }\n\n    /**\n     * Creates a slice of `array` with elements taken from the beginning. Elements\n     * are taken until `predicate` returns falsey. The predicate is invoked with\n     * three arguments: (value, index, array).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': false },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': true }\n     * ];\n     *\n     * _.takeWhile(users, function(o) { return !o.active; });\n     * // => objects for ['barney', 'fred']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.takeWhile(users, { 'user': 'barney', 'active': false });\n     * // => objects for ['barney']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.takeWhile(users, ['active', false]);\n     * // => objects for ['barney', 'fred']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.takeWhile(users, 'active');\n     * // => []\n     */\n    function takeWhile(array, predicate) {\n      return (array && array.length)\n        ? baseWhile(array, getIteratee(predicate, 3))\n        : [];\n    }\n\n    /**\n     * Creates an array of unique values, in order, from all given arrays using\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @returns {Array} Returns the new array of combined values.\n     * @example\n     *\n     * _.union([2], [1, 2]);\n     * // => [2, 1]\n     */\n    var union = baseRest(function(arrays) {\n      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));\n    });\n\n    /**\n     * This method is like `_.union` except that it accepts `iteratee` which is\n     * invoked for each element of each `arrays` to generate the criterion by\n     * which uniqueness is computed. Result values are chosen from the first\n     * array in which the value occurs. The iteratee is invoked with one argument:\n     * (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new array of combined values.\n     * @example\n     *\n     * _.unionBy([2.1], [1.2, 2.3], Math.floor);\n     * // => [2.1, 1.2]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\n     * // => [{ 'x': 1 }, { 'x': 2 }]\n     */\n    var unionBy = baseRest(function(arrays) {\n      var iteratee = last(arrays);\n      if (isArrayLikeObject(iteratee)) {\n        iteratee = undefined;\n      }\n      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));\n    });\n\n    /**\n     * This method is like `_.union` except that it accepts `comparator` which\n     * is invoked to compare elements of `arrays`. Result values are chosen from\n     * the first array in which the value occurs. The comparator is invoked\n     * with two arguments: (arrVal, othVal).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of combined values.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\n     *\n     * _.unionWith(objects, others, _.isEqual);\n     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]\n     */\n    var unionWith = baseRest(function(arrays) {\n      var comparator = last(arrays);\n      comparator = typeof comparator == 'function' ? comparator : undefined;\n      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);\n    });\n\n    /**\n     * Creates a duplicate-free version of an array, using\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons, in which only the first occurrence of each element\n     * is kept. The order of result values is determined by the order they occur\n     * in the array.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * _.uniq([2, 1, 2]);\n     * // => [2, 1]\n     */\n    function uniq(array) {\n      return (array && array.length) ? baseUniq(array) : [];\n    }\n\n    /**\n     * This method is like `_.uniq` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the criterion by which\n     * uniqueness is computed. The order of result values is determined by the\n     * order they occur in the array. The iteratee is invoked with one argument:\n     * (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);\n     * // => [2.1, 1.2]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');\n     * // => [{ 'x': 1 }, { 'x': 2 }]\n     */\n    function uniqBy(array, iteratee) {\n      return (array && array.length) ? baseUniq(array, getIteratee(iteratee, 2)) : [];\n    }\n\n    /**\n     * This method is like `_.uniq` except that it accepts `comparator` which\n     * is invoked to compare elements of `array`. The order of result values is\n     * determined by the order they occur in the array.The comparator is invoked\n     * with two arguments: (arrVal, othVal).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];\n     *\n     * _.uniqWith(objects, _.isEqual);\n     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]\n     */\n    function uniqWith(array, comparator) {\n      comparator = typeof comparator == 'function' ? comparator : undefined;\n      return (array && array.length) ? baseUniq(array, undefined, comparator) : [];\n    }\n\n    /**\n     * This method is like `_.zip` except that it accepts an array of grouped\n     * elements and creates an array regrouping the elements to their pre-zip\n     * configuration.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.2.0\n     * @category Array\n     * @param {Array} array The array of grouped elements to process.\n     * @returns {Array} Returns the new array of regrouped elements.\n     * @example\n     *\n     * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);\n     * // => [['a', 1, true], ['b', 2, false]]\n     *\n     * _.unzip(zipped);\n     * // => [['a', 'b'], [1, 2], [true, false]]\n     */\n    function unzip(array) {\n      if (!(array && array.length)) {\n        return [];\n      }\n      var length = 0;\n      array = arrayFilter(array, function(group) {\n        if (isArrayLikeObject(group)) {\n          length = nativeMax(group.length, length);\n          return true;\n        }\n      });\n      return baseTimes(length, function(index) {\n        return arrayMap(array, baseProperty(index));\n      });\n    }\n\n    /**\n     * This method is like `_.unzip` except that it accepts `iteratee` to specify\n     * how regrouped values should be combined. The iteratee is invoked with the\n     * elements of each group: (...group).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.8.0\n     * @category Array\n     * @param {Array} array The array of grouped elements to process.\n     * @param {Function} [iteratee=_.identity] The function to combine\n     *  regrouped values.\n     * @returns {Array} Returns the new array of regrouped elements.\n     * @example\n     *\n     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);\n     * // => [[1, 10, 100], [2, 20, 200]]\n     *\n     * _.unzipWith(zipped, _.add);\n     * // => [3, 30, 300]\n     */\n    function unzipWith(array, iteratee) {\n      if (!(array && array.length)) {\n        return [];\n      }\n      var result = unzip(array);\n      if (iteratee == null) {\n        return result;\n      }\n      return arrayMap(result, function(group) {\n        return apply(iteratee, undefined, group);\n      });\n    }\n\n    /**\n     * Creates an array excluding all given values using\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons.\n     *\n     * **Note:** Unlike `_.pull`, this method returns a new array.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {...*} [values] The values to exclude.\n     * @returns {Array} Returns the new array of filtered values.\n     * @see _.difference, _.xor\n     * @example\n     *\n     * _.without([2, 1, 2, 3], 1, 2);\n     * // => [3]\n     */\n    var without = baseRest(function(array, values) {\n      return isArrayLikeObject(array)\n        ? baseDifference(array, values)\n        : [];\n    });\n\n    /**\n     * Creates an array of unique values that is the\n     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)\n     * of the given arrays. The order of result values is determined by the order\n     * they occur in the arrays.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @returns {Array} Returns the new array of filtered values.\n     * @see _.difference, _.without\n     * @example\n     *\n     * _.xor([2, 1], [2, 3]);\n     * // => [1, 3]\n     */\n    var xor = baseRest(function(arrays) {\n      return baseXor(arrayFilter(arrays, isArrayLikeObject));\n    });\n\n    /**\n     * This method is like `_.xor` except that it accepts `iteratee` which is\n     * invoked for each element of each `arrays` to generate the criterion by\n     * which by which they're compared. The order of result values is determined\n     * by the order they occur in the arrays. The iteratee is invoked with one\n     * argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);\n     * // => [1.2, 3.4]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\n     * // => [{ 'x': 2 }]\n     */\n    var xorBy = baseRest(function(arrays) {\n      var iteratee = last(arrays);\n      if (isArrayLikeObject(iteratee)) {\n        iteratee = undefined;\n      }\n      return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));\n    });\n\n    /**\n     * This method is like `_.xor` except that it accepts `comparator` which is\n     * invoked to compare elements of `arrays`. The order of result values is\n     * determined by the order they occur in the arrays. The comparator is invoked\n     * with two arguments: (arrVal, othVal).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\n     *\n     * _.xorWith(objects, others, _.isEqual);\n     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]\n     */\n    var xorWith = baseRest(function(arrays) {\n      var comparator = last(arrays);\n      comparator = typeof comparator == 'function' ? comparator : undefined;\n      return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);\n    });\n\n    /**\n     * Creates an array of grouped elements, the first of which contains the\n     * first elements of the given arrays, the second of which contains the\n     * second elements of the given arrays, and so on.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to process.\n     * @returns {Array} Returns the new array of grouped elements.\n     * @example\n     *\n     * _.zip(['a', 'b'], [1, 2], [true, false]);\n     * // => [['a', 1, true], ['b', 2, false]]\n     */\n    var zip = baseRest(unzip);\n\n    /**\n     * This method is like `_.fromPairs` except that it accepts two arrays,\n     * one of property identifiers and one of corresponding values.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.4.0\n     * @category Array\n     * @param {Array} [props=[]] The property identifiers.\n     * @param {Array} [values=[]] The property values.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * _.zipObject(['a', 'b'], [1, 2]);\n     * // => { 'a': 1, 'b': 2 }\n     */\n    function zipObject(props, values) {\n      return baseZipObject(props || [], values || [], assignValue);\n    }\n\n    /**\n     * This method is like `_.zipObject` except that it supports property paths.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.1.0\n     * @category Array\n     * @param {Array} [props=[]] The property identifiers.\n     * @param {Array} [values=[]] The property values.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);\n     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }\n     */\n    function zipObjectDeep(props, values) {\n      return baseZipObject(props || [], values || [], baseSet);\n    }\n\n    /**\n     * This method is like `_.zip` except that it accepts `iteratee` to specify\n     * how grouped values should be combined. The iteratee is invoked with the\n     * elements of each group: (...group).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.8.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to process.\n     * @param {Function} [iteratee=_.identity] The function to combine\n     *  grouped values.\n     * @returns {Array} Returns the new array of grouped elements.\n     * @example\n     *\n     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {\n     *   return a + b + c;\n     * });\n     * // => [111, 222]\n     */\n    var zipWith = baseRest(function(arrays) {\n      var length = arrays.length,\n          iteratee = length > 1 ? arrays[length - 1] : undefined;\n\n      iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;\n      return unzipWith(arrays, iteratee);\n    });\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a `lodash` wrapper instance that wraps `value` with explicit method\n     * chain sequences enabled. The result of such sequences must be unwrapped\n     * with `_#value`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.3.0\n     * @category Seq\n     * @param {*} value The value to wrap.\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'age': 36 },\n     *   { 'user': 'fred',    'age': 40 },\n     *   { 'user': 'pebbles', 'age': 1 }\n     * ];\n     *\n     * var youngest = _\n     *   .chain(users)\n     *   .sortBy('age')\n     *   .map(function(o) {\n     *     return o.user + ' is ' + o.age;\n     *   })\n     *   .head()\n     *   .value();\n     * // => 'pebbles is 1'\n     */\n    function chain(value) {\n      var result = lodash(value);\n      result.__chain__ = true;\n      return result;\n    }\n\n    /**\n     * This method invokes `interceptor` and returns `value`. The interceptor\n     * is invoked with one argument; (value). The purpose of this method is to\n     * \"tap into\" a method chain sequence in order to modify intermediate results.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Seq\n     * @param {*} value The value to provide to `interceptor`.\n     * @param {Function} interceptor The function to invoke.\n     * @returns {*} Returns `value`.\n     * @example\n     *\n     * _([1, 2, 3])\n     *  .tap(function(array) {\n     *    // Mutate input array.\n     *    array.pop();\n     *  })\n     *  .reverse()\n     *  .value();\n     * // => [2, 1]\n     */\n    function tap(value, interceptor) {\n      interceptor(value);\n      return value;\n    }\n\n    /**\n     * This method is like `_.tap` except that it returns the result of `interceptor`.\n     * The purpose of this method is to \"pass thru\" values replacing intermediate\n     * results in a method chain sequence.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Seq\n     * @param {*} value The value to provide to `interceptor`.\n     * @param {Function} interceptor The function to invoke.\n     * @returns {*} Returns the result of `interceptor`.\n     * @example\n     *\n     * _('  abc  ')\n     *  .chain()\n     *  .trim()\n     *  .thru(function(value) {\n     *    return [value];\n     *  })\n     *  .value();\n     * // => ['abc']\n     */\n    function thru(value, interceptor) {\n      return interceptor(value);\n    }\n\n    /**\n     * This method is the wrapper version of `_.at`.\n     *\n     * @name at\n     * @memberOf _\n     * @since 1.0.0\n     * @category Seq\n     * @param {...(string|string[])} [paths] The property paths to pick.\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };\n     *\n     * _(object).at(['a[0].b.c', 'a[1]']).value();\n     * // => [3, 4]\n     */\n    var wrapperAt = flatRest(function(paths) {\n      var length = paths.length,\n          start = length ? paths[0] : 0,\n          value = this.__wrapped__,\n          interceptor = function(object) { return baseAt(object, paths); };\n\n      if (length > 1 || this.__actions__.length ||\n          !(value instanceof LazyWrapper) || !isIndex(start)) {\n        return this.thru(interceptor);\n      }\n      value = value.slice(start, +start + (length ? 1 : 0));\n      value.__actions__.push({\n        'func': thru,\n        'args': [interceptor],\n        'thisArg': undefined\n      });\n      return new LodashWrapper(value, this.__chain__).thru(function(array) {\n        if (length && !array.length) {\n          array.push(undefined);\n        }\n        return array;\n      });\n    });\n\n    /**\n     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.\n     *\n     * @name chain\n     * @memberOf _\n     * @since 0.1.0\n     * @category Seq\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36 },\n     *   { 'user': 'fred',   'age': 40 }\n     * ];\n     *\n     * // A sequence without explicit chaining.\n     * _(users).head();\n     * // => { 'user': 'barney', 'age': 36 }\n     *\n     * // A sequence with explicit chaining.\n     * _(users)\n     *   .chain()\n     *   .head()\n     *   .pick('user')\n     *   .value();\n     * // => { 'user': 'barney' }\n     */\n    function wrapperChain() {\n      return chain(this);\n    }\n\n    /**\n     * Executes the chain sequence and returns the wrapped result.\n     *\n     * @name commit\n     * @memberOf _\n     * @since 3.2.0\n     * @category Seq\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var array = [1, 2];\n     * var wrapped = _(array).push(3);\n     *\n     * console.log(array);\n     * // => [1, 2]\n     *\n     * wrapped = wrapped.commit();\n     * console.log(array);\n     * // => [1, 2, 3]\n     *\n     * wrapped.last();\n     * // => 3\n     *\n     * console.log(array);\n     * // => [1, 2, 3]\n     */\n    function wrapperCommit() {\n      return new LodashWrapper(this.value(), this.__chain__);\n    }\n\n    /**\n     * Gets the next value on a wrapped object following the\n     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).\n     *\n     * @name next\n     * @memberOf _\n     * @since 4.0.0\n     * @category Seq\n     * @returns {Object} Returns the next iterator value.\n     * @example\n     *\n     * var wrapped = _([1, 2]);\n     *\n     * wrapped.next();\n     * // => { 'done': false, 'value': 1 }\n     *\n     * wrapped.next();\n     * // => { 'done': false, 'value': 2 }\n     *\n     * wrapped.next();\n     * // => { 'done': true, 'value': undefined }\n     */\n    function wrapperNext() {\n      if (this.__values__ === undefined) {\n        this.__values__ = toArray(this.value());\n      }\n      var done = this.__index__ >= this.__values__.length,\n          value = done ? undefined : this.__values__[this.__index__++];\n\n      return { 'done': done, 'value': value };\n    }\n\n    /**\n     * Enables the wrapper to be iterable.\n     *\n     * @name Symbol.iterator\n     * @memberOf _\n     * @since 4.0.0\n     * @category Seq\n     * @returns {Object} Returns the wrapper object.\n     * @example\n     *\n     * var wrapped = _([1, 2]);\n     *\n     * wrapped[Symbol.iterator]() === wrapped;\n     * // => true\n     *\n     * Array.from(wrapped);\n     * // => [1, 2]\n     */\n    function wrapperToIterator() {\n      return this;\n    }\n\n    /**\n     * Creates a clone of the chain sequence planting `value` as the wrapped value.\n     *\n     * @name plant\n     * @memberOf _\n     * @since 3.2.0\n     * @category Seq\n     * @param {*} value The value to plant.\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var wrapped = _([1, 2]).map(square);\n     * var other = wrapped.plant([3, 4]);\n     *\n     * other.value();\n     * // => [9, 16]\n     *\n     * wrapped.value();\n     * // => [1, 4]\n     */\n    function wrapperPlant(value) {\n      var result,\n          parent = this;\n\n      while (parent instanceof baseLodash) {\n        var clone = wrapperClone(parent);\n        clone.__index__ = 0;\n        clone.__values__ = undefined;\n        if (result) {\n          previous.__wrapped__ = clone;\n        } else {\n          result = clone;\n        }\n        var previous = clone;\n        parent = parent.__wrapped__;\n      }\n      previous.__wrapped__ = value;\n      return result;\n    }\n\n    /**\n     * This method is the wrapper version of `_.reverse`.\n     *\n     * **Note:** This method mutates the wrapped array.\n     *\n     * @name reverse\n     * @memberOf _\n     * @since 0.1.0\n     * @category Seq\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var array = [1, 2, 3];\n     *\n     * _(array).reverse().value()\n     * // => [3, 2, 1]\n     *\n     * console.log(array);\n     * // => [3, 2, 1]\n     */\n    function wrapperReverse() {\n      var value = this.__wrapped__;\n      if (value instanceof LazyWrapper) {\n        var wrapped = value;\n        if (this.__actions__.length) {\n          wrapped = new LazyWrapper(this);\n        }\n        wrapped = wrapped.reverse();\n        wrapped.__actions__.push({\n          'func': thru,\n          'args': [reverse],\n          'thisArg': undefined\n        });\n        return new LodashWrapper(wrapped, this.__chain__);\n      }\n      return this.thru(reverse);\n    }\n\n    /**\n     * Executes the chain sequence to resolve the unwrapped value.\n     *\n     * @name value\n     * @memberOf _\n     * @since 0.1.0\n     * @alias toJSON, valueOf\n     * @category Seq\n     * @returns {*} Returns the resolved unwrapped value.\n     * @example\n     *\n     * _([1, 2, 3]).value();\n     * // => [1, 2, 3]\n     */\n    function wrapperValue() {\n      return baseWrapperValue(this.__wrapped__, this.__actions__);\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates an object composed of keys generated from the results of running\n     * each element of `collection` thru `iteratee`. The corresponding value of\n     * each key is the number of times the key was returned by `iteratee`. The\n     * iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.5.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * _.countBy([6.1, 4.2, 6.3], Math.floor);\n     * // => { '4': 1, '6': 2 }\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.countBy(['one', 'two', 'three'], 'length');\n     * // => { '3': 2, '5': 1 }\n     */\n    var countBy = createAggregator(function(result, value, key) {\n      if (hasOwnProperty.call(result, key)) {\n        ++result[key];\n      } else {\n        baseAssignValue(result, key, 1);\n      }\n    });\n\n    /**\n     * Checks if `predicate` returns truthy for **all** elements of `collection`.\n     * Iteration is stopped once `predicate` returns falsey. The predicate is\n     * invoked with three arguments: (value, index|key, collection).\n     *\n     * **Note:** This method returns `true` for\n     * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because\n     * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of\n     * elements of empty collections.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {boolean} Returns `true` if all elements pass the predicate check,\n     *  else `false`.\n     * @example\n     *\n     * _.every([true, 1, null, 'yes'], Boolean);\n     * // => false\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': false },\n     *   { 'user': 'fred',   'age': 40, 'active': false }\n     * ];\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.every(users, { 'user': 'barney', 'active': false });\n     * // => false\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.every(users, ['active', false]);\n     * // => true\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.every(users, 'active');\n     * // => false\n     */\n    function every(collection, predicate, guard) {\n      var func = isArray(collection) ? arrayEvery : baseEvery;\n      if (guard && isIterateeCall(collection, predicate, guard)) {\n        predicate = undefined;\n      }\n      return func(collection, getIteratee(predicate, 3));\n    }\n\n    /**\n     * Iterates over elements of `collection`, returning an array of all elements\n     * `predicate` returns truthy for. The predicate is invoked with three\n     * arguments: (value, index|key, collection).\n     *\n     * **Note:** Unlike `_.remove`, this method returns a new array.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new filtered array.\n     * @see _.reject\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': true },\n     *   { 'user': 'fred',   'age': 40, 'active': false }\n     * ];\n     *\n     * _.filter(users, function(o) { return !o.active; });\n     * // => objects for ['fred']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.filter(users, { 'age': 36, 'active': true });\n     * // => objects for ['barney']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.filter(users, ['active', false]);\n     * // => objects for ['fred']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.filter(users, 'active');\n     * // => objects for ['barney']\n     *\n     * // Combining several predicates using `_.overEvery` or `_.overSome`.\n     * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));\n     * // => objects for ['fred', 'barney']\n     */\n    function filter(collection, predicate) {\n      var func = isArray(collection) ? arrayFilter : baseFilter;\n      return func(collection, getIteratee(predicate, 3));\n    }\n\n    /**\n     * Iterates over elements of `collection`, returning the first element\n     * `predicate` returns truthy for. The predicate is invoked with three\n     * arguments: (value, index|key, collection).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param {number} [fromIndex=0] The index to search from.\n     * @returns {*} Returns the matched element, else `undefined`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'age': 36, 'active': true },\n     *   { 'user': 'fred',    'age': 40, 'active': false },\n     *   { 'user': 'pebbles', 'age': 1,  'active': true }\n     * ];\n     *\n     * _.find(users, function(o) { return o.age < 40; });\n     * // => object for 'barney'\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.find(users, { 'age': 1, 'active': true });\n     * // => object for 'pebbles'\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.find(users, ['active', false]);\n     * // => object for 'fred'\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.find(users, 'active');\n     * // => object for 'barney'\n     */\n    var find = createFind(findIndex);\n\n    /**\n     * This method is like `_.find` except that it iterates over elements of\n     * `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param {number} [fromIndex=collection.length-1] The index to search from.\n     * @returns {*} Returns the matched element, else `undefined`.\n     * @example\n     *\n     * _.findLast([1, 2, 3, 4], function(n) {\n     *   return n % 2 == 1;\n     * });\n     * // => 3\n     */\n    var findLast = createFind(findLastIndex);\n\n    /**\n     * Creates a flattened array of values by running each element in `collection`\n     * thru `iteratee` and flattening the mapped results. The iteratee is invoked\n     * with three arguments: (value, index|key, collection).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * function duplicate(n) {\n     *   return [n, n];\n     * }\n     *\n     * _.flatMap([1, 2], duplicate);\n     * // => [1, 1, 2, 2]\n     */\n    function flatMap(collection, iteratee) {\n      return baseFlatten(map(collection, iteratee), 1);\n    }\n\n    /**\n     * This method is like `_.flatMap` except that it recursively flattens the\n     * mapped results.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.7.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * function duplicate(n) {\n     *   return [[[n, n]]];\n     * }\n     *\n     * _.flatMapDeep([1, 2], duplicate);\n     * // => [1, 1, 2, 2]\n     */\n    function flatMapDeep(collection, iteratee) {\n      return baseFlatten(map(collection, iteratee), INFINITY);\n    }\n\n    /**\n     * This method is like `_.flatMap` except that it recursively flattens the\n     * mapped results up to `depth` times.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.7.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {number} [depth=1] The maximum recursion depth.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * function duplicate(n) {\n     *   return [[[n, n]]];\n     * }\n     *\n     * _.flatMapDepth([1, 2], duplicate, 2);\n     * // => [[1, 1], [2, 2]]\n     */\n    function flatMapDepth(collection, iteratee, depth) {\n      depth = depth === undefined ? 1 : toInteger(depth);\n      return baseFlatten(map(collection, iteratee), depth);\n    }\n\n    /**\n     * Iterates over elements of `collection` and invokes `iteratee` for each element.\n     * The iteratee is invoked with three arguments: (value, index|key, collection).\n     * Iteratee functions may exit iteration early by explicitly returning `false`.\n     *\n     * **Note:** As with other \"Collections\" methods, objects with a \"length\"\n     * property are iterated like arrays. To avoid this behavior use `_.forIn`\n     * or `_.forOwn` for object iteration.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @alias each\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array|Object} Returns `collection`.\n     * @see _.forEachRight\n     * @example\n     *\n     * _.forEach([1, 2], function(value) {\n     *   console.log(value);\n     * });\n     * // => Logs `1` then `2`.\n     *\n     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => Logs 'a' then 'b' (iteration order is not guaranteed).\n     */\n    function forEach(collection, iteratee) {\n      var func = isArray(collection) ? arrayEach : baseEach;\n      return func(collection, getIteratee(iteratee, 3));\n    }\n\n    /**\n     * This method is like `_.forEach` except that it iterates over elements of\n     * `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @alias eachRight\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array|Object} Returns `collection`.\n     * @see _.forEach\n     * @example\n     *\n     * _.forEachRight([1, 2], function(value) {\n     *   console.log(value);\n     * });\n     * // => Logs `2` then `1`.\n     */\n    function forEachRight(collection, iteratee) {\n      var func = isArray(collection) ? arrayEachRight : baseEachRight;\n      return func(collection, getIteratee(iteratee, 3));\n    }\n\n    /**\n     * Creates an object composed of keys generated from the results of running\n     * each element of `collection` thru `iteratee`. The order of grouped values\n     * is determined by the order they occur in `collection`. The corresponding\n     * value of each key is an array of elements responsible for generating the\n     * key. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * _.groupBy([6.1, 4.2, 6.3], Math.floor);\n     * // => { '4': [4.2], '6': [6.1, 6.3] }\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.groupBy(['one', 'two', 'three'], 'length');\n     * // => { '3': ['one', 'two'], '5': ['three'] }\n     */\n    var groupBy = createAggregator(function(result, value, key) {\n      if (hasOwnProperty.call(result, key)) {\n        result[key].push(value);\n      } else {\n        baseAssignValue(result, key, [value]);\n      }\n    });\n\n    /**\n     * Checks if `value` is in `collection`. If `collection` is a string, it's\n     * checked for a substring of `value`, otherwise\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * is used for equality comparisons. If `fromIndex` is negative, it's used as\n     * the offset from the end of `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to inspect.\n     * @param {*} value The value to search for.\n     * @param {number} [fromIndex=0] The index to search from.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.\n     * @returns {boolean} Returns `true` if `value` is found, else `false`.\n     * @example\n     *\n     * _.includes([1, 2, 3], 1);\n     * // => true\n     *\n     * _.includes([1, 2, 3], 1, 2);\n     * // => false\n     *\n     * _.includes({ 'a': 1, 'b': 2 }, 1);\n     * // => true\n     *\n     * _.includes('abcd', 'bc');\n     * // => true\n     */\n    function includes(collection, value, fromIndex, guard) {\n      collection = isArrayLike(collection) ? collection : values(collection);\n      fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;\n\n      var length = collection.length;\n      if (fromIndex < 0) {\n        fromIndex = nativeMax(length + fromIndex, 0);\n      }\n      return isString(collection)\n        ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)\n        : (!!length && baseIndexOf(collection, value, fromIndex) > -1);\n    }\n\n    /**\n     * Invokes the method at `path` of each element in `collection`, returning\n     * an array of the results of each invoked method. Any additional arguments\n     * are provided to each invoked method. If `path` is a function, it's invoked\n     * for, and `this` bound to, each element in `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Array|Function|string} path The path of the method to invoke or\n     *  the function invoked per iteration.\n     * @param {...*} [args] The arguments to invoke each method with.\n     * @returns {Array} Returns the array of results.\n     * @example\n     *\n     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');\n     * // => [[1, 5, 7], [1, 2, 3]]\n     *\n     * _.invokeMap([123, 456], String.prototype.split, '');\n     * // => [['1', '2', '3'], ['4', '5', '6']]\n     */\n    var invokeMap = baseRest(function(collection, path, args) {\n      var index = -1,\n          isFunc = typeof path == 'function',\n          result = isArrayLike(collection) ? Array(collection.length) : [];\n\n      baseEach(collection, function(value) {\n        result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);\n      });\n      return result;\n    });\n\n    /**\n     * Creates an object composed of keys generated from the results of running\n     * each element of `collection` thru `iteratee`. The corresponding value of\n     * each key is the last element responsible for generating the key. The\n     * iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * var array = [\n     *   { 'dir': 'left', 'code': 97 },\n     *   { 'dir': 'right', 'code': 100 }\n     * ];\n     *\n     * _.keyBy(array, function(o) {\n     *   return String.fromCharCode(o.code);\n     * });\n     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }\n     *\n     * _.keyBy(array, 'dir');\n     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }\n     */\n    var keyBy = createAggregator(function(result, value, key) {\n      baseAssignValue(result, key, value);\n    });\n\n    /**\n     * Creates an array of values by running each element in `collection` thru\n     * `iteratee`. The iteratee is invoked with three arguments:\n     * (value, index|key, collection).\n     *\n     * Many lodash methods are guarded to work as iteratees for methods like\n     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.\n     *\n     * The guarded methods are:\n     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,\n     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,\n     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,\n     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new mapped array.\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * _.map([4, 8], square);\n     * // => [16, 64]\n     *\n     * _.map({ 'a': 4, 'b': 8 }, square);\n     * // => [16, 64] (iteration order is not guaranteed)\n     *\n     * var users = [\n     *   { 'user': 'barney' },\n     *   { 'user': 'fred' }\n     * ];\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.map(users, 'user');\n     * // => ['barney', 'fred']\n     */\n    function map(collection, iteratee) {\n      var func = isArray(collection) ? arrayMap : baseMap;\n      return func(collection, getIteratee(iteratee, 3));\n    }\n\n    /**\n     * This method is like `_.sortBy` except that it allows specifying the sort\n     * orders of the iteratees to sort by. If `orders` is unspecified, all values\n     * are sorted in ascending order. Otherwise, specify an order of \"desc\" for\n     * descending or \"asc\" for ascending sort order of corresponding values.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]\n     *  The iteratees to sort by.\n     * @param {string[]} [orders] The sort orders of `iteratees`.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.\n     * @returns {Array} Returns the new sorted array.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'fred',   'age': 48 },\n     *   { 'user': 'barney', 'age': 34 },\n     *   { 'user': 'fred',   'age': 40 },\n     *   { 'user': 'barney', 'age': 36 }\n     * ];\n     *\n     * // Sort by `user` in ascending order and by `age` in descending order.\n     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);\n     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]\n     */\n    function orderBy(collection, iteratees, orders, guard) {\n      if (collection == null) {\n        return [];\n      }\n      if (!isArray(iteratees)) {\n        iteratees = iteratees == null ? [] : [iteratees];\n      }\n      orders = guard ? undefined : orders;\n      if (!isArray(orders)) {\n        orders = orders == null ? [] : [orders];\n      }\n      return baseOrderBy(collection, iteratees, orders);\n    }\n\n    /**\n     * Creates an array of elements split into two groups, the first of which\n     * contains elements `predicate` returns truthy for, the second of which\n     * contains elements `predicate` returns falsey for. The predicate is\n     * invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the array of grouped elements.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'age': 36, 'active': false },\n     *   { 'user': 'fred',    'age': 40, 'active': true },\n     *   { 'user': 'pebbles', 'age': 1,  'active': false }\n     * ];\n     *\n     * _.partition(users, function(o) { return o.active; });\n     * // => objects for [['fred'], ['barney', 'pebbles']]\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.partition(users, { 'age': 1, 'active': false });\n     * // => objects for [['pebbles'], ['barney', 'fred']]\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.partition(users, ['active', false]);\n     * // => objects for [['barney', 'pebbles'], ['fred']]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.partition(users, 'active');\n     * // => objects for [['fred'], ['barney', 'pebbles']]\n     */\n    var partition = createAggregator(function(result, value, key) {\n      result[key ? 0 : 1].push(value);\n    }, function() { return [[], []]; });\n\n    /**\n     * Reduces `collection` to a value which is the accumulated result of running\n     * each element in `collection` thru `iteratee`, where each successive\n     * invocation is supplied the return value of the previous. If `accumulator`\n     * is not given, the first element of `collection` is used as the initial\n     * value. The iteratee is invoked with four arguments:\n     * (accumulator, value, index|key, collection).\n     *\n     * Many lodash methods are guarded to work as iteratees for methods like\n     * `_.reduce`, `_.reduceRight`, and `_.transform`.\n     *\n     * The guarded methods are:\n     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,\n     * and `sortBy`\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [accumulator] The initial value.\n     * @returns {*} Returns the accumulated value.\n     * @see _.reduceRight\n     * @example\n     *\n     * _.reduce([1, 2], function(sum, n) {\n     *   return sum + n;\n     * }, 0);\n     * // => 3\n     *\n     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {\n     *   (result[value] || (result[value] = [])).push(key);\n     *   return result;\n     * }, {});\n     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)\n     */\n    function reduce(collection, iteratee, accumulator) {\n      var func = isArray(collection) ? arrayReduce : baseReduce,\n          initAccum = arguments.length < 3;\n\n      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);\n    }\n\n    /**\n     * This method is like `_.reduce` except that it iterates over elements of\n     * `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [accumulator] The initial value.\n     * @returns {*} Returns the accumulated value.\n     * @see _.reduce\n     * @example\n     *\n     * var array = [[0, 1], [2, 3], [4, 5]];\n     *\n     * _.reduceRight(array, function(flattened, other) {\n     *   return flattened.concat(other);\n     * }, []);\n     * // => [4, 5, 2, 3, 0, 1]\n     */\n    function reduceRight(collection, iteratee, accumulator) {\n      var func = isArray(collection) ? arrayReduceRight : baseReduce,\n          initAccum = arguments.length < 3;\n\n      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);\n    }\n\n    /**\n     * The opposite of `_.filter`; this method returns the elements of `collection`\n     * that `predicate` does **not** return truthy for.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new filtered array.\n     * @see _.filter\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': false },\n     *   { 'user': 'fred',   'age': 40, 'active': true }\n     * ];\n     *\n     * _.reject(users, function(o) { return !o.active; });\n     * // => objects for ['fred']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.reject(users, { 'age': 40, 'active': true });\n     * // => objects for ['barney']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.reject(users, ['active', false]);\n     * // => objects for ['fred']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.reject(users, 'active');\n     * // => objects for ['barney']\n     */\n    function reject(collection, predicate) {\n      var func = isArray(collection) ? arrayFilter : baseFilter;\n      return func(collection, negate(getIteratee(predicate, 3)));\n    }\n\n    /**\n     * Gets a random element from `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to sample.\n     * @returns {*} Returns the random element.\n     * @example\n     *\n     * _.sample([1, 2, 3, 4]);\n     * // => 2\n     */\n    function sample(collection) {\n      var func = isArray(collection) ? arraySample : baseSample;\n      return func(collection);\n    }\n\n    /**\n     * Gets `n` random elements at unique keys from `collection` up to the\n     * size of `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to sample.\n     * @param {number} [n=1] The number of elements to sample.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the random elements.\n     * @example\n     *\n     * _.sampleSize([1, 2, 3], 2);\n     * // => [3, 1]\n     *\n     * _.sampleSize([1, 2, 3], 4);\n     * // => [2, 3, 1]\n     */\n    function sampleSize(collection, n, guard) {\n      if ((guard ? isIterateeCall(collection, n, guard) : n === undefined)) {\n        n = 1;\n      } else {\n        n = toInteger(n);\n      }\n      var func = isArray(collection) ? arraySampleSize : baseSampleSize;\n      return func(collection, n);\n    }\n\n    /**\n     * Creates an array of shuffled values, using a version of the\n     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to shuffle.\n     * @returns {Array} Returns the new shuffled array.\n     * @example\n     *\n     * _.shuffle([1, 2, 3, 4]);\n     * // => [4, 1, 3, 2]\n     */\n    function shuffle(collection) {\n      var func = isArray(collection) ? arrayShuffle : baseShuffle;\n      return func(collection);\n    }\n\n    /**\n     * Gets the size of `collection` by returning its length for array-like\n     * values or the number of own enumerable string keyed properties for objects.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to inspect.\n     * @returns {number} Returns the collection size.\n     * @example\n     *\n     * _.size([1, 2, 3]);\n     * // => 3\n     *\n     * _.size({ 'a': 1, 'b': 2 });\n     * // => 2\n     *\n     * _.size('pebbles');\n     * // => 7\n     */\n    function size(collection) {\n      if (collection == null) {\n        return 0;\n      }\n      if (isArrayLike(collection)) {\n        return isString(collection) ? stringSize(collection) : collection.length;\n      }\n      var tag = getTag(collection);\n      if (tag == mapTag || tag == setTag) {\n        return collection.size;\n      }\n      return baseKeys(collection).length;\n    }\n\n    /**\n     * Checks if `predicate` returns truthy for **any** element of `collection`.\n     * Iteration is stopped once `predicate` returns truthy. The predicate is\n     * invoked with three arguments: (value, index|key, collection).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {boolean} Returns `true` if any element passes the predicate check,\n     *  else `false`.\n     * @example\n     *\n     * _.some([null, 0, 'yes', false], Boolean);\n     * // => true\n     *\n     * var users = [\n     *   { 'user': 'barney', 'active': true },\n     *   { 'user': 'fred',   'active': false }\n     * ];\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.some(users, { 'user': 'barney', 'active': false });\n     * // => false\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.some(users, ['active', false]);\n     * // => true\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.some(users, 'active');\n     * // => true\n     */\n    function some(collection, predicate, guard) {\n      var func = isArray(collection) ? arraySome : baseSome;\n      if (guard && isIterateeCall(collection, predicate, guard)) {\n        predicate = undefined;\n      }\n      return func(collection, getIteratee(predicate, 3));\n    }\n\n    /**\n     * Creates an array of elements, sorted in ascending order by the results of\n     * running each element in a collection thru each iteratee. This method\n     * performs a stable sort, that is, it preserves the original sort order of\n     * equal elements. The iteratees are invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {...(Function|Function[])} [iteratees=[_.identity]]\n     *  The iteratees to sort by.\n     * @returns {Array} Returns the new sorted array.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'fred',   'age': 48 },\n     *   { 'user': 'barney', 'age': 36 },\n     *   { 'user': 'fred',   'age': 30 },\n     *   { 'user': 'barney', 'age': 34 }\n     * ];\n     *\n     * _.sortBy(users, [function(o) { return o.user; }]);\n     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]\n     *\n     * _.sortBy(users, ['user', 'age']);\n     * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]\n     */\n    var sortBy = baseRest(function(collection, iteratees) {\n      if (collection == null) {\n        return [];\n      }\n      var length = iteratees.length;\n      if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {\n        iteratees = [];\n      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {\n        iteratees = [iteratees[0]];\n      }\n      return baseOrderBy(collection, baseFlatten(iteratees, 1), []);\n    });\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Gets the timestamp of the number of milliseconds that have elapsed since\n     * the Unix epoch (1 January 1970 00:00:00 UTC).\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Date\n     * @returns {number} Returns the timestamp.\n     * @example\n     *\n     * _.defer(function(stamp) {\n     *   console.log(_.now() - stamp);\n     * }, _.now());\n     * // => Logs the number of milliseconds it took for the deferred invocation.\n     */\n    var now = ctxNow || function() {\n      return root.Date.now();\n    };\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * The opposite of `_.before`; this method creates a function that invokes\n     * `func` once it's called `n` or more times.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {number} n The number of calls before `func` is invoked.\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new restricted function.\n     * @example\n     *\n     * var saves = ['profile', 'settings'];\n     *\n     * var done = _.after(saves.length, function() {\n     *   console.log('done saving!');\n     * });\n     *\n     * _.forEach(saves, function(type) {\n     *   asyncSave({ 'type': type, 'complete': done });\n     * });\n     * // => Logs 'done saving!' after the two async saves have completed.\n     */\n    function after(n, func) {\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      n = toInteger(n);\n      return function() {\n        if (--n < 1) {\n          return func.apply(this, arguments);\n        }\n      };\n    }\n\n    /**\n     * Creates a function that invokes `func`, with up to `n` arguments,\n     * ignoring any additional arguments.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Function\n     * @param {Function} func The function to cap arguments for.\n     * @param {number} [n=func.length] The arity cap.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Function} Returns the new capped function.\n     * @example\n     *\n     * _.map(['6', '8', '10'], _.ary(parseInt, 1));\n     * // => [6, 8, 10]\n     */\n    function ary(func, n, guard) {\n      n = guard ? undefined : n;\n      n = (func && n == null) ? func.length : n;\n      return createWrap(func, WRAP_ARY_FLAG, undefined, undefined, undefined, undefined, n);\n    }\n\n    /**\n     * Creates a function that invokes `func`, with the `this` binding and arguments\n     * of the created function, while it's called less than `n` times. Subsequent\n     * calls to the created function return the result of the last `func` invocation.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Function\n     * @param {number} n The number of calls at which `func` is no longer invoked.\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new restricted function.\n     * @example\n     *\n     * jQuery(element).on('click', _.before(5, addContactToList));\n     * // => Allows adding up to 4 contacts to the list.\n     */\n    function before(n, func) {\n      var result;\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      n = toInteger(n);\n      return function() {\n        if (--n > 0) {\n          result = func.apply(this, arguments);\n        }\n        if (n <= 1) {\n          func = undefined;\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Creates a function that invokes `func` with the `this` binding of `thisArg`\n     * and `partials` prepended to the arguments it receives.\n     *\n     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,\n     * may be used as a placeholder for partially applied arguments.\n     *\n     * **Note:** Unlike native `Function#bind`, this method doesn't set the \"length\"\n     * property of bound functions.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to bind.\n     * @param {*} thisArg The `this` binding of `func`.\n     * @param {...*} [partials] The arguments to be partially applied.\n     * @returns {Function} Returns the new bound function.\n     * @example\n     *\n     * function greet(greeting, punctuation) {\n     *   return greeting + ' ' + this.user + punctuation;\n     * }\n     *\n     * var object = { 'user': 'fred' };\n     *\n     * var bound = _.bind(greet, object, 'hi');\n     * bound('!');\n     * // => 'hi fred!'\n     *\n     * // Bound with placeholders.\n     * var bound = _.bind(greet, object, _, '!');\n     * bound('hi');\n     * // => 'hi fred!'\n     */\n    var bind = baseRest(function(func, thisArg, partials) {\n      var bitmask = WRAP_BIND_FLAG;\n      if (partials.length) {\n        var holders = replaceHolders(partials, getHolder(bind));\n        bitmask |= WRAP_PARTIAL_FLAG;\n      }\n      return createWrap(func, bitmask, thisArg, partials, holders);\n    });\n\n    /**\n     * Creates a function that invokes the method at `object[key]` with `partials`\n     * prepended to the arguments it receives.\n     *\n     * This method differs from `_.bind` by allowing bound functions to reference\n     * methods that may be redefined or don't yet exist. See\n     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)\n     * for more details.\n     *\n     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for partially applied arguments.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.10.0\n     * @category Function\n     * @param {Object} object The object to invoke the method on.\n     * @param {string} key The key of the method.\n     * @param {...*} [partials] The arguments to be partially applied.\n     * @returns {Function} Returns the new bound function.\n     * @example\n     *\n     * var object = {\n     *   'user': 'fred',\n     *   'greet': function(greeting, punctuation) {\n     *     return greeting + ' ' + this.user + punctuation;\n     *   }\n     * };\n     *\n     * var bound = _.bindKey(object, 'greet', 'hi');\n     * bound('!');\n     * // => 'hi fred!'\n     *\n     * object.greet = function(greeting, punctuation) {\n     *   return greeting + 'ya ' + this.user + punctuation;\n     * };\n     *\n     * bound('!');\n     * // => 'hiya fred!'\n     *\n     * // Bound with placeholders.\n     * var bound = _.bindKey(object, 'greet', _, '!');\n     * bound('hi');\n     * // => 'hiya fred!'\n     */\n    var bindKey = baseRest(function(object, key, partials) {\n      var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;\n      if (partials.length) {\n        var holders = replaceHolders(partials, getHolder(bindKey));\n        bitmask |= WRAP_PARTIAL_FLAG;\n      }\n      return createWrap(key, bitmask, object, partials, holders);\n    });\n\n    /**\n     * Creates a function that accepts arguments of `func` and either invokes\n     * `func` returning its result, if at least `arity` number of arguments have\n     * been provided, or returns a function that accepts the remaining `func`\n     * arguments, and so on. The arity of `func` may be specified if `func.length`\n     * is not sufficient.\n     *\n     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,\n     * may be used as a placeholder for provided arguments.\n     *\n     * **Note:** This method doesn't set the \"length\" property of curried functions.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Function\n     * @param {Function} func The function to curry.\n     * @param {number} [arity=func.length] The arity of `func`.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Function} Returns the new curried function.\n     * @example\n     *\n     * var abc = function(a, b, c) {\n     *   return [a, b, c];\n     * };\n     *\n     * var curried = _.curry(abc);\n     *\n     * curried(1)(2)(3);\n     * // => [1, 2, 3]\n     *\n     * curried(1, 2)(3);\n     * // => [1, 2, 3]\n     *\n     * curried(1, 2, 3);\n     * // => [1, 2, 3]\n     *\n     * // Curried with placeholders.\n     * curried(1)(_, 3)(2);\n     * // => [1, 2, 3]\n     */\n    function curry(func, arity, guard) {\n      arity = guard ? undefined : arity;\n      var result = createWrap(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);\n      result.placeholder = curry.placeholder;\n      return result;\n    }\n\n    /**\n     * This method is like `_.curry` except that arguments are applied to `func`\n     * in the manner of `_.partialRight` instead of `_.partial`.\n     *\n     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for provided arguments.\n     *\n     * **Note:** This method doesn't set the \"length\" property of curried functions.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Function\n     * @param {Function} func The function to curry.\n     * @param {number} [arity=func.length] The arity of `func`.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Function} Returns the new curried function.\n     * @example\n     *\n     * var abc = function(a, b, c) {\n     *   return [a, b, c];\n     * };\n     *\n     * var curried = _.curryRight(abc);\n     *\n     * curried(3)(2)(1);\n     * // => [1, 2, 3]\n     *\n     * curried(2, 3)(1);\n     * // => [1, 2, 3]\n     *\n     * curried(1, 2, 3);\n     * // => [1, 2, 3]\n     *\n     * // Curried with placeholders.\n     * curried(3)(1, _)(2);\n     * // => [1, 2, 3]\n     */\n    function curryRight(func, arity, guard) {\n      arity = guard ? undefined : arity;\n      var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);\n      result.placeholder = curryRight.placeholder;\n      return result;\n    }\n\n    /**\n     * Creates a debounced function that delays invoking `func` until after `wait`\n     * milliseconds have elapsed since the last time the debounced function was\n     * invoked. The debounced function comes with a `cancel` method to cancel\n     * delayed `func` invocations and a `flush` method to immediately invoke them.\n     * Provide `options` to indicate whether `func` should be invoked on the\n     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n     * with the last arguments provided to the debounced function. Subsequent\n     * calls to the debounced function return the result of the last `func`\n     * invocation.\n     *\n     * **Note:** If `leading` and `trailing` options are `true`, `func` is\n     * invoked on the trailing edge of the timeout only if the debounced function\n     * is invoked more than once during the `wait` timeout.\n     *\n     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n     * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n     *\n     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n     * for details over the differences between `_.debounce` and `_.throttle`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to debounce.\n     * @param {number} [wait=0] The number of milliseconds to delay.\n     * @param {Object} [options={}] The options object.\n     * @param {boolean} [options.leading=false]\n     *  Specify invoking on the leading edge of the timeout.\n     * @param {number} [options.maxWait]\n     *  The maximum time `func` is allowed to be delayed before it's invoked.\n     * @param {boolean} [options.trailing=true]\n     *  Specify invoking on the trailing edge of the timeout.\n     * @returns {Function} Returns the new debounced function.\n     * @example\n     *\n     * // Avoid costly calculations while the window size is in flux.\n     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n     *\n     * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n     * jQuery(element).on('click', _.debounce(sendMail, 300, {\n     *   'leading': true,\n     *   'trailing': false\n     * }));\n     *\n     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n     * var source = new EventSource('/stream');\n     * jQuery(source).on('message', debounced);\n     *\n     * // Cancel the trailing debounced invocation.\n     * jQuery(window).on('popstate', debounced.cancel);\n     */\n    function debounce(func, wait, options) {\n      var lastArgs,\n          lastThis,\n          maxWait,\n          result,\n          timerId,\n          lastCallTime,\n          lastInvokeTime = 0,\n          leading = false,\n          maxing = false,\n          trailing = true;\n\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      wait = toNumber(wait) || 0;\n      if (isObject(options)) {\n        leading = !!options.leading;\n        maxing = 'maxWait' in options;\n        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n        trailing = 'trailing' in options ? !!options.trailing : trailing;\n      }\n\n      function invokeFunc(time) {\n        var args = lastArgs,\n            thisArg = lastThis;\n\n        lastArgs = lastThis = undefined;\n        lastInvokeTime = time;\n        result = func.apply(thisArg, args);\n        return result;\n      }\n\n      function leadingEdge(time) {\n        // Reset any `maxWait` timer.\n        lastInvokeTime = time;\n        // Start the timer for the trailing edge.\n        timerId = setTimeout(timerExpired, wait);\n        // Invoke the leading edge.\n        return leading ? invokeFunc(time) : result;\n      }\n\n      function remainingWait(time) {\n        var timeSinceLastCall = time - lastCallTime,\n            timeSinceLastInvoke = time - lastInvokeTime,\n            timeWaiting = wait - timeSinceLastCall;\n\n        return maxing\n          ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)\n          : timeWaiting;\n      }\n\n      function shouldInvoke(time) {\n        var timeSinceLastCall = time - lastCallTime,\n            timeSinceLastInvoke = time - lastInvokeTime;\n\n        // Either this is the first call, activity has stopped and we're at the\n        // trailing edge, the system time has gone backwards and we're treating\n        // it as the trailing edge, or we've hit the `maxWait` limit.\n        return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n          (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n      }\n\n      function timerExpired() {\n        var time = now();\n        if (shouldInvoke(time)) {\n          return trailingEdge(time);\n        }\n        // Restart the timer.\n        timerId = setTimeout(timerExpired, remainingWait(time));\n      }\n\n      function trailingEdge(time) {\n        timerId = undefined;\n\n        // Only invoke if we have `lastArgs` which means `func` has been\n        // debounced at least once.\n        if (trailing && lastArgs) {\n          return invokeFunc(time);\n        }\n        lastArgs = lastThis = undefined;\n        return result;\n      }\n\n      function cancel() {\n        if (timerId !== undefined) {\n          clearTimeout(timerId);\n        }\n        lastInvokeTime = 0;\n        lastArgs = lastCallTime = lastThis = timerId = undefined;\n      }\n\n      function flush() {\n        return timerId === undefined ? result : trailingEdge(now());\n      }\n\n      function debounced() {\n        var time = now(),\n            isInvoking = shouldInvoke(time);\n\n        lastArgs = arguments;\n        lastThis = this;\n        lastCallTime = time;\n\n        if (isInvoking) {\n          if (timerId === undefined) {\n            return leadingEdge(lastCallTime);\n          }\n          if (maxing) {\n            // Handle invocations in a tight loop.\n            clearTimeout(timerId);\n            timerId = setTimeout(timerExpired, wait);\n            return invokeFunc(lastCallTime);\n          }\n        }\n        if (timerId === undefined) {\n          timerId = setTimeout(timerExpired, wait);\n        }\n        return result;\n      }\n      debounced.cancel = cancel;\n      debounced.flush = flush;\n      return debounced;\n    }\n\n    /**\n     * Defers invoking the `func` until the current call stack has cleared. Any\n     * additional arguments are provided to `func` when it's invoked.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to defer.\n     * @param {...*} [args] The arguments to invoke `func` with.\n     * @returns {number} Returns the timer id.\n     * @example\n     *\n     * _.defer(function(text) {\n     *   console.log(text);\n     * }, 'deferred');\n     * // => Logs 'deferred' after one millisecond.\n     */\n    var defer = baseRest(function(func, args) {\n      return baseDelay(func, 1, args);\n    });\n\n    /**\n     * Invokes `func` after `wait` milliseconds. Any additional arguments are\n     * provided to `func` when it's invoked.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to delay.\n     * @param {number} wait The number of milliseconds to delay invocation.\n     * @param {...*} [args] The arguments to invoke `func` with.\n     * @returns {number} Returns the timer id.\n     * @example\n     *\n     * _.delay(function(text) {\n     *   console.log(text);\n     * }, 1000, 'later');\n     * // => Logs 'later' after one second.\n     */\n    var delay = baseRest(function(func, wait, args) {\n      return baseDelay(func, toNumber(wait) || 0, args);\n    });\n\n    /**\n     * Creates a function that invokes `func` with arguments reversed.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Function\n     * @param {Function} func The function to flip arguments for.\n     * @returns {Function} Returns the new flipped function.\n     * @example\n     *\n     * var flipped = _.flip(function() {\n     *   return _.toArray(arguments);\n     * });\n     *\n     * flipped('a', 'b', 'c', 'd');\n     * // => ['d', 'c', 'b', 'a']\n     */\n    function flip(func) {\n      return createWrap(func, WRAP_FLIP_FLAG);\n    }\n\n    /**\n     * Creates a function that memoizes the result of `func`. If `resolver` is\n     * provided, it determines the cache key for storing the result based on the\n     * arguments provided to the memoized function. By default, the first argument\n     * provided to the memoized function is used as the map cache key. The `func`\n     * is invoked with the `this` binding of the memoized function.\n     *\n     * **Note:** The cache is exposed as the `cache` property on the memoized\n     * function. Its creation may be customized by replacing the `_.memoize.Cache`\n     * constructor with one whose instances implement the\n     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n     * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to have its output memoized.\n     * @param {Function} [resolver] The function to resolve the cache key.\n     * @returns {Function} Returns the new memoized function.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2 };\n     * var other = { 'c': 3, 'd': 4 };\n     *\n     * var values = _.memoize(_.values);\n     * values(object);\n     * // => [1, 2]\n     *\n     * values(other);\n     * // => [3, 4]\n     *\n     * object.a = 2;\n     * values(object);\n     * // => [1, 2]\n     *\n     * // Modify the result cache.\n     * values.cache.set(object, ['a', 'b']);\n     * values(object);\n     * // => ['a', 'b']\n     *\n     * // Replace `_.memoize.Cache`.\n     * _.memoize.Cache = WeakMap;\n     */\n    function memoize(func, resolver) {\n      if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      var memoized = function() {\n        var args = arguments,\n            key = resolver ? resolver.apply(this, args) : args[0],\n            cache = memoized.cache;\n\n        if (cache.has(key)) {\n          return cache.get(key);\n        }\n        var result = func.apply(this, args);\n        memoized.cache = cache.set(key, result) || cache;\n        return result;\n      };\n      memoized.cache = new (memoize.Cache || MapCache);\n      return memoized;\n    }\n\n    // Expose `MapCache`.\n    memoize.Cache = MapCache;\n\n    /**\n     * Creates a function that negates the result of the predicate `func`. The\n     * `func` predicate is invoked with the `this` binding and arguments of the\n     * created function.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Function\n     * @param {Function} predicate The predicate to negate.\n     * @returns {Function} Returns the new negated function.\n     * @example\n     *\n     * function isEven(n) {\n     *   return n % 2 == 0;\n     * }\n     *\n     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));\n     * // => [1, 3, 5]\n     */\n    function negate(predicate) {\n      if (typeof predicate != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      return function() {\n        var args = arguments;\n        switch (args.length) {\n          case 0: return !predicate.call(this);\n          case 1: return !predicate.call(this, args[0]);\n          case 2: return !predicate.call(this, args[0], args[1]);\n          case 3: return !predicate.call(this, args[0], args[1], args[2]);\n        }\n        return !predicate.apply(this, args);\n      };\n    }\n\n    /**\n     * Creates a function that is restricted to invoking `func` once. Repeat calls\n     * to the function return the value of the first invocation. The `func` is\n     * invoked with the `this` binding and arguments of the created function.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new restricted function.\n     * @example\n     *\n     * var initialize = _.once(createApplication);\n     * initialize();\n     * initialize();\n     * // => `createApplication` is invoked once\n     */\n    function once(func) {\n      return before(2, func);\n    }\n\n    /**\n     * Creates a function that invokes `func` with its arguments transformed.\n     *\n     * @static\n     * @since 4.0.0\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to wrap.\n     * @param {...(Function|Function[])} [transforms=[_.identity]]\n     *  The argument transforms.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * function doubled(n) {\n     *   return n * 2;\n     * }\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var func = _.overArgs(function(x, y) {\n     *   return [x, y];\n     * }, [square, doubled]);\n     *\n     * func(9, 3);\n     * // => [81, 6]\n     *\n     * func(10, 5);\n     * // => [100, 10]\n     */\n    var overArgs = castRest(function(func, transforms) {\n      transforms = (transforms.length == 1 && isArray(transforms[0]))\n        ? arrayMap(transforms[0], baseUnary(getIteratee()))\n        : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));\n\n      var funcsLength = transforms.length;\n      return baseRest(function(args) {\n        var index = -1,\n            length = nativeMin(args.length, funcsLength);\n\n        while (++index < length) {\n          args[index] = transforms[index].call(this, args[index]);\n        }\n        return apply(func, this, args);\n      });\n    });\n\n    /**\n     * Creates a function that invokes `func` with `partials` prepended to the\n     * arguments it receives. This method is like `_.bind` except it does **not**\n     * alter the `this` binding.\n     *\n     * The `_.partial.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for partially applied arguments.\n     *\n     * **Note:** This method doesn't set the \"length\" property of partially\n     * applied functions.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.2.0\n     * @category Function\n     * @param {Function} func The function to partially apply arguments to.\n     * @param {...*} [partials] The arguments to be partially applied.\n     * @returns {Function} Returns the new partially applied function.\n     * @example\n     *\n     * function greet(greeting, name) {\n     *   return greeting + ' ' + name;\n     * }\n     *\n     * var sayHelloTo = _.partial(greet, 'hello');\n     * sayHelloTo('fred');\n     * // => 'hello fred'\n     *\n     * // Partially applied with placeholders.\n     * var greetFred = _.partial(greet, _, 'fred');\n     * greetFred('hi');\n     * // => 'hi fred'\n     */\n    var partial = baseRest(function(func, partials) {\n      var holders = replaceHolders(partials, getHolder(partial));\n      return createWrap(func, WRAP_PARTIAL_FLAG, undefined, partials, holders);\n    });\n\n    /**\n     * This method is like `_.partial` except that partially applied arguments\n     * are appended to the arguments it receives.\n     *\n     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for partially applied arguments.\n     *\n     * **Note:** This method doesn't set the \"length\" property of partially\n     * applied functions.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.0.0\n     * @category Function\n     * @param {Function} func The function to partially apply arguments to.\n     * @param {...*} [partials] The arguments to be partially applied.\n     * @returns {Function} Returns the new partially applied function.\n     * @example\n     *\n     * function greet(greeting, name) {\n     *   return greeting + ' ' + name;\n     * }\n     *\n     * var greetFred = _.partialRight(greet, 'fred');\n     * greetFred('hi');\n     * // => 'hi fred'\n     *\n     * // Partially applied with placeholders.\n     * var sayHelloTo = _.partialRight(greet, 'hello', _);\n     * sayHelloTo('fred');\n     * // => 'hello fred'\n     */\n    var partialRight = baseRest(function(func, partials) {\n      var holders = replaceHolders(partials, getHolder(partialRight));\n      return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined, partials, holders);\n    });\n\n    /**\n     * Creates a function that invokes `func` with arguments arranged according\n     * to the specified `indexes` where the argument value at the first index is\n     * provided as the first argument, the argument value at the second index is\n     * provided as the second argument, and so on.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Function\n     * @param {Function} func The function to rearrange arguments for.\n     * @param {...(number|number[])} indexes The arranged argument indexes.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var rearged = _.rearg(function(a, b, c) {\n     *   return [a, b, c];\n     * }, [2, 0, 1]);\n     *\n     * rearged('b', 'c', 'a')\n     * // => ['a', 'b', 'c']\n     */\n    var rearg = flatRest(function(func, indexes) {\n      return createWrap(func, WRAP_REARG_FLAG, undefined, undefined, undefined, indexes);\n    });\n\n    /**\n     * Creates a function that invokes `func` with the `this` binding of the\n     * created function and arguments from `start` and beyond provided as\n     * an array.\n     *\n     * **Note:** This method is based on the\n     * [rest parameter](https://mdn.io/rest_parameters).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Function\n     * @param {Function} func The function to apply a rest parameter to.\n     * @param {number} [start=func.length-1] The start position of the rest parameter.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var say = _.rest(function(what, names) {\n     *   return what + ' ' + _.initial(names).join(', ') +\n     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);\n     * });\n     *\n     * say('hello', 'fred', 'barney', 'pebbles');\n     * // => 'hello fred, barney, & pebbles'\n     */\n    function rest(func, start) {\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      start = start === undefined ? start : toInteger(start);\n      return baseRest(func, start);\n    }\n\n    /**\n     * Creates a function that invokes `func` with the `this` binding of the\n     * create function and an array of arguments much like\n     * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).\n     *\n     * **Note:** This method is based on the\n     * [spread operator](https://mdn.io/spread_operator).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.2.0\n     * @category Function\n     * @param {Function} func The function to spread arguments over.\n     * @param {number} [start=0] The start position of the spread.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var say = _.spread(function(who, what) {\n     *   return who + ' says ' + what;\n     * });\n     *\n     * say(['fred', 'hello']);\n     * // => 'fred says hello'\n     *\n     * var numbers = Promise.all([\n     *   Promise.resolve(40),\n     *   Promise.resolve(36)\n     * ]);\n     *\n     * numbers.then(_.spread(function(x, y) {\n     *   return x + y;\n     * }));\n     * // => a Promise of 76\n     */\n    function spread(func, start) {\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      start = start == null ? 0 : nativeMax(toInteger(start), 0);\n      return baseRest(function(args) {\n        var array = args[start],\n            otherArgs = castSlice(args, 0, start);\n\n        if (array) {\n          arrayPush(otherArgs, array);\n        }\n        return apply(func, this, otherArgs);\n      });\n    }\n\n    /**\n     * Creates a throttled function that only invokes `func` at most once per\n     * every `wait` milliseconds. The throttled function comes with a `cancel`\n     * method to cancel delayed `func` invocations and a `flush` method to\n     * immediately invoke them. Provide `options` to indicate whether `func`\n     * should be invoked on the leading and/or trailing edge of the `wait`\n     * timeout. The `func` is invoked with the last arguments provided to the\n     * throttled function. Subsequent calls to the throttled function return the\n     * result of the last `func` invocation.\n     *\n     * **Note:** If `leading` and `trailing` options are `true`, `func` is\n     * invoked on the trailing edge of the timeout only if the throttled function\n     * is invoked more than once during the `wait` timeout.\n     *\n     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n     * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n     *\n     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n     * for details over the differences between `_.throttle` and `_.debounce`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to throttle.\n     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.\n     * @param {Object} [options={}] The options object.\n     * @param {boolean} [options.leading=true]\n     *  Specify invoking on the leading edge of the timeout.\n     * @param {boolean} [options.trailing=true]\n     *  Specify invoking on the trailing edge of the timeout.\n     * @returns {Function} Returns the new throttled function.\n     * @example\n     *\n     * // Avoid excessively updating the position while scrolling.\n     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));\n     *\n     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\n     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });\n     * jQuery(element).on('click', throttled);\n     *\n     * // Cancel the trailing throttled invocation.\n     * jQuery(window).on('popstate', throttled.cancel);\n     */\n    function throttle(func, wait, options) {\n      var leading = true,\n          trailing = true;\n\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      if (isObject(options)) {\n        leading = 'leading' in options ? !!options.leading : leading;\n        trailing = 'trailing' in options ? !!options.trailing : trailing;\n      }\n      return debounce(func, wait, {\n        'leading': leading,\n        'maxWait': wait,\n        'trailing': trailing\n      });\n    }\n\n    /**\n     * Creates a function that accepts up to one argument, ignoring any\n     * additional arguments.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Function\n     * @param {Function} func The function to cap arguments for.\n     * @returns {Function} Returns the new capped function.\n     * @example\n     *\n     * _.map(['6', '8', '10'], _.unary(parseInt));\n     * // => [6, 8, 10]\n     */\n    function unary(func) {\n      return ary(func, 1);\n    }\n\n    /**\n     * Creates a function that provides `value` to `wrapper` as its first\n     * argument. Any additional arguments provided to the function are appended\n     * to those provided to the `wrapper`. The wrapper is invoked with the `this`\n     * binding of the created function.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {*} value The value to wrap.\n     * @param {Function} [wrapper=identity] The wrapper function.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var p = _.wrap(_.escape, function(func, text) {\n     *   return '<p>' + func(text) + '</p>';\n     * });\n     *\n     * p('fred, barney, & pebbles');\n     * // => '<p>fred, barney, &amp; pebbles</p>'\n     */\n    function wrap(value, wrapper) {\n      return partial(castFunction(wrapper), value);\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Casts `value` as an array if it's not one.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.4.0\n     * @category Lang\n     * @param {*} value The value to inspect.\n     * @returns {Array} Returns the cast array.\n     * @example\n     *\n     * _.castArray(1);\n     * // => [1]\n     *\n     * _.castArray({ 'a': 1 });\n     * // => [{ 'a': 1 }]\n     *\n     * _.castArray('abc');\n     * // => ['abc']\n     *\n     * _.castArray(null);\n     * // => [null]\n     *\n     * _.castArray(undefined);\n     * // => [undefined]\n     *\n     * _.castArray();\n     * // => []\n     *\n     * var array = [1, 2, 3];\n     * console.log(_.castArray(array) === array);\n     * // => true\n     */\n    function castArray() {\n      if (!arguments.length) {\n        return [];\n      }\n      var value = arguments[0];\n      return isArray(value) ? value : [value];\n    }\n\n    /**\n     * Creates a shallow clone of `value`.\n     *\n     * **Note:** This method is loosely based on the\n     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)\n     * and supports cloning arrays, array buffers, booleans, date objects, maps,\n     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed\n     * arrays. The own enumerable properties of `arguments` objects are cloned\n     * as plain objects. An empty object is returned for uncloneable values such\n     * as error objects, functions, DOM nodes, and WeakMaps.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to clone.\n     * @returns {*} Returns the cloned value.\n     * @see _.cloneDeep\n     * @example\n     *\n     * var objects = [{ 'a': 1 }, { 'b': 2 }];\n     *\n     * var shallow = _.clone(objects);\n     * console.log(shallow[0] === objects[0]);\n     * // => true\n     */\n    function clone(value) {\n      return baseClone(value, CLONE_SYMBOLS_FLAG);\n    }\n\n    /**\n     * This method is like `_.clone` except that it accepts `customizer` which\n     * is invoked to produce the cloned value. If `customizer` returns `undefined`,\n     * cloning is handled by the method instead. The `customizer` is invoked with\n     * up to four arguments; (value [, index|key, object, stack]).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to clone.\n     * @param {Function} [customizer] The function to customize cloning.\n     * @returns {*} Returns the cloned value.\n     * @see _.cloneDeepWith\n     * @example\n     *\n     * function customizer(value) {\n     *   if (_.isElement(value)) {\n     *     return value.cloneNode(false);\n     *   }\n     * }\n     *\n     * var el = _.cloneWith(document.body, customizer);\n     *\n     * console.log(el === document.body);\n     * // => false\n     * console.log(el.nodeName);\n     * // => 'BODY'\n     * console.log(el.childNodes.length);\n     * // => 0\n     */\n    function cloneWith(value, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);\n    }\n\n    /**\n     * This method is like `_.clone` except that it recursively clones `value`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.0.0\n     * @category Lang\n     * @param {*} value The value to recursively clone.\n     * @returns {*} Returns the deep cloned value.\n     * @see _.clone\n     * @example\n     *\n     * var objects = [{ 'a': 1 }, { 'b': 2 }];\n     *\n     * var deep = _.cloneDeep(objects);\n     * console.log(deep[0] === objects[0]);\n     * // => false\n     */\n    function cloneDeep(value) {\n      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);\n    }\n\n    /**\n     * This method is like `_.cloneWith` except that it recursively clones `value`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to recursively clone.\n     * @param {Function} [customizer] The function to customize cloning.\n     * @returns {*} Returns the deep cloned value.\n     * @see _.cloneWith\n     * @example\n     *\n     * function customizer(value) {\n     *   if (_.isElement(value)) {\n     *     return value.cloneNode(true);\n     *   }\n     * }\n     *\n     * var el = _.cloneDeepWith(document.body, customizer);\n     *\n     * console.log(el === document.body);\n     * // => false\n     * console.log(el.nodeName);\n     * // => 'BODY'\n     * console.log(el.childNodes.length);\n     * // => 20\n     */\n    function cloneDeepWith(value, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);\n    }\n\n    /**\n     * Checks if `object` conforms to `source` by invoking the predicate\n     * properties of `source` with the corresponding property values of `object`.\n     *\n     * **Note:** This method is equivalent to `_.conforms` when `source` is\n     * partially applied.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.14.0\n     * @category Lang\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property predicates to conform to.\n     * @returns {boolean} Returns `true` if `object` conforms, else `false`.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2 };\n     *\n     * _.conformsTo(object, { 'b': function(n) { return n > 1; } });\n     * // => true\n     *\n     * _.conformsTo(object, { 'b': function(n) { return n > 2; } });\n     * // => false\n     */\n    function conformsTo(object, source) {\n      return source == null || baseConformsTo(object, source, keys(source));\n    }\n\n    /**\n     * Performs a\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * comparison between two values to determine if they are equivalent.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     * @example\n     *\n     * var object = { 'a': 1 };\n     * var other = { 'a': 1 };\n     *\n     * _.eq(object, object);\n     * // => true\n     *\n     * _.eq(object, other);\n     * // => false\n     *\n     * _.eq('a', 'a');\n     * // => true\n     *\n     * _.eq('a', Object('a'));\n     * // => false\n     *\n     * _.eq(NaN, NaN);\n     * // => true\n     */\n    function eq(value, other) {\n      return value === other || (value !== value && other !== other);\n    }\n\n    /**\n     * Checks if `value` is greater than `other`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.9.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is greater than `other`,\n     *  else `false`.\n     * @see _.lt\n     * @example\n     *\n     * _.gt(3, 1);\n     * // => true\n     *\n     * _.gt(3, 3);\n     * // => false\n     *\n     * _.gt(1, 3);\n     * // => false\n     */\n    var gt = createRelationalOperation(baseGt);\n\n    /**\n     * Checks if `value` is greater than or equal to `other`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.9.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is greater than or equal to\n     *  `other`, else `false`.\n     * @see _.lte\n     * @example\n     *\n     * _.gte(3, 1);\n     * // => true\n     *\n     * _.gte(3, 3);\n     * // => true\n     *\n     * _.gte(1, 3);\n     * // => false\n     */\n    var gte = createRelationalOperation(function(value, other) {\n      return value >= other;\n    });\n\n    /**\n     * Checks if `value` is likely an `arguments` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n     *  else `false`.\n     * @example\n     *\n     * _.isArguments(function() { return arguments; }());\n     * // => true\n     *\n     * _.isArguments([1, 2, 3]);\n     * // => false\n     */\n    var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n      return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n        !propertyIsEnumerable.call(value, 'callee');\n    };\n\n    /**\n     * Checks if `value` is classified as an `Array` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n     * @example\n     *\n     * _.isArray([1, 2, 3]);\n     * // => true\n     *\n     * _.isArray(document.body.children);\n     * // => false\n     *\n     * _.isArray('abc');\n     * // => false\n     *\n     * _.isArray(_.noop);\n     * // => false\n     */\n    var isArray = Array.isArray;\n\n    /**\n     * Checks if `value` is classified as an `ArrayBuffer` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.\n     * @example\n     *\n     * _.isArrayBuffer(new ArrayBuffer(2));\n     * // => true\n     *\n     * _.isArrayBuffer(new Array(2));\n     * // => false\n     */\n    var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;\n\n    /**\n     * Checks if `value` is array-like. A value is considered array-like if it's\n     * not a function and has a `value.length` that's an integer greater than or\n     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n     * @example\n     *\n     * _.isArrayLike([1, 2, 3]);\n     * // => true\n     *\n     * _.isArrayLike(document.body.children);\n     * // => true\n     *\n     * _.isArrayLike('abc');\n     * // => true\n     *\n     * _.isArrayLike(_.noop);\n     * // => false\n     */\n    function isArrayLike(value) {\n      return value != null && isLength(value.length) && !isFunction(value);\n    }\n\n    /**\n     * This method is like `_.isArrayLike` except that it also checks if `value`\n     * is an object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an array-like object,\n     *  else `false`.\n     * @example\n     *\n     * _.isArrayLikeObject([1, 2, 3]);\n     * // => true\n     *\n     * _.isArrayLikeObject(document.body.children);\n     * // => true\n     *\n     * _.isArrayLikeObject('abc');\n     * // => false\n     *\n     * _.isArrayLikeObject(_.noop);\n     * // => false\n     */\n    function isArrayLikeObject(value) {\n      return isObjectLike(value) && isArrayLike(value);\n    }\n\n    /**\n     * Checks if `value` is classified as a boolean primitive or object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.\n     * @example\n     *\n     * _.isBoolean(false);\n     * // => true\n     *\n     * _.isBoolean(null);\n     * // => false\n     */\n    function isBoolean(value) {\n      return value === true || value === false ||\n        (isObjectLike(value) && baseGetTag(value) == boolTag);\n    }\n\n    /**\n     * Checks if `value` is a buffer.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n     * @example\n     *\n     * _.isBuffer(new Buffer(2));\n     * // => true\n     *\n     * _.isBuffer(new Uint8Array(2));\n     * // => false\n     */\n    var isBuffer = nativeIsBuffer || stubFalse;\n\n    /**\n     * Checks if `value` is classified as a `Date` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.\n     * @example\n     *\n     * _.isDate(new Date);\n     * // => true\n     *\n     * _.isDate('Mon April 23 2012');\n     * // => false\n     */\n    var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;\n\n    /**\n     * Checks if `value` is likely a DOM element.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.\n     * @example\n     *\n     * _.isElement(document.body);\n     * // => true\n     *\n     * _.isElement('<body>');\n     * // => false\n     */\n    function isElement(value) {\n      return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);\n    }\n\n    /**\n     * Checks if `value` is an empty object, collection, map, or set.\n     *\n     * Objects are considered empty if they have no own enumerable string keyed\n     * properties.\n     *\n     * Array-like values such as `arguments` objects, arrays, buffers, strings, or\n     * jQuery-like collections are considered empty if they have a `length` of `0`.\n     * Similarly, maps and sets are considered empty if they have a `size` of `0`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is empty, else `false`.\n     * @example\n     *\n     * _.isEmpty(null);\n     * // => true\n     *\n     * _.isEmpty(true);\n     * // => true\n     *\n     * _.isEmpty(1);\n     * // => true\n     *\n     * _.isEmpty([1, 2, 3]);\n     * // => false\n     *\n     * _.isEmpty({ 'a': 1 });\n     * // => false\n     */\n    function isEmpty(value) {\n      if (value == null) {\n        return true;\n      }\n      if (isArrayLike(value) &&\n          (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||\n            isBuffer(value) || isTypedArray(value) || isArguments(value))) {\n        return !value.length;\n      }\n      var tag = getTag(value);\n      if (tag == mapTag || tag == setTag) {\n        return !value.size;\n      }\n      if (isPrototype(value)) {\n        return !baseKeys(value).length;\n      }\n      for (var key in value) {\n        if (hasOwnProperty.call(value, key)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    /**\n     * Performs a deep comparison between two values to determine if they are\n     * equivalent.\n     *\n     * **Note:** This method supports comparing arrays, array buffers, booleans,\n     * date objects, error objects, maps, numbers, `Object` objects, regexes,\n     * sets, strings, symbols, and typed arrays. `Object` objects are compared\n     * by their own, not inherited, enumerable properties. Functions and DOM\n     * nodes are compared by strict equality, i.e. `===`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     * @example\n     *\n     * var object = { 'a': 1 };\n     * var other = { 'a': 1 };\n     *\n     * _.isEqual(object, other);\n     * // => true\n     *\n     * object === other;\n     * // => false\n     */\n    function isEqual(value, other) {\n      return baseIsEqual(value, other);\n    }\n\n    /**\n     * This method is like `_.isEqual` except that it accepts `customizer` which\n     * is invoked to compare values. If `customizer` returns `undefined`, comparisons\n     * are handled by the method instead. The `customizer` is invoked with up to\n     * six arguments: (objValue, othValue [, index|key, object, other, stack]).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @param {Function} [customizer] The function to customize comparisons.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     * @example\n     *\n     * function isGreeting(value) {\n     *   return /^h(?:i|ello)$/.test(value);\n     * }\n     *\n     * function customizer(objValue, othValue) {\n     *   if (isGreeting(objValue) && isGreeting(othValue)) {\n     *     return true;\n     *   }\n     * }\n     *\n     * var array = ['hello', 'goodbye'];\n     * var other = ['hi', 'goodbye'];\n     *\n     * _.isEqualWith(array, other, customizer);\n     * // => true\n     */\n    function isEqualWith(value, other, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      var result = customizer ? customizer(value, other) : undefined;\n      return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result;\n    }\n\n    /**\n     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,\n     * `SyntaxError`, `TypeError`, or `URIError` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.\n     * @example\n     *\n     * _.isError(new Error);\n     * // => true\n     *\n     * _.isError(Error);\n     * // => false\n     */\n    function isError(value) {\n      if (!isObjectLike(value)) {\n        return false;\n      }\n      var tag = baseGetTag(value);\n      return tag == errorTag || tag == domExcTag ||\n        (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));\n    }\n\n    /**\n     * Checks if `value` is a finite primitive number.\n     *\n     * **Note:** This method is based on\n     * [`Number.isFinite`](https://mdn.io/Number/isFinite).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.\n     * @example\n     *\n     * _.isFinite(3);\n     * // => true\n     *\n     * _.isFinite(Number.MIN_VALUE);\n     * // => true\n     *\n     * _.isFinite(Infinity);\n     * // => false\n     *\n     * _.isFinite('3');\n     * // => false\n     */\n    function isFinite(value) {\n      return typeof value == 'number' && nativeIsFinite(value);\n    }\n\n    /**\n     * Checks if `value` is classified as a `Function` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n     * @example\n     *\n     * _.isFunction(_);\n     * // => true\n     *\n     * _.isFunction(/abc/);\n     * // => false\n     */\n    function isFunction(value) {\n      if (!isObject(value)) {\n        return false;\n      }\n      // The use of `Object#toString` avoids issues with the `typeof` operator\n      // in Safari 9 which returns 'object' for typed arrays and other constructors.\n      var tag = baseGetTag(value);\n      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n    }\n\n    /**\n     * Checks if `value` is an integer.\n     *\n     * **Note:** This method is based on\n     * [`Number.isInteger`](https://mdn.io/Number/isInteger).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.\n     * @example\n     *\n     * _.isInteger(3);\n     * // => true\n     *\n     * _.isInteger(Number.MIN_VALUE);\n     * // => false\n     *\n     * _.isInteger(Infinity);\n     * // => false\n     *\n     * _.isInteger('3');\n     * // => false\n     */\n    function isInteger(value) {\n      return typeof value == 'number' && value == toInteger(value);\n    }\n\n    /**\n     * Checks if `value` is a valid array-like length.\n     *\n     * **Note:** This method is loosely based on\n     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n     * @example\n     *\n     * _.isLength(3);\n     * // => true\n     *\n     * _.isLength(Number.MIN_VALUE);\n     * // => false\n     *\n     * _.isLength(Infinity);\n     * // => false\n     *\n     * _.isLength('3');\n     * // => false\n     */\n    function isLength(value) {\n      return typeof value == 'number' &&\n        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n    }\n\n    /**\n     * Checks if `value` is the\n     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n     * @example\n     *\n     * _.isObject({});\n     * // => true\n     *\n     * _.isObject([1, 2, 3]);\n     * // => true\n     *\n     * _.isObject(_.noop);\n     * // => true\n     *\n     * _.isObject(null);\n     * // => false\n     */\n    function isObject(value) {\n      var type = typeof value;\n      return value != null && (type == 'object' || type == 'function');\n    }\n\n    /**\n     * Checks if `value` is object-like. A value is object-like if it's not `null`\n     * and has a `typeof` result of \"object\".\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n     * @example\n     *\n     * _.isObjectLike({});\n     * // => true\n     *\n     * _.isObjectLike([1, 2, 3]);\n     * // => true\n     *\n     * _.isObjectLike(_.noop);\n     * // => false\n     *\n     * _.isObjectLike(null);\n     * // => false\n     */\n    function isObjectLike(value) {\n      return value != null && typeof value == 'object';\n    }\n\n    /**\n     * Checks if `value` is classified as a `Map` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n     * @example\n     *\n     * _.isMap(new Map);\n     * // => true\n     *\n     * _.isMap(new WeakMap);\n     * // => false\n     */\n    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;\n\n    /**\n     * Performs a partial deep comparison between `object` and `source` to\n     * determine if `object` contains equivalent property values.\n     *\n     * **Note:** This method is equivalent to `_.matches` when `source` is\n     * partially applied.\n     *\n     * Partial comparisons will match empty array and empty object `source`\n     * values against any array or object value, respectively. See `_.isEqual`\n     * for a list of supported value comparisons.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property values to match.\n     * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2 };\n     *\n     * _.isMatch(object, { 'b': 2 });\n     * // => true\n     *\n     * _.isMatch(object, { 'b': 1 });\n     * // => false\n     */\n    function isMatch(object, source) {\n      return object === source || baseIsMatch(object, source, getMatchData(source));\n    }\n\n    /**\n     * This method is like `_.isMatch` except that it accepts `customizer` which\n     * is invoked to compare values. If `customizer` returns `undefined`, comparisons\n     * are handled by the method instead. The `customizer` is invoked with five\n     * arguments: (objValue, srcValue, index|key, object, source).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property values to match.\n     * @param {Function} [customizer] The function to customize comparisons.\n     * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n     * @example\n     *\n     * function isGreeting(value) {\n     *   return /^h(?:i|ello)$/.test(value);\n     * }\n     *\n     * function customizer(objValue, srcValue) {\n     *   if (isGreeting(objValue) && isGreeting(srcValue)) {\n     *     return true;\n     *   }\n     * }\n     *\n     * var object = { 'greeting': 'hello' };\n     * var source = { 'greeting': 'hi' };\n     *\n     * _.isMatchWith(object, source, customizer);\n     * // => true\n     */\n    function isMatchWith(object, source, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      return baseIsMatch(object, source, getMatchData(source), customizer);\n    }\n\n    /**\n     * Checks if `value` is `NaN`.\n     *\n     * **Note:** This method is based on\n     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as\n     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for\n     * `undefined` and other non-number values.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n     * @example\n     *\n     * _.isNaN(NaN);\n     * // => true\n     *\n     * _.isNaN(new Number(NaN));\n     * // => true\n     *\n     * isNaN(undefined);\n     * // => true\n     *\n     * _.isNaN(undefined);\n     * // => false\n     */\n    function isNaN(value) {\n      // An `NaN` primitive is the only value that is not equal to itself.\n      // Perform the `toStringTag` check first to avoid errors with some\n      // ActiveX objects in IE.\n      return isNumber(value) && value != +value;\n    }\n\n    /**\n     * Checks if `value` is a pristine native function.\n     *\n     * **Note:** This method can't reliably detect native functions in the presence\n     * of the core-js package because core-js circumvents this kind of detection.\n     * Despite multiple requests, the core-js maintainer has made it clear: any\n     * attempt to fix the detection will be obstructed. As a result, we're left\n     * with little choice but to throw an error. Unfortunately, this also affects\n     * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),\n     * which rely on core-js.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a native function,\n     *  else `false`.\n     * @example\n     *\n     * _.isNative(Array.prototype.push);\n     * // => true\n     *\n     * _.isNative(_);\n     * // => false\n     */\n    function isNative(value) {\n      if (isMaskable(value)) {\n        throw new Error(CORE_ERROR_TEXT);\n      }\n      return baseIsNative(value);\n    }\n\n    /**\n     * Checks if `value` is `null`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.\n     * @example\n     *\n     * _.isNull(null);\n     * // => true\n     *\n     * _.isNull(void 0);\n     * // => false\n     */\n    function isNull(value) {\n      return value === null;\n    }\n\n    /**\n     * Checks if `value` is `null` or `undefined`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.\n     * @example\n     *\n     * _.isNil(null);\n     * // => true\n     *\n     * _.isNil(void 0);\n     * // => true\n     *\n     * _.isNil(NaN);\n     * // => false\n     */\n    function isNil(value) {\n      return value == null;\n    }\n\n    /**\n     * Checks if `value` is classified as a `Number` primitive or object.\n     *\n     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are\n     * classified as numbers, use the `_.isFinite` method.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a number, else `false`.\n     * @example\n     *\n     * _.isNumber(3);\n     * // => true\n     *\n     * _.isNumber(Number.MIN_VALUE);\n     * // => true\n     *\n     * _.isNumber(Infinity);\n     * // => true\n     *\n     * _.isNumber('3');\n     * // => false\n     */\n    function isNumber(value) {\n      return typeof value == 'number' ||\n        (isObjectLike(value) && baseGetTag(value) == numberTag);\n    }\n\n    /**\n     * Checks if `value` is a plain object, that is, an object created by the\n     * `Object` constructor or one with a `[[Prototype]]` of `null`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.8.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     * }\n     *\n     * _.isPlainObject(new Foo);\n     * // => false\n     *\n     * _.isPlainObject([1, 2, 3]);\n     * // => false\n     *\n     * _.isPlainObject({ 'x': 0, 'y': 0 });\n     * // => true\n     *\n     * _.isPlainObject(Object.create(null));\n     * // => true\n     */\n    function isPlainObject(value) {\n      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {\n        return false;\n      }\n      var proto = getPrototype(value);\n      if (proto === null) {\n        return true;\n      }\n      var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;\n      return typeof Ctor == 'function' && Ctor instanceof Ctor &&\n        funcToString.call(Ctor) == objectCtorString;\n    }\n\n    /**\n     * Checks if `value` is classified as a `RegExp` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.\n     * @example\n     *\n     * _.isRegExp(/abc/);\n     * // => true\n     *\n     * _.isRegExp('/abc/');\n     * // => false\n     */\n    var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;\n\n    /**\n     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754\n     * double precision number which isn't the result of a rounded unsafe integer.\n     *\n     * **Note:** This method is based on\n     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.\n     * @example\n     *\n     * _.isSafeInteger(3);\n     * // => true\n     *\n     * _.isSafeInteger(Number.MIN_VALUE);\n     * // => false\n     *\n     * _.isSafeInteger(Infinity);\n     * // => false\n     *\n     * _.isSafeInteger('3');\n     * // => false\n     */\n    function isSafeInteger(value) {\n      return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;\n    }\n\n    /**\n     * Checks if `value` is classified as a `Set` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n     * @example\n     *\n     * _.isSet(new Set);\n     * // => true\n     *\n     * _.isSet(new WeakSet);\n     * // => false\n     */\n    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;\n\n    /**\n     * Checks if `value` is classified as a `String` primitive or object.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a string, else `false`.\n     * @example\n     *\n     * _.isString('abc');\n     * // => true\n     *\n     * _.isString(1);\n     * // => false\n     */\n    function isString(value) {\n      return typeof value == 'string' ||\n        (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);\n    }\n\n    /**\n     * Checks if `value` is classified as a `Symbol` primitive or object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n     * @example\n     *\n     * _.isSymbol(Symbol.iterator);\n     * // => true\n     *\n     * _.isSymbol('abc');\n     * // => false\n     */\n    function isSymbol(value) {\n      return typeof value == 'symbol' ||\n        (isObjectLike(value) && baseGetTag(value) == symbolTag);\n    }\n\n    /**\n     * Checks if `value` is classified as a typed array.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n     * @example\n     *\n     * _.isTypedArray(new Uint8Array);\n     * // => true\n     *\n     * _.isTypedArray([]);\n     * // => false\n     */\n    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\n    /**\n     * Checks if `value` is `undefined`.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.\n     * @example\n     *\n     * _.isUndefined(void 0);\n     * // => true\n     *\n     * _.isUndefined(null);\n     * // => false\n     */\n    function isUndefined(value) {\n      return value === undefined;\n    }\n\n    /**\n     * Checks if `value` is classified as a `WeakMap` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.\n     * @example\n     *\n     * _.isWeakMap(new WeakMap);\n     * // => true\n     *\n     * _.isWeakMap(new Map);\n     * // => false\n     */\n    function isWeakMap(value) {\n      return isObjectLike(value) && getTag(value) == weakMapTag;\n    }\n\n    /**\n     * Checks if `value` is classified as a `WeakSet` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.\n     * @example\n     *\n     * _.isWeakSet(new WeakSet);\n     * // => true\n     *\n     * _.isWeakSet(new Set);\n     * // => false\n     */\n    function isWeakSet(value) {\n      return isObjectLike(value) && baseGetTag(value) == weakSetTag;\n    }\n\n    /**\n     * Checks if `value` is less than `other`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.9.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is less than `other`,\n     *  else `false`.\n     * @see _.gt\n     * @example\n     *\n     * _.lt(1, 3);\n     * // => true\n     *\n     * _.lt(3, 3);\n     * // => false\n     *\n     * _.lt(3, 1);\n     * // => false\n     */\n    var lt = createRelationalOperation(baseLt);\n\n    /**\n     * Checks if `value` is less than or equal to `other`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.9.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is less than or equal to\n     *  `other`, else `false`.\n     * @see _.gte\n     * @example\n     *\n     * _.lte(1, 3);\n     * // => true\n     *\n     * _.lte(3, 3);\n     * // => true\n     *\n     * _.lte(3, 1);\n     * // => false\n     */\n    var lte = createRelationalOperation(function(value, other) {\n      return value <= other;\n    });\n\n    /**\n     * Converts `value` to an array.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {Array} Returns the converted array.\n     * @example\n     *\n     * _.toArray({ 'a': 1, 'b': 2 });\n     * // => [1, 2]\n     *\n     * _.toArray('abc');\n     * // => ['a', 'b', 'c']\n     *\n     * _.toArray(1);\n     * // => []\n     *\n     * _.toArray(null);\n     * // => []\n     */\n    function toArray(value) {\n      if (!value) {\n        return [];\n      }\n      if (isArrayLike(value)) {\n        return isString(value) ? stringToArray(value) : copyArray(value);\n      }\n      if (symIterator && value[symIterator]) {\n        return iteratorToArray(value[symIterator]());\n      }\n      var tag = getTag(value),\n          func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);\n\n      return func(value);\n    }\n\n    /**\n     * Converts `value` to a finite number.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.12.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {number} Returns the converted number.\n     * @example\n     *\n     * _.toFinite(3.2);\n     * // => 3.2\n     *\n     * _.toFinite(Number.MIN_VALUE);\n     * // => 5e-324\n     *\n     * _.toFinite(Infinity);\n     * // => 1.7976931348623157e+308\n     *\n     * _.toFinite('3.2');\n     * // => 3.2\n     */\n    function toFinite(value) {\n      if (!value) {\n        return value === 0 ? value : 0;\n      }\n      value = toNumber(value);\n      if (value === INFINITY || value === -INFINITY) {\n        var sign = (value < 0 ? -1 : 1);\n        return sign * MAX_INTEGER;\n      }\n      return value === value ? value : 0;\n    }\n\n    /**\n     * Converts `value` to an integer.\n     *\n     * **Note:** This method is loosely based on\n     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {number} Returns the converted integer.\n     * @example\n     *\n     * _.toInteger(3.2);\n     * // => 3\n     *\n     * _.toInteger(Number.MIN_VALUE);\n     * // => 0\n     *\n     * _.toInteger(Infinity);\n     * // => 1.7976931348623157e+308\n     *\n     * _.toInteger('3.2');\n     * // => 3\n     */\n    function toInteger(value) {\n      var result = toFinite(value),\n          remainder = result % 1;\n\n      return result === result ? (remainder ? result - remainder : result) : 0;\n    }\n\n    /**\n     * Converts `value` to an integer suitable for use as the length of an\n     * array-like object.\n     *\n     * **Note:** This method is based on\n     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {number} Returns the converted integer.\n     * @example\n     *\n     * _.toLength(3.2);\n     * // => 3\n     *\n     * _.toLength(Number.MIN_VALUE);\n     * // => 0\n     *\n     * _.toLength(Infinity);\n     * // => 4294967295\n     *\n     * _.toLength('3.2');\n     * // => 3\n     */\n    function toLength(value) {\n      return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;\n    }\n\n    /**\n     * Converts `value` to a number.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to process.\n     * @returns {number} Returns the number.\n     * @example\n     *\n     * _.toNumber(3.2);\n     * // => 3.2\n     *\n     * _.toNumber(Number.MIN_VALUE);\n     * // => 5e-324\n     *\n     * _.toNumber(Infinity);\n     * // => Infinity\n     *\n     * _.toNumber('3.2');\n     * // => 3.2\n     */\n    function toNumber(value) {\n      if (typeof value == 'number') {\n        return value;\n      }\n      if (isSymbol(value)) {\n        return NAN;\n      }\n      if (isObject(value)) {\n        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n        value = isObject(other) ? (other + '') : other;\n      }\n      if (typeof value != 'string') {\n        return value === 0 ? value : +value;\n      }\n      value = baseTrim(value);\n      var isBinary = reIsBinary.test(value);\n      return (isBinary || reIsOctal.test(value))\n        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n        : (reIsBadHex.test(value) ? NAN : +value);\n    }\n\n    /**\n     * Converts `value` to a plain object flattening inherited enumerable string\n     * keyed properties of `value` to own properties of the plain object.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {Object} Returns the converted plain object.\n     * @example\n     *\n     * function Foo() {\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.assign({ 'a': 1 }, new Foo);\n     * // => { 'a': 1, 'b': 2 }\n     *\n     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));\n     * // => { 'a': 1, 'b': 2, 'c': 3 }\n     */\n    function toPlainObject(value) {\n      return copyObject(value, keysIn(value));\n    }\n\n    /**\n     * Converts `value` to a safe integer. A safe integer can be compared and\n     * represented correctly.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {number} Returns the converted integer.\n     * @example\n     *\n     * _.toSafeInteger(3.2);\n     * // => 3\n     *\n     * _.toSafeInteger(Number.MIN_VALUE);\n     * // => 0\n     *\n     * _.toSafeInteger(Infinity);\n     * // => 9007199254740991\n     *\n     * _.toSafeInteger('3.2');\n     * // => 3\n     */\n    function toSafeInteger(value) {\n      return value\n        ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER)\n        : (value === 0 ? value : 0);\n    }\n\n    /**\n     * Converts `value` to a string. An empty string is returned for `null`\n     * and `undefined` values. The sign of `-0` is preserved.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {string} Returns the converted string.\n     * @example\n     *\n     * _.toString(null);\n     * // => ''\n     *\n     * _.toString(-0);\n     * // => '-0'\n     *\n     * _.toString([1, 2, 3]);\n     * // => '1,2,3'\n     */\n    function toString(value) {\n      return value == null ? '' : baseToString(value);\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Assigns own enumerable string keyed properties of source objects to the\n     * destination object. Source objects are applied from left to right.\n     * Subsequent sources overwrite property assignments of previous sources.\n     *\n     * **Note:** This method mutates `object` and is loosely based on\n     * [`Object.assign`](https://mdn.io/Object/assign).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.10.0\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @see _.assignIn\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     * }\n     *\n     * function Bar() {\n     *   this.c = 3;\n     * }\n     *\n     * Foo.prototype.b = 2;\n     * Bar.prototype.d = 4;\n     *\n     * _.assign({ 'a': 0 }, new Foo, new Bar);\n     * // => { 'a': 1, 'c': 3 }\n     */\n    var assign = createAssigner(function(object, source) {\n      if (isPrototype(source) || isArrayLike(source)) {\n        copyObject(source, keys(source), object);\n        return;\n      }\n      for (var key in source) {\n        if (hasOwnProperty.call(source, key)) {\n          assignValue(object, key, source[key]);\n        }\n      }\n    });\n\n    /**\n     * This method is like `_.assign` except that it iterates over own and\n     * inherited source properties.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @alias extend\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @see _.assign\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     * }\n     *\n     * function Bar() {\n     *   this.c = 3;\n     * }\n     *\n     * Foo.prototype.b = 2;\n     * Bar.prototype.d = 4;\n     *\n     * _.assignIn({ 'a': 0 }, new Foo, new Bar);\n     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }\n     */\n    var assignIn = createAssigner(function(object, source) {\n      copyObject(source, keysIn(source), object);\n    });\n\n    /**\n     * This method is like `_.assignIn` except that it accepts `customizer`\n     * which is invoked to produce the assigned values. If `customizer` returns\n     * `undefined`, assignment is handled by the method instead. The `customizer`\n     * is invoked with five arguments: (objValue, srcValue, key, object, source).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @alias extendWith\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} sources The source objects.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @see _.assignWith\n     * @example\n     *\n     * function customizer(objValue, srcValue) {\n     *   return _.isUndefined(objValue) ? srcValue : objValue;\n     * }\n     *\n     * var defaults = _.partialRight(_.assignInWith, customizer);\n     *\n     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n     * // => { 'a': 1, 'b': 2 }\n     */\n    var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {\n      copyObject(source, keysIn(source), object, customizer);\n    });\n\n    /**\n     * This method is like `_.assign` except that it accepts `customizer`\n     * which is invoked to produce the assigned values. If `customizer` returns\n     * `undefined`, assignment is handled by the method instead. The `customizer`\n     * is invoked with five arguments: (objValue, srcValue, key, object, source).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} sources The source objects.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @see _.assignInWith\n     * @example\n     *\n     * function customizer(objValue, srcValue) {\n     *   return _.isUndefined(objValue) ? srcValue : objValue;\n     * }\n     *\n     * var defaults = _.partialRight(_.assignWith, customizer);\n     *\n     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n     * // => { 'a': 1, 'b': 2 }\n     */\n    var assignWith = createAssigner(function(object, source, srcIndex, customizer) {\n      copyObject(source, keys(source), object, customizer);\n    });\n\n    /**\n     * Creates an array of values corresponding to `paths` of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.0.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {...(string|string[])} [paths] The property paths to pick.\n     * @returns {Array} Returns the picked values.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };\n     *\n     * _.at(object, ['a[0].b.c', 'a[1]']);\n     * // => [3, 4]\n     */\n    var at = flatRest(baseAt);\n\n    /**\n     * Creates an object that inherits from the `prototype` object. If a\n     * `properties` object is given, its own enumerable string keyed properties\n     * are assigned to the created object.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.3.0\n     * @category Object\n     * @param {Object} prototype The object to inherit from.\n     * @param {Object} [properties] The properties to assign to the object.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * function Shape() {\n     *   this.x = 0;\n     *   this.y = 0;\n     * }\n     *\n     * function Circle() {\n     *   Shape.call(this);\n     * }\n     *\n     * Circle.prototype = _.create(Shape.prototype, {\n     *   'constructor': Circle\n     * });\n     *\n     * var circle = new Circle;\n     * circle instanceof Circle;\n     * // => true\n     *\n     * circle instanceof Shape;\n     * // => true\n     */\n    function create(prototype, properties) {\n      var result = baseCreate(prototype);\n      return properties == null ? result : baseAssign(result, properties);\n    }\n\n    /**\n     * Assigns own and inherited enumerable string keyed properties of source\n     * objects to the destination object for all destination properties that\n     * resolve to `undefined`. Source objects are applied from left to right.\n     * Once a property is set, additional values of the same property are ignored.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @see _.defaultsDeep\n     * @example\n     *\n     * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n     * // => { 'a': 1, 'b': 2 }\n     */\n    var defaults = baseRest(function(object, sources) {\n      object = Object(object);\n\n      var index = -1;\n      var length = sources.length;\n      var guard = length > 2 ? sources[2] : undefined;\n\n      if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n        length = 1;\n      }\n\n      while (++index < length) {\n        var source = sources[index];\n        var props = keysIn(source);\n        var propsIndex = -1;\n        var propsLength = props.length;\n\n        while (++propsIndex < propsLength) {\n          var key = props[propsIndex];\n          var value = object[key];\n\n          if (value === undefined ||\n              (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {\n            object[key] = source[key];\n          }\n        }\n      }\n\n      return object;\n    });\n\n    /**\n     * This method is like `_.defaults` except that it recursively assigns\n     * default properties.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.10.0\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @see _.defaults\n     * @example\n     *\n     * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });\n     * // => { 'a': { 'b': 2, 'c': 3 } }\n     */\n    var defaultsDeep = baseRest(function(args) {\n      args.push(undefined, customDefaultsMerge);\n      return apply(mergeWith, undefined, args);\n    });\n\n    /**\n     * This method is like `_.find` except that it returns the key of the first\n     * element `predicate` returns truthy for instead of the element itself.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.1.0\n     * @category Object\n     * @param {Object} object The object to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {string|undefined} Returns the key of the matched element,\n     *  else `undefined`.\n     * @example\n     *\n     * var users = {\n     *   'barney':  { 'age': 36, 'active': true },\n     *   'fred':    { 'age': 40, 'active': false },\n     *   'pebbles': { 'age': 1,  'active': true }\n     * };\n     *\n     * _.findKey(users, function(o) { return o.age < 40; });\n     * // => 'barney' (iteration order is not guaranteed)\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.findKey(users, { 'age': 1, 'active': true });\n     * // => 'pebbles'\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.findKey(users, ['active', false]);\n     * // => 'fred'\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.findKey(users, 'active');\n     * // => 'barney'\n     */\n    function findKey(object, predicate) {\n      return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);\n    }\n\n    /**\n     * This method is like `_.findKey` except that it iterates over elements of\n     * a collection in the opposite order.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Object\n     * @param {Object} object The object to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {string|undefined} Returns the key of the matched element,\n     *  else `undefined`.\n     * @example\n     *\n     * var users = {\n     *   'barney':  { 'age': 36, 'active': true },\n     *   'fred':    { 'age': 40, 'active': false },\n     *   'pebbles': { 'age': 1,  'active': true }\n     * };\n     *\n     * _.findLastKey(users, function(o) { return o.age < 40; });\n     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.findLastKey(users, { 'age': 36, 'active': true });\n     * // => 'barney'\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.findLastKey(users, ['active', false]);\n     * // => 'fred'\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.findLastKey(users, 'active');\n     * // => 'pebbles'\n     */\n    function findLastKey(object, predicate) {\n      return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);\n    }\n\n    /**\n     * Iterates over own and inherited enumerable string keyed properties of an\n     * object and invokes `iteratee` for each property. The iteratee is invoked\n     * with three arguments: (value, key, object). Iteratee functions may exit\n     * iteration early by explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.3.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     * @see _.forInRight\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forIn(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).\n     */\n    function forIn(object, iteratee) {\n      return object == null\n        ? object\n        : baseFor(object, getIteratee(iteratee, 3), keysIn);\n    }\n\n    /**\n     * This method is like `_.forIn` except that it iterates over properties of\n     * `object` in the opposite order.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     * @see _.forIn\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forInRight(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.\n     */\n    function forInRight(object, iteratee) {\n      return object == null\n        ? object\n        : baseForRight(object, getIteratee(iteratee, 3), keysIn);\n    }\n\n    /**\n     * Iterates over own enumerable string keyed properties of an object and\n     * invokes `iteratee` for each property. The iteratee is invoked with three\n     * arguments: (value, key, object). Iteratee functions may exit iteration\n     * early by explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.3.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     * @see _.forOwnRight\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forOwn(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => Logs 'a' then 'b' (iteration order is not guaranteed).\n     */\n    function forOwn(object, iteratee) {\n      return object && baseForOwn(object, getIteratee(iteratee, 3));\n    }\n\n    /**\n     * This method is like `_.forOwn` except that it iterates over properties of\n     * `object` in the opposite order.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     * @see _.forOwn\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forOwnRight(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.\n     */\n    function forOwnRight(object, iteratee) {\n      return object && baseForOwnRight(object, getIteratee(iteratee, 3));\n    }\n\n    /**\n     * Creates an array of function property names from own enumerable properties\n     * of `object`.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to inspect.\n     * @returns {Array} Returns the function names.\n     * @see _.functionsIn\n     * @example\n     *\n     * function Foo() {\n     *   this.a = _.constant('a');\n     *   this.b = _.constant('b');\n     * }\n     *\n     * Foo.prototype.c = _.constant('c');\n     *\n     * _.functions(new Foo);\n     * // => ['a', 'b']\n     */\n    function functions(object) {\n      return object == null ? [] : baseFunctions(object, keys(object));\n    }\n\n    /**\n     * Creates an array of function property names from own and inherited\n     * enumerable properties of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to inspect.\n     * @returns {Array} Returns the function names.\n     * @see _.functions\n     * @example\n     *\n     * function Foo() {\n     *   this.a = _.constant('a');\n     *   this.b = _.constant('b');\n     * }\n     *\n     * Foo.prototype.c = _.constant('c');\n     *\n     * _.functionsIn(new Foo);\n     * // => ['a', 'b', 'c']\n     */\n    function functionsIn(object) {\n      return object == null ? [] : baseFunctions(object, keysIn(object));\n    }\n\n    /**\n     * Gets the value at `path` of `object`. If the resolved value is\n     * `undefined`, the `defaultValue` is returned in its place.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.7.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the property to get.\n     * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n     * @returns {*} Returns the resolved value.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n     *\n     * _.get(object, 'a[0].b.c');\n     * // => 3\n     *\n     * _.get(object, ['a', '0', 'b', 'c']);\n     * // => 3\n     *\n     * _.get(object, 'a.b.c', 'default');\n     * // => 'default'\n     */\n    function get(object, path, defaultValue) {\n      var result = object == null ? undefined : baseGet(object, path);\n      return result === undefined ? defaultValue : result;\n    }\n\n    /**\n     * Checks if `path` is a direct property of `object`.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path to check.\n     * @returns {boolean} Returns `true` if `path` exists, else `false`.\n     * @example\n     *\n     * var object = { 'a': { 'b': 2 } };\n     * var other = _.create({ 'a': _.create({ 'b': 2 }) });\n     *\n     * _.has(object, 'a');\n     * // => true\n     *\n     * _.has(object, 'a.b');\n     * // => true\n     *\n     * _.has(object, ['a', 'b']);\n     * // => true\n     *\n     * _.has(other, 'a');\n     * // => false\n     */\n    function has(object, path) {\n      return object != null && hasPath(object, path, baseHas);\n    }\n\n    /**\n     * Checks if `path` is a direct or inherited property of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path to check.\n     * @returns {boolean} Returns `true` if `path` exists, else `false`.\n     * @example\n     *\n     * var object = _.create({ 'a': _.create({ 'b': 2 }) });\n     *\n     * _.hasIn(object, 'a');\n     * // => true\n     *\n     * _.hasIn(object, 'a.b');\n     * // => true\n     *\n     * _.hasIn(object, ['a', 'b']);\n     * // => true\n     *\n     * _.hasIn(object, 'b');\n     * // => false\n     */\n    function hasIn(object, path) {\n      return object != null && hasPath(object, path, baseHasIn);\n    }\n\n    /**\n     * Creates an object composed of the inverted keys and values of `object`.\n     * If `object` contains duplicate values, subsequent values overwrite\n     * property assignments of previous values.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.7.0\n     * @category Object\n     * @param {Object} object The object to invert.\n     * @returns {Object} Returns the new inverted object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2, 'c': 1 };\n     *\n     * _.invert(object);\n     * // => { '1': 'c', '2': 'b' }\n     */\n    var invert = createInverter(function(result, value, key) {\n      if (value != null &&\n          typeof value.toString != 'function') {\n        value = nativeObjectToString.call(value);\n      }\n\n      result[value] = key;\n    }, constant(identity));\n\n    /**\n     * This method is like `_.invert` except that the inverted object is generated\n     * from the results of running each element of `object` thru `iteratee`. The\n     * corresponding inverted value of each inverted key is an array of keys\n     * responsible for generating the inverted value. The iteratee is invoked\n     * with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.1.0\n     * @category Object\n     * @param {Object} object The object to invert.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Object} Returns the new inverted object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2, 'c': 1 };\n     *\n     * _.invertBy(object);\n     * // => { '1': ['a', 'c'], '2': ['b'] }\n     *\n     * _.invertBy(object, function(value) {\n     *   return 'group' + value;\n     * });\n     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }\n     */\n    var invertBy = createInverter(function(result, value, key) {\n      if (value != null &&\n          typeof value.toString != 'function') {\n        value = nativeObjectToString.call(value);\n      }\n\n      if (hasOwnProperty.call(result, value)) {\n        result[value].push(key);\n      } else {\n        result[value] = [key];\n      }\n    }, getIteratee);\n\n    /**\n     * Invokes the method at `path` of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the method to invoke.\n     * @param {...*} [args] The arguments to invoke the method with.\n     * @returns {*} Returns the result of the invoked method.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };\n     *\n     * _.invoke(object, 'a[0].b.c.slice', 1, 3);\n     * // => [2, 3]\n     */\n    var invoke = baseRest(baseInvoke);\n\n    /**\n     * Creates an array of the own enumerable property names of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects. See the\n     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n     * for more details.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.keys(new Foo);\n     * // => ['a', 'b'] (iteration order is not guaranteed)\n     *\n     * _.keys('hi');\n     * // => ['0', '1']\n     */\n    function keys(object) {\n      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n    }\n\n    /**\n     * Creates an array of the own and inherited enumerable property names of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.keysIn(new Foo);\n     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n     */\n    function keysIn(object) {\n      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);\n    }\n\n    /**\n     * The opposite of `_.mapValues`; this method creates an object with the\n     * same values as `object` and keys generated by running each own enumerable\n     * string keyed property of `object` thru `iteratee`. The iteratee is invoked\n     * with three arguments: (value, key, object).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.8.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns the new mapped object.\n     * @see _.mapValues\n     * @example\n     *\n     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {\n     *   return key + value;\n     * });\n     * // => { 'a1': 1, 'b2': 2 }\n     */\n    function mapKeys(object, iteratee) {\n      var result = {};\n      iteratee = getIteratee(iteratee, 3);\n\n      baseForOwn(object, function(value, key, object) {\n        baseAssignValue(result, iteratee(value, key, object), value);\n      });\n      return result;\n    }\n\n    /**\n     * Creates an object with the same keys as `object` and values generated\n     * by running each own enumerable string keyed property of `object` thru\n     * `iteratee`. The iteratee is invoked with three arguments:\n     * (value, key, object).\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns the new mapped object.\n     * @see _.mapKeys\n     * @example\n     *\n     * var users = {\n     *   'fred':    { 'user': 'fred',    'age': 40 },\n     *   'pebbles': { 'user': 'pebbles', 'age': 1 }\n     * };\n     *\n     * _.mapValues(users, function(o) { return o.age; });\n     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.mapValues(users, 'age');\n     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)\n     */\n    function mapValues(object, iteratee) {\n      var result = {};\n      iteratee = getIteratee(iteratee, 3);\n\n      baseForOwn(object, function(value, key, object) {\n        baseAssignValue(result, key, iteratee(value, key, object));\n      });\n      return result;\n    }\n\n    /**\n     * This method is like `_.assign` except that it recursively merges own and\n     * inherited enumerable string keyed properties of source objects into the\n     * destination object. Source properties that resolve to `undefined` are\n     * skipped if a destination value exists. Array and plain object properties\n     * are merged recursively. Other objects and value types are overridden by\n     * assignment. Source objects are applied from left to right. Subsequent\n     * sources overwrite property assignments of previous sources.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.5.0\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = {\n     *   'a': [{ 'b': 2 }, { 'd': 4 }]\n     * };\n     *\n     * var other = {\n     *   'a': [{ 'c': 3 }, { 'e': 5 }]\n     * };\n     *\n     * _.merge(object, other);\n     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }\n     */\n    var merge = createAssigner(function(object, source, srcIndex) {\n      baseMerge(object, source, srcIndex);\n    });\n\n    /**\n     * This method is like `_.merge` except that it accepts `customizer` which\n     * is invoked to produce the merged values of the destination and source\n     * properties. If `customizer` returns `undefined`, merging is handled by the\n     * method instead. The `customizer` is invoked with six arguments:\n     * (objValue, srcValue, key, object, source, stack).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} sources The source objects.\n     * @param {Function} customizer The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * function customizer(objValue, srcValue) {\n     *   if (_.isArray(objValue)) {\n     *     return objValue.concat(srcValue);\n     *   }\n     * }\n     *\n     * var object = { 'a': [1], 'b': [2] };\n     * var other = { 'a': [3], 'b': [4] };\n     *\n     * _.mergeWith(object, other, customizer);\n     * // => { 'a': [1, 3], 'b': [2, 4] }\n     */\n    var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {\n      baseMerge(object, source, srcIndex, customizer);\n    });\n\n    /**\n     * The opposite of `_.pick`; this method creates an object composed of the\n     * own and inherited enumerable property paths of `object` that are not omitted.\n     *\n     * **Note:** This method is considerably slower than `_.pick`.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The source object.\n     * @param {...(string|string[])} [paths] The property paths to omit.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': '2', 'c': 3 };\n     *\n     * _.omit(object, ['a', 'c']);\n     * // => { 'b': '2' }\n     */\n    var omit = flatRest(function(object, paths) {\n      var result = {};\n      if (object == null) {\n        return result;\n      }\n      var isDeep = false;\n      paths = arrayMap(paths, function(path) {\n        path = castPath(path, object);\n        isDeep || (isDeep = path.length > 1);\n        return path;\n      });\n      copyObject(object, getAllKeysIn(object), result);\n      if (isDeep) {\n        result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);\n      }\n      var length = paths.length;\n      while (length--) {\n        baseUnset(result, paths[length]);\n      }\n      return result;\n    });\n\n    /**\n     * The opposite of `_.pickBy`; this method creates an object composed of\n     * the own and inherited enumerable string keyed properties of `object` that\n     * `predicate` doesn't return truthy for. The predicate is invoked with two\n     * arguments: (value, key).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The source object.\n     * @param {Function} [predicate=_.identity] The function invoked per property.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': '2', 'c': 3 };\n     *\n     * _.omitBy(object, _.isNumber);\n     * // => { 'b': '2' }\n     */\n    function omitBy(object, predicate) {\n      return pickBy(object, negate(getIteratee(predicate)));\n    }\n\n    /**\n     * Creates an object composed of the picked `object` properties.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The source object.\n     * @param {...(string|string[])} [paths] The property paths to pick.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': '2', 'c': 3 };\n     *\n     * _.pick(object, ['a', 'c']);\n     * // => { 'a': 1, 'c': 3 }\n     */\n    var pick = flatRest(function(object, paths) {\n      return object == null ? {} : basePick(object, paths);\n    });\n\n    /**\n     * Creates an object composed of the `object` properties `predicate` returns\n     * truthy for. The predicate is invoked with two arguments: (value, key).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The source object.\n     * @param {Function} [predicate=_.identity] The function invoked per property.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': '2', 'c': 3 };\n     *\n     * _.pickBy(object, _.isNumber);\n     * // => { 'a': 1, 'c': 3 }\n     */\n    function pickBy(object, predicate) {\n      if (object == null) {\n        return {};\n      }\n      var props = arrayMap(getAllKeysIn(object), function(prop) {\n        return [prop];\n      });\n      predicate = getIteratee(predicate);\n      return basePickBy(object, props, function(value, path) {\n        return predicate(value, path[0]);\n      });\n    }\n\n    /**\n     * This method is like `_.get` except that if the resolved value is a\n     * function it's invoked with the `this` binding of its parent object and\n     * its result is returned.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the property to resolve.\n     * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n     * @returns {*} Returns the resolved value.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };\n     *\n     * _.result(object, 'a[0].b.c1');\n     * // => 3\n     *\n     * _.result(object, 'a[0].b.c2');\n     * // => 4\n     *\n     * _.result(object, 'a[0].b.c3', 'default');\n     * // => 'default'\n     *\n     * _.result(object, 'a[0].b.c3', _.constant('default'));\n     * // => 'default'\n     */\n    function result(object, path, defaultValue) {\n      path = castPath(path, object);\n\n      var index = -1,\n          length = path.length;\n\n      // Ensure the loop is entered when path is empty.\n      if (!length) {\n        length = 1;\n        object = undefined;\n      }\n      while (++index < length) {\n        var value = object == null ? undefined : object[toKey(path[index])];\n        if (value === undefined) {\n          index = length;\n          value = defaultValue;\n        }\n        object = isFunction(value) ? value.call(object) : value;\n      }\n      return object;\n    }\n\n    /**\n     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,\n     * it's created. Arrays are created for missing index properties while objects\n     * are created for all other missing properties. Use `_.setWith` to customize\n     * `path` creation.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.7.0\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n     *\n     * _.set(object, 'a[0].b.c', 4);\n     * console.log(object.a[0].b.c);\n     * // => 4\n     *\n     * _.set(object, ['x', '0', 'y', 'z'], 5);\n     * console.log(object.x[0].y.z);\n     * // => 5\n     */\n    function set(object, path, value) {\n      return object == null ? object : baseSet(object, path, value);\n    }\n\n    /**\n     * This method is like `_.set` except that it accepts `customizer` which is\n     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`\n     * path creation is handled by the method instead. The `customizer` is invoked\n     * with three arguments: (nsValue, key, nsObject).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {*} value The value to set.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = {};\n     *\n     * _.setWith(object, '[0][1]', 'a', Object);\n     * // => { '0': { '1': 'a' } }\n     */\n    function setWith(object, path, value, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      return object == null ? object : baseSet(object, path, value, customizer);\n    }\n\n    /**\n     * Creates an array of own enumerable string keyed-value pairs for `object`\n     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its\n     * entries are returned.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @alias entries\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the key-value pairs.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.toPairs(new Foo);\n     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)\n     */\n    var toPairs = createToPairs(keys);\n\n    /**\n     * Creates an array of own and inherited enumerable string keyed-value pairs\n     * for `object` which can be consumed by `_.fromPairs`. If `object` is a map\n     * or set, its entries are returned.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @alias entriesIn\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the key-value pairs.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.toPairsIn(new Foo);\n     * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)\n     */\n    var toPairsIn = createToPairs(keysIn);\n\n    /**\n     * An alternative to `_.reduce`; this method transforms `object` to a new\n     * `accumulator` object which is the result of running each of its own\n     * enumerable string keyed properties thru `iteratee`, with each invocation\n     * potentially mutating the `accumulator` object. If `accumulator` is not\n     * provided, a new object with the same `[[Prototype]]` will be used. The\n     * iteratee is invoked with four arguments: (accumulator, value, key, object).\n     * Iteratee functions may exit iteration early by explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.3.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [accumulator] The custom accumulator value.\n     * @returns {*} Returns the accumulated value.\n     * @example\n     *\n     * _.transform([2, 3, 4], function(result, n) {\n     *   result.push(n *= n);\n     *   return n % 2 == 0;\n     * }, []);\n     * // => [4, 9]\n     *\n     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {\n     *   (result[value] || (result[value] = [])).push(key);\n     * }, {});\n     * // => { '1': ['a', 'c'], '2': ['b'] }\n     */\n    function transform(object, iteratee, accumulator) {\n      var isArr = isArray(object),\n          isArrLike = isArr || isBuffer(object) || isTypedArray(object);\n\n      iteratee = getIteratee(iteratee, 4);\n      if (accumulator == null) {\n        var Ctor = object && object.constructor;\n        if (isArrLike) {\n          accumulator = isArr ? new Ctor : [];\n        }\n        else if (isObject(object)) {\n          accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};\n        }\n        else {\n          accumulator = {};\n        }\n      }\n      (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {\n        return iteratee(accumulator, value, index, object);\n      });\n      return accumulator;\n    }\n\n    /**\n     * Removes the property at `path` of `object`.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to unset.\n     * @returns {boolean} Returns `true` if the property is deleted, else `false`.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 7 } }] };\n     * _.unset(object, 'a[0].b.c');\n     * // => true\n     *\n     * console.log(object);\n     * // => { 'a': [{ 'b': {} }] };\n     *\n     * _.unset(object, ['a', '0', 'b', 'c']);\n     * // => true\n     *\n     * console.log(object);\n     * // => { 'a': [{ 'b': {} }] };\n     */\n    function unset(object, path) {\n      return object == null ? true : baseUnset(object, path);\n    }\n\n    /**\n     * This method is like `_.set` except that accepts `updater` to produce the\n     * value to set. Use `_.updateWith` to customize `path` creation. The `updater`\n     * is invoked with one argument: (value).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.6.0\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {Function} updater The function to produce the updated value.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n     *\n     * _.update(object, 'a[0].b.c', function(n) { return n * n; });\n     * console.log(object.a[0].b.c);\n     * // => 9\n     *\n     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });\n     * console.log(object.x[0].y.z);\n     * // => 0\n     */\n    function update(object, path, updater) {\n      return object == null ? object : baseUpdate(object, path, castFunction(updater));\n    }\n\n    /**\n     * This method is like `_.update` except that it accepts `customizer` which is\n     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`\n     * path creation is handled by the method instead. The `customizer` is invoked\n     * with three arguments: (nsValue, key, nsObject).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.6.0\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {Function} updater The function to produce the updated value.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = {};\n     *\n     * _.updateWith(object, '[0][1]', _.constant('a'), Object);\n     * // => { '0': { '1': 'a' } }\n     */\n    function updateWith(object, path, updater, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);\n    }\n\n    /**\n     * Creates an array of the own enumerable string keyed property values of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property values.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.values(new Foo);\n     * // => [1, 2] (iteration order is not guaranteed)\n     *\n     * _.values('hi');\n     * // => ['h', 'i']\n     */\n    function values(object) {\n      return object == null ? [] : baseValues(object, keys(object));\n    }\n\n    /**\n     * Creates an array of the own and inherited enumerable string keyed property\n     * values of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property values.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.valuesIn(new Foo);\n     * // => [1, 2, 3] (iteration order is not guaranteed)\n     */\n    function valuesIn(object) {\n      return object == null ? [] : baseValues(object, keysIn(object));\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Clamps `number` within the inclusive `lower` and `upper` bounds.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Number\n     * @param {number} number The number to clamp.\n     * @param {number} [lower] The lower bound.\n     * @param {number} upper The upper bound.\n     * @returns {number} Returns the clamped number.\n     * @example\n     *\n     * _.clamp(-10, -5, 5);\n     * // => -5\n     *\n     * _.clamp(10, -5, 5);\n     * // => 5\n     */\n    function clamp(number, lower, upper) {\n      if (upper === undefined) {\n        upper = lower;\n        lower = undefined;\n      }\n      if (upper !== undefined) {\n        upper = toNumber(upper);\n        upper = upper === upper ? upper : 0;\n      }\n      if (lower !== undefined) {\n        lower = toNumber(lower);\n        lower = lower === lower ? lower : 0;\n      }\n      return baseClamp(toNumber(number), lower, upper);\n    }\n\n    /**\n     * Checks if `n` is between `start` and up to, but not including, `end`. If\n     * `end` is not specified, it's set to `start` with `start` then set to `0`.\n     * If `start` is greater than `end` the params are swapped to support\n     * negative ranges.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.3.0\n     * @category Number\n     * @param {number} number The number to check.\n     * @param {number} [start=0] The start of the range.\n     * @param {number} end The end of the range.\n     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.\n     * @see _.range, _.rangeRight\n     * @example\n     *\n     * _.inRange(3, 2, 4);\n     * // => true\n     *\n     * _.inRange(4, 8);\n     * // => true\n     *\n     * _.inRange(4, 2);\n     * // => false\n     *\n     * _.inRange(2, 2);\n     * // => false\n     *\n     * _.inRange(1.2, 2);\n     * // => true\n     *\n     * _.inRange(5.2, 4);\n     * // => false\n     *\n     * _.inRange(-3, -2, -6);\n     * // => true\n     */\n    function inRange(number, start, end) {\n      start = toFinite(start);\n      if (end === undefined) {\n        end = start;\n        start = 0;\n      } else {\n        end = toFinite(end);\n      }\n      number = toNumber(number);\n      return baseInRange(number, start, end);\n    }\n\n    /**\n     * Produces a random number between the inclusive `lower` and `upper` bounds.\n     * If only one argument is provided a number between `0` and the given number\n     * is returned. If `floating` is `true`, or either `lower` or `upper` are\n     * floats, a floating-point number is returned instead of an integer.\n     *\n     * **Note:** JavaScript follows the IEEE-754 standard for resolving\n     * floating-point values which can produce unexpected results.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.7.0\n     * @category Number\n     * @param {number} [lower=0] The lower bound.\n     * @param {number} [upper=1] The upper bound.\n     * @param {boolean} [floating] Specify returning a floating-point number.\n     * @returns {number} Returns the random number.\n     * @example\n     *\n     * _.random(0, 5);\n     * // => an integer between 0 and 5\n     *\n     * _.random(5);\n     * // => also an integer between 0 and 5\n     *\n     * _.random(5, true);\n     * // => a floating-point number between 0 and 5\n     *\n     * _.random(1.2, 5.2);\n     * // => a floating-point number between 1.2 and 5.2\n     */\n    function random(lower, upper, floating) {\n      if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {\n        upper = floating = undefined;\n      }\n      if (floating === undefined) {\n        if (typeof upper == 'boolean') {\n          floating = upper;\n          upper = undefined;\n        }\n        else if (typeof lower == 'boolean') {\n          floating = lower;\n          lower = undefined;\n        }\n      }\n      if (lower === undefined && upper === undefined) {\n        lower = 0;\n        upper = 1;\n      }\n      else {\n        lower = toFinite(lower);\n        if (upper === undefined) {\n          upper = lower;\n          lower = 0;\n        } else {\n          upper = toFinite(upper);\n        }\n      }\n      if (lower > upper) {\n        var temp = lower;\n        lower = upper;\n        upper = temp;\n      }\n      if (floating || lower % 1 || upper % 1) {\n        var rand = nativeRandom();\n        return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);\n      }\n      return baseRandom(lower, upper);\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the camel cased string.\n     * @example\n     *\n     * _.camelCase('Foo Bar');\n     * // => 'fooBar'\n     *\n     * _.camelCase('--foo-bar--');\n     * // => 'fooBar'\n     *\n     * _.camelCase('__FOO_BAR__');\n     * // => 'fooBar'\n     */\n    var camelCase = createCompounder(function(result, word, index) {\n      word = word.toLowerCase();\n      return result + (index ? capitalize(word) : word);\n    });\n\n    /**\n     * Converts the first character of `string` to upper case and the remaining\n     * to lower case.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to capitalize.\n     * @returns {string} Returns the capitalized string.\n     * @example\n     *\n     * _.capitalize('FRED');\n     * // => 'Fred'\n     */\n    function capitalize(string) {\n      return upperFirst(toString(string).toLowerCase());\n    }\n\n    /**\n     * Deburrs `string` by converting\n     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)\n     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)\n     * letters to basic Latin letters and removing\n     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to deburr.\n     * @returns {string} Returns the deburred string.\n     * @example\n     *\n     * _.deburr('déjà vu');\n     * // => 'deja vu'\n     */\n    function deburr(string) {\n      string = toString(string);\n      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');\n    }\n\n    /**\n     * Checks if `string` ends with the given target string.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to inspect.\n     * @param {string} [target] The string to search for.\n     * @param {number} [position=string.length] The position to search up to.\n     * @returns {boolean} Returns `true` if `string` ends with `target`,\n     *  else `false`.\n     * @example\n     *\n     * _.endsWith('abc', 'c');\n     * // => true\n     *\n     * _.endsWith('abc', 'b');\n     * // => false\n     *\n     * _.endsWith('abc', 'b', 2);\n     * // => true\n     */\n    function endsWith(string, target, position) {\n      string = toString(string);\n      target = baseToString(target);\n\n      var length = string.length;\n      position = position === undefined\n        ? length\n        : baseClamp(toInteger(position), 0, length);\n\n      var end = position;\n      position -= target.length;\n      return position >= 0 && string.slice(position, end) == target;\n    }\n\n    /**\n     * Converts the characters \"&\", \"<\", \">\", '\"', and \"'\" in `string` to their\n     * corresponding HTML entities.\n     *\n     * **Note:** No other characters are escaped. To escape additional\n     * characters use a third-party library like [_he_](https://mths.be/he).\n     *\n     * Though the \">\" character is escaped for symmetry, characters like\n     * \">\" and \"/\" don't need escaping in HTML and have no special meaning\n     * unless they're part of a tag or unquoted attribute value. See\n     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)\n     * (under \"semi-related fun fact\") for more details.\n     *\n     * When working with HTML you should always\n     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce\n     * XSS vectors.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to escape.\n     * @returns {string} Returns the escaped string.\n     * @example\n     *\n     * _.escape('fred, barney, & pebbles');\n     * // => 'fred, barney, &amp; pebbles'\n     */\n    function escape(string) {\n      string = toString(string);\n      return (string && reHasUnescapedHtml.test(string))\n        ? string.replace(reUnescapedHtml, escapeHtmlChar)\n        : string;\n    }\n\n    /**\n     * Escapes the `RegExp` special characters \"^\", \"$\", \"\\\", \".\", \"*\", \"+\",\n     * \"?\", \"(\", \")\", \"[\", \"]\", \"{\", \"}\", and \"|\" in `string`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to escape.\n     * @returns {string} Returns the escaped string.\n     * @example\n     *\n     * _.escapeRegExp('[lodash](https://lodash.com/)');\n     * // => '\\[lodash\\]\\(https://lodash\\.com/\\)'\n     */\n    function escapeRegExp(string) {\n      string = toString(string);\n      return (string && reHasRegExpChar.test(string))\n        ? string.replace(reRegExpChar, '\\\\$&')\n        : string;\n    }\n\n    /**\n     * Converts `string` to\n     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the kebab cased string.\n     * @example\n     *\n     * _.kebabCase('Foo Bar');\n     * // => 'foo-bar'\n     *\n     * _.kebabCase('fooBar');\n     * // => 'foo-bar'\n     *\n     * _.kebabCase('__FOO_BAR__');\n     * // => 'foo-bar'\n     */\n    var kebabCase = createCompounder(function(result, word, index) {\n      return result + (index ? '-' : '') + word.toLowerCase();\n    });\n\n    /**\n     * Converts `string`, as space separated words, to lower case.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the lower cased string.\n     * @example\n     *\n     * _.lowerCase('--Foo-Bar--');\n     * // => 'foo bar'\n     *\n     * _.lowerCase('fooBar');\n     * // => 'foo bar'\n     *\n     * _.lowerCase('__FOO_BAR__');\n     * // => 'foo bar'\n     */\n    var lowerCase = createCompounder(function(result, word, index) {\n      return result + (index ? ' ' : '') + word.toLowerCase();\n    });\n\n    /**\n     * Converts the first character of `string` to lower case.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the converted string.\n     * @example\n     *\n     * _.lowerFirst('Fred');\n     * // => 'fred'\n     *\n     * _.lowerFirst('FRED');\n     * // => 'fRED'\n     */\n    var lowerFirst = createCaseFirst('toLowerCase');\n\n    /**\n     * Pads `string` on the left and right sides if it's shorter than `length`.\n     * Padding characters are truncated if they can't be evenly divided by `length`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to pad.\n     * @param {number} [length=0] The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padded string.\n     * @example\n     *\n     * _.pad('abc', 8);\n     * // => '  abc   '\n     *\n     * _.pad('abc', 8, '_-');\n     * // => '_-abc_-_'\n     *\n     * _.pad('abc', 3);\n     * // => 'abc'\n     */\n    function pad(string, length, chars) {\n      string = toString(string);\n      length = toInteger(length);\n\n      var strLength = length ? stringSize(string) : 0;\n      if (!length || strLength >= length) {\n        return string;\n      }\n      var mid = (length - strLength) / 2;\n      return (\n        createPadding(nativeFloor(mid), chars) +\n        string +\n        createPadding(nativeCeil(mid), chars)\n      );\n    }\n\n    /**\n     * Pads `string` on the right side if it's shorter than `length`. Padding\n     * characters are truncated if they exceed `length`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to pad.\n     * @param {number} [length=0] The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padded string.\n     * @example\n     *\n     * _.padEnd('abc', 6);\n     * // => 'abc   '\n     *\n     * _.padEnd('abc', 6, '_-');\n     * // => 'abc_-_'\n     *\n     * _.padEnd('abc', 3);\n     * // => 'abc'\n     */\n    function padEnd(string, length, chars) {\n      string = toString(string);\n      length = toInteger(length);\n\n      var strLength = length ? stringSize(string) : 0;\n      return (length && strLength < length)\n        ? (string + createPadding(length - strLength, chars))\n        : string;\n    }\n\n    /**\n     * Pads `string` on the left side if it's shorter than `length`. Padding\n     * characters are truncated if they exceed `length`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to pad.\n     * @param {number} [length=0] The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padded string.\n     * @example\n     *\n     * _.padStart('abc', 6);\n     * // => '   abc'\n     *\n     * _.padStart('abc', 6, '_-');\n     * // => '_-_abc'\n     *\n     * _.padStart('abc', 3);\n     * // => 'abc'\n     */\n    function padStart(string, length, chars) {\n      string = toString(string);\n      length = toInteger(length);\n\n      var strLength = length ? stringSize(string) : 0;\n      return (length && strLength < length)\n        ? (createPadding(length - strLength, chars) + string)\n        : string;\n    }\n\n    /**\n     * Converts `string` to an integer of the specified radix. If `radix` is\n     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a\n     * hexadecimal, in which case a `radix` of `16` is used.\n     *\n     * **Note:** This method aligns with the\n     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.1.0\n     * @category String\n     * @param {string} string The string to convert.\n     * @param {number} [radix=10] The radix to interpret `value` by.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {number} Returns the converted integer.\n     * @example\n     *\n     * _.parseInt('08');\n     * // => 8\n     *\n     * _.map(['6', '08', '10'], _.parseInt);\n     * // => [6, 8, 10]\n     */\n    function parseInt(string, radix, guard) {\n      if (guard || radix == null) {\n        radix = 0;\n      } else if (radix) {\n        radix = +radix;\n      }\n      return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0);\n    }\n\n    /**\n     * Repeats the given string `n` times.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to repeat.\n     * @param {number} [n=1] The number of times to repeat the string.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {string} Returns the repeated string.\n     * @example\n     *\n     * _.repeat('*', 3);\n     * // => '***'\n     *\n     * _.repeat('abc', 2);\n     * // => 'abcabc'\n     *\n     * _.repeat('abc', 0);\n     * // => ''\n     */\n    function repeat(string, n, guard) {\n      if ((guard ? isIterateeCall(string, n, guard) : n === undefined)) {\n        n = 1;\n      } else {\n        n = toInteger(n);\n      }\n      return baseRepeat(toString(string), n);\n    }\n\n    /**\n     * Replaces matches for `pattern` in `string` with `replacement`.\n     *\n     * **Note:** This method is based on\n     * [`String#replace`](https://mdn.io/String/replace).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to modify.\n     * @param {RegExp|string} pattern The pattern to replace.\n     * @param {Function|string} replacement The match replacement.\n     * @returns {string} Returns the modified string.\n     * @example\n     *\n     * _.replace('Hi Fred', 'Fred', 'Barney');\n     * // => 'Hi Barney'\n     */\n    function replace() {\n      var args = arguments,\n          string = toString(args[0]);\n\n      return args.length < 3 ? string : string.replace(args[1], args[2]);\n    }\n\n    /**\n     * Converts `string` to\n     * [snake case](https://en.wikipedia.org/wiki/Snake_case).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the snake cased string.\n     * @example\n     *\n     * _.snakeCase('Foo Bar');\n     * // => 'foo_bar'\n     *\n     * _.snakeCase('fooBar');\n     * // => 'foo_bar'\n     *\n     * _.snakeCase('--FOO-BAR--');\n     * // => 'foo_bar'\n     */\n    var snakeCase = createCompounder(function(result, word, index) {\n      return result + (index ? '_' : '') + word.toLowerCase();\n    });\n\n    /**\n     * Splits `string` by `separator`.\n     *\n     * **Note:** This method is based on\n     * [`String#split`](https://mdn.io/String/split).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to split.\n     * @param {RegExp|string} separator The separator pattern to split by.\n     * @param {number} [limit] The length to truncate results to.\n     * @returns {Array} Returns the string segments.\n     * @example\n     *\n     * _.split('a-b-c', '-', 2);\n     * // => ['a', 'b']\n     */\n    function split(string, separator, limit) {\n      if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {\n        separator = limit = undefined;\n      }\n      limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;\n      if (!limit) {\n        return [];\n      }\n      string = toString(string);\n      if (string && (\n            typeof separator == 'string' ||\n            (separator != null && !isRegExp(separator))\n          )) {\n        separator = baseToString(separator);\n        if (!separator && hasUnicode(string)) {\n          return castSlice(stringToArray(string), 0, limit);\n        }\n      }\n      return string.split(separator, limit);\n    }\n\n    /**\n     * Converts `string` to\n     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.1.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the start cased string.\n     * @example\n     *\n     * _.startCase('--foo-bar--');\n     * // => 'Foo Bar'\n     *\n     * _.startCase('fooBar');\n     * // => 'Foo Bar'\n     *\n     * _.startCase('__FOO_BAR__');\n     * // => 'FOO BAR'\n     */\n    var startCase = createCompounder(function(result, word, index) {\n      return result + (index ? ' ' : '') + upperFirst(word);\n    });\n\n    /**\n     * Checks if `string` starts with the given target string.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to inspect.\n     * @param {string} [target] The string to search for.\n     * @param {number} [position=0] The position to search from.\n     * @returns {boolean} Returns `true` if `string` starts with `target`,\n     *  else `false`.\n     * @example\n     *\n     * _.startsWith('abc', 'a');\n     * // => true\n     *\n     * _.startsWith('abc', 'b');\n     * // => false\n     *\n     * _.startsWith('abc', 'b', 1);\n     * // => true\n     */\n    function startsWith(string, target, position) {\n      string = toString(string);\n      position = position == null\n        ? 0\n        : baseClamp(toInteger(position), 0, string.length);\n\n      target = baseToString(target);\n      return string.slice(position, position + target.length) == target;\n    }\n\n    /**\n     * Creates a compiled template function that can interpolate data properties\n     * in \"interpolate\" delimiters, HTML-escape interpolated data properties in\n     * \"escape\" delimiters, and execute JavaScript in \"evaluate\" delimiters. Data\n     * properties may be accessed as free variables in the template. If a setting\n     * object is given, it takes precedence over `_.templateSettings` values.\n     *\n     * **Note:** In the development build `_.template` utilizes\n     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)\n     * for easier debugging.\n     *\n     * For more information on precompiling templates see\n     * [lodash's custom builds documentation](https://lodash.com/custom-builds).\n     *\n     * For more information on Chrome extension sandboxes see\n     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The template string.\n     * @param {Object} [options={}] The options object.\n     * @param {RegExp} [options.escape=_.templateSettings.escape]\n     *  The HTML \"escape\" delimiter.\n     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]\n     *  The \"evaluate\" delimiter.\n     * @param {Object} [options.imports=_.templateSettings.imports]\n     *  An object to import into the template as free variables.\n     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]\n     *  The \"interpolate\" delimiter.\n     * @param {string} [options.sourceURL='lodash.templateSources[n]']\n     *  The sourceURL of the compiled template.\n     * @param {string} [options.variable='obj']\n     *  The data object variable name.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Function} Returns the compiled template function.\n     * @example\n     *\n     * // Use the \"interpolate\" delimiter to create a compiled template.\n     * var compiled = _.template('hello <%= user %>!');\n     * compiled({ 'user': 'fred' });\n     * // => 'hello fred!'\n     *\n     * // Use the HTML \"escape\" delimiter to escape data property values.\n     * var compiled = _.template('<b><%- value %></b>');\n     * compiled({ 'value': '<script>' });\n     * // => '<b>&lt;script&gt;</b>'\n     *\n     * // Use the \"evaluate\" delimiter to execute JavaScript and generate HTML.\n     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');\n     * compiled({ 'users': ['fred', 'barney'] });\n     * // => '<li>fred</li><li>barney</li>'\n     *\n     * // Use the internal `print` function in \"evaluate\" delimiters.\n     * var compiled = _.template('<% print(\"hello \" + user); %>!');\n     * compiled({ 'user': 'barney' });\n     * // => 'hello barney!'\n     *\n     * // Use the ES template literal delimiter as an \"interpolate\" delimiter.\n     * // Disable support by replacing the \"interpolate\" delimiter.\n     * var compiled = _.template('hello ${ user }!');\n     * compiled({ 'user': 'pebbles' });\n     * // => 'hello pebbles!'\n     *\n     * // Use backslashes to treat delimiters as plain text.\n     * var compiled = _.template('<%= \"\\\\<%- value %\\\\>\" %>');\n     * compiled({ 'value': 'ignored' });\n     * // => '<%- value %>'\n     *\n     * // Use the `imports` option to import `jQuery` as `jq`.\n     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';\n     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });\n     * compiled({ 'users': ['fred', 'barney'] });\n     * // => '<li>fred</li><li>barney</li>'\n     *\n     * // Use the `sourceURL` option to specify a custom sourceURL for the template.\n     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });\n     * compiled(data);\n     * // => Find the source of \"greeting.jst\" under the Sources tab or Resources panel of the web inspector.\n     *\n     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.\n     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });\n     * compiled.source;\n     * // => function(data) {\n     * //   var __t, __p = '';\n     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';\n     * //   return __p;\n     * // }\n     *\n     * // Use custom template delimiters.\n     * _.templateSettings.interpolate = /{{([\\s\\S]+?)}}/g;\n     * var compiled = _.template('hello {{ user }}!');\n     * compiled({ 'user': 'mustache' });\n     * // => 'hello mustache!'\n     *\n     * // Use the `source` property to inline compiled templates for meaningful\n     * // line numbers in error messages and stack traces.\n     * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\\\n     *   var JST = {\\\n     *     \"main\": ' + _.template(mainText).source + '\\\n     *   };\\\n     * ');\n     */\n    function template(string, options, guard) {\n      // Based on John Resig's `tmpl` implementation\n      // (http://ejohn.org/blog/javascript-micro-templating/)\n      // and Laura Doktorova's doT.js (https://github.com/olado/doT).\n      var settings = lodash.templateSettings;\n\n      if (guard && isIterateeCall(string, options, guard)) {\n        options = undefined;\n      }\n      string = toString(string);\n      options = assignInWith({}, options, settings, customDefaultsAssignIn);\n\n      var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),\n          importsKeys = keys(imports),\n          importsValues = baseValues(imports, importsKeys);\n\n      var isEscaping,\n          isEvaluating,\n          index = 0,\n          interpolate = options.interpolate || reNoMatch,\n          source = \"__p += '\";\n\n      // Compile the regexp to match each delimiter.\n      var reDelimiters = RegExp(\n        (options.escape || reNoMatch).source + '|' +\n        interpolate.source + '|' +\n        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +\n        (options.evaluate || reNoMatch).source + '|$'\n      , 'g');\n\n      // Use a sourceURL for easier debugging.\n      // The sourceURL gets injected into the source that's eval-ed, so be careful\n      // to normalize all kinds of whitespace, so e.g. newlines (and unicode versions of it) can't sneak in\n      // and escape the comment, thus injecting code that gets evaled.\n      var sourceURL = '//# sourceURL=' +\n        (hasOwnProperty.call(options, 'sourceURL')\n          ? (options.sourceURL + '').replace(/\\s/g, ' ')\n          : ('lodash.templateSources[' + (++templateCounter) + ']')\n        ) + '\\n';\n\n      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {\n        interpolateValue || (interpolateValue = esTemplateValue);\n\n        // Escape characters that can't be included in string literals.\n        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);\n\n        // Replace delimiters with snippets.\n        if (escapeValue) {\n          isEscaping = true;\n          source += \"' +\\n__e(\" + escapeValue + \") +\\n'\";\n        }\n        if (evaluateValue) {\n          isEvaluating = true;\n          source += \"';\\n\" + evaluateValue + \";\\n__p += '\";\n        }\n        if (interpolateValue) {\n          source += \"' +\\n((__t = (\" + interpolateValue + \")) == null ? '' : __t) +\\n'\";\n        }\n        index = offset + match.length;\n\n        // The JS engine embedded in Adobe products needs `match` returned in\n        // order to produce the correct `offset` value.\n        return match;\n      });\n\n      source += \"';\\n\";\n\n      // If `variable` is not specified wrap a with-statement around the generated\n      // code to add the data object to the top of the scope chain.\n      var variable = hasOwnProperty.call(options, 'variable') && options.variable;\n      if (!variable) {\n        source = 'with (obj) {\\n' + source + '\\n}\\n';\n      }\n      // Throw an error if a forbidden character was found in `variable`, to prevent\n      // potential command injection attacks.\n      else if (reForbiddenIdentifierChars.test(variable)) {\n        throw new Error(INVALID_TEMPL_VAR_ERROR_TEXT);\n      }\n\n      // Cleanup code by stripping empty strings.\n      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)\n        .replace(reEmptyStringMiddle, '$1')\n        .replace(reEmptyStringTrailing, '$1;');\n\n      // Frame code as the function body.\n      source = 'function(' + (variable || 'obj') + ') {\\n' +\n        (variable\n          ? ''\n          : 'obj || (obj = {});\\n'\n        ) +\n        \"var __t, __p = ''\" +\n        (isEscaping\n           ? ', __e = _.escape'\n           : ''\n        ) +\n        (isEvaluating\n          ? ', __j = Array.prototype.join;\\n' +\n            \"function print() { __p += __j.call(arguments, '') }\\n\"\n          : ';\\n'\n        ) +\n        source +\n        'return __p\\n}';\n\n      var result = attempt(function() {\n        return Function(importsKeys, sourceURL + 'return ' + source)\n          .apply(undefined, importsValues);\n      });\n\n      // Provide the compiled function's source by its `toString` method or\n      // the `source` property as a convenience for inlining compiled templates.\n      result.source = source;\n      if (isError(result)) {\n        throw result;\n      }\n      return result;\n    }\n\n    /**\n     * Converts `string`, as a whole, to lower case just like\n     * [String#toLowerCase](https://mdn.io/toLowerCase).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the lower cased string.\n     * @example\n     *\n     * _.toLower('--Foo-Bar--');\n     * // => '--foo-bar--'\n     *\n     * _.toLower('fooBar');\n     * // => 'foobar'\n     *\n     * _.toLower('__FOO_BAR__');\n     * // => '__foo_bar__'\n     */\n    function toLower(value) {\n      return toString(value).toLowerCase();\n    }\n\n    /**\n     * Converts `string`, as a whole, to upper case just like\n     * [String#toUpperCase](https://mdn.io/toUpperCase).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the upper cased string.\n     * @example\n     *\n     * _.toUpper('--foo-bar--');\n     * // => '--FOO-BAR--'\n     *\n     * _.toUpper('fooBar');\n     * // => 'FOOBAR'\n     *\n     * _.toUpper('__foo_bar__');\n     * // => '__FOO_BAR__'\n     */\n    function toUpper(value) {\n      return toString(value).toUpperCase();\n    }\n\n    /**\n     * Removes leading and trailing whitespace or specified characters from `string`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to trim.\n     * @param {string} [chars=whitespace] The characters to trim.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {string} Returns the trimmed string.\n     * @example\n     *\n     * _.trim('  abc  ');\n     * // => 'abc'\n     *\n     * _.trim('-_-abc-_-', '_-');\n     * // => 'abc'\n     *\n     * _.map(['  foo  ', '  bar  '], _.trim);\n     * // => ['foo', 'bar']\n     */\n    function trim(string, chars, guard) {\n      string = toString(string);\n      if (string && (guard || chars === undefined)) {\n        return baseTrim(string);\n      }\n      if (!string || !(chars = baseToString(chars))) {\n        return string;\n      }\n      var strSymbols = stringToArray(string),\n          chrSymbols = stringToArray(chars),\n          start = charsStartIndex(strSymbols, chrSymbols),\n          end = charsEndIndex(strSymbols, chrSymbols) + 1;\n\n      return castSlice(strSymbols, start, end).join('');\n    }\n\n    /**\n     * Removes trailing whitespace or specified characters from `string`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to trim.\n     * @param {string} [chars=whitespace] The characters to trim.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {string} Returns the trimmed string.\n     * @example\n     *\n     * _.trimEnd('  abc  ');\n     * // => '  abc'\n     *\n     * _.trimEnd('-_-abc-_-', '_-');\n     * // => '-_-abc'\n     */\n    function trimEnd(string, chars, guard) {\n      string = toString(string);\n      if (string && (guard || chars === undefined)) {\n        return string.slice(0, trimmedEndIndex(string) + 1);\n      }\n      if (!string || !(chars = baseToString(chars))) {\n        return string;\n      }\n      var strSymbols = stringToArray(string),\n          end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;\n\n      return castSlice(strSymbols, 0, end).join('');\n    }\n\n    /**\n     * Removes leading whitespace or specified characters from `string`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to trim.\n     * @param {string} [chars=whitespace] The characters to trim.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {string} Returns the trimmed string.\n     * @example\n     *\n     * _.trimStart('  abc  ');\n     * // => 'abc  '\n     *\n     * _.trimStart('-_-abc-_-', '_-');\n     * // => 'abc-_-'\n     */\n    function trimStart(string, chars, guard) {\n      string = toString(string);\n      if (string && (guard || chars === undefined)) {\n        return string.replace(reTrimStart, '');\n      }\n      if (!string || !(chars = baseToString(chars))) {\n        return string;\n      }\n      var strSymbols = stringToArray(string),\n          start = charsStartIndex(strSymbols, stringToArray(chars));\n\n      return castSlice(strSymbols, start).join('');\n    }\n\n    /**\n     * Truncates `string` if it's longer than the given maximum string length.\n     * The last characters of the truncated string are replaced with the omission\n     * string which defaults to \"...\".\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to truncate.\n     * @param {Object} [options={}] The options object.\n     * @param {number} [options.length=30] The maximum string length.\n     * @param {string} [options.omission='...'] The string to indicate text is omitted.\n     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.\n     * @returns {string} Returns the truncated string.\n     * @example\n     *\n     * _.truncate('hi-diddly-ho there, neighborino');\n     * // => 'hi-diddly-ho there, neighbo...'\n     *\n     * _.truncate('hi-diddly-ho there, neighborino', {\n     *   'length': 24,\n     *   'separator': ' '\n     * });\n     * // => 'hi-diddly-ho there,...'\n     *\n     * _.truncate('hi-diddly-ho there, neighborino', {\n     *   'length': 24,\n     *   'separator': /,? +/\n     * });\n     * // => 'hi-diddly-ho there...'\n     *\n     * _.truncate('hi-diddly-ho there, neighborino', {\n     *   'omission': ' [...]'\n     * });\n     * // => 'hi-diddly-ho there, neig [...]'\n     */\n    function truncate(string, options) {\n      var length = DEFAULT_TRUNC_LENGTH,\n          omission = DEFAULT_TRUNC_OMISSION;\n\n      if (isObject(options)) {\n        var separator = 'separator' in options ? options.separator : separator;\n        length = 'length' in options ? toInteger(options.length) : length;\n        omission = 'omission' in options ? baseToString(options.omission) : omission;\n      }\n      string = toString(string);\n\n      var strLength = string.length;\n      if (hasUnicode(string)) {\n        var strSymbols = stringToArray(string);\n        strLength = strSymbols.length;\n      }\n      if (length >= strLength) {\n        return string;\n      }\n      var end = length - stringSize(omission);\n      if (end < 1) {\n        return omission;\n      }\n      var result = strSymbols\n        ? castSlice(strSymbols, 0, end).join('')\n        : string.slice(0, end);\n\n      if (separator === undefined) {\n        return result + omission;\n      }\n      if (strSymbols) {\n        end += (result.length - end);\n      }\n      if (isRegExp(separator)) {\n        if (string.slice(end).search(separator)) {\n          var match,\n              substring = result;\n\n          if (!separator.global) {\n            separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');\n          }\n          separator.lastIndex = 0;\n          while ((match = separator.exec(substring))) {\n            var newEnd = match.index;\n          }\n          result = result.slice(0, newEnd === undefined ? end : newEnd);\n        }\n      } else if (string.indexOf(baseToString(separator), end) != end) {\n        var index = result.lastIndexOf(separator);\n        if (index > -1) {\n          result = result.slice(0, index);\n        }\n      }\n      return result + omission;\n    }\n\n    /**\n     * The inverse of `_.escape`; this method converts the HTML entities\n     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to\n     * their corresponding characters.\n     *\n     * **Note:** No other HTML entities are unescaped. To unescape additional\n     * HTML entities use a third-party library like [_he_](https://mths.be/he).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.6.0\n     * @category String\n     * @param {string} [string=''] The string to unescape.\n     * @returns {string} Returns the unescaped string.\n     * @example\n     *\n     * _.unescape('fred, barney, &amp; pebbles');\n     * // => 'fred, barney, & pebbles'\n     */\n    function unescape(string) {\n      string = toString(string);\n      return (string && reHasEscapedHtml.test(string))\n        ? string.replace(reEscapedHtml, unescapeHtmlChar)\n        : string;\n    }\n\n    /**\n     * Converts `string`, as space separated words, to upper case.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the upper cased string.\n     * @example\n     *\n     * _.upperCase('--foo-bar');\n     * // => 'FOO BAR'\n     *\n     * _.upperCase('fooBar');\n     * // => 'FOO BAR'\n     *\n     * _.upperCase('__foo_bar__');\n     * // => 'FOO BAR'\n     */\n    var upperCase = createCompounder(function(result, word, index) {\n      return result + (index ? ' ' : '') + word.toUpperCase();\n    });\n\n    /**\n     * Converts the first character of `string` to upper case.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the converted string.\n     * @example\n     *\n     * _.upperFirst('fred');\n     * // => 'Fred'\n     *\n     * _.upperFirst('FRED');\n     * // => 'FRED'\n     */\n    var upperFirst = createCaseFirst('toUpperCase');\n\n    /**\n     * Splits `string` into an array of its words.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to inspect.\n     * @param {RegExp|string} [pattern] The pattern to match words.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the words of `string`.\n     * @example\n     *\n     * _.words('fred, barney, & pebbles');\n     * // => ['fred', 'barney', 'pebbles']\n     *\n     * _.words('fred, barney, & pebbles', /[^, ]+/g);\n     * // => ['fred', 'barney', '&', 'pebbles']\n     */\n    function words(string, pattern, guard) {\n      string = toString(string);\n      pattern = guard ? undefined : pattern;\n\n      if (pattern === undefined) {\n        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);\n      }\n      return string.match(pattern) || [];\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Attempts to invoke `func`, returning either the result or the caught error\n     * object. Any additional arguments are provided to `func` when it's invoked.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Util\n     * @param {Function} func The function to attempt.\n     * @param {...*} [args] The arguments to invoke `func` with.\n     * @returns {*} Returns the `func` result or error object.\n     * @example\n     *\n     * // Avoid throwing errors for invalid selectors.\n     * var elements = _.attempt(function(selector) {\n     *   return document.querySelectorAll(selector);\n     * }, '>_>');\n     *\n     * if (_.isError(elements)) {\n     *   elements = [];\n     * }\n     */\n    var attempt = baseRest(function(func, args) {\n      try {\n        return apply(func, undefined, args);\n      } catch (e) {\n        return isError(e) ? e : new Error(e);\n      }\n    });\n\n    /**\n     * Binds methods of an object to the object itself, overwriting the existing\n     * method.\n     *\n     * **Note:** This method doesn't set the \"length\" property of bound functions.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {Object} object The object to bind and assign the bound methods to.\n     * @param {...(string|string[])} methodNames The object method names to bind.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var view = {\n     *   'label': 'docs',\n     *   'click': function() {\n     *     console.log('clicked ' + this.label);\n     *   }\n     * };\n     *\n     * _.bindAll(view, ['click']);\n     * jQuery(element).on('click', view.click);\n     * // => Logs 'clicked docs' when clicked.\n     */\n    var bindAll = flatRest(function(object, methodNames) {\n      arrayEach(methodNames, function(key) {\n        key = toKey(key);\n        baseAssignValue(object, key, bind(object[key], object));\n      });\n      return object;\n    });\n\n    /**\n     * Creates a function that iterates over `pairs` and invokes the corresponding\n     * function of the first predicate to return truthy. The predicate-function\n     * pairs are invoked with the `this` binding and arguments of the created\n     * function.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {Array} pairs The predicate-function pairs.\n     * @returns {Function} Returns the new composite function.\n     * @example\n     *\n     * var func = _.cond([\n     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],\n     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],\n     *   [_.stubTrue,                      _.constant('no match')]\n     * ]);\n     *\n     * func({ 'a': 1, 'b': 2 });\n     * // => 'matches A'\n     *\n     * func({ 'a': 0, 'b': 1 });\n     * // => 'matches B'\n     *\n     * func({ 'a': '1', 'b': '2' });\n     * // => 'no match'\n     */\n    function cond(pairs) {\n      var length = pairs == null ? 0 : pairs.length,\n          toIteratee = getIteratee();\n\n      pairs = !length ? [] : arrayMap(pairs, function(pair) {\n        if (typeof pair[1] != 'function') {\n          throw new TypeError(FUNC_ERROR_TEXT);\n        }\n        return [toIteratee(pair[0]), pair[1]];\n      });\n\n      return baseRest(function(args) {\n        var index = -1;\n        while (++index < length) {\n          var pair = pairs[index];\n          if (apply(pair[0], this, args)) {\n            return apply(pair[1], this, args);\n          }\n        }\n      });\n    }\n\n    /**\n     * Creates a function that invokes the predicate properties of `source` with\n     * the corresponding property values of a given object, returning `true` if\n     * all predicates return truthy, else `false`.\n     *\n     * **Note:** The created function is equivalent to `_.conformsTo` with\n     * `source` partially applied.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {Object} source The object of property predicates to conform to.\n     * @returns {Function} Returns the new spec function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': 2, 'b': 1 },\n     *   { 'a': 1, 'b': 2 }\n     * ];\n     *\n     * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));\n     * // => [{ 'a': 1, 'b': 2 }]\n     */\n    function conforms(source) {\n      return baseConforms(baseClone(source, CLONE_DEEP_FLAG));\n    }\n\n    /**\n     * Creates a function that returns `value`.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Util\n     * @param {*} value The value to return from the new function.\n     * @returns {Function} Returns the new constant function.\n     * @example\n     *\n     * var objects = _.times(2, _.constant({ 'a': 1 }));\n     *\n     * console.log(objects);\n     * // => [{ 'a': 1 }, { 'a': 1 }]\n     *\n     * console.log(objects[0] === objects[1]);\n     * // => true\n     */\n    function constant(value) {\n      return function() {\n        return value;\n      };\n    }\n\n    /**\n     * Checks `value` to determine whether a default value should be returned in\n     * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,\n     * or `undefined`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.14.0\n     * @category Util\n     * @param {*} value The value to check.\n     * @param {*} defaultValue The default value.\n     * @returns {*} Returns the resolved value.\n     * @example\n     *\n     * _.defaultTo(1, 10);\n     * // => 1\n     *\n     * _.defaultTo(undefined, 10);\n     * // => 10\n     */\n    function defaultTo(value, defaultValue) {\n      return (value == null || value !== value) ? defaultValue : value;\n    }\n\n    /**\n     * Creates a function that returns the result of invoking the given functions\n     * with the `this` binding of the created function, where each successive\n     * invocation is supplied the return value of the previous.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Util\n     * @param {...(Function|Function[])} [funcs] The functions to invoke.\n     * @returns {Function} Returns the new composite function.\n     * @see _.flowRight\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var addSquare = _.flow([_.add, square]);\n     * addSquare(1, 2);\n     * // => 9\n     */\n    var flow = createFlow();\n\n    /**\n     * This method is like `_.flow` except that it creates a function that\n     * invokes the given functions from right to left.\n     *\n     * @static\n     * @since 3.0.0\n     * @memberOf _\n     * @category Util\n     * @param {...(Function|Function[])} [funcs] The functions to invoke.\n     * @returns {Function} Returns the new composite function.\n     * @see _.flow\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var addSquare = _.flowRight([square, _.add]);\n     * addSquare(1, 2);\n     * // => 9\n     */\n    var flowRight = createFlow(true);\n\n    /**\n     * This method returns the first argument it receives.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {*} value Any value.\n     * @returns {*} Returns `value`.\n     * @example\n     *\n     * var object = { 'a': 1 };\n     *\n     * console.log(_.identity(object) === object);\n     * // => true\n     */\n    function identity(value) {\n      return value;\n    }\n\n    /**\n     * Creates a function that invokes `func` with the arguments of the created\n     * function. If `func` is a property name, the created function returns the\n     * property value for a given element. If `func` is an array or object, the\n     * created function returns `true` for elements that contain the equivalent\n     * source properties, otherwise it returns `false`.\n     *\n     * @static\n     * @since 4.0.0\n     * @memberOf _\n     * @category Util\n     * @param {*} [func=_.identity] The value to convert to a callback.\n     * @returns {Function} Returns the callback.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': true },\n     *   { 'user': 'fred',   'age': 40, 'active': false }\n     * ];\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));\n     * // => [{ 'user': 'barney', 'age': 36, 'active': true }]\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.filter(users, _.iteratee(['user', 'fred']));\n     * // => [{ 'user': 'fred', 'age': 40 }]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.map(users, _.iteratee('user'));\n     * // => ['barney', 'fred']\n     *\n     * // Create custom iteratee shorthands.\n     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {\n     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {\n     *     return func.test(string);\n     *   };\n     * });\n     *\n     * _.filter(['abc', 'def'], /ef/);\n     * // => ['def']\n     */\n    function iteratee(func) {\n      return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG));\n    }\n\n    /**\n     * Creates a function that performs a partial deep comparison between a given\n     * object and `source`, returning `true` if the given object has equivalent\n     * property values, else `false`.\n     *\n     * **Note:** The created function is equivalent to `_.isMatch` with `source`\n     * partially applied.\n     *\n     * Partial comparisons will match empty array and empty object `source`\n     * values against any array or object value, respectively. See `_.isEqual`\n     * for a list of supported value comparisons.\n     *\n     * **Note:** Multiple values can be checked by combining several matchers\n     * using `_.overSome`\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Util\n     * @param {Object} source The object of property values to match.\n     * @returns {Function} Returns the new spec function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': 1, 'b': 2, 'c': 3 },\n     *   { 'a': 4, 'b': 5, 'c': 6 }\n     * ];\n     *\n     * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));\n     * // => [{ 'a': 4, 'b': 5, 'c': 6 }]\n     *\n     * // Checking for several possible values\n     * _.filter(objects, _.overSome([_.matches({ 'a': 1 }), _.matches({ 'a': 4 })]));\n     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]\n     */\n    function matches(source) {\n      return baseMatches(baseClone(source, CLONE_DEEP_FLAG));\n    }\n\n    /**\n     * Creates a function that performs a partial deep comparison between the\n     * value at `path` of a given object to `srcValue`, returning `true` if the\n     * object value is equivalent, else `false`.\n     *\n     * **Note:** Partial comparisons will match empty array and empty object\n     * `srcValue` values against any array or object value, respectively. See\n     * `_.isEqual` for a list of supported value comparisons.\n     *\n     * **Note:** Multiple values can be checked by combining several matchers\n     * using `_.overSome`\n     *\n     * @static\n     * @memberOf _\n     * @since 3.2.0\n     * @category Util\n     * @param {Array|string} path The path of the property to get.\n     * @param {*} srcValue The value to match.\n     * @returns {Function} Returns the new spec function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': 1, 'b': 2, 'c': 3 },\n     *   { 'a': 4, 'b': 5, 'c': 6 }\n     * ];\n     *\n     * _.find(objects, _.matchesProperty('a', 4));\n     * // => { 'a': 4, 'b': 5, 'c': 6 }\n     *\n     * // Checking for several possible values\n     * _.filter(objects, _.overSome([_.matchesProperty('a', 1), _.matchesProperty('a', 4)]));\n     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]\n     */\n    function matchesProperty(path, srcValue) {\n      return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));\n    }\n\n    /**\n     * Creates a function that invokes the method at `path` of a given object.\n     * Any additional arguments are provided to the invoked method.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.7.0\n     * @category Util\n     * @param {Array|string} path The path of the method to invoke.\n     * @param {...*} [args] The arguments to invoke the method with.\n     * @returns {Function} Returns the new invoker function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': { 'b': _.constant(2) } },\n     *   { 'a': { 'b': _.constant(1) } }\n     * ];\n     *\n     * _.map(objects, _.method('a.b'));\n     * // => [2, 1]\n     *\n     * _.map(objects, _.method(['a', 'b']));\n     * // => [2, 1]\n     */\n    var method = baseRest(function(path, args) {\n      return function(object) {\n        return baseInvoke(object, path, args);\n      };\n    });\n\n    /**\n     * The opposite of `_.method`; this method creates a function that invokes\n     * the method at a given path of `object`. Any additional arguments are\n     * provided to the invoked method.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.7.0\n     * @category Util\n     * @param {Object} object The object to query.\n     * @param {...*} [args] The arguments to invoke the method with.\n     * @returns {Function} Returns the new invoker function.\n     * @example\n     *\n     * var array = _.times(3, _.constant),\n     *     object = { 'a': array, 'b': array, 'c': array };\n     *\n     * _.map(['a[2]', 'c[0]'], _.methodOf(object));\n     * // => [2, 0]\n     *\n     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));\n     * // => [2, 0]\n     */\n    var methodOf = baseRest(function(object, args) {\n      return function(path) {\n        return baseInvoke(object, path, args);\n      };\n    });\n\n    /**\n     * Adds all own enumerable string keyed function properties of a source\n     * object to the destination object. If `object` is a function, then methods\n     * are added to its prototype as well.\n     *\n     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to\n     * avoid conflicts caused by modifying the original.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {Function|Object} [object=lodash] The destination object.\n     * @param {Object} source The object of functions to add.\n     * @param {Object} [options={}] The options object.\n     * @param {boolean} [options.chain=true] Specify whether mixins are chainable.\n     * @returns {Function|Object} Returns `object`.\n     * @example\n     *\n     * function vowels(string) {\n     *   return _.filter(string, function(v) {\n     *     return /[aeiou]/i.test(v);\n     *   });\n     * }\n     *\n     * _.mixin({ 'vowels': vowels });\n     * _.vowels('fred');\n     * // => ['e']\n     *\n     * _('fred').vowels().value();\n     * // => ['e']\n     *\n     * _.mixin({ 'vowels': vowels }, { 'chain': false });\n     * _('fred').vowels();\n     * // => ['e']\n     */\n    function mixin(object, source, options) {\n      var props = keys(source),\n          methodNames = baseFunctions(source, props);\n\n      if (options == null &&\n          !(isObject(source) && (methodNames.length || !props.length))) {\n        options = source;\n        source = object;\n        object = this;\n        methodNames = baseFunctions(source, keys(source));\n      }\n      var chain = !(isObject(options) && 'chain' in options) || !!options.chain,\n          isFunc = isFunction(object);\n\n      arrayEach(methodNames, function(methodName) {\n        var func = source[methodName];\n        object[methodName] = func;\n        if (isFunc) {\n          object.prototype[methodName] = function() {\n            var chainAll = this.__chain__;\n            if (chain || chainAll) {\n              var result = object(this.__wrapped__),\n                  actions = result.__actions__ = copyArray(this.__actions__);\n\n              actions.push({ 'func': func, 'args': arguments, 'thisArg': object });\n              result.__chain__ = chainAll;\n              return result;\n            }\n            return func.apply(object, arrayPush([this.value()], arguments));\n          };\n        }\n      });\n\n      return object;\n    }\n\n    /**\n     * Reverts the `_` variable to its previous value and returns a reference to\n     * the `lodash` function.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @returns {Function} Returns the `lodash` function.\n     * @example\n     *\n     * var lodash = _.noConflict();\n     */\n    function noConflict() {\n      if (root._ === this) {\n        root._ = oldDash;\n      }\n      return this;\n    }\n\n    /**\n     * This method returns `undefined`.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.3.0\n     * @category Util\n     * @example\n     *\n     * _.times(2, _.noop);\n     * // => [undefined, undefined]\n     */\n    function noop() {\n      // No operation performed.\n    }\n\n    /**\n     * Creates a function that gets the argument at index `n`. If `n` is negative,\n     * the nth argument from the end is returned.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {number} [n=0] The index of the argument to return.\n     * @returns {Function} Returns the new pass-thru function.\n     * @example\n     *\n     * var func = _.nthArg(1);\n     * func('a', 'b', 'c', 'd');\n     * // => 'b'\n     *\n     * var func = _.nthArg(-2);\n     * func('a', 'b', 'c', 'd');\n     * // => 'c'\n     */\n    function nthArg(n) {\n      n = toInteger(n);\n      return baseRest(function(args) {\n        return baseNth(args, n);\n      });\n    }\n\n    /**\n     * Creates a function that invokes `iteratees` with the arguments it receives\n     * and returns their results.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {...(Function|Function[])} [iteratees=[_.identity]]\n     *  The iteratees to invoke.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var func = _.over([Math.max, Math.min]);\n     *\n     * func(1, 2, 3, 4);\n     * // => [4, 1]\n     */\n    var over = createOver(arrayMap);\n\n    /**\n     * Creates a function that checks if **all** of the `predicates` return\n     * truthy when invoked with the arguments it receives.\n     *\n     * Following shorthands are possible for providing predicates.\n     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.\n     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {...(Function|Function[])} [predicates=[_.identity]]\n     *  The predicates to check.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var func = _.overEvery([Boolean, isFinite]);\n     *\n     * func('1');\n     * // => true\n     *\n     * func(null);\n     * // => false\n     *\n     * func(NaN);\n     * // => false\n     */\n    var overEvery = createOver(arrayEvery);\n\n    /**\n     * Creates a function that checks if **any** of the `predicates` return\n     * truthy when invoked with the arguments it receives.\n     *\n     * Following shorthands are possible for providing predicates.\n     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.\n     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {...(Function|Function[])} [predicates=[_.identity]]\n     *  The predicates to check.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var func = _.overSome([Boolean, isFinite]);\n     *\n     * func('1');\n     * // => true\n     *\n     * func(null);\n     * // => true\n     *\n     * func(NaN);\n     * // => false\n     *\n     * var matchesFunc = _.overSome([{ 'a': 1 }, { 'a': 2 }])\n     * var matchesPropertyFunc = _.overSome([['a', 1], ['a', 2]])\n     */\n    var overSome = createOver(arraySome);\n\n    /**\n     * Creates a function that returns the value at `path` of a given object.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Util\n     * @param {Array|string} path The path of the property to get.\n     * @returns {Function} Returns the new accessor function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': { 'b': 2 } },\n     *   { 'a': { 'b': 1 } }\n     * ];\n     *\n     * _.map(objects, _.property('a.b'));\n     * // => [2, 1]\n     *\n     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\n     * // => [1, 2]\n     */\n    function property(path) {\n      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n    }\n\n    /**\n     * The opposite of `_.property`; this method creates a function that returns\n     * the value at a given path of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Util\n     * @param {Object} object The object to query.\n     * @returns {Function} Returns the new accessor function.\n     * @example\n     *\n     * var array = [0, 1, 2],\n     *     object = { 'a': array, 'b': array, 'c': array };\n     *\n     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));\n     * // => [2, 0]\n     *\n     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));\n     * // => [2, 0]\n     */\n    function propertyOf(object) {\n      return function(path) {\n        return object == null ? undefined : baseGet(object, path);\n      };\n    }\n\n    /**\n     * Creates an array of numbers (positive and/or negative) progressing from\n     * `start` up to, but not including, `end`. A step of `-1` is used if a negative\n     * `start` is specified without an `end` or `step`. If `end` is not specified,\n     * it's set to `start` with `start` then set to `0`.\n     *\n     * **Note:** JavaScript follows the IEEE-754 standard for resolving\n     * floating-point values which can produce unexpected results.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {number} [start=0] The start of the range.\n     * @param {number} end The end of the range.\n     * @param {number} [step=1] The value to increment or decrement by.\n     * @returns {Array} Returns the range of numbers.\n     * @see _.inRange, _.rangeRight\n     * @example\n     *\n     * _.range(4);\n     * // => [0, 1, 2, 3]\n     *\n     * _.range(-4);\n     * // => [0, -1, -2, -3]\n     *\n     * _.range(1, 5);\n     * // => [1, 2, 3, 4]\n     *\n     * _.range(0, 20, 5);\n     * // => [0, 5, 10, 15]\n     *\n     * _.range(0, -4, -1);\n     * // => [0, -1, -2, -3]\n     *\n     * _.range(1, 4, 0);\n     * // => [1, 1, 1]\n     *\n     * _.range(0);\n     * // => []\n     */\n    var range = createRange();\n\n    /**\n     * This method is like `_.range` except that it populates values in\n     * descending order.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {number} [start=0] The start of the range.\n     * @param {number} end The end of the range.\n     * @param {number} [step=1] The value to increment or decrement by.\n     * @returns {Array} Returns the range of numbers.\n     * @see _.inRange, _.range\n     * @example\n     *\n     * _.rangeRight(4);\n     * // => [3, 2, 1, 0]\n     *\n     * _.rangeRight(-4);\n     * // => [-3, -2, -1, 0]\n     *\n     * _.rangeRight(1, 5);\n     * // => [4, 3, 2, 1]\n     *\n     * _.rangeRight(0, 20, 5);\n     * // => [15, 10, 5, 0]\n     *\n     * _.rangeRight(0, -4, -1);\n     * // => [-3, -2, -1, 0]\n     *\n     * _.rangeRight(1, 4, 0);\n     * // => [1, 1, 1]\n     *\n     * _.rangeRight(0);\n     * // => []\n     */\n    var rangeRight = createRange(true);\n\n    /**\n     * This method returns a new empty array.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {Array} Returns the new empty array.\n     * @example\n     *\n     * var arrays = _.times(2, _.stubArray);\n     *\n     * console.log(arrays);\n     * // => [[], []]\n     *\n     * console.log(arrays[0] === arrays[1]);\n     * // => false\n     */\n    function stubArray() {\n      return [];\n    }\n\n    /**\n     * This method returns `false`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {boolean} Returns `false`.\n     * @example\n     *\n     * _.times(2, _.stubFalse);\n     * // => [false, false]\n     */\n    function stubFalse() {\n      return false;\n    }\n\n    /**\n     * This method returns a new empty object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {Object} Returns the new empty object.\n     * @example\n     *\n     * var objects = _.times(2, _.stubObject);\n     *\n     * console.log(objects);\n     * // => [{}, {}]\n     *\n     * console.log(objects[0] === objects[1]);\n     * // => false\n     */\n    function stubObject() {\n      return {};\n    }\n\n    /**\n     * This method returns an empty string.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {string} Returns the empty string.\n     * @example\n     *\n     * _.times(2, _.stubString);\n     * // => ['', '']\n     */\n    function stubString() {\n      return '';\n    }\n\n    /**\n     * This method returns `true`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {boolean} Returns `true`.\n     * @example\n     *\n     * _.times(2, _.stubTrue);\n     * // => [true, true]\n     */\n    function stubTrue() {\n      return true;\n    }\n\n    /**\n     * Invokes the iteratee `n` times, returning an array of the results of\n     * each invocation. The iteratee is invoked with one argument; (index).\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {number} n The number of times to invoke `iteratee`.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the array of results.\n     * @example\n     *\n     * _.times(3, String);\n     * // => ['0', '1', '2']\n     *\n     *  _.times(4, _.constant(0));\n     * // => [0, 0, 0, 0]\n     */\n    function times(n, iteratee) {\n      n = toInteger(n);\n      if (n < 1 || n > MAX_SAFE_INTEGER) {\n        return [];\n      }\n      var index = MAX_ARRAY_LENGTH,\n          length = nativeMin(n, MAX_ARRAY_LENGTH);\n\n      iteratee = getIteratee(iteratee);\n      n -= MAX_ARRAY_LENGTH;\n\n      var result = baseTimes(length, iteratee);\n      while (++index < n) {\n        iteratee(index);\n      }\n      return result;\n    }\n\n    /**\n     * Converts `value` to a property path array.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {*} value The value to convert.\n     * @returns {Array} Returns the new property path array.\n     * @example\n     *\n     * _.toPath('a.b.c');\n     * // => ['a', 'b', 'c']\n     *\n     * _.toPath('a[0].b.c');\n     * // => ['a', '0', 'b', 'c']\n     */\n    function toPath(value) {\n      if (isArray(value)) {\n        return arrayMap(value, toKey);\n      }\n      return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));\n    }\n\n    /**\n     * Generates a unique ID. If `prefix` is given, the ID is appended to it.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {string} [prefix=''] The value to prefix the ID with.\n     * @returns {string} Returns the unique ID.\n     * @example\n     *\n     * _.uniqueId('contact_');\n     * // => 'contact_104'\n     *\n     * _.uniqueId();\n     * // => '105'\n     */\n    function uniqueId(prefix) {\n      var id = ++idCounter;\n      return toString(prefix) + id;\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Adds two numbers.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.4.0\n     * @category Math\n     * @param {number} augend The first number in an addition.\n     * @param {number} addend The second number in an addition.\n     * @returns {number} Returns the total.\n     * @example\n     *\n     * _.add(6, 4);\n     * // => 10\n     */\n    var add = createMathOperation(function(augend, addend) {\n      return augend + addend;\n    }, 0);\n\n    /**\n     * Computes `number` rounded up to `precision`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.10.0\n     * @category Math\n     * @param {number} number The number to round up.\n     * @param {number} [precision=0] The precision to round up to.\n     * @returns {number} Returns the rounded up number.\n     * @example\n     *\n     * _.ceil(4.006);\n     * // => 5\n     *\n     * _.ceil(6.004, 2);\n     * // => 6.01\n     *\n     * _.ceil(6040, -2);\n     * // => 6100\n     */\n    var ceil = createRound('ceil');\n\n    /**\n     * Divide two numbers.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.7.0\n     * @category Math\n     * @param {number} dividend The first number in a division.\n     * @param {number} divisor The second number in a division.\n     * @returns {number} Returns the quotient.\n     * @example\n     *\n     * _.divide(6, 4);\n     * // => 1.5\n     */\n    var divide = createMathOperation(function(dividend, divisor) {\n      return dividend / divisor;\n    }, 1);\n\n    /**\n     * Computes `number` rounded down to `precision`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.10.0\n     * @category Math\n     * @param {number} number The number to round down.\n     * @param {number} [precision=0] The precision to round down to.\n     * @returns {number} Returns the rounded down number.\n     * @example\n     *\n     * _.floor(4.006);\n     * // => 4\n     *\n     * _.floor(0.046, 2);\n     * // => 0.04\n     *\n     * _.floor(4060, -2);\n     * // => 4000\n     */\n    var floor = createRound('floor');\n\n    /**\n     * Computes the maximum value of `array`. If `array` is empty or falsey,\n     * `undefined` is returned.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @returns {*} Returns the maximum value.\n     * @example\n     *\n     * _.max([4, 2, 8, 6]);\n     * // => 8\n     *\n     * _.max([]);\n     * // => undefined\n     */\n    function max(array) {\n      return (array && array.length)\n        ? baseExtremum(array, identity, baseGt)\n        : undefined;\n    }\n\n    /**\n     * This method is like `_.max` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the criterion by which\n     * the value is ranked. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {*} Returns the maximum value.\n     * @example\n     *\n     * var objects = [{ 'n': 1 }, { 'n': 2 }];\n     *\n     * _.maxBy(objects, function(o) { return o.n; });\n     * // => { 'n': 2 }\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.maxBy(objects, 'n');\n     * // => { 'n': 2 }\n     */\n    function maxBy(array, iteratee) {\n      return (array && array.length)\n        ? baseExtremum(array, getIteratee(iteratee, 2), baseGt)\n        : undefined;\n    }\n\n    /**\n     * Computes the mean of the values in `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @returns {number} Returns the mean.\n     * @example\n     *\n     * _.mean([4, 2, 8, 6]);\n     * // => 5\n     */\n    function mean(array) {\n      return baseMean(array, identity);\n    }\n\n    /**\n     * This method is like `_.mean` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the value to be averaged.\n     * The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.7.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {number} Returns the mean.\n     * @example\n     *\n     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];\n     *\n     * _.meanBy(objects, function(o) { return o.n; });\n     * // => 5\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.meanBy(objects, 'n');\n     * // => 5\n     */\n    function meanBy(array, iteratee) {\n      return baseMean(array, getIteratee(iteratee, 2));\n    }\n\n    /**\n     * Computes the minimum value of `array`. If `array` is empty or falsey,\n     * `undefined` is returned.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @returns {*} Returns the minimum value.\n     * @example\n     *\n     * _.min([4, 2, 8, 6]);\n     * // => 2\n     *\n     * _.min([]);\n     * // => undefined\n     */\n    function min(array) {\n      return (array && array.length)\n        ? baseExtremum(array, identity, baseLt)\n        : undefined;\n    }\n\n    /**\n     * This method is like `_.min` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the criterion by which\n     * the value is ranked. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {*} Returns the minimum value.\n     * @example\n     *\n     * var objects = [{ 'n': 1 }, { 'n': 2 }];\n     *\n     * _.minBy(objects, function(o) { return o.n; });\n     * // => { 'n': 1 }\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.minBy(objects, 'n');\n     * // => { 'n': 1 }\n     */\n    function minBy(array, iteratee) {\n      return (array && array.length)\n        ? baseExtremum(array, getIteratee(iteratee, 2), baseLt)\n        : undefined;\n    }\n\n    /**\n     * Multiply two numbers.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.7.0\n     * @category Math\n     * @param {number} multiplier The first number in a multiplication.\n     * @param {number} multiplicand The second number in a multiplication.\n     * @returns {number} Returns the product.\n     * @example\n     *\n     * _.multiply(6, 4);\n     * // => 24\n     */\n    var multiply = createMathOperation(function(multiplier, multiplicand) {\n      return multiplier * multiplicand;\n    }, 1);\n\n    /**\n     * Computes `number` rounded to `precision`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.10.0\n     * @category Math\n     * @param {number} number The number to round.\n     * @param {number} [precision=0] The precision to round to.\n     * @returns {number} Returns the rounded number.\n     * @example\n     *\n     * _.round(4.006);\n     * // => 4\n     *\n     * _.round(4.006, 2);\n     * // => 4.01\n     *\n     * _.round(4060, -2);\n     * // => 4100\n     */\n    var round = createRound('round');\n\n    /**\n     * Subtract two numbers.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Math\n     * @param {number} minuend The first number in a subtraction.\n     * @param {number} subtrahend The second number in a subtraction.\n     * @returns {number} Returns the difference.\n     * @example\n     *\n     * _.subtract(6, 4);\n     * // => 2\n     */\n    var subtract = createMathOperation(function(minuend, subtrahend) {\n      return minuend - subtrahend;\n    }, 0);\n\n    /**\n     * Computes the sum of the values in `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.4.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @returns {number} Returns the sum.\n     * @example\n     *\n     * _.sum([4, 2, 8, 6]);\n     * // => 20\n     */\n    function sum(array) {\n      return (array && array.length)\n        ? baseSum(array, identity)\n        : 0;\n    }\n\n    /**\n     * This method is like `_.sum` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the value to be summed.\n     * The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {number} Returns the sum.\n     * @example\n     *\n     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];\n     *\n     * _.sumBy(objects, function(o) { return o.n; });\n     * // => 20\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.sumBy(objects, 'n');\n     * // => 20\n     */\n    function sumBy(array, iteratee) {\n      return (array && array.length)\n        ? baseSum(array, getIteratee(iteratee, 2))\n        : 0;\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    // Add methods that return wrapped values in chain sequences.\n    lodash.after = after;\n    lodash.ary = ary;\n    lodash.assign = assign;\n    lodash.assignIn = assignIn;\n    lodash.assignInWith = assignInWith;\n    lodash.assignWith = assignWith;\n    lodash.at = at;\n    lodash.before = before;\n    lodash.bind = bind;\n    lodash.bindAll = bindAll;\n    lodash.bindKey = bindKey;\n    lodash.castArray = castArray;\n    lodash.chain = chain;\n    lodash.chunk = chunk;\n    lodash.compact = compact;\n    lodash.concat = concat;\n    lodash.cond = cond;\n    lodash.conforms = conforms;\n    lodash.constant = constant;\n    lodash.countBy = countBy;\n    lodash.create = create;\n    lodash.curry = curry;\n    lodash.curryRight = curryRight;\n    lodash.debounce = debounce;\n    lodash.defaults = defaults;\n    lodash.defaultsDeep = defaultsDeep;\n    lodash.defer = defer;\n    lodash.delay = delay;\n    lodash.difference = difference;\n    lodash.differenceBy = differenceBy;\n    lodash.differenceWith = differenceWith;\n    lodash.drop = drop;\n    lodash.dropRight = dropRight;\n    lodash.dropRightWhile = dropRightWhile;\n    lodash.dropWhile = dropWhile;\n    lodash.fill = fill;\n    lodash.filter = filter;\n    lodash.flatMap = flatMap;\n    lodash.flatMapDeep = flatMapDeep;\n    lodash.flatMapDepth = flatMapDepth;\n    lodash.flatten = flatten;\n    lodash.flattenDeep = flattenDeep;\n    lodash.flattenDepth = flattenDepth;\n    lodash.flip = flip;\n    lodash.flow = flow;\n    lodash.flowRight = flowRight;\n    lodash.fromPairs = fromPairs;\n    lodash.functions = functions;\n    lodash.functionsIn = functionsIn;\n    lodash.groupBy = groupBy;\n    lodash.initial = initial;\n    lodash.intersection = intersection;\n    lodash.intersectionBy = intersectionBy;\n    lodash.intersectionWith = intersectionWith;\n    lodash.invert = invert;\n    lodash.invertBy = invertBy;\n    lodash.invokeMap = invokeMap;\n    lodash.iteratee = iteratee;\n    lodash.keyBy = keyBy;\n    lodash.keys = keys;\n    lodash.keysIn = keysIn;\n    lodash.map = map;\n    lodash.mapKeys = mapKeys;\n    lodash.mapValues = mapValues;\n    lodash.matches = matches;\n    lodash.matchesProperty = matchesProperty;\n    lodash.memoize = memoize;\n    lodash.merge = merge;\n    lodash.mergeWith = mergeWith;\n    lodash.method = method;\n    lodash.methodOf = methodOf;\n    lodash.mixin = mixin;\n    lodash.negate = negate;\n    lodash.nthArg = nthArg;\n    lodash.omit = omit;\n    lodash.omitBy = omitBy;\n    lodash.once = once;\n    lodash.orderBy = orderBy;\n    lodash.over = over;\n    lodash.overArgs = overArgs;\n    lodash.overEvery = overEvery;\n    lodash.overSome = overSome;\n    lodash.partial = partial;\n    lodash.partialRight = partialRight;\n    lodash.partition = partition;\n    lodash.pick = pick;\n    lodash.pickBy = pickBy;\n    lodash.property = property;\n    lodash.propertyOf = propertyOf;\n    lodash.pull = pull;\n    lodash.pullAll = pullAll;\n    lodash.pullAllBy = pullAllBy;\n    lodash.pullAllWith = pullAllWith;\n    lodash.pullAt = pullAt;\n    lodash.range = range;\n    lodash.rangeRight = rangeRight;\n    lodash.rearg = rearg;\n    lodash.reject = reject;\n    lodash.remove = remove;\n    lodash.rest = rest;\n    lodash.reverse = reverse;\n    lodash.sampleSize = sampleSize;\n    lodash.set = set;\n    lodash.setWith = setWith;\n    lodash.shuffle = shuffle;\n    lodash.slice = slice;\n    lodash.sortBy = sortBy;\n    lodash.sortedUniq = sortedUniq;\n    lodash.sortedUniqBy = sortedUniqBy;\n    lodash.split = split;\n    lodash.spread = spread;\n    lodash.tail = tail;\n    lodash.take = take;\n    lodash.takeRight = takeRight;\n    lodash.takeRightWhile = takeRightWhile;\n    lodash.takeWhile = takeWhile;\n    lodash.tap = tap;\n    lodash.throttle = throttle;\n    lodash.thru = thru;\n    lodash.toArray = toArray;\n    lodash.toPairs = toPairs;\n    lodash.toPairsIn = toPairsIn;\n    lodash.toPath = toPath;\n    lodash.toPlainObject = toPlainObject;\n    lodash.transform = transform;\n    lodash.unary = unary;\n    lodash.union = union;\n    lodash.unionBy = unionBy;\n    lodash.unionWith = unionWith;\n    lodash.uniq = uniq;\n    lodash.uniqBy = uniqBy;\n    lodash.uniqWith = uniqWith;\n    lodash.unset = unset;\n    lodash.unzip = unzip;\n    lodash.unzipWith = unzipWith;\n    lodash.update = update;\n    lodash.updateWith = updateWith;\n    lodash.values = values;\n    lodash.valuesIn = valuesIn;\n    lodash.without = without;\n    lodash.words = words;\n    lodash.wrap = wrap;\n    lodash.xor = xor;\n    lodash.xorBy = xorBy;\n    lodash.xorWith = xorWith;\n    lodash.zip = zip;\n    lodash.zipObject = zipObject;\n    lodash.zipObjectDeep = zipObjectDeep;\n    lodash.zipWith = zipWith;\n\n    // Add aliases.\n    lodash.entries = toPairs;\n    lodash.entriesIn = toPairsIn;\n    lodash.extend = assignIn;\n    lodash.extendWith = assignInWith;\n\n    // Add methods to `lodash.prototype`.\n    mixin(lodash, lodash);\n\n    /*------------------------------------------------------------------------*/\n\n    // Add methods that return unwrapped values in chain sequences.\n    lodash.add = add;\n    lodash.attempt = attempt;\n    lodash.camelCase = camelCase;\n    lodash.capitalize = capitalize;\n    lodash.ceil = ceil;\n    lodash.clamp = clamp;\n    lodash.clone = clone;\n    lodash.cloneDeep = cloneDeep;\n    lodash.cloneDeepWith = cloneDeepWith;\n    lodash.cloneWith = cloneWith;\n    lodash.conformsTo = conformsTo;\n    lodash.deburr = deburr;\n    lodash.defaultTo = defaultTo;\n    lodash.divide = divide;\n    lodash.endsWith = endsWith;\n    lodash.eq = eq;\n    lodash.escape = escape;\n    lodash.escapeRegExp = escapeRegExp;\n    lodash.every = every;\n    lodash.find = find;\n    lodash.findIndex = findIndex;\n    lodash.findKey = findKey;\n    lodash.findLast = findLast;\n    lodash.findLastIndex = findLastIndex;\n    lodash.findLastKey = findLastKey;\n    lodash.floor = floor;\n    lodash.forEach = forEach;\n    lodash.forEachRight = forEachRight;\n    lodash.forIn = forIn;\n    lodash.forInRight = forInRight;\n    lodash.forOwn = forOwn;\n    lodash.forOwnRight = forOwnRight;\n    lodash.get = get;\n    lodash.gt = gt;\n    lodash.gte = gte;\n    lodash.has = has;\n    lodash.hasIn = hasIn;\n    lodash.head = head;\n    lodash.identity = identity;\n    lodash.includes = includes;\n    lodash.indexOf = indexOf;\n    lodash.inRange = inRange;\n    lodash.invoke = invoke;\n    lodash.isArguments = isArguments;\n    lodash.isArray = isArray;\n    lodash.isArrayBuffer = isArrayBuffer;\n    lodash.isArrayLike = isArrayLike;\n    lodash.isArrayLikeObject = isArrayLikeObject;\n    lodash.isBoolean = isBoolean;\n    lodash.isBuffer = isBuffer;\n    lodash.isDate = isDate;\n    lodash.isElement = isElement;\n    lodash.isEmpty = isEmpty;\n    lodash.isEqual = isEqual;\n    lodash.isEqualWith = isEqualWith;\n    lodash.isError = isError;\n    lodash.isFinite = isFinite;\n    lodash.isFunction = isFunction;\n    lodash.isInteger = isInteger;\n    lodash.isLength = isLength;\n    lodash.isMap = isMap;\n    lodash.isMatch = isMatch;\n    lodash.isMatchWith = isMatchWith;\n    lodash.isNaN = isNaN;\n    lodash.isNative = isNative;\n    lodash.isNil = isNil;\n    lodash.isNull = isNull;\n    lodash.isNumber = isNumber;\n    lodash.isObject = isObject;\n    lodash.isObjectLike = isObjectLike;\n    lodash.isPlainObject = isPlainObject;\n    lodash.isRegExp = isRegExp;\n    lodash.isSafeInteger = isSafeInteger;\n    lodash.isSet = isSet;\n    lodash.isString = isString;\n    lodash.isSymbol = isSymbol;\n    lodash.isTypedArray = isTypedArray;\n    lodash.isUndefined = isUndefined;\n    lodash.isWeakMap = isWeakMap;\n    lodash.isWeakSet = isWeakSet;\n    lodash.join = join;\n    lodash.kebabCase = kebabCase;\n    lodash.last = last;\n    lodash.lastIndexOf = lastIndexOf;\n    lodash.lowerCase = lowerCase;\n    lodash.lowerFirst = lowerFirst;\n    lodash.lt = lt;\n    lodash.lte = lte;\n    lodash.max = max;\n    lodash.maxBy = maxBy;\n    lodash.mean = mean;\n    lodash.meanBy = meanBy;\n    lodash.min = min;\n    lodash.minBy = minBy;\n    lodash.stubArray = stubArray;\n    lodash.stubFalse = stubFalse;\n    lodash.stubObject = stubObject;\n    lodash.stubString = stubString;\n    lodash.stubTrue = stubTrue;\n    lodash.multiply = multiply;\n    lodash.nth = nth;\n    lodash.noConflict = noConflict;\n    lodash.noop = noop;\n    lodash.now = now;\n    lodash.pad = pad;\n    lodash.padEnd = padEnd;\n    lodash.padStart = padStart;\n    lodash.parseInt = parseInt;\n    lodash.random = random;\n    lodash.reduce = reduce;\n    lodash.reduceRight = reduceRight;\n    lodash.repeat = repeat;\n    lodash.replace = replace;\n    lodash.result = result;\n    lodash.round = round;\n    lodash.runInContext = runInContext;\n    lodash.sample = sample;\n    lodash.size = size;\n    lodash.snakeCase = snakeCase;\n    lodash.some = some;\n    lodash.sortedIndex = sortedIndex;\n    lodash.sortedIndexBy = sortedIndexBy;\n    lodash.sortedIndexOf = sortedIndexOf;\n    lodash.sortedLastIndex = sortedLastIndex;\n    lodash.sortedLastIndexBy = sortedLastIndexBy;\n    lodash.sortedLastIndexOf = sortedLastIndexOf;\n    lodash.startCase = startCase;\n    lodash.startsWith = startsWith;\n    lodash.subtract = subtract;\n    lodash.sum = sum;\n    lodash.sumBy = sumBy;\n    lodash.template = template;\n    lodash.times = times;\n    lodash.toFinite = toFinite;\n    lodash.toInteger = toInteger;\n    lodash.toLength = toLength;\n    lodash.toLower = toLower;\n    lodash.toNumber = toNumber;\n    lodash.toSafeInteger = toSafeInteger;\n    lodash.toString = toString;\n    lodash.toUpper = toUpper;\n    lodash.trim = trim;\n    lodash.trimEnd = trimEnd;\n    lodash.trimStart = trimStart;\n    lodash.truncate = truncate;\n    lodash.unescape = unescape;\n    lodash.uniqueId = uniqueId;\n    lodash.upperCase = upperCase;\n    lodash.upperFirst = upperFirst;\n\n    // Add aliases.\n    lodash.each = forEach;\n    lodash.eachRight = forEachRight;\n    lodash.first = head;\n\n    mixin(lodash, (function() {\n      var source = {};\n      baseForOwn(lodash, function(func, methodName) {\n        if (!hasOwnProperty.call(lodash.prototype, methodName)) {\n          source[methodName] = func;\n        }\n      });\n      return source;\n    }()), { 'chain': false });\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * The semantic version number.\n     *\n     * @static\n     * @memberOf _\n     * @type {string}\n     */\n    lodash.VERSION = VERSION;\n\n    // Assign default placeholders.\n    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {\n      lodash[methodName].placeholder = lodash;\n    });\n\n    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.\n    arrayEach(['drop', 'take'], function(methodName, index) {\n      LazyWrapper.prototype[methodName] = function(n) {\n        n = n === undefined ? 1 : nativeMax(toInteger(n), 0);\n\n        var result = (this.__filtered__ && !index)\n          ? new LazyWrapper(this)\n          : this.clone();\n\n        if (result.__filtered__) {\n          result.__takeCount__ = nativeMin(n, result.__takeCount__);\n        } else {\n          result.__views__.push({\n            'size': nativeMin(n, MAX_ARRAY_LENGTH),\n            'type': methodName + (result.__dir__ < 0 ? 'Right' : '')\n          });\n        }\n        return result;\n      };\n\n      LazyWrapper.prototype[methodName + 'Right'] = function(n) {\n        return this.reverse()[methodName](n).reverse();\n      };\n    });\n\n    // Add `LazyWrapper` methods that accept an `iteratee` value.\n    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {\n      var type = index + 1,\n          isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;\n\n      LazyWrapper.prototype[methodName] = function(iteratee) {\n        var result = this.clone();\n        result.__iteratees__.push({\n          'iteratee': getIteratee(iteratee, 3),\n          'type': type\n        });\n        result.__filtered__ = result.__filtered__ || isFilter;\n        return result;\n      };\n    });\n\n    // Add `LazyWrapper` methods for `_.head` and `_.last`.\n    arrayEach(['head', 'last'], function(methodName, index) {\n      var takeName = 'take' + (index ? 'Right' : '');\n\n      LazyWrapper.prototype[methodName] = function() {\n        return this[takeName](1).value()[0];\n      };\n    });\n\n    // Add `LazyWrapper` methods for `_.initial` and `_.tail`.\n    arrayEach(['initial', 'tail'], function(methodName, index) {\n      var dropName = 'drop' + (index ? '' : 'Right');\n\n      LazyWrapper.prototype[methodName] = function() {\n        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);\n      };\n    });\n\n    LazyWrapper.prototype.compact = function() {\n      return this.filter(identity);\n    };\n\n    LazyWrapper.prototype.find = function(predicate) {\n      return this.filter(predicate).head();\n    };\n\n    LazyWrapper.prototype.findLast = function(predicate) {\n      return this.reverse().find(predicate);\n    };\n\n    LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {\n      if (typeof path == 'function') {\n        return new LazyWrapper(this);\n      }\n      return this.map(function(value) {\n        return baseInvoke(value, path, args);\n      });\n    });\n\n    LazyWrapper.prototype.reject = function(predicate) {\n      return this.filter(negate(getIteratee(predicate)));\n    };\n\n    LazyWrapper.prototype.slice = function(start, end) {\n      start = toInteger(start);\n\n      var result = this;\n      if (result.__filtered__ && (start > 0 || end < 0)) {\n        return new LazyWrapper(result);\n      }\n      if (start < 0) {\n        result = result.takeRight(-start);\n      } else if (start) {\n        result = result.drop(start);\n      }\n      if (end !== undefined) {\n        end = toInteger(end);\n        result = end < 0 ? result.dropRight(-end) : result.take(end - start);\n      }\n      return result;\n    };\n\n    LazyWrapper.prototype.takeRightWhile = function(predicate) {\n      return this.reverse().takeWhile(predicate).reverse();\n    };\n\n    LazyWrapper.prototype.toArray = function() {\n      return this.take(MAX_ARRAY_LENGTH);\n    };\n\n    // Add `LazyWrapper` methods to `lodash.prototype`.\n    baseForOwn(LazyWrapper.prototype, function(func, methodName) {\n      var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),\n          isTaker = /^(?:head|last)$/.test(methodName),\n          lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName],\n          retUnwrapped = isTaker || /^find/.test(methodName);\n\n      if (!lodashFunc) {\n        return;\n      }\n      lodash.prototype[methodName] = function() {\n        var value = this.__wrapped__,\n            args = isTaker ? [1] : arguments,\n            isLazy = value instanceof LazyWrapper,\n            iteratee = args[0],\n            useLazy = isLazy || isArray(value);\n\n        var interceptor = function(value) {\n          var result = lodashFunc.apply(lodash, arrayPush([value], args));\n          return (isTaker && chainAll) ? result[0] : result;\n        };\n\n        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {\n          // Avoid lazy use if the iteratee has a \"length\" value other than `1`.\n          isLazy = useLazy = false;\n        }\n        var chainAll = this.__chain__,\n            isHybrid = !!this.__actions__.length,\n            isUnwrapped = retUnwrapped && !chainAll,\n            onlyLazy = isLazy && !isHybrid;\n\n        if (!retUnwrapped && useLazy) {\n          value = onlyLazy ? value : new LazyWrapper(this);\n          var result = func.apply(value, args);\n          result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });\n          return new LodashWrapper(result, chainAll);\n        }\n        if (isUnwrapped && onlyLazy) {\n          return func.apply(this, args);\n        }\n        result = this.thru(interceptor);\n        return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;\n      };\n    });\n\n    // Add `Array` methods to `lodash.prototype`.\n    arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {\n      var func = arrayProto[methodName],\n          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',\n          retUnwrapped = /^(?:pop|shift)$/.test(methodName);\n\n      lodash.prototype[methodName] = function() {\n        var args = arguments;\n        if (retUnwrapped && !this.__chain__) {\n          var value = this.value();\n          return func.apply(isArray(value) ? value : [], args);\n        }\n        return this[chainName](function(value) {\n          return func.apply(isArray(value) ? value : [], args);\n        });\n      };\n    });\n\n    // Map minified method names to their real names.\n    baseForOwn(LazyWrapper.prototype, function(func, methodName) {\n      var lodashFunc = lodash[methodName];\n      if (lodashFunc) {\n        var key = lodashFunc.name + '';\n        if (!hasOwnProperty.call(realNames, key)) {\n          realNames[key] = [];\n        }\n        realNames[key].push({ 'name': methodName, 'func': lodashFunc });\n      }\n    });\n\n    realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [{\n      'name': 'wrapper',\n      'func': undefined\n    }];\n\n    // Add methods to `LazyWrapper`.\n    LazyWrapper.prototype.clone = lazyClone;\n    LazyWrapper.prototype.reverse = lazyReverse;\n    LazyWrapper.prototype.value = lazyValue;\n\n    // Add chain sequence methods to the `lodash` wrapper.\n    lodash.prototype.at = wrapperAt;\n    lodash.prototype.chain = wrapperChain;\n    lodash.prototype.commit = wrapperCommit;\n    lodash.prototype.next = wrapperNext;\n    lodash.prototype.plant = wrapperPlant;\n    lodash.prototype.reverse = wrapperReverse;\n    lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;\n\n    // Add lazy aliases.\n    lodash.prototype.first = lodash.prototype.head;\n\n    if (symIterator) {\n      lodash.prototype[symIterator] = wrapperToIterator;\n    }\n    return lodash;\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  // Export lodash.\n  var _ = runInContext();\n\n  // Some AMD build optimizers, like r.js, check for condition patterns like:\n  if (true) {\n    // Expose Lodash on the global object to prevent errors when Lodash is\n    // loaded by a script tag in the presence of an AMD loader.\n    // See http://requirejs.org/docs/errors.html#mismatch for more details.\n    // Use `_.noConflict` to remove Lodash from the global object.\n    root._ = _;\n\n    // Define as an anonymous module so, through path mapping, it can be\n    // referenced as the \"underscore\" module.\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n      return _;\n    }).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  }\n  // Check for `exports` after `define` in case a build optimizer adds it.\n  else {}\n}.call(this));\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))\n\n//# sourceURL=webpack:///./node_modules/lodash/lodash.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function(module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n\n\n//# sourceURL=webpack:///(webpack)/buildin/module.js?");

/***/ }),

/***/ "./src/app.js":
/*!********************!*\
  !*** ./src/app.js ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.tractatus = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     this is the main entry point for the application\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     relevant classes are broken out into other files such as Section.ts, PTSection.ts, ISection.ts, util.ts, etc\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     \n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     The code relies on a specific data structure in ptSectionsJson.json, sectionsJson.json, linesJson.json and ptLinesJson.json files\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     \n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     psSectionsJson.json must look like this example...\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         {\"sections\":[ {\"label\": \"1\", \"precision\": 0, \"fontSize\": \"90px\", \"y_axis\": 1, \"x_axis\": 1, \"ger\": \"Test German\", \"ogd\": \"Test OGD\", \"pmc\": \"Test PMC\"}, ... ]}\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ptLinesJson.json must look like this example...\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         {\"lines\" : [{\"label\": \"1\", \"sections\": [1,1.1,1.2], \"start\": \"1\", \"end\": \"1.2\", \"precision\": 1, \"color\": \"#bf4f4e\"}, ...]}\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     sectionsJson.json must look like this example...\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         {\"sections\":[{ \"label\": \"2.01\", \"precision\": 2, \"fontSize\":\"40px\", \"y_axis\": 3, \"x_axis\": 11, \"ger\": \"Test German\", \"ogd\": \"Test OGD\", \"pmc\": \"Test PMC\"}, ... ]}\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     linesJson.json must look like this example...\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         {\"lines\" : [{\"label\": \"1.1\", \"sections\": [1.1,1.11,1.12,1.13], \"start\": \"1.1\", \"end\": \"1.13\", \"precision\": 2, \"color\": \"#f6944c\"}, ... ]}\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */\n\n//break out separate classes for clarity\n\n\nvar _diff = __webpack_require__(/*! diff */ \"./node_modules/diff/dist/diff.js\");\n\nvar JsDiff = _interopRequireWildcard(_diff);\n\nvar _lodash = __webpack_require__(/*! lodash */ \"./node_modules/lodash/lodash.js\");\n\nvar _ = _interopRequireWildcard(_lodash);\n\nvar _reference = __webpack_require__(/*! ./reference */ \"./src/reference.js\");\n\nvar _util = __webpack_require__(/*! ./util */ \"./src/util.js\");\n\nvar _section = __webpack_require__(/*! ./section */ \"./src/section.js\");\n\nvar _line2 = __webpack_require__(/*! ./line */ \"./src/line.js\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar sectionsJson = __webpack_require__(/*! ./data/sections.json */ \"./src/data/sections.json\");\nvar ptSectionsJson = __webpack_require__(/*! ./data/ptSections.json */ \"./src/data/ptSections.json\");\nvar linesJson = __webpack_require__(/*! ./data/lines.json */ \"./src/data/lines.json\");\nvar ptLinesJson = __webpack_require__(/*! ./data/ptLines.json */ \"./src/data/ptLines.json\");\nvar tractatus = exports.tractatus = undefined;\n(function (tractatus) {\n    var Container = function () {\n        function Container() {\n            _classCallCheck(this, Container);\n\n            //version = ger, pmc, ogd\n            this._version = 'ger';\n            this._gap = 50;\n            this._width = $(\"#map\").width(); //doesn't work yet\n            this._height = $(window).height();\n            this._divCounter = 0;\n            this._startPage = 0;\n            this._endPage = 0;\n            //template = either pt or tlp.  introduced to avoid the need for maintaining separate code bases for each\n            this._template = 'tlp';\n            this.diffWords = function (result, sectionText) {\n                return JsDiff.diffWords(result, sectionText);\n            };\n        }\n\n        _createClass(Container, [{\n            key: 'setupAccordionSidePanel',\n            value: function setupAccordionSidePanel() {\n                var container = this;\n                var version = container.version;\n                $(\".accordion-column\").hide();\n                //hide the page selector unless PT is selected\n                $(\"#page-select-form\").hide();\n                $(\"#accordion\").collapse().sortable();\n                $('#version-selector-all').val(version);\n                $(\"#reset-btn\").on('click', function () {\n                    window.location.reload();\n                });\n                //choose which template to use (PT or TLP)\n                $(\"#pt-btn\").on('click', function () {\n                    if ($(this).val() == \"Load Tractatus\") {\n                        localStorage.setItem('tlp-template', 'tlp');\n                        container.template == \"tlp\";\n                    } else {\n                        localStorage.setItem('tlp-template', 'pt');\n                        container.template == \"pt\";\n                    }\n                    window.location.reload();\n                });\n                //show the page selector if PT is selected\n                if (container.template == \"pt\") {\n                    //localStorage.setItem('tlp-version', \"ger\");\n                    $(\"#pt-btn\").html(\"Load Tractatus\").val(\"Load Tractatus\");\n                    $(\"option[value='ogd']\").remove();\n                    $(\"#page-select-form\").show();\n                } else {\n                    $(\"#pt-btn\").html(\"Load Prototractatus\").val(\"Load Prototractatus\");\n                }\n                /*\n                 Leaving for now.  May want something like this in the future.\n                $(document).on('click', '#scroll-to-top', function () {\n                    window.scrollTo(0, 0);\n                })*/\n                //close panels.  if it's the last one, hide the panel column\n                $(\".panel-group\").on('click', '.close-panel', function () {\n                    $('.panel-group').find($(this).parents('.panel-default:first')).remove();\n                    $.when($(this).parents('.panel-default:first').remove()).then(function () {\n                        if ($(\".panel-default\").length <= 0) {\n                            $(\".accordion-column\").hide();\n                        }\n                    });\n                });\n                $(\"#collapse-all-btn\").on('click', function () {\n                    $(\".panel-collapse\").collapse('hide');\n                });\n                $(\"#expand-all-btn\").on('click', function () {\n                    $(\".panel-collapse\").collapse('show');\n                });\n                $(\"#close-all-btn\").on('click', function () {\n                    $(\".panel-default\").remove();\n                    $(\".accordion-column\").hide();\n                });\n                /*Note: An overall version selector becomes available when clicking a line which displays multiple panels (one for each section in the line)\n                      If an individual circle/Section is clicked, a panel will display and will have it's own version selector.  This is so that you can\n                      compare text for the same section.*/\n                //change versions in the overall version selector (not the individual panel version selectors)\n                $(\".accordion-column\").on('change', \"#version-selector-all\", function () {\n                    var selector = $(this);\n                    var version = $(\"option:selected\", selector).attr('value');\n                    var u = container.util;\n                    $('.panel-body').each(function () {\n                        var panelBody = $(this);\n                        var sectionNum = panelBody.attr(\"value\");\n                        if ($(\".version-selector\", panelBody).length <= 0) {\n                            var parentDivId = panelBody.parents('div:first').attr('id');\n                            var text = panelBody.attr(version);\n                            $(\".text-display-li\", panelBody).html(text);\n                            $(\"li\", panelBody).remove();\n                            panelBody.append($('<li class=\"text-display-li\">' + text + '</li>')).load(text, function () {\n                                MathJax.Hub.Queue([\"Typeset\", MathJax.Hub, parentDivId]);\n                            });\n                            //check if page is pt\n                            if (container.template == 'pt') {\n                                var parent = panelBody.parents(\".panel-collapse:first\");\n                                $(\".pnum\", parent).remove();\n                                $(\".diff\", parent).remove();\n                                var returnVal = u.findDiff(sectionNum, version);\n                                parent.append('<div class=\"pnum\">text difference when compared to TLP ' + u.ptToTlp(sectionNum) + '</div>');\n                                parent.append(returnVal);\n                            }\n                        }\n                    });\n                    localStorage.setItem('tlp-version', version);\n                });\n                //change versions in the individual panel version selectors (not the overall panel version selector)\n                $('.accordion-column').on('change', \".version-selector\", function () {\n                    var $this = $(this);\n                    var panelBody = $this.parents('.panel-body');\n                    var sectionNum = panelBody.attr(\"value\");\n                    var parentDivId = panelBody.parents('div:first').attr('id');\n                    var v = $(\"option:selected\", $this).attr('value');\n                    var text = panelBody.attr(v);\n                    var u = container.util;\n                    $this.closest($(\".text-display-li\")).html(text);\n                    $(\"li\", panelBody).remove();\n                    panelBody.append($('<li class=\"text-display-li\">' + text + '</li>')).load(text, function () {\n                        MathJax.Hub.Queue([\"Typeset\", MathJax.Hub, parentDivId]);\n                    });\n                    //check if page is pt\n                    if (container.template == 'pt') {\n                        var parent = panelBody.parents(\".panel-collapse:first\");\n                        $(\".pnum\", parent).remove();\n                        $(\".diff\", parent).remove();\n                        var returnVal = u.findDiff(sectionNum, v);\n                        parent.append('<div class=\"pnum\">text difference when compared to TLP ' + u.ptToTlp(sectionNum) + '</div>');\n                        parent.append(returnVal);\n                    }\n                    localStorage.setItem('tlp-version', v);\n                });\n            }\n            //filter sections based on pages entered (PT only)\n\n        }, {\n            key: 'setupPTPaging',\n            value: function setupPTPaging() {\n                var container = this;\n                $('#start-page').val(container.startPage);\n                $('#end-page').val(container.endPage);\n                var sectionList = container.sectionList;\n                var pageFilteredPTList = [];\n                // when the page form submit button is clicked, set the start and end page values based on text box values\n                $('#page-submit').click(function () {\n                    container.startPage = parseInt($('#start-page').val().toString());\n                    container.endPage = parseInt($('#end-page').val().toString());\n                });\n                // add all object in the sectionList that fall between start and end page numbers.\n                _.forEach(sectionList.sections, function (value, key) {\n                    if (value.page >= container.startPage && value.page <= container.endPage) {\n                        pageFilteredPTList.push(parseFloat(value.label));\n                    };\n                });\n                container.pageFilteredPTList = pageFilteredPTList;\n            }\n        }, {\n            key: 'setupD3',\n            value: function setupD3() {\n                var container = this;\n                var gap = container.gap;\n                var width = $(\"#map\").width();\n                var height = container.height;\n                var sectionAr = [];\n                var lineAr = [];\n                var sectionList = container.sectionList;\n                var lineList = container.lineList;\n                $.each(sectionList.sections, function () {\n                    var $this = $(this);\n                    var o = $(this)[0];\n                    var section = new _section.Section(o.label, o.fontSize, o.precision, o.x_axis, o.y_axis, o.ger, o.ogd, o.pmc, o.str);\n                    sectionAr.push(section);\n                });\n                $.each(lineList.lines, function () {\n                    var l = $(this)[0];\n                    var i = 0;\n                    var sections = l.sections;\n                    $.each(sections, function () {\n                        if (i + 1 != sections.length) {\n                            var o = sections[i];\n                            var o1 = sections[i + 1];\n                            var _line = new _line2.Line(o, l.sections, o, o1, l.precision, l.color);\n                            lineAr.push(_line);\n                            i++;\n                        }\n                    });\n                });\n                var svg = d3.select(\"#map\").append(\"svg\").attr(\"width\", width).attr(\"height\", height).attr(\"id\", \"tractatus-map\");\n                /* Define the data for the circles */\n                var elem = svg.selectAll(\"g\").data(sectionAr);\n                /* Define the data for the lines */\n                var elemLine = svg.selectAll(\"g\").data(lineAr);\n                var elemLineEnter = elemLine.enter().append(\"g\");\n                /*Create and place the \"blocks\" containing the circle and the text */\n                var elemEnter = elem.enter().append(\"g\");\n                var line = elemLineEnter.append(\"line\").attr(\"x1\", function (d) {\n                    var point = d.findPoints(container);\n                    return point.x1 * gap;\n                }) //x_axis of 1st section + radius/2 ?\n                .attr(\"y1\", function (d) {\n                    var point = d.findPoints(container);\n                    return point.y1 * gap;\n                }) //y_axis of 1st section\n                .attr(\"x2\", function (d) {\n                    var point = d.findPoints(container);\n                    return point.x2 * gap;\n                }) //x_axis of 2nd section\n                .attr(\"y2\", function (d) {\n                    var point = d.findPoints(container);\n                    return point.y2 * gap;\n                }) //y_axis of 2nd section\n                .attr(\"stroke-width\", 20) //double radius?\n                .attr(\"stroke\", function (d) {\n                    if (container.template == \"pt\") {\n                        return d.checkLineColor(container.pageFilteredPTList, d.start, d.end, d.color);\n                    }\n                    return d.color;\n                }).style(\"cursor\", \"pointer\").on(\"click\", function (d) {\n                    d.buildGroup(container);\n                    //animate the border of the panels to show that something happened when you click on a section or line.  if appended to the bottom, it's\n                    //difficult to tell that anything happened when you click on a line/section\n                    $(\"#accordion\").css({\n                        border: '0 solid #86d0f3'\n                    }).animate({\n                        borderWidth: 2\n                    }, 500).animate({\n                        borderWidth: 0\n                    }, 500);\n                });\n                /*Create the circle for each block */\n                var circle = elemEnter.append(\"circle\").attr(\"cx\", function (d) {\n                    return d.x_axis * gap;\n                }).attr(\"cy\", function (d) {\n                    return d.y_axis * gap;\n                }).attr(\"r\", 15).attr(\"stroke\", function (d) {\n                    if (container.template == \"pt\") {\n                        return d.checkCircleColor(container._pageFilteredPTList, d.label, 'black');\n                    }\n                    return \"black\";\n                }).attr(\"fill\", \"white\").attr(\"stroke-width\", 4).style(\"cursor\", \"pointer\").on(\"click\", function (d) {\n                    container.divCounter = d.displayText(true, container.version, container.divCounter, container.template, container.util);\n                    $(\"#accordion\").css({\n                        border: '0 solid #86d0f3'\n                    }).animate({\n                        borderWidth: 2\n                    }, 500).animate({\n                        borderWidth: 0\n                    }, 500);\n                });\n                /* Create the text for each block */\n                elemEnter.append(\"text\").attr(\"dx\", function (d) {\n                    return d.x_axis * gap + 15;\n                }).attr(\"dy\", function (d) {\n                    return d.y_axis * gap - 15;\n                }).attr(\"font-size\", function (d) {\n                    return d.fontSize;\n                }).text(function (d) {\n                    return d.label;\n                });\n            }\n        }, {\n            key: 'version',\n            get: function get() {\n                if (localStorage.getItem('tlp-version') != null) {\n                    return localStorage.getItem('tlp-version');\n                }\n                return this._version;\n            },\n            set: function set(version) {\n                this._version = version;\n                localStorage.setItem(\"tlp-version\", version);\n            }\n        }, {\n            key: 'gap',\n            get: function get() {\n                return this._gap;\n            },\n            set: function set(gap) {\n                this._gap = gap;\n            }\n        }, {\n            key: 'width',\n            get: function get() {\n                return this._width;\n            },\n            set: function set(width) {\n                this._width = width;\n            }\n        }, {\n            key: 'height',\n            get: function get() {\n                return this._height;\n            },\n            set: function set(height) {\n                this._height = height;\n            }\n        }, {\n            key: 'divCounter',\n            get: function get() {\n                return this._divCounter;\n            },\n            set: function set(divCounter) {\n                this._divCounter = divCounter;\n            }\n        }, {\n            key: 'startPage',\n            get: function get() {\n                if (localStorage.getItem('tlp-startPage') != null) {\n                    return parseInt(localStorage.getItem('tlp-startPage'));\n                }\n                return this._startPage;\n            },\n            set: function set(startPage) {\n                this._startPage = startPage;\n                localStorage.setItem(\"tlp-startPage\", startPage.toString());\n            }\n        }, {\n            key: 'endPage',\n            get: function get() {\n                if (localStorage.getItem('tlp-endPage') != null) {\n                    return parseInt(localStorage.getItem('tlp-endPage'));\n                }\n                return this._endPage;\n            },\n            set: function set(endPage) {\n                this._endPage = endPage;\n                localStorage.setItem(\"tlp-endPage\", endPage.toString());\n            }\n        }, {\n            key: 'template',\n            get: function get() {\n                if (localStorage.getItem('tlp-template') != null) {\n                    return localStorage.getItem('tlp-template');\n                }\n                return this._template;\n            },\n            set: function set(template) {\n                this._template = template;\n                localStorage.setItem('tlp-template', template);\n            }\n        }, {\n            key: 'sectionList',\n            get: function get() {\n                return this._sectionList;\n            },\n            set: function set(sectionList) {\n                this._sectionList = sectionList;\n            }\n        }, {\n            key: 'lineList',\n            get: function get() {\n                return this._lineList;\n            },\n            set: function set(lineList) {\n                this._lineList = lineList;\n            }\n        }, {\n            key: 'pageFilteredPTList',\n            get: function get() {\n                return this._pageFilteredPTList;\n            },\n            set: function set(value) {\n                this._pageFilteredPTList = value;\n            }\n        }, {\n            key: 'util',\n            get: function get() {\n                return this._util;\n            },\n            set: function set(value) {\n                this._util = value;\n            }\n        }, {\n            key: 'ref',\n            get: function get() {\n                return this._ref;\n            },\n            set: function set(value) {\n                this._ref = value;\n            }\n        }]);\n\n        return Container;\n    }();\n\n    tractatus.Container = Container;\n})(tractatus || (exports.tractatus = tractatus = {}));\n//initialize everything\nvar container = new tractatus.Container();\ncontainer.ref = new _reference.Reference.Ref();\nvar util = new _util.Utility.Utils();\nutil.container = container;\nutil.setup();\ncontainer.util = util;\ncontainer.sectionList = container.template == \"pt\" ? ptSectionsJson : sectionsJson;\ncontainer.lineList = container.template == \"pt\" ? ptLinesJson : linesJson;\ncontainer.setupAccordionSidePanel();\ncontainer.setupPTPaging();\ncontainer.setupD3();\n\n//# sourceURL=webpack:///./src/app.js?");

/***/ }),

/***/ "./src/data/lines.json":
/*!*****************************!*\
  !*** ./src/data/lines.json ***!
  \*****************************/
/*! exports provided: lines, default */
/***/ (function(module) {

eval("module.exports = {\"lines\":[{\"label\":\"1\",\"sections\":[1,2,3,4,5,6,7],\"start\":\"1\",\"end\":\"7\",\"precision\":0,\"color\":\"#9b0058\"},{\"label\":\"1\",\"sections\":[1,1.1,1.2],\"start\":\"1\",\"end\":\"1.2\",\"precision\":1,\"color\":\"#bf4f4e\"},{\"label\":\"1.1\",\"sections\":[1.1,1.11,1.12,1.13],\"start\":\"1.1\",\"end\":\"1.13\",\"precision\":2,\"color\":\"#f6944c\"},{\"label\":\"1.2\",\"sections\":[1.2,1.21],\"start\":\"1.2\",\"end\":\"1.21\",\"precision\":2,\"color\":\"#f6944c\"},{\"label\":\"2.01\",\"sections\":[2,2.01,2.02,2.03,2.04,2.05,2.06],\"start\":\"2.01\",\"end\":\"2.06\",\"precision\":2,\"color\":\"#e5b8b7\"},{\"label\":\"2\",\"sections\":[2,2.1,2.2],\"start\":\"2\",\"end\":\"2.2\",\"precision\":1,\"color\":\"#bf4f4e\"},{\"label\":\"2.21\",\"sections\":[2.2,2.21,2.22],\"start\":\"2.21\",\"end\":\"2.22\",\"precision\":2,\"color\":\"#f6944c\"},{\"label\":\"2.2\",\"sections\":[2.2,2.201,2.202,2.203],\"start\":\"2.2\",\"end\":\"2.203\",\"precision\":3,\"color\":\"#fcd4b5\"},{\"label\":\"2.22\",\"sections\":[2.22,2.221,2.222,2.223,2.224,2.225],\"start\":\"2.22\",\"end\":\"2.225\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"2.1\",\"sections\":[2.1,2.11,2.12,2.13,2.14,2.15,2.16,2.17,2.18,2.19],\"start\":\"2.1\",\"end\":\"2.19\",\"precision\":2,\"color\":\"#f6944c\"},{\"label\":\"2.06\",\"sections\":[2.06,2.061,2.062,2.063],\"start\":\"2.06\",\"end\":\"2.063\",\"precision\":3,\"color\":\"#fcd4b5\"},{\"label\":\"2.03\",\"sections\":[2.03,2.031,2.032,2.033,2.034],\"start\":\"2.03\",\"end\":\"2.034\",\"precision\":3,\"color\":\"#fcd4b5\"},{\"label\":\"3.1\",\"sections\":[3.1,3.11,3.12,3.13,3.14],\"start\":\"3.1\",\"end\":\"3.14\",\"precision\":2,\"color\":\"#f6944c\"},{\"label\":\"2.02\",\"sections\":[2.02,2.021,2.022,2.023,2.024,2.025,2.026,2.027],\"start\":\"2.02\",\"end\":\"2.027\",\"precision\":3,\"color\":\"#fcd4b5\"},{\"label\":\"2.01\",\"sections\":[2.01,2.011,2.012,2.013,2.014],\"start\":\"2.01\",\"end\":\"2.014\",\"precision\":3,\"color\":\"#fcd4b5\"},{\"label\":\"2.021\",\"sections\":[2.021,2.0211,2.0212],\"start\":\"2.021\",\"end\":\"2.0212\",\"precision\":4,\"color\":\"#d9e3bd\"},{\"label\":\"2.023\",\"sections\":[2.023,2.0231,2.0232,2.0233],\"start\":\"2.023\",\"end\":\"2.0233\",\"precision\":4,\"color\":\"#d9e3bd\"},{\"label\":\"2.025\",\"sections\":[2.025,2.0251],\"start\":\"2.025\",\"end\":\"2.0251\",\"precision\":4,\"color\":\"#d9e3bd\"},{\"label\":\"2.027\",\"sections\":[2.027,2.0271,2.0272],\"start\":\"2.027\",\"end\":\"2.0272\",\"precision\":4,\"color\":\"#d9e3bd\"},{\"label\":\"2.0233\",\"sections\":[2.0233,2.02331],\"start\":\"2.0233\",\"end\":\"2.02331\",\"precision\":5,\"color\":\"#b8dede\"},{\"label\":\"2.012\",\"sections\":[2.012,2.0121,2.0122,2.0123,2.0124],\"start\":\"2.012\",\"end\":\"2.0124\",\"precision\":4,\"color\":\"#d9e3bd\"},{\"label\":\"2.013\",\"sections\":[2.013,2.0131],\"start\":\"2.013\",\"end\":\"2.0131\",\"precision\":4,\"color\":\"#d9e3bd\"},{\"label\":\"2.014\",\"sections\":[2.014,2.0141],\"start\":\"2.014\",\"end\":\"2.0141\",\"precision\":4,\"color\":\"#d9e3bd\"},{\"label\":\"2.0123\",\"sections\":[2.0123,2.01231],\"start\":\"2.0123\",\"end\":\"2.01231\",\"precision\":5,\"color\":\"#b8dede\"},{\"label\":\"2.13\",\"sections\":[2.13,2.131],\"start\":\"2.13\",\"end\":\"2.131\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"2.14\",\"sections\":[2.14,2.141],\"start\":\"2.14\",\"end\":\"2.141\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"2.15\",\"sections\":[2.15,2.151],\"start\":\"2.15\",\"end\":\"2.151\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"2.16\",\"sections\":[2.16,2.161],\"start\":\"2.16\",\"end\":\"2.161\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"2.17\",\"sections\":[2.17,2.171,2.172,2.173,2.174],\"start\":\"2.17\",\"end\":\"2.174\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"2.18\",\"sections\":[2.18,2.181,2.182],\"start\":\"2.18\",\"end\":\"2.182\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"2.151\",\"sections\":[2.151,2.1511,2.1512,2.1513,2.1514,2.1515],\"start\":\"2.151\",\"end\":\"2.1515\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"2.1512\",\"sections\":[2.1512,2.15121],\"start\":\"2.1512\",\"end\":\"2.15121\",\"precision\":5,\"color\":\"#4f83bb\"},{\"label\":\"3\",\"sections\":[3,3.1,3.2,3.3,3.4,3.5],\"start\":\"3\",\"end\":\"3.5\",\"precision\":1,\"color\":\"#bf4f4e\"},{\"label\":\"3.1\",\"sections\":[3.1,3.11,3.12,3.13,3.14],\"start\":\"3.1\",\"end\":\"3.14\",\"precision\":2,\"color\":\"#f6944c\"},{\"label\":\"3.2\",\"sections\":[3.2,3.21,3.22,3.23,3.24,3.25,3.26],\"start\":\"3.2\",\"end\":\"3.26\",\"precision\":2,\"color\":\"#f6944c\"},{\"label\":\"3.2\",\"sections\":[3.2,3.201,3.202,3.203],\"start\":\"3.2\",\"end\":\"3.201\",\"precision\":3,\"color\":\"#fcd4b5\"},{\"label\":\"3.201\",\"sections\":[3.2,3.201,3.202,3.203],\"start\":\"3.201\",\"end\":\"3.203\",\"precision\":3,\"color\":\"#fcd4b5\"},{\"label\":\"3.3\",\"sections\":[3.3,3.31,3.32,3.33,3.34],\"start\":\"3.3\",\"end\":\"3.34\",\"precision\":2,\"color\":\"#f6944c\"},{\"label\":\"3.4\",\"sections\":[3.4,3.41,3.42],\"start\":\"3.4\",\"end\":\"3.42\",\"precision\":2,\"color\":\"#f6944c\"},{\"label\":\"3.4\",\"sections\":[3.4,3.41,3.42],\"start\":\"3.4\",\"end\":\"3.42\",\"precision\":2,\"color\":\"#f6944c\"},{\"label\":\"3.14\",\"sections\":[3.14,3.141,3.142,3.143,3.144],\"start\":\"3.14\",\"end\":\"3.144\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"3.22\",\"sections\":[3.22,3.221],\"start\":\"3.22\",\"end\":\"3.221\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"3.25\",\"sections\":[3.25,3.251],\"start\":\"3.25\",\"end\":\"3.251\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"3.26\",\"sections\":[3.26,3.261,3.262,3.263],\"start\":\"3.26\",\"end\":\"3.263\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"3.31\",\"sections\":[3.31,3.311,3.312,3.313,3.314,3.315,3.316,3.317,3.318],\"start\":\"3.31\",\"end\":\"3.318\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"3.32\",\"sections\":[3.32,3.321,3.322,3.323,3.324,3.325,3.326,3.327,3.328],\"start\":\"3.32\",\"end\":\"3.328\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"3.33\",\"sections\":[3.33,3.331,3.332,3.333,3.334],\"start\":\"3.33\",\"end\":\"3.334\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"3.34\",\"sections\":[3.34,3.341,3.342,3.343,3.344],\"start\":\"3.34\",\"end\":\"3.344\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"3.41\",\"sections\":[3.41,3.411],\"start\":\"3.41\",\"end\":\"3.411\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"3.143\",\"sections\":[3.143,3.1431,3.1432],\"start\":\"3.143\",\"end\":\"3.1432\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"3.341\",\"sections\":[3.341,3.3411],\"start\":\"3.341\",\"end\":\"3.3411\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"3.342\",\"sections\":[3.342,3.3421],\"start\":\"3.342\",\"end\":\"3.3421\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"3.344\",\"sections\":[3.344,3.3441,3.3442],\"start\":\"3.344\",\"end\":\"3.3442\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"3.01\",\"sections\":[3,3.01,3.02,3.03,3.04,3.05],\"start\":\"3.01\",\"end\":\"3.05\",\"precision\":2,\"color\":\"#e5b8b7\"},{\"label\":\"3.03\",\"sections\":[3.03,3.031,3.032],\"start\":\"3.03\",\"end\":\"3.032\",\"precision\":3,\"color\":\"#fcd4b5\"},{\"label\":\"3.032\",\"sections\":[3.032,3.0321],\"start\":\"3.032\",\"end\":\"3.0321\",\"precision\":4,\"color\":\"#d9e3bd\"},{\"label\":\"4\",\"sections\":[4,4.1,4.2,4.3,4.4,4.5],\"start\":\"4\",\"end\":\"4.5\",\"precision\":1,\"color\":\"#bf4f4e\"},{\"label\":\"4.1\",\"sections\":[4.1,4.11,4.12],\"start\":\"4.1\",\"end\":\"4.12\",\"precision\":2,\"color\":\"#f6944c\"},{\"label\":\"4.2\",\"sections\":[4.2,4.21,4.22,4.23,4.24,4.25,4.26,4.27,4.28],\"start\":\"4.2\",\"end\":\"4.28\",\"precision\":2,\"color\":\"#f6944c\"},{\"label\":\"4.3\",\"sections\":[4.3,4.31],\"start\":\"4.3\",\"end\":\"4.31\",\"precision\":2,\"color\":\"#f6944c\"},{\"label\":\"4.4\",\"sections\":[4.4,4.41,4.42,4.43,4.44,4.45,4.46],\"start\":\"4.4\",\"end\":\"4.46\",\"precision\":2,\"color\":\"#f6944c\"},{\"label\":\"4.5\",\"sections\":[4.5,4.51,4.52,4.53],\"start\":\"4.5\",\"end\":\"4.53\",\"precision\":2,\"color\":\"#f6944c\"},{\"label\":\"4.11\",\"sections\":[4.11,4.111,4.112,4.113,4.114,4.115,4.116],\"start\":\"4.11\",\"end\":\"4.116\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"4.12\",\"sections\":[4.12,4.121,4.122,4.123,4.124,4.125,4.126,4.127,4.128],\"start\":\"4.12\",\"end\":\"4.128\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"4.21\",\"sections\":[4.21,4.211],\"start\":\"4.21\",\"end\":\"4.211\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"4.22\",\"sections\":[4.22,4.221],\"start\":\"4.22\",\"end\":\"4.221\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"4.24\",\"sections\":[4.24,4.241,4.242,4.243],\"start\":\"4.24\",\"end\":\"4.243\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"4.41\",\"sections\":[4.41,4.411],\"start\":\"4.41\",\"end\":\"4.411\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"4.43\",\"sections\":[4.43,4.431],\"start\":\"4.43\",\"end\":\"4.431\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"4.44\",\"sections\":[4.44,4.441,4.442],\"start\":\"4.44\",\"end\":\"4.442\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"4.46\",\"sections\":[4.46,4.461,4.462,4.463,4.464,4.465,4.466],\"start\":\"4.46\",\"end\":\"4.466\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"4.112\",\"sections\":[4.112,4.1121,4.1122],\"start\":\"4.112\",\"end\":\"4.1122\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"4.121\",\"sections\":[4.121,4.1211,4.1212,4.1213],\"start\":\"4.121\",\"end\":\"4.1213\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"4.122\",\"sections\":[4.122,4.1221],\"start\":\"4.122\",\"end\":\"4.1221\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"4.124\",\"sections\":[4.124,4.1241],\"start\":\"4.124\",\"end\":\"4.1241\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"4.125\",\"sections\":[4.125,4.1251,4.1252],\"start\":\"4.125\",\"end\":\"4.1252\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"4.127\",\"sections\":[4.127,4.1271,4.1272,4.1273,4.1274],\"start\":\"4.127\",\"end\":\"4.1274\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"4.221\",\"sections\":[4.221,4.2211],\"start\":\"4.221\",\"end\":\"4.2211\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"4.461\",\"sections\":[4.461,4.4611],\"start\":\"4.461\",\"end\":\"4.4611\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"4.466\",\"sections\":[4.466,4.4661],\"start\":\"4.466\",\"end\":\"4.4661\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"4.1272\",\"sections\":[4.1272,4.12721],\"start\":\"4.1272\",\"end\":\"4.12721\",\"precision\":5,\"color\":\"#4f83bb\"},{\"label\":\"4.01\",\"sections\":[4,4.01,4.02,4.03,4.04,4.05,4.06],\"start\":\"4.01\",\"end\":\"4.06\",\"precision\":2,\"color\":\"#e5b8b7\"},{\"label\":\"4.06\",\"sections\":[4.06,4.061,4.062,4.063,4.064],\"start\":\"4.06\",\"end\":\"4.064\",\"precision\":3,\"color\":\"#fcd4b5\"},{\"label\":\"4.04\",\"sections\":[4.04,4.041],\"start\":\"4.04\",\"end\":\"4.041\",\"precision\":3,\"color\":\"#fcd4b5\"},{\"label\":\"4.03\",\"sections\":[4.03,4.031,4.032],\"start\":\"4.03\",\"end\":\"4.032\",\"precision\":3,\"color\":\"#fcd4b5\"},{\"label\":\"4.02\",\"sections\":[4.02,4.021,4.022,4.023,4.024,4.025,4.026,4.027],\"start\":\"4.02\",\"end\":\"4.027\",\"precision\":3,\"color\":\"#fcd4b5\"},{\"label\":\"4.01\",\"sections\":[4.01,4.011,4.012,4.013,4.014,4.015,4.016],\"start\":\"4.01\",\"end\":\"4.016\",\"precision\":3,\"color\":\"#fcd4b5\"},{\"label\":\"4.062\",\"sections\":[4.062,4.0621],\"start\":\"4.062\",\"end\":\"4.0621\",\"precision\":4,\"color\":\"#d9e3bd\"},{\"label\":\"4.064\",\"sections\":[4.064,4.0641],\"start\":\"4.064\",\"end\":\"4.0641\",\"precision\":4,\"color\":\"#d9e3bd\"},{\"label\":\"4.041\",\"sections\":[4.041,4.0411,4.0412],\"start\":\"4.041\",\"end\":\"4.0412\",\"precision\":4,\"color\":\"#d9e3bd\"},{\"label\":\"4.031\",\"sections\":[4.031,4.0311,4.0312],\"start\":\"4.031\",\"end\":\"4.0312\",\"precision\":4,\"color\":\"#d9e3bd\"},{\"label\":\"4.014\",\"sections\":[4.014,4.0141],\"start\":\"4.014\",\"end\":\"4.0141\",\"precision\":4,\"color\":\"#d9e3bd\"},{\"label\":\"4.001\",\"sections\":[4,4.001,4.002,4.003],\"start\":\"4.001\",\"end\":\"4.003\",\"precision\":3,\"color\":\"#f2dcda\"},{\"label\":\"4.003\",\"sections\":[4.003,4.0031],\"start\":\"4.003\",\"end\":\"4.0031\",\"precision\":4,\"color\":\"#fde9da\"},{\"label\":\"5\",\"sections\":[5,5.1,5.2,5.3,5.4,5.5,5.6],\"start\":\"5\",\"end\":\"5.6\",\"precision\":1,\"color\":\"#bf4f4e\"},{\"label\":\"5.11\",\"sections\":[5.1,5.11,5.12,5.13,5.14,5.15],\"start\":\"5.11\",\"end\":\"5.15\",\"precision\":2,\"color\":\"#f6944c\"},{\"label\":\"5.2\",\"sections\":[5.2,5.21,5.22,5.23,5.24,5.25],\"start\":\"5.2\",\"end\":\"5.25\",\"precision\":2,\"color\":\"#f6944c\"},{\"label\":\"5.3\",\"sections\":[5.3,5.31,5.32],\"start\":\"5.3\",\"end\":\"5.32\",\"precision\":2,\"color\":\"#f6944c\"},{\"label\":\"5.4\",\"sections\":[5.4,5.41,5.42,5.43,5.44,5.45,5.46,5.47],\"start\":\"5.4\",\"end\":\"5.47\",\"precision\":2,\"color\":\"#f6944c\"},{\"label\":\"5.51\",\"sections\":[5.5,5.51,5.52,5.53,5.54,5.55],\"start\":\"5.51\",\"end\":\"5.55\",\"precision\":2,\"color\":\"#f6944c\"},{\"label\":\"5.6\",\"sections\":[5.6,5.61,5.62,5.63,5.64],\"start\":\"5.6\",\"end\":\"5.64\",\"precision\":2,\"color\":\"#f6944c\"},{\"label\":\"5.12\",\"sections\":[5.12,5.121,5.122,5.123,5.124],\"start\":\"5.12\",\"end\":\"5.124\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"5.13\",\"sections\":[5.13,5.131,5.132,5.133,5.134,5.135,5.136],\"start\":\"5.13\",\"end\":\"5.136\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"5.14\",\"sections\":[5.14,5.141,5.142,5.143],\"start\":\"5.14\",\"end\":\"5.143\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"5.15\",\"sections\":[5.15,5.151,5.152,5.153,5.154,5.155,5.156],\"start\":\"5.15\",\"end\":\"5.156\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"5.23\",\"sections\":[5.23,5.231,5.232,5.233,5.234],\"start\":\"5.23\",\"end\":\"5.234\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"5.24\",\"sections\":[5.24,5.241,5.242],\"start\":\"5.24\",\"end\":\"5.242\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"5.25\",\"sections\":[5.25,5.251,5.252,5.253,5.254],\"start\":\"5.25\",\"end\":\"5.254\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"5.44\",\"sections\":[5.44,5.441,5.442],\"start\":\"5.44\",\"end\":\"5.442\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"5.45\",\"sections\":[5.45,5.451,5.452,5.453,5.454],\"start\":\"5.45\",\"end\":\"5.454\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"5.46\",\"sections\":[5.46,5.461],\"start\":\"5.46\",\"end\":\"5.461\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"5.47\",\"sections\":[5.47,5.471,5.472,5.473,5.474,5.475,5.476],\"start\":\"5.47\",\"end\":\"5.476\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"5.51\",\"sections\":[5.51,5.511,5.512,5.513,5.514,5.515],\"start\":\"5.51\",\"end\":\"5.515\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"5.52\",\"sections\":[5.52,5.521,5.522,5.523,5.524,5.525,5.526],\"start\":\"5.52\",\"end\":\"5.526\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"5.53\",\"sections\":[5.53,5.531,5.532,5.533,5.534,5.535],\"start\":\"5.53\",\"end\":\"5.531\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"5.531\",\"sections\":[5.53,5.531,5.532,5.533,5.534,5.535],\"start\":\"5.531\",\"end\":\"5.535\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"5.54\",\"sections\":[5.54,5.541,5.542],\"start\":\"5.54\",\"end\":\"5.542\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"5.55\",\"sections\":[5.55,5.551,5.552,5.553,5.554,5.555,5.556,5.557],\"start\":\"5.55\",\"end\":\"5.557\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"5.62\",\"sections\":[5.62,5.621],\"start\":\"5.62\",\"end\":\"5.621\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"5.63\",\"sections\":[5.63,5.631,5.632,5.633,5.634],\"start\":\"5.63\",\"end\":\"5.634\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"5.64\",\"sections\":[5.64,5.641],\"start\":\"5.64\",\"end\":\"5.641\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"5.124\",\"sections\":[5.124,5.1241],\"start\":\"5.124\",\"end\":\"5.1241\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"5.136\",\"sections\":[5.136,5.1361,5.1362,5.1363],\"start\":\"5.136\",\"end\":\"5.1363\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"5.151\",\"sections\":[5.151,5.1511],\"start\":\"5.151\",\"end\":\"5.1511\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"5.234\",\"sections\":[5.234,5.2341],\"start\":\"5.234\",\"end\":\"5.2341\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"5.252\",\"sections\":[5.252,5.2521,5.2522,5.2523],\"start\":\"5.252\",\"end\":\"5.2523\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"5.454\",\"sections\":[5.454,5.4541],\"start\":\"5.454\",\"end\":\"5.4541\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"5.461\",\"sections\":[5.461,5.4611],\"start\":\"5.461\",\"end\":\"5.4611\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"5.471\",\"sections\":[5.471,5.4711],\"start\":\"5.471\",\"end\":\"5.4711\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"5.473\",\"sections\":[5.473,5.4731,5.4732,5.4733],\"start\":\"5.473\",\"end\":\"5.4733\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"5.515\",\"sections\":[5.515,5.5151],\"start\":\"5.515\",\"end\":\"5.5151\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"5.526\",\"sections\":[5.526,5.5261,5.5262],\"start\":\"5.526\",\"end\":\"5.5262\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"5.532\",\"sections\":[5.532,5.5321],\"start\":\"5.532\",\"end\":\"5.5321\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"5.535\",\"sections\":[5.535,5.5351,5.5352],\"start\":\"5.535\",\"end\":\"5.5352\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"5.542\",\"sections\":[5.542,5.5421,5.5422,5.5423],\"start\":\"5.542\",\"end\":\"5.5423\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"5.552\",\"sections\":[5.552,5.5521],\"start\":\"5.552\",\"end\":\"5.5521\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"5.554\",\"sections\":[5.554,5.5541,5.5542],\"start\":\"5.554\",\"end\":\"5.5542\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"5.556\",\"sections\":[5.556,5.5561,5.5562,5.5563],\"start\":\"5.556\",\"end\":\"5.5563\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"5.557\",\"sections\":[5.557,5.5571],\"start\":\"5.557\",\"end\":\"5.5571\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"5.633\",\"sections\":[5.633,5.6331],\"start\":\"5.633\",\"end\":\"5.6331\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"5.4732\",\"sections\":[5.4732,5.47321],\"start\":\"5.4732\",\"end\":\"5.47321\",\"precision\":5,\"color\":\"#4f83bb\"},{\"label\":\"5.53\",\"sections\":[5.53,5.5301,5.5302,5.5303],\"start\":\"5.53\",\"end\":\"5.5303\",\"precision\":4,\"color\":\"#d9e3bd\"},{\"label\":\"5.5\",\"sections\":[5.5,5.501,5.502,5.503],\"start\":\"5.5\",\"end\":\"5.503\",\"precision\":3,\"color\":\"#fcd4b5\"},{\"label\":\"5.1\",\"sections\":[5.1,5.101],\"start\":\"5.1\",\"end\":\"5.101\",\"precision\":3,\"color\":\"#fcd4b5\"},{\"label\":\"5.01\",\"sections\":[5,5.01,5.02],\"start\":\"5.01\",\"end\":\"5.02\",\"precision\":2,\"color\":\"#fcd4b5\"},{\"label\":\"6\",\"sections\":[6,6.1,6.2,6.3,6.4,6.5],\"start\":\"6\",\"end\":\"6.5\",\"precision\":1,\"color\":\"#bf4f4e\"},{\"label\":\"6.1\",\"sections\":[6.1,6.11,6.12,6.13],\"start\":\"6.1\",\"end\":\"6.13\",\"precision\":2,\"color\":\"#f6944c\"},{\"label\":\"6.2\",\"sections\":[6.2,6.21,6.22,6.23,6.24],\"start\":\"6.2\",\"end\":\"6.24\",\"precision\":2,\"color\":\"#f6944c\"},{\"label\":\"6.3\",\"sections\":[6.3,6.31,6.32,6.33,6.34,6.35,6.36,6.37],\"start\":\"6.3\",\"end\":\"6.37\",\"precision\":2,\"color\":\"#f6944c\"},{\"label\":\"6.4\",\"sections\":[6.4,6.41,6.42,6.43,6.44,6.45],\"start\":\"6.4\",\"end\":\"6.45\",\"precision\":2,\"color\":\"#f6944c\"},{\"label\":\"6.5\",\"sections\":[6.5,6.51,6.52,6.53,6.54],\"start\":\"6.5\",\"end\":\"6.54\",\"precision\":2,\"color\":\"#f6944c\"},{\"label\":\"6.11\",\"sections\":[6.11,6.111,6.112,6.113],\"start\":\"6.11\",\"end\":\"6.113\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"6.121\",\"sections\":[6.12,6.121,6.122,6.123,6.124,6.125,6.126,6.127],\"start\":\"6.121\",\"end\":\"6.127\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"6.21\",\"sections\":[6.21,6.211],\"start\":\"6.21\",\"end\":\"6.211\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"6.23\",\"sections\":[6.23,6.231,6.232,6.233,6.234],\"start\":\"6.23\",\"end\":\"6.234\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"6.24\",\"sections\":[6.24,6.241],\"start\":\"6.24\",\"end\":\"6.241\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"6.32\",\"sections\":[6.32,6.321],\"start\":\"6.32\",\"end\":\"6.321\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"6.34\",\"sections\":[6.34,6.341,6.342,6.343],\"start\":\"6.34\",\"end\":\"6.343\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"6.36\",\"sections\":[6.36,6.361,6.362,6.363],\"start\":\"6.36\",\"end\":\"6.363\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"6.37\",\"sections\":[6.37,6.371,6.372,6.373,6.374,6.375],\"start\":\"6.37\",\"end\":\"6.375\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"6.42\",\"sections\":[6.42,6.421,6.422,6.423],\"start\":\"6.42\",\"end\":\"6.423\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"6.43\",\"sections\":[6.43,6.431,6.432],\"start\":\"6.43\",\"end\":\"6.432\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"6.52\",\"sections\":[6.52,6.521,6.522],\"start\":\"6.52\",\"end\":\"6.522\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"6.122\",\"sections\":[6.122,6.1221,6.1222,6.1223,6.1224],\"start\":\"6.122\",\"end\":\"6.1224\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"6.123\",\"sections\":[6.123,6.1231,6.1232,6.1233],\"start\":\"6.123\",\"end\":\"6.1233\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"6.125\",\"sections\":[6.125,6.1251],\"start\":\"6.125\",\"end\":\"6.1251\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"6.126\",\"sections\":[6.126,6.1261,6.1262,6.1263,6.1264,6.1265],\"start\":\"6.126\",\"end\":\"6.1265\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"6.127\",\"sections\":[6.127,6.1271],\"start\":\"6.127\",\"end\":\"6.1271\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"6.231\",\"sections\":[6.231,6.2311],\"start\":\"6.231\",\"end\":\"6.2311\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"6.232\",\"sections\":[6.232,6.2321,6.2322,6.2323],\"start\":\"6.232\",\"end\":\"6.2323\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"6.233\",\"sections\":[6.233,6.2331],\"start\":\"6.233\",\"end\":\"6.2331\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"6.234\",\"sections\":[6.234,6.2341],\"start\":\"6.234\",\"end\":\"6.2341\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"6.321\",\"sections\":[6.321,6.3211],\"start\":\"6.321\",\"end\":\"6.3211\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"6.343\",\"sections\":[6.343,6.3431,6.3432],\"start\":\"6.343\",\"end\":\"6.3432\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"6.361\",\"sections\":[6.361,6.3611],\"start\":\"6.361\",\"end\":\"6.3611\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"6.363\",\"sections\":[6.363,6.3631],\"start\":\"6.363\",\"end\":\"6.3631\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"6.375\",\"sections\":[6.375,6.3751],\"start\":\"6.375\",\"end\":\"6.3751\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"6.431\",\"sections\":[6.431,6.4311,6.4312],\"start\":\"6.431\",\"end\":\"6.4312\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"6.432\",\"sections\":[6.432,6.4321],\"start\":\"6.432\",\"end\":\"6.4321\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"6.3611\",\"sections\":[6.3611,6.36111],\"start\":\"6.3611\",\"end\":\"6.36111\",\"precision\":5,\"color\":\"#4f83bb\"},{\"label\":\"6.3631\",\"sections\":[6.3631,6.36311],\"start\":\"6.3631\",\"end\":\"6.36311\",\"precision\":5,\"color\":\"#4f83bb\"},{\"label\":\"6.12\",\"sections\":[6.12,6.1201,6.1202,6.1203],\"start\":\"6.12\",\"end\":\"6.1203\",\"precision\":4,\"color\":\"#d9e3bd\"},{\"label\":\"6.01\",\"sections\":[6,6.01,6.02,6.03],\"start\":\"6.01\",\"end\":\"6.03\",\"precision\":2,\"color\":\"#e5b8b7\"},{\"label\":\"6.03\",\"sections\":[6.03,6.031],\"start\":\"6.03\",\"end\":\"6.031\",\"precision\":3,\"color\":\"#fcd4b5\"},{\"label\":\"6.02\",\"sections\":[6.02,6.022],\"start\":\"6.02\",\"end\":\"6.022\",\"precision\":3,\"color\":\"#fcd4b5\"},{\"label\":\"6.001\",\"sections\":[6,6.001,6.002],\"start\":\"6.001\",\"end\":\"6.002\",\"precision\":3,\"color\":\"#fde9da\"},{\"label\":\"2\",\"sections\":[2,2.01,2.02,2.03,2.04,2.05,2.06],\"start\":\"2\",\"end\":\"2.01\",\"precision\":2,\"color\":\"#e5b8b7\"},{\"label\":\"2.2\",\"sections\":[2.2,2.21,2.22],\"start\":\"2.2\",\"end\":\"2.21\",\"precision\":2,\"color\":\"#f6944c\"},{\"label\":\"2.02\",\"sections\":[2.02,2.0201],\"start\":\"2.02\",\"end\":\"2.0201\",\"precision\":4,\"color\":\"#fde9da\"},{\"label\":\"3\",\"sections\":[3,3.001],\"start\":\"3\",\"end\":\"3.001\",\"precision\":3,\"color\":\"#fde9da\"},{\"label\":\"3\",\"sections\":[3,3.01,3.02,3.03,3.04,3.05],\"start\":\"3\",\"end\":\"3.01\",\"precision\":2,\"color\":\"#e5b8b7\"},{\"label\":\"4\",\"sections\":[4,4.001,4.002,4.003],\"start\":\"4\",\"end\":\"4.001\",\"precision\":3,\"color\":\"#f2dcda\"},{\"label\":\"4\",\"sections\":[4,4.01],\"start\":\"4\",\"end\":\"4.01\",\"precision\":2,\"color\":\"#e5b8b7\"},{\"label\":\"5\",\"sections\":[5,5.01,5.02],\"start\":\"5\",\"end\":\"5.01\",\"precision\":2,\"color\":\"#fcd4b5\"},{\"label\":\"5.1\",\"sections\":[5.1,5.11,5.12,5.13,5.14,5.15],\"start\":\"5.1\",\"end\":\"5.11\",\"precision\":2,\"color\":\"#f6944c\"},{\"label\":\"5.5\",\"sections\":[5.5,5.51,5.52,5.53,5.54,5.55],\"start\":\"5.5\",\"end\":\"5.51\",\"precision\":2,\"color\":\"#f6944c\"},{\"label\":\"6\",\"sections\":[6,6.001,6.002],\"start\":\"6\",\"end\":\"6.001\",\"precision\":3,\"color\":\"#fde9da\"},{\"label\":\"6\",\"sections\":[6,6.01,6.02,6.03],\"start\":\"6\",\"end\":\"6.01\",\"precision\":2,\"color\":\"#e5b8b7\"},{\"label\":\"6.12\",\"sections\":[6.12,6.121,6.122,6.123,6.124,6.125,6.126,6.127],\"start\":\"6.12\",\"end\":\"6.121\",\"precision\":3,\"color\":\"#9cb95e\"}]};\n\n//# sourceURL=webpack:///./src/data/lines.json?");

/***/ }),

/***/ "./src/data/ptLines.json":
/*!*******************************!*\
  !*** ./src/data/ptLines.json ***!
  \*******************************/
/*! exports provided: lines, default */
/***/ (function(module) {

eval("module.exports = {\"lines\":[{\"label\":\"1\",\"sections\":[1,2,3,4,5,6,7],\"start\":\"1\",\"end\":\"7\",\"precision\":0,\"color\":\"#9b0058\"},{\"label\":\"2\",\"sections\":[2,2.1,2.2],\"start\":\"2\",\"end\":\"2.2\",\"precision\":1,\"color\":\"#bf4f4e\"},{\"label\":\"3\",\"sections\":[3,3.1,3.2,3.3],\"start\":\"3\",\"end\":\"3.3\",\"precision\":1,\"color\":\"#bf4f4e\"},{\"label\":\"4\",\"sections\":[4,4.1,4.2,4.3,4.4],\"start\":\"4\",\"end\":\"4.4\",\"precision\":1,\"color\":\"#bf4f4e\"},{\"label\":\"5\",\"sections\":[5,5.1,5.2,5.3,5.4],\"start\":\"5\",\"end\":\"5.4\",\"precision\":1,\"color\":\"#bf4f4e\"},{\"label\":\"6\",\"sections\":[6,6.1,6.2,6.3,6.4,6.5],\"start\":\"6\",\"end\":\"6.5\",\"precision\":1,\"color\":\"#bf4f4e\"},{\"label\":\"1\",\"sections\":[1,1.1,1.2],\"start\":\"1\",\"end\":\"1.2\",\"precision\":1,\"color\":\"#bf4f4e\"},{\"label\":\"1.1\",\"sections\":[1.1,1.11,1.12,1.13],\"start\":\"1.1\",\"end\":\"1.13\",\"precision\":2,\"color\":\"#f6944c\"},{\"label\":\"1.2\",\"sections\":[1.2,1.21],\"start\":\"1.2\",\"end\":\"1.21\",\"precision\":2,\"color\":\"#f6944c\"},{\"label\":\"2\",\"sections\":[2,2.01,2.02,2.03,2.04,2.05,2.06,2.07],\"start\":\"2\",\"end\":\"2.01\",\"precision\":2,\"color\":\"#f2dcda\"},{\"label\":\"2.01\",\"sections\":[2,2.01,2.02,2.03,2.04,2.05,2.06,2.07],\"start\":\"2.01\",\"end\":\"2.07\",\"precision\":2,\"color\":\"#f2dcda\"},{\"label\":\"2.01\",\"sections\":[2.01,2.011,2.012,2.013,2.014],\"start\":\"2.01\",\"end\":\"2.014\",\"precision\":3,\"color\":\"#fcd4b5\"},{\"label\":\"2.012\",\"sections\":[2.012,2.01201,2.01202,2.01203,2.01204],\"start\":\"2.012\",\"end\":\"2.01204\",\"precision\":5,\"color\":\"#ebf0db\"},{\"label\":\"2.012\",\"sections\":[2.012,2.0121],\"start\":\"2.012\",\"end\":\"2.0121\",\"precision\":4,\"color\":\"#d9e3bd\"},{\"label\":\"2.0121\",\"sections\":[2.0121,2.0122,2.0123,2.0124,2.0125,2.0126],\"start\":\"2.0121\",\"end\":\"2.0126\",\"precision\":4,\"color\":\"#d9e3bd\"},{\"label\":\"2.014\",\"sections\":[2.014,2.0141,2.0142],\"start\":\"2.014\",\"end\":\"2.0142\",\"precision\":4,\"color\":\"#d9e3bd\"},{\"label\":\"2.0124\",\"sections\":[2.0124,2.01241],\"start\":\"2.0124\",\"end\":\"2.01241\",\"precision\":5,\"color\":\"#b8dede\"},{\"label\":\"2.0141\",\"sections\":[2.0141,2.01411],\"start\":\"2.0141\",\"end\":\"2.01411\",\"precision\":5,\"color\":\"#b8dede\"},{\"label\":\"2.02\",\"sections\":[2.02,2.021,2.022,2.023,2.024,2.025,2.026,2.027],\"start\":\"2.02\",\"end\":\"2.021\",\"precision\":3,\"color\":\"#fde9da\"},{\"label\":\"2.02\",\"sections\":[2.02,2.021],\"start\":\"2.02\",\"end\":\"2.021\",\"precision\":3,\"color\":\"#fcd4b5\"},{\"label\":\"2.02\",\"sections\":[2.02,2.0201],\"start\":\"2.02\",\"end\":\"2.0201\",\"precision\":4,\"color\":\"#fde9da\"},{\"label\":\"2.021\",\"sections\":[2.02,2.021,2.022,2.023,2.024,2.025,2.026,2.027],\"start\":\"2.021\",\"end\":\"2.027\",\"precision\":3,\"color\":\"#fcd4b5\"},{\"label\":\"2.03\",\"sections\":[2.03,2.031,2.032,2.033],\"start\":\"2.03\",\"end\":\"2.033\",\"precision\":3,\"color\":\"#fcd4b5\"},{\"label\":\"2.023\",\"sections\":[2.023,2.0231,2.0232,2.0233],\"start\":\"2.023\",\"end\":\"2.0233\",\"precision\":4,\"color\":\"#d9e3bd\"},{\"label\":\"2.021\",\"sections\":[2.021,2.0211,2.0212],\"start\":\"2.021\",\"end\":\"2.0212\",\"precision\":4,\"color\":\"#d9e3bd\"},{\"label\":\"2.025\",\"sections\":[2.025,2.0251,2.0252],\"start\":\"2.025\",\"end\":\"2.0252\",\"precision\":4,\"color\":\"#d9e3bd\"},{\"label\":\"2.027\",\"sections\":[2.027,2.0271,2.0272],\"start\":\"2.027\",\"end\":\"2.0272\",\"precision\":4,\"color\":\"#d9e3bd\"},{\"label\":\"2.0233\",\"sections\":[2.0233,2.02331],\"start\":\"2.0233\",\"end\":\"2.02331\",\"precision\":5,\"color\":\"#b8dede\"},{\"label\":\"2.06\",\"sections\":[2.06,2.0601],\"start\":\"2.06\",\"end\":\"2.0601\",\"precision\":4,\"color\":\"#fde9da\"},{\"label\":\"2.06\",\"sections\":[2.06,2.061,2.062],\"start\":\"2.06\",\"end\":\"2.061\",\"precision\":3,\"color\":\"#fcd4b5\"},{\"label\":\"2.06\",\"sections\":[2.06,2.07],\"start\":\"2.06\",\"end\":\"2.07\",\"precision\":2,\"color\":\"#fcd4b5\"},{\"label\":\"2.061\",\"sections\":[2.06,2.061,2.062],\"start\":\"2.061\",\"end\":\"2.062\",\"precision\":3,\"color\":\"#fcd4b5\"},{\"label\":\"2.1\",\"sections\":[2.1,2.11,2.12,2.13,2.14,2.15,2.16,2.17,2.18,2.19],\"start\":\"2.1\",\"end\":\"2.19\",\"precision\":2,\"color\":\"#f6944c\"},{\"label\":\"2.2\",\"sections\":[2.2,2.21,2.22],\"start\":\"2.2\",\"end\":\"2.21\",\"precision\":2,\"color\":\"#f6944c\"},{\"label\":\"2.21\",\"sections\":[2.2,2.21,2.22],\"start\":\"2.21\",\"end\":\"2.22\",\"precision\":2,\"color\":\"#f6944c\"},{\"label\":\"2.2\",\"sections\":[2.2,2.201,2.202,2.203],\"start\":\"2.2\",\"end\":\"2.203\",\"precision\":3,\"color\":\"#fcd4b5\"},{\"label\":\"2.22\",\"sections\":[2.22,2.221,2.222,2.223,2.224,2.225],\"start\":\"2.22\",\"end\":\"2.225\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"2.13\",\"sections\":[2.13,2.131],\"start\":\"2.13\",\"end\":\"2.131\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"2.15\",\"sections\":[2.15,2.1512,2.1513,2.1514,2.1515,2.1516],\"start\":\"2.15\",\"end\":\"2.1516\",\"precision\":4,\"color\":\"#9cb95e\"},{\"label\":\"2.151\",\"sections\":[2.151,2.15101],\"start\":\"2.151\",\"end\":\"2.15101\",\"precision\":5,\"color\":\"#d9e3bd\"},{\"label\":\"2.1513\",\"sections\":[2.1513,2.15131],\"start\":\"2.1513\",\"end\":\"2.15131\",\"precision\":5,\"color\":\"#4dadc5\"},{\"label\":\"2.16\",\"sections\":[2.16,2.161],\"start\":\"2.16\",\"end\":\"2.161\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"2.17\",\"sections\":[2.17,2.171,2.172,2.173,2.174,2.175],\"start\":\"2.17\",\"end\":\"2.175\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"2.18\",\"sections\":[2.18,2.181,2.182],\"start\":\"2.18\",\"end\":\"2.182\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"3\",\"sections\":[3,3.001],\"start\":\"3\",\"end\":\"3.001\",\"precision\":3,\"color\":\"#f2dcda\"},{\"label\":\"3\",\"sections\":[3,3.01,3.02,3.03,3.04,3.05],\"start\":\"3\",\"end\":\"3.01\",\"precision\":2,\"color\":\"#e5b8b7\"},{\"label\":\"3.01\",\"sections\":[3,3.01,3.02,3.03,3.04,3.05],\"start\":\"3.01\",\"end\":\"3.05\",\"precision\":2,\"color\":\"#e5b8b7\"},{\"label\":\"3.03\",\"sections\":[3.03,3.031,3.032],\"start\":\"3.03\",\"end\":\"3.032\",\"precision\":3,\"color\":\"#fcd4b5\"},{\"label\":\"3.032\",\"sections\":[3.032,3.0321],\"start\":\"3.032\",\"end\":\"3.0321\",\"precision\":4,\"color\":\"#d9e3bd\"},{\"label\":\"3.1\",\"sections\":[3.1,3.11,3.12,3.13,3.14,3.15,3.16],\"start\":\"3.1\",\"end\":\"3.16\",\"precision\":2,\"color\":\"#f6944c\"},{\"label\":\"3.11\",\"sections\":[3.11,3.111],\"start\":\"3.11\",\"end\":\"3.111\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"3.14\",\"sections\":[3.14,3.141],\"start\":\"3.14\",\"end\":\"3.141\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"3.16\",\"sections\":[3.16,3.1601,3.1602,3.1603,3.1604],\"start\":\"3.16\",\"end\":\"3.1604\",\"precision\":4,\"color\":\"#d9e3bd\"},{\"label\":\"3.1602\",\"sections\":[3.1602,3.16021],\"start\":\"3.1602\",\"end\":\"3.16021\",\"precision\":5,\"color\":\"#b8dede\"},{\"label\":\"3.16\",\"sections\":[3.16,3.161,3.162,3.163,3.164],\"start\":\"3.16\",\"end\":\"3.161\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"3.161\",\"sections\":[3.16,3.161,3.162,3.163,3.164],\"start\":\"3.161\",\"end\":\"3.164\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"3.162\",\"sections\":[3.162,3.1621,3.1622],\"start\":\"3.162\",\"end\":\"3.1622\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"3.2\",\"sections\":[3.2,3.201,3.202],\"start\":\"3.2\",\"end\":\"3.202\",\"precision\":3,\"color\":\"#fcd4b5\"},{\"label\":\"3.201\",\"sections\":[3.201,3.20101,3.20102,3.20103,3.20104,3.20105,3.20106,3.20107,3.20108],\"start\":\"3.201\",\"end\":\"3.20108\",\"precision\":5,\"color\":\"#d9e3bd\"},{\"label\":\"3.201\",\"sections\":[3.201,3.2011,3.2012,3.2013,3.2014,3.2015,3.2016,3.2017],\"start\":\"3.201\",\"end\":\"3.2011\",\"precision\":4,\"color\":\"#d9e3bd\"},{\"label\":\"3.2011\",\"sections\":[3.201,3.2011,3.2012,3.2013,3.2014,3.2015,3.2016,3.2017],\"start\":\"3.2011\",\"end\":\"3.2017\",\"precision\":4,\"color\":\"#d9e3bd\"},{\"label\":\"3.2012\",\"sections\":[3.2012,3.20121,3.20122],\"start\":\"3.2012\",\"end\":\"3.20122\",\"precision\":5,\"color\":\"#b8dede\"},{\"label\":\"3.20122\",\"sections\":[3.20122,3.201221],\"start\":\"3.20122\",\"end\":\"3.201221\",\"precision\":6,\"color\":\"#b8cce4\"},{\"label\":\"3.2014\",\"sections\":[3.2014,3.20141,3.20142],\"start\":\"3.2014\",\"end\":\"3.20142\",\"precision\":5,\"color\":\"#b8dede\"},{\"label\":\"3.20141\",\"sections\":[3.20141,3.201411,3.201412],\"start\":\"3.20141\",\"end\":\"3.201412\",\"precision\":6,\"color\":\"#b8cce4\"},{\"label\":\"3.2015\",\"sections\":[3.2015,3.20151,3.20152],\"start\":\"3.2015\",\"end\":\"3.20152\",\"precision\":5,\"color\":\"#b8dede\"},{\"label\":\"3.2017\",\"sections\":[3.2017,3.20171,3.20172,3.20173],\"start\":\"3.2017\",\"end\":\"3.20173\",\"precision\":5,\"color\":\"#b8dede\"},{\"label\":\"3.20173\",\"sections\":[3.20173,3.201731],\"start\":\"3.20173\",\"end\":\"3.201731\",\"precision\":6,\"color\":\"#b8cce4\"},{\"label\":\"3.202\",\"sections\":[3.202,3.2021],\"start\":\"3.202\",\"end\":\"3.2021\",\"precision\":4,\"color\":\"#d9e3bd\"},{\"label\":\"3.2021\",\"sections\":[3.2021,3.20211,3.20212],\"start\":\"3.2021\",\"end\":\"3.20212\",\"precision\":5,\"color\":\"#b8dede\"},{\"label\":\"3.20211\",\"sections\":[3.20211,3.202111],\"start\":\"3.20211\",\"end\":\"3.202111\",\"precision\":6,\"color\":\"#b8cce4\"},{\"label\":\"3.2\",\"sections\":[3.2,3.21,3.22,3.23,3.24,3.25],\"start\":\"3.2\",\"end\":\"3.21\",\"precision\":2,\"color\":\"#f6944c\"},{\"label\":\"3.21\",\"sections\":[3.2,3.21,3.22,3.23,3.24,3.25],\"start\":\"3.21\",\"end\":\"3.25\",\"precision\":2,\"color\":\"#f6944c\"},{\"label\":\"3.21\",\"sections\":[3.21,3.2101,3.2102,3.2103,3.2104],\"start\":\"3.21\",\"end\":\"3.2104\",\"precision\":4,\"color\":\"#d9e3bd\"},{\"label\":\"3.21\",\"sections\":[3.21,3.211,3.212,3.213,3.214],\"start\":\"3.21\",\"end\":\"3.211\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"3.211\",\"sections\":[3.21,3.211,3.212,3.213,3.214],\"start\":\"3.211\",\"end\":\"3.214\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"3.24\",\"sections\":[3.24,3.241,3.242],\"start\":\"3.24\",\"end\":\"3.242\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"3.25\",\"sections\":[3.25,3.251,3.252,3.253],\"start\":\"3.25\",\"end\":\"3.253\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"3.213\",\"sections\":[3.213,3.2131],\"start\":\"3.213\",\"end\":\"3.2131\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"3.214\",\"sections\":[3.214,3.2141,3.2142],\"start\":\"3.214\",\"end\":\"3.2142\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"3.241\",\"sections\":[3.241,3.2411],\"start\":\"3.241\",\"end\":\"3.2411\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"3.242\",\"sections\":[3.242,3.2421],\"start\":\"3.242\",\"end\":\"3.2421\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"3.2421\",\"sections\":[3.2421,3.24211],\"start\":\"3.2421\",\"end\":\"3.24211\",\"precision\":5,\"color\":\"#4f83bb\"},{\"label\":\"3.251\",\"sections\":[3.251,3.2511,3.2512,3.2513],\"start\":\"3.251\",\"end\":\"3.2513\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"3.252\",\"sections\":[3.252,3.2521,3.2522],\"start\":\"3.252\",\"end\":\"3.2522\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"3.253\",\"sections\":[3.253,3.2531],\"start\":\"3.253\",\"end\":\"3.2531\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"4\",\"sections\":[4,4.001,4.0011,4.0012,4.0013,4.0014,4.0015,4.0016],\"start\":\"4\",\"end\":\"4.0011\",\"precision\":4,\"color\":\"#f2dcda\"},{\"label\":\"4.0014\",\"sections\":[4.0014,4.00141],\"start\":\"4.0014\",\"end\":\"4.00141\",\"precision\":5,\"color\":\"#ebf0db\"},{\"label\":\"4.0015\",\"sections\":[4.0015,4.00151],\"start\":\"4.0015\",\"end\":\"4.00151\",\"precision\":5,\"color\":\"#ebf0db\"},{\"label\":\"4.0016\",\"sections\":[4.0016,4.00161,4.00162,4.00163],\"start\":\"4.0016\",\"end\":\"4.00163\",\"precision\":5,\"color\":\"#ebf0db\"},{\"label\":\"4\",\"sections\":[4,4.01,4.02,4.03,4.04,4.05,4.06,4.07,4.08,4.09],\"start\":\"4\",\"end\":\"4.01\",\"precision\":2,\"color\":\"#e5b8b7\"},{\"label\":\"4.01\",\"sections\":[4,4.01,4.02,4.03,4.04,4.05,4.06,4.07,4.08,4.09],\"start\":\"4.01\",\"end\":\"4.09\",\"precision\":2,\"color\":\"#e5b8b7\"},{\"label\":\"4.01\",\"sections\":[4.01,4.0101,4.0102,4.0103],\"start\":\"4.01\",\"end\":\"4.0103\",\"precision\":4,\"color\":\"#fde9da\"},{\"label\":\"4.01\",\"sections\":[4.01,4.011],\"start\":\"4.01\",\"end\":\"4.011\",\"precision\":3,\"color\":\"#fcd4b5\"},{\"label\":\"4.011\",\"sections\":[4.011,4.0111,4.0112,4.0113,4.0114,4.0115,4.0116],\"start\":\"4.011\",\"end\":\"4.0116\",\"precision\":4,\"color\":\"#d9e3bd\"},{\"label\":\"4.0112\",\"sections\":[4.0112,4.01121,4.01122],\"start\":\"4.0112\",\"end\":\"4.01122\",\"precision\":5,\"color\":\"#b8dede\"},{\"label\":\"4.0114\",\"sections\":[4.0114,4.01141],\"start\":\"4.0114\",\"end\":\"4.01141\",\"precision\":5,\"color\":\"#b8dede\"},{\"label\":\"4.01141\",\"sections\":[4.01141,4.011411],\"start\":\"4.01141\",\"end\":\"4.011411\",\"precision\":6,\"color\":\"#4f83bb\"},{\"label\":\"4.02\",\"sections\":[4.02,4.021,4.022,4.023,4.024,4.025,4.026],\"start\":\"4.02\",\"end\":\"4.026\",\"precision\":3,\"color\":\"#fcd4b5\"},{\"label\":\"4.05\",\"sections\":[4.05,4.051],\"start\":\"4.05\",\"end\":\"4.051\",\"precision\":3,\"color\":\"#fcd4b5\"},{\"label\":\"4.07\",\"sections\":[4.07,4.071,4.072,4.073,4.074],\"start\":\"4.07\",\"end\":\"4.074\",\"precision\":3,\"color\":\"#fcd4b5\"},{\"label\":\"4.09\",\"sections\":[4.09,4.091,4.092,4.094,4.095],\"start\":\"4.09\",\"end\":\"4.095\",\"precision\":3,\"color\":\"#fcd4b5\"},{\"label\":\"4.023\",\"sections\":[4.023,4.0231,4.0232],\"start\":\"4.023\",\"end\":\"4.0232\",\"precision\":4,\"color\":\"#d9e3bd\"},{\"label\":\"4.0232\",\"sections\":[4.0232,4.02321,4.02322],\"start\":\"4.0232\",\"end\":\"4.02322\",\"precision\":5,\"color\":\"#b8dede\"},{\"label\":\"4.026\",\"sections\":[4.026,4.0261,4.0262],\"start\":\"4.026\",\"end\":\"4.0262\",\"precision\":4,\"color\":\"#d9e3bd\"},{\"label\":\"4.071\",\"sections\":[4.071,4.0711,4.0712],\"start\":\"4.071\",\"end\":\"4.0712\",\"precision\":4,\"color\":\"#d9e3bd\"},{\"label\":\"4.072\",\"sections\":[4.072,4.0721],\"start\":\"4.072\",\"end\":\"4.0721\",\"precision\":4,\"color\":\"#d9e3bd\"},{\"label\":\"4.072\",\"sections\":[4.072,4.0721],\"start\":\"4.072\",\"end\":\"4.0721\",\"precision\":4,\"color\":\"#d9e3bd\"},{\"label\":\"4.074\",\"sections\":[4.074,4.0741,4.0742,4.0743],\"start\":\"4.074\",\"end\":\"4.0743\",\"precision\":4,\"color\":\"#d9e3bd\"},{\"label\":\"4.091\",\"sections\":[4.091,4.0911],\"start\":\"4.091\",\"end\":\"4.0911\",\"precision\":4,\"color\":\"#d9e3bd\"},{\"label\":\"4.092\",\"sections\":[4.092,4.0921,4.0922,4.0923],\"start\":\"4.092\",\"end\":\"4.0923\",\"precision\":4,\"color\":\"#d9e3bd\"},{\"label\":\"4.095\",\"sections\":[4.095,4.0951,4.0952,4.0953],\"start\":\"4.095\",\"end\":\"4.0953\",\"precision\":4,\"color\":\"#d9e3bd\"},{\"label\":\"4.1\",\"sections\":[4.1,4.1001],\"start\":\"4.1\",\"end\":\"4.1001\",\"precision\":4,\"color\":\"#fde9da\"},{\"label\":\"4.1001\",\"sections\":[4.1001,4.10011,4.10012,4.10013,4.10014,4.10015,4.10016,4.10017,4.10018,4.10019],\"start\":\"4.1001\",\"end\":\"4.10019\",\"precision\":5,\"color\":\"#d9e3bd\"},{\"label\":\"4.10015\",\"sections\":[4.10015,4.100151,4.100152,4.100153,4.100154],\"start\":\"4.10015\",\"end\":\"4.100154\",\"precision\":6,\"color\":\"#eef7f7\"},{\"label\":\"4.10016\",\"sections\":[4.10016,4.100161],\"start\":\"4.10016\",\"end\":\"4.100161\",\"precision\":6,\"color\":\"#eef7f7\"},{\"label\":\"4.10017\",\"sections\":[4.10017,4.100171],\"start\":\"4.10017\",\"end\":\"4.100171\",\"precision\":6,\"color\":\"#eef7f7\"},{\"label\":\"4.100153\",\"sections\":[4.100153,4.1001531],\"start\":\"4.100153\",\"end\":\"4.1001531\",\"precision\":7,\"color\":\"#fde9da\"},{\"label\":\"4.1\",\"sections\":[4.1,4.101],\"start\":\"4.1\",\"end\":\"4.101\",\"precision\":3,\"color\":\"#fcd4b5\"},{\"label\":\"4.101\",\"sections\":[4.101,4.102,4.103,4.104],\"start\":\"4.101\",\"end\":\"4.104\",\"precision\":3,\"color\":\"#fcd4b5\"},{\"label\":\"4.101\",\"sections\":[4.101,4.1011],\"start\":\"4.101\",\"end\":\"4.1011\",\"precision\":4,\"color\":\"#d9e3bd\"},{\"label\":\"4.102\",\"sections\":[4.102,4.1021,4.1022],\"start\":\"4.102\",\"end\":\"4.1022\",\"precision\":4,\"color\":\"#d9e3bd\"},{\"label\":\"4.103\",\"sections\":[4.103,4.1031,4.1032],\"start\":\"4.103\",\"end\":\"4.1032\",\"precision\":4,\"color\":\"#d9e3bd\"},{\"label\":\"4.1\",\"sections\":[4.1,4.11],\"start\":\"4.1\",\"end\":\"4.11\",\"precision\":2,\"color\":\"#f6944c\"},{\"label\":\"4.11\",\"sections\":[4.11],\"start\":\"4.11\",\"end\":\"4.11\",\"precision\":2,\"color\":\"#9cb95e\"},{\"label\":\"4.1022\",\"sections\":[4.1022,4.10221,4.10222,4.10223,4.10224,4.10225,4.10226,4.10227],\"start\":\"4.1022\",\"end\":\"4.10227\",\"precision\":5,\"color\":\"#b8dede\"},{\"label\":\"4.10221\",\"sections\":[4.10221,4.102211,4.102212],\"start\":\"4.10221\",\"end\":\"4.102212\",\"precision\":6,\"color\":\"#b8cce4\"},{\"label\":\"4.10223\",\"sections\":[4.10223,4.102231,4.102232,4.102233,4.102234],\"start\":\"4.10223\",\"end\":\"4.102234\",\"precision\":6,\"color\":\"#b8cce4\"},{\"label\":\"4.10224\",\"sections\":[4.10224,4.102241],\"start\":\"4.10224\",\"end\":\"4.102241\",\"precision\":6,\"color\":\"#b8cce4\"},{\"label\":\"4.10225\",\"sections\":[4.10225,4.1022501],\"start\":\"4.10225\",\"end\":\"4.1022501\",\"precision\":7,\"color\":\"#b8cce4\"},{\"label\":\"4.10225\",\"sections\":[4.10225],\"start\":\"4.10225\",\"end\":\"4.10225\",\"precision\":5,\"color\":\"#b8cce4\"},{\"label\":\"4.10225\",\"sections\":[4.10225,4.102251,4.102252,4.102253,4.102254],\"start\":\"4.10225\",\"end\":\"4.102251\",\"precision\":6,\"color\":\"#b8cce4\"},{\"label\":\"4.102251\",\"sections\":[4.10225,4.102251,4.102252,4.102253,4.102254],\"start\":\"4.102251\",\"end\":\"4.102254\",\"precision\":6,\"color\":\"#b8cce4\"},{\"label\":\"4.10226\",\"sections\":[4.10226,4.102261,4.102262,4.102263,4.102264,4.102265],\"start\":\"4.10226\",\"end\":\"4.102265\",\"precision\":6,\"color\":\"#b8cce4\"},{\"label\":\"4.10227\",\"sections\":[4.10227,4.102271,4.102272,4.102273,4.102274],\"start\":\"4.10227\",\"end\":\"4.102274\",\"precision\":6,\"color\":\"#b8cce4\"},{\"label\":\"4.102233\",\"sections\":[4.102233,4.1022331],\"start\":\"4.102233\",\"end\":\"4.1022331\",\"precision\":7,\"color\":\"#fef1e7\"},{\"label\":\"4.102251\",\"sections\":[4.102251,4.1022511],\"start\":\"4.102251\",\"end\":\"4.1022511\",\"precision\":7,\"color\":\"#fef1e7\"},{\"label\":\"4.102263\",\"sections\":[4.102263,4.1022631],\"start\":\"4.102263\",\"end\":\"4.1022631\",\"precision\":7,\"color\":\"#fef1e7\"},{\"label\":\"4.102272\",\"sections\":[4.102272,4.1022721,4.1022722,4.1022723,4.1022724,4.1022725,4.1022726,4.1022727,4.1022728,4.1022729],\"start\":\"4.102272\",\"end\":\"4.1022729\",\"precision\":7,\"color\":\"#fef1e7\"},{\"label\":\"4.1022725\",\"sections\":[4.1022725,4.10227251,4.10227252,4.10227253,4.10227254],\"start\":\"4.1022725\",\"end\":\"4.10227254\",\"precision\":8,\"color\":\"#C0C0C0\"},{\"label\":\"4.1022728\",\"sections\":[4.1022728,4.10227281],\"start\":\"4.1022728\",\"end\":\"4.10227281\",\"precision\":8,\"color\":\"#C0C0C0\"},{\"label\":\"4.1022729\",\"sections\":[4.1022729,4.10227291],\"start\":\"4.1022729\",\"end\":\"4.10227291\",\"precision\":8,\"color\":\"#C0C0C0\"},{\"label\":\"4.2\",\"sections\":[4.2,4.21,4.22,4.23,4.24,4.25,4.26],\"start\":\"4.2\",\"end\":\"4.26\",\"precision\":2,\"color\":\"#f6944c\"},{\"label\":\"4.22\",\"sections\":[4.22,4.221,4.222],\"start\":\"4.22\",\"end\":\"4.222\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"4.23\",\"sections\":[4.23,4.231,4.232],\"start\":\"4.23\",\"end\":\"4.232\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"4.221\",\"sections\":[4.221,4.2211,4.2212,4.2213,4.2214,4.2215],\"start\":\"4.221\",\"end\":\"4.2215\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"4.2212\",\"sections\":[4.2212,4.22121,4.22122],\"start\":\"4.2212\",\"end\":\"4.22122\",\"precision\":5,\"color\":\"#4f83bb\"},{\"label\":\"4.2213\",\"sections\":[4.2213,4.22131],\"start\":\"4.2213\",\"end\":\"4.22131\",\"precision\":5,\"color\":\"#4f83bb\"},{\"label\":\"4.2215\",\"sections\":[4.2215,4.22151],\"start\":\"4.2215\",\"end\":\"4.22151\",\"precision\":5,\"color\":\"#4f83bb\"},{\"label\":\"4.3\",\"sections\":[4.3,4.31],\"start\":\"4.3\",\"end\":\"4.31\",\"precision\":2,\"color\":\"#f6944c\"},{\"label\":\"4.4\",\"sections\":[4.4,4.4001],\"start\":\"4.4\",\"end\":\"4.4001\",\"precision\":4,\"color\":\"#fde9da\"},{\"label\":\"4.4\",\"sections\":[4.4,4.401],\"start\":\"4.4\",\"end\":\"4.401\",\"precision\":3,\"color\":\"#fcd4b5\"},{\"label\":\"4.401\",\"sections\":[4.401,4.4011],\"start\":\"4.401\",\"end\":\"4.4011\",\"precision\":4,\"color\":\"#d9e3bd\"},{\"label\":\"4.4\",\"sections\":[4.4,4.41],\"start\":\"4.4\",\"end\":\"4.41\",\"precision\":2,\"color\":\"#f6944c\"},{\"label\":\"4.41\",\"sections\":[4.41,4.42,4.43,4.44],\"start\":\"4.41\",\"end\":\"4.44\",\"precision\":2,\"color\":\"#f6944c\"},{\"label\":\"4.42\",\"sections\":[4.42,4.421,4.422,4.423],\"start\":\"4.42\",\"end\":\"4.423\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"4.422\",\"sections\":[4.422,4.4221],\"start\":\"4.422\",\"end\":\"4.4221\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"4.43\",\"sections\":[4.43,4.4301,4.4302,4.4303],\"start\":\"4.43\",\"end\":\"4.4303\",\"precision\":4,\"color\":\"#d9e3bd\"},{\"label\":\"4.4301\",\"sections\":[4.4301,4.43011,4.43012,4.43013,4.43014],\"start\":\"4.4301\",\"end\":\"4.43014\",\"precision\":5,\"color\":\"#b8dede\"},{\"label\":\"4.43014\",\"sections\":[4.43014,4.430141],\"start\":\"4.43014\",\"end\":\"4.430141\",\"precision\":6,\"color\":\"#b8cce4\"},{\"label\":\"4.43\",\"sections\":[4.43,4.431,4.432,4.433],\"start\":\"4.43\",\"end\":\"4.431\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"4.431\",\"sections\":[4.43,4.431,4.432,4.433],\"start\":\"4.431\",\"end\":\"4.433\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"4.431\",\"sections\":[4.431,4.4311],\"start\":\"4.431\",\"end\":\"4.4311\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"4.432\",\"sections\":[4.432,4.4321,4.4322],\"start\":\"4.432\",\"end\":\"4.4322\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"4.433\",\"sections\":[4.433,4.4331],\"start\":\"4.433\",\"end\":\"4.4331\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"4.44\",\"sections\":[4.44,4.441,4.442,4.443,4.444,4.445,4.446,4.447,4.448,4.449],\"start\":\"4.44\",\"end\":\"4.449\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"4.446\",\"sections\":[4.446,4.44601,4.44602],\"start\":\"4.446\",\"end\":\"4.44602\",\"precision\":5,\"color\":\"#b8dede\"},{\"label\":\"4.446\",\"sections\":[4.446,4.4461,4.4462],\"start\":\"4.446\",\"end\":\"4.4461\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"4.4461\",\"sections\":[4.446,4.4461,4.4462],\"start\":\"4.4461\",\"end\":\"4.4462\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"4.448\",\"sections\":[4.448,4.44801],\"start\":\"4.448\",\"end\":\"4.44801\",\"precision\":5,\"color\":\"#b8dede\"},{\"label\":\"4.448\",\"sections\":[4.448,4.4481,4.4482,4.4483,4.4484,4.4485,4.4486],\"start\":\"4.448\",\"end\":\"4.4481\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"4.4481\",\"sections\":[4.448,4.4481,4.4482,4.4483,4.4484,4.4485,4.4486],\"start\":\"4.4481\",\"end\":\"4.4486\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"4.449\",\"sections\":[4.449,4.4491,4.4492],\"start\":\"4.449\",\"end\":\"4.4492\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"4.4486\",\"sections\":[4.4486,4.44861],\"start\":\"4.4486\",\"end\":\"4.44861\",\"precision\":5,\"color\":\"#4f83bb\"},{\"label\":\"5\",\"sections\":[5,5.001],\"start\":\"5\",\"end\":\"5.001\",\"precision\":3,\"color\":\"#fde9da\"},{\"label\":\"5.001\",\"sections\":[5.001,5.002,5.003,5.004,5.005],\"start\":\"5.001\",\"end\":\"5.005\",\"precision\":3,\"color\":\"#f2dcda\"},{\"label\":\"5.001\",\"sections\":[5.001,5.0011,5.0012,5.0013,5.0014,5.0015,5.0016,5.0017],\"start\":\"5.001\",\"end\":\"5.0017\",\"precision\":4,\"color\":\"#fde9da\"},{\"label\":\"5.002\",\"sections\":[5.002,5.0021,5.0022],\"start\":\"5.002\",\"end\":\"5.0022\",\"precision\":4,\"color\":\"#fde9da\"},{\"label\":\"5.004\",\"sections\":[5.004,5.0041],\"start\":\"5.004\",\"end\":\"5.0041\",\"precision\":4,\"color\":\"#fde9da\"},{\"label\":\"5.005\",\"sections\":[5.005,5.00501],\"start\":\"5.005\",\"end\":\"5.00501\",\"precision\":5,\"color\":\"#fef1e7\"},{\"label\":\"5.005\",\"sections\":[5.005,5.0051],\"start\":\"5.005\",\"end\":\"5.0051\",\"precision\":4,\"color\":\"#fde9da\"},{\"label\":\"5.0051\",\"sections\":[5.0051,5.0052,5.0053,5.0054],\"start\":\"5.0051\",\"end\":\"5.0054\",\"precision\":4,\"color\":\"#fde9da\"},{\"label\":\"5.0016\",\"sections\":[5.0016,5.00161,5.00162,5.00163],\"start\":\"5.0016\",\"end\":\"5.00163\",\"precision\":5,\"color\":\"#ebf0db\"},{\"label\":\"5.0053\",\"sections\":[5.0053,5.00531,5.00532,5.00533,5.00534,5.00535],\"start\":\"5.0053\",\"end\":\"5.00535\",\"precision\":5,\"color\":\"#ebf0db\"},{\"label\":\"5.041\",\"sections\":[5.041,5.04101,5.04102,5.04103,5.04104,5.04105],\"start\":\"5.041\",\"end\":\"5.04105\",\"precision\":5,\"color\":\"#d9e3bd\"},{\"label\":\"5.00534\",\"sections\":[5.00534,5.005342],\"start\":\"5.00534\",\"end\":\"5.005342\",\"precision\":6,\"color\":\"#eef7f7\"},{\"label\":\"5.00535\",\"sections\":[5.00535,5.005351],\"start\":\"5.00535\",\"end\":\"5.005351 \",\"precision\":7,\"color\":\"#eef7f7\"},{\"label\":\"5\",\"sections\":[5,5,5.01,5.02,5.03,5.04,5.05,5.06,5.07,5.08,5.09],\"start\":\"5\",\"end\":\"5.01\",\"precision\":2,\"color\":\"#e5b8b7\"},{\"label\":\"5.01\",\"sections\":[5,5,5.01,5.02,5.03,5.04,5.05,5.06,5.07,5.08,5.09],\"start\":\"5.01\",\"end\":\"5.09\",\"precision\":2,\"color\":\"#e5b8b7\"},{\"label\":\"5.01\",\"sections\":[5.01,5.011,5.012,5.013],\"start\":\"5.01\",\"end\":\"5.013\",\"precision\":3,\"color\":\"#fcd4b5\"},{\"label\":\"5.02\",\"sections\":[5.02,5.021,5.022,5.023],\"start\":\"5.02\",\"end\":\"5.023\",\"precision\":3,\"color\":\"#fcd4b5\"},{\"label\":\"5.04\",\"sections\":[5.04,5.041,5.042,5.043,5.044],\"start\":\"5.04\",\"end\":\"5.044\",\"precision\":3,\"color\":\"#fcd4b5\"},{\"label\":\"5.08\",\"sections\":[5.08,5.081,5.082],\"start\":\"5.08\",\"end\":\"5.082\",\"precision\":3,\"color\":\"#fcd4b5\"},{\"label\":\"5.09\",\"sections\":[5.09,5.091,5.092,5.093],\"start\":\"5.09\",\"end\":\"5.093\",\"precision\":3,\"color\":\"#fcd4b5\"},{\"label\":\"5.041\",\"sections\":[5.041,5.0411],\"start\":\"5.041\",\"end\":\"5.0411\",\"precision\":4,\"color\":\"#d9e3bd\"},{\"label\":\"5.0411\",\"sections\":[5.0411,5.0412,5.0413,5.0414,5.0415],\"start\":\"5.0411\",\"end\":\"5.0415\",\"precision\":4,\"color\":\"#d9e3bd\"},{\"label\":\"5.044\",\"sections\":[5.044,5.0441,5.0442,5.0443,5.0444],\"start\":\"5.044\",\"end\":\"5.0444\",\"precision\":4,\"color\":\"#d9e3bd\"},{\"label\":\"5.04102\",\"sections\":[5.04102,5.041021],\"start\":\"5.04102\",\"end\":\"5.041021\",\"precision\":6,\"color\":\"#b8dede\"},{\"label\":\"5.04103\",\"sections\":[5.04103,5.041031],\"start\":\"5.04103\",\"end\":\"5.041031\",\"precision\":6,\"color\":\"#b8dede\"},{\"label\":\"5.0411\",\"sections\":[5.0411,5.04111,5.04112,5.04113],\"start\":\"5.0411\",\"end\":\"5.04113\",\"precision\":5,\"color\":\"#b8dede\"},{\"label\":\"5.0414\",\"sections\":[5.0414,5.04141],\"start\":\"5.0414\",\"end\":\"5.04141\",\"precision\":5,\"color\":\"#b8dede\"},{\"label\":\"5.0444\",\"sections\":[5.0444,5.04441,5.04442],\"start\":\"5.0444\",\"end\":\"5.04442\",\"precision\":5,\"color\":\"#b8dede\"},{\"label\":\"5.093\",\"sections\":[5.093,5.0931,5.0932,5.0933,5.0934],\"start\":\"5.093\",\"end\":\"5.0934\",\"precision\":4,\"color\":\"#d9e3bd\"},{\"label\":\"5.0931\",\"sections\":[5.0931,5.09311],\"start\":\"5.0931\",\"end\":\"5.09311\",\"precision\":5,\"color\":\"#b8dede\"},{\"label\":\"5.1\",\"sections\":[5.1,5.101],\"start\":\"5.1\",\"end\":\"5.101\",\"precision\":3,\"color\":\"#fcd4b5\"},{\"label\":\"5.1\",\"sections\":[5.1,5.11,5.12],\"start\":\"5.1\",\"end\":\"5.11\",\"precision\":2,\"color\":\"#f6944c\"},{\"label\":\"5.11\",\"sections\":[5.1,5.11,5.12],\"start\":\"5.11\",\"end\":\"5.12\",\"precision\":2,\"color\":\"#f6944c\"},{\"label\":\"5.2\",\"sections\":[5.2,5.21,5.22,5.23],\"start\":\"5.2\",\"end\":\"5.23\",\"precision\":2,\"color\":\"#f6944c\"},{\"label\":\"5.22\",\"sections\":[5.22,5.2201],\"start\":\"5.22\",\"end\":\"5.2201\",\"precision\":4,\"color\":\"#d9e3bd\"},{\"label\":\"5.22\",\"sections\":[5.22,5.221,5.222,5.223,5.224],\"start\":\"5.22\",\"end\":\"5.221\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"5.221\",\"sections\":[5.22,5.221,5.222,5.223,5.224],\"start\":\"5.221\",\"end\":\"5.224\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"5.23\",\"sections\":[5.23,5.231,5.232,5.233,5.234],\"start\":\"5.23\",\"end\":\"5.234\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"5.221\",\"sections\":[5.221,5.2211],\"start\":\"5.221\",\"end\":\"5.2211\",\"precision\":4,\"color\":\"#4f83bb\"},{\"label\":\"5.233\",\"sections\":[5.233,5.2331],\"start\":\"5.233\",\"end\":\"5.2331\",\"precision\":4,\"color\":\"#4f83bb\"},{\"label\":\"5.3\",\"sections\":[5.3,5.3001,5.3002,5.3003],\"start\":\"5.3\",\"end\":\"5.3003\",\"precision\":4,\"color\":\"#fde9da\"},{\"label\":\"5.3\",\"sections\":[5.3,5.301],\"start\":\"5.3\",\"end\":\"5.301\",\"precision\":3,\"color\":\"#fcd4b5\"},{\"label\":\"5.301\",\"sections\":[5.301,5.302,5.303,5.304,5.305,5.306,5.307],\"start\":\"5.301\",\"end\":\"5.307\",\"precision\":3,\"color\":\"#fcd4b5\"},{\"label\":\"5.302\",\"sections\":[5.302,5.30201,5.30202],\"start\":\"5.302\",\"end\":\"5.30202\",\"precision\":5,\"color\":\"#fde9da\"},{\"label\":\"5.302\",\"sections\":[5.302,5.3021,5.3022,5.3023,5.3024],\"start\":\"5.302\",\"end\":\"5.3021\",\"precision\":4,\"color\":\"#d9e3bd\"},{\"label\":\"5.3021\",\"sections\":[5.302,5.3021,5.3022,5.3023,5.3024],\"start\":\"5.3021\",\"end\":\"5.3024\",\"precision\":4,\"color\":\"#d9e3bd\"},{\"label\":\"5.303\",\"sections\":[5.303,5.3031,5.3032],\"start\":\"5.303\",\"end\":\"5.3032\",\"precision\":4,\"color\":\"#d9e3bd\"},{\"label\":\"5.306\",\"sections\":[5.306,5.3061,5.3062,5.3063,5.3064],\"start\":\"5.306\",\"end\":\"5.3064\",\"precision\":4,\"color\":\"#d9e3bd\"},{\"label\":\"5.307\",\"sections\":[5.307,5.3071,5.3072,5.3073],\"start\":\"5.307\",\"end\":\"5.3073\",\"precision\":4,\"color\":\"#d9e3bd\"},{\"label\":\"5.3063\",\"sections\":[5.3063,5.30631,5.30632,5.30633,5.30634],\"start\":\"5.3063\",\"end\":\"5.30634\",\"precision\":5,\"color\":\"#b8dede\"},{\"label\":\"5.3064\",\"sections\":[5.3064,5.30641],\"start\":\"5.3064\",\"end\":\"5.30641\",\"precision\":5,\"color\":\"#b8dede\"},{\"label\":\"5.3022\",\"sections\":[5.3022,5.30221,5.30222,5.30223,5.30224,5.30225],\"start\":\"5.3022\",\"end\":\"5.30225\",\"precision\":5,\"color\":\"#b8dede\"},{\"label\":\"5.3023\",\"sections\":[5.3023,5.30231],\"start\":\"5.3023\",\"end\":\"5.30231\",\"precision\":5,\"color\":\"#b8dede\"},{\"label\":\"5.3\",\"sections\":[5.3,5.31,5.32,5.33,5.34],\"start\":\"5.3\",\"end\":\"5.31\",\"precision\":2,\"color\":\"#f6944c\"},{\"label\":\"5.31\",\"sections\":[5.3,5.31,5.32,5.33,5.34],\"start\":\"5.31\",\"end\":\"5.34\",\"precision\":2,\"color\":\"#f6944c\"},{\"label\":\"5.31\",\"sections\":[5.31,5.3101,5.3102,5.3103],\"start\":\"5.31\",\"end\":\"5.3103\",\"precision\":4,\"color\":\"#d9e3bd\"},{\"label\":\"5.31\",\"sections\":[5.31,5.311,5.312,5.313,5.314,5.315],\"start\":\"5.31\",\"end\":\"5.311\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"5.311\",\"sections\":[5.31,5.311,5.312,5.313,5.314,5.315],\"start\":\"5.311\",\"end\":\"5.315\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"5.313\",\"sections\":[5.313,5.3131,5.3132,5.3133],\"start\":\"5.313\",\"end\":\"5.3133\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"5.32\",\"sections\":[5.32,5.3201,5.3202,5.3203,5.3204],\"start\":\"5.32\",\"end\":\"5.3204\",\"precision\":4,\"color\":\"#d9e3bd\"},{\"label\":\"5.3204\",\"sections\":[5.3204,5.32041],\"start\":\"5.3204\",\"end\":\"5.32041\",\"precision\":5,\"color\":\"#b8dede\"},{\"label\":\"5.32\",\"sections\":[5.32,5.321,5.322,5.323,5.324,5.325,5.326],\"start\":\"5.32\",\"end\":\"5.321\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"5.321\",\"sections\":[5.32,5.321,5.322,5.323,5.324,5.325,5.326],\"start\":\"5.321\",\"end\":\"5.326\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"5.322\",\"sections\":[5.322,5.3221],\"start\":\"5.322\",\"end\":\"5.3221\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"5.325\",\"sections\":[5.325,5.3251],\"start\":\"5.325\",\"end\":\"5.3251\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"5.33\",\"sections\":[5.33,5.3301,5.3302,5.3303,5.3304],\"start\":\"5.33\",\"end\":\"5.3304\",\"precision\":4,\"color\":\"#d9e3bd\"},{\"label\":\"5.33\",\"sections\":[5.33,5.331,5.332,5.333,5.334,5.335],\"start\":\"5.33\",\"end\":\"5.331\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"5.331\",\"sections\":[5.33,5.331,5.332,5.333,5.334,5.335],\"start\":\"5.331\",\"end\":\"5.335\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"5.34\",\"sections\":[5.34,5.341,5.342,5.343],\"start\":\"5.34\",\"end\":\"5.343\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"5.332\",\"sections\":[5.332,5.3321],\"start\":\"5.332\",\"end\":\"5.3321\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"5.334\",\"sections\":[5.334,5.3341,5.3342,5.3343,5.3344],\"start\":\"5.334\",\"end\":\"5.3344\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"5.335\",\"sections\":[5.335,5.3351,5.3352,5.3353,5.3354,5.3355],\"start\":\"5.335\",\"end\":\"5.3355\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"5.343\",\"sections\":[5.343,5.3431,5.3432],\"start\":\"5.343\",\"end\":\"5.3432\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"5.4\",\"sections\":[5.4,5.401,5.402,5.403,5.404,5.405],\"start\":\"5.4\",\"end\":\"5.405\",\"precision\":3,\"color\":\"#fcd4b5\"},{\"label\":\"5.401\",\"sections\":[5.401,5.4011,5.4012],\"start\":\"5.401\",\"end\":\"5.4012\",\"precision\":4,\"color\":\"#d9e3bd\"},{\"label\":\"5.404\",\"sections\":[5.404,5.4041,5.4042,5.4043],\"start\":\"5.404\",\"end\":\"5.4043\",\"precision\":4,\"color\":\"#d9e3bd\"},{\"label\":\"5.405\",\"sections\":[5.405,5.4051],\"start\":\"5.405\",\"end\":\"5.4051\",\"precision\":4,\"color\":\"#d9e3bd\"},{\"label\":\"5.4042\",\"sections\":[5.4042,5.40421],\"start\":\"5.4042\",\"end\":\"5.40421\",\"precision\":5,\"color\":\"#b8dede\"},{\"label\":\"5.4\",\"sections\":[5.4,5.41],\"start\":\"5.4\",\"end\":\"5.41\",\"precision\":2,\"color\":\"#f6944c\"},{\"label\":\"5.41\",\"sections\":[5.41,5.42],\"start\":\"5.41\",\"end\":\"5.42\",\"precision\":2,\"color\":\"#f6944c\"},{\"label\":\"5.41\",\"sections\":[5.41,5.4101,5.4102,5.4103],\"start\":\"5.41\",\"end\":\"5.4101\",\"precision\":4,\"color\":\"#d9e3bd\"},{\"label\":\"5.4101\",\"sections\":[5.4101,5.41011],\"start\":\"5.4101\",\"end\":\"5.41011\",\"precision\":5,\"color\":\"#b8dede\"},{\"label\":\"5.4101\",\"sections\":[5.41,5.4101,5.4102,5.4103],\"start\":\"5.4101\",\"end\":\"5.4103\",\"precision\":4,\"color\":\"#d9e3bd\"},{\"label\":\"5.41\",\"sections\":[5.41,5.411,5.412,5.413,5.414],\"start\":\"5.41\",\"end\":\"5.411\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"5.411\",\"sections\":[5.41,5.411,5.412,5.413,5.414],\"start\":\"5.411\",\"end\":\"5.414\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"5.42\",\"sections\":[5.42,5.421,5.422],\"start\":\"5.42\",\"end\":\"5.422\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"5.421\",\"sections\":[5.421,5.4211,5.4212,5.4213,5.4214],\"start\":\"5.421\",\"end\":\"5.4214\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"5.422\",\"sections\":[5.422,5.4221,5.4222,5.4223],\"start\":\"5.422\",\"end\":\"5.4223\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"5.3341\",\"sections\":[5.3341,5.33411,5.33412],\"start\":\"5.3341\",\"end\":\"5.33412\",\"precision\":5,\"color\":\"#4f83bb\"},{\"label\":\"5.3353\",\"sections\":[5.3353,5.33531,5.33532],\"start\":\"5.3353\",\"end\":\"5.33532\",\"precision\":5,\"color\":\"#4f83bb\"},{\"label\":\"5.3354\",\"sections\":[5.3354,5.33541,5.33542,5.33543,5.33544,5.33545,5.33546],\"start\":\"5.3354\",\"end\":\"5.33546\",\"precision\":5,\"color\":\"#4f83bb\"},{\"label\":\"5.3355\",\"sections\":[5.3355,5.33551,5.33552],\"start\":\"5.3355\",\"end\":\"5.33552\",\"precision\":5,\"color\":\"#4f83bb\"},{\"label\":\"5.33543\",\"sections\":[5.33543,5.335431],\"start\":\"5.33543\",\"end\":\"5.335431\",\"precision\":6,\"color\":\"#fef1e7\"},{\"label\":\"6\",\"sections\":[6,6.001,6.002,6.003,6.004,6.005],\"start\":\"6\",\"end\":\"6.001\",\"precision\":3,\"color\":\"#f2dcda\"},{\"label\":\"6.001\",\"sections\":[6,6.001,6.002,6.003,6.004,6.005],\"start\":\"6.001\",\"end\":\"6.005\",\"precision\":3,\"color\":\"#f2dcda\"},{\"label\":\"6\",\"sections\":[6,6.01,6.02],\"start\":\"6\",\"end\":\"6.01\",\"precision\":2,\"color\":\"#e5b8b7\"},{\"label\":\"6.01\",\"sections\":[6,6.01,6.02],\"start\":\"6.01\",\"end\":\"6.02\",\"precision\":2,\"color\":\"#e5b8b7\"},{\"label\":\"6.01\",\"sections\":[6.01,6.011,6.012,6.013],\"start\":\"6.01\",\"end\":\"6.013\",\"precision\":3,\"color\":\"#fcd4b5\"},{\"label\":\"6.02\",\"sections\":[6.02,6.0201],\"start\":\"6.02\",\"end\":\"6.0201\",\"precision\":4,\"color\":\"#fde9da\"},{\"label\":\"6.004\",\"sections\":[6.004,6.0041,6.0042,6.0043],\"start\":\"6.004\",\"end\":\"6.0043\",\"precision\":4,\"color\":\"#fde9da\"},{\"label\":\"6.005\",\"sections\":[6.005,6.0051],\"start\":\"6.005\",\"end\":\"6.0051\",\"precision\":4,\"color\":\"#fde9da\"},{\"label\":\"6.1\",\"sections\":[6.1,6.1001,6.1002,6.1003,6.1004],\"start\":\"6.1\",\"end\":\"6.1004\",\"precision\":4,\"color\":\"#fde9da\"},{\"label\":\"6.1\",\"sections\":[6.1,6.101,6.102],\"start\":\"6.1\",\"end\":\"6.101\",\"precision\":3,\"color\":\"#fcd4b5\"},{\"label\":\"6.101\",\"sections\":[6.101,6.102],\"start\":\"6.101\",\"end\":\"6.102\",\"precision\":3,\"color\":\"#fcd4b5\"},{\"label\":\"6.1\",\"sections\":[6.1,6.11,6.12,6.13],\"start\":\"6.1\",\"end\":\"6.11\",\"precision\":2,\"color\":\"#f6944c\"},{\"label\":\"6.11\",\"sections\":[6.1,6.11,6.12,6.13],\"start\":\"6.11\",\"end\":\"6.13\",\"precision\":2,\"color\":\"#f6944c\"},{\"label\":\"6.11\",\"sections\":[6.11,6.111,6.112,6.113,6.114],\"start\":\"6.11\",\"end\":\"6.114\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"6.12\",\"sections\":[6.12,6.121,6.122],\"start\":\"6.12\",\"end\":\"6.122\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"6.13\",\"sections\":[6.13,6.131],\"start\":\"6.13\",\"end\":\"6.131\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"6.112\",\"sections\":[6.112,6.1121,6.1122],\"start\":\"6.112\",\"end\":\"6.1122\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"6.11211\",\"sections\":[6.1121,6.11211],\"start\":\"6.112\",\"end\":\"6.11211\",\"precision\":5,\"color\":\"#4f83bb\"},{\"label\":\"6.113\",\"sections\":[6.113,6.1131,6.1132,6.1133,6.1134,6.1135,6.1136],\"start\":\"6.113\",\"end\":\"6.1136\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"6.114\",\"sections\":[6.114,6.1141,6.1142,6.1143],\"start\":\"6.114\",\"end\":\"6.1143\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"6.121\",\"sections\":[6.121,6.1211,6.1212,6.1213,6.1214,6.1215,6.1216],\"start\":\"6.121\",\"end\":\"6.1216\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"6.122\",\"sections\":[6.122,6.1221],\"start\":\"6.122\",\"end\":\"6.1221\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"6.1134\",\"sections\":[6.1134,6.11341,6.11342,6.11343],\"start\":\"6.1134\",\"end\":\"6.11343\",\"precision\":5,\"color\":\"#4f83bb\"},{\"label\":\"6.1135\",\"sections\":[6.1135,6.113501],\"start\":\"6.1135\",\"end\":\"6.113501\",\"precision\":6,\"color\":\"#4dadc5\"},{\"label\":\"6.1135\",\"sections\":[6.1135,6.11351,6.11352],\"start\":\"6.1135\",\"end\":\"6.11351\",\"precision\":5,\"color\":\"#4f83bb\"},{\"label\":\"6.11351\",\"sections\":[6.1135,6.11351,6.11352],\"start\":\"6.11351\",\"end\":\"6.11352\",\"precision\":5,\"color\":\"#4f83bb\"},{\"label\":\"6.1211\",\"sections\":[6.1211,6.12111,6.12112],\"start\":\"6.1211\",\"end\":\"6.12112\",\"precision\":5,\"color\":\"#4f83bb\"},{\"label\":\"6.2\",\"sections\":[6.2,6.21,6.22,6.23,6.24],\"start\":\"6.2\",\"end\":\"6.24\",\"precision\":2,\"color\":\"#f6944c\"},{\"label\":\"6.3\",\"sections\":[6.3,6.31,6.32,6.33,6.34,6.35,6.36,6.37],\"start\":\"6.3\",\"end\":\"6.37\",\"precision\":2,\"color\":\"#f6944c\"},{\"label\":\"6.21\",\"sections\":[6.21,6.211,6.212],\"start\":\"6.21\",\"end\":\"6.212\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"6.23\",\"sections\":[6.23,6.231,6.232],\"start\":\"6.23\",\"end\":\"6.232\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"6.31\",\"sections\":[6.31,6.311],\"start\":\"6.31\",\"end\":\"6.311\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"6.33\",\"sections\":[6.33,6.331],\"start\":\"6.33\",\"end\":\"6.331\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"6.34\",\"sections\":[6.34,6.341],\"start\":\"6.34\",\"end\":\"6.341\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"6.36\",\"sections\":[6.36,6.361,6.362,6.363,6.364,6.365],\"start\":\"6.36\",\"end\":\"6.365\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"6.37\",\"sections\":[6.37,6.371,6.372,6.373,6.374,6.375],\"start\":\"6.37\",\"end\":\"6.375\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"6.341\",\"sections\":[6.341,6.3411,6.3412],\"start\":\"6.341\",\"end\":\"6.3412\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"6.363\",\"sections\":[6.363,6.3631,6.3632],\"start\":\"6.363\",\"end\":\"6.3632\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"6.365\",\"sections\":[6.365,6.3651,6.3652],\"start\":\"6.365\",\"end\":\"6.3652\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"6.375\",\"sections\":[6.375,6.3751,6.3752],\"start\":\"6.375\",\"end\":\"6.3752\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"6.3632\",\"sections\":[6.3632,6.36321,6.36322,6.36323],\"start\":\"6.3632\",\"end\":\"6.36323\",\"precision\":5,\"color\":\"#4f83bb\"},{\"label\":\"6.3652\",\"sections\":[6.3652,6.36521],\"start\":\"6.3652\",\"end\":\"6.36521\",\"precision\":5,\"color\":\"#4f83bb\"},{\"label\":\"6.4\",\"sections\":[6.4,6.41,6.42,6.43,6.44],\"start\":\"6.4\",\"end\":\"6.44\",\"precision\":2,\"color\":\"#f6944c\"},{\"label\":\"6.5\",\"sections\":[6.5,6.51,6.52,6.53,6.54,6.55],\"start\":\"6.5\",\"end\":\"6.55\",\"precision\":2,\"color\":\"#f6944c\"},{\"label\":\"6.42\",\"sections\":[6.42,6.421,6.422],\"start\":\"6.42\",\"end\":\"6.422\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"6.43\",\"sections\":[6.43,6.431,6.432],\"start\":\"6.43\",\"end\":\"6.432\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"6.44\",\"sections\":[6.44,6.441,6.442],\"start\":\"6.44\",\"end\":\"6.442\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"6.52\",\"sections\":[6.52,6.521],\"start\":\"6.52\",\"end\":\"6.521\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"6.53\",\"sections\":[6.53,6.531],\"start\":\"6.53\",\"end\":\"6.531\",\"precision\":3,\"color\":\"#9cb95e\"},{\"label\":\"6.422\",\"sections\":[6.422,6.4221],\"start\":\"6.422\",\"end\":\"6.4221\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"6.441\",\"sections\":[6.441,6.4411,6.4412],\"start\":\"6.441\",\"end\":\"6.4412\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"6.442\",\"sections\":[6.442,6.4421,6.4422,6.4423],\"start\":\"6.442\",\"end\":\"6.4423\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"6.521\",\"sections\":[6.521,6.5211],\"start\":\"6.521\",\"end\":\"6.5211\",\"precision\":4,\"color\":\"#4dadc5\"},{\"label\":\"6.4422\",\"sections\":[6.4422,6.44221],\"start\":\"6.4422\",\"end\":\"6.44221\",\"precision\":5,\"color\":\"#4f83bb\"},{\"label\":\"6.4423\",\"sections\":[6.4423,6.44231,6.44232],\"start\":\"6.4423\",\"end\":\"6.44232\",\"precision\":5,\"color\":\"#4f83bb\"}]};\n\n//# sourceURL=webpack:///./src/data/ptLines.json?");

/***/ }),

/***/ "./src/data/ptSections.json":
/*!**********************************!*\
  !*** ./src/data/ptSections.json ***!
  \**********************************/
/*! exports provided: sections, default */
/***/ (function(module) {

eval("module.exports = {\"sections\":[{\"label\":\"1\",\"precision\":0,\"fontSize\":\"90px\",\"y_axis\":1,\"x_axis\":1,\"page\":1,\"ger\":\"Die Welt ist alles was der Fall ist.\",\"pmc\":\"The world is all that is the case.\",\"ogd\":\"\",\"str\":\"The world is all that is the case.\",\"tlp\":[1]},{\"label\":\"2\",\"precision\":0,\"fontSize\":\"90px\",\"y_axis\":1,\"x_axis\":9,\"page\":1,\"ger\":\"Was der Fall ist, die Tatsache, ist das Bestehen von Sachverhalten.\",\"pmc\":\"What is the case - a fact - is the existence of states of affairs.\",\"ogd\":\"\",\"str\":\"What is the case—a fact—is the obtaining of elementary facts.\",\"tlp\":[2]},{\"label\":\"3\",\"precision\":0,\"fontSize\":\"90px\",\"y_axis\":1,\"x_axis\":45,\"page\":1,\"ger\":\"Das logische Bild der Tatsachen ist der Gedanke. \",\"pmc\":\"A logical picture of facts is a thought.\",\"ogd\":\"\",\"str\":\"A thought is a logical picture of facts.\",\"tlp\":[3]},{\"label\":\"4\",\"precision\":0,\"fontSize\":\"90px\",\"y_axis\":1,\"x_axis\":67,\"page\":1,\"ger\":\"Der Gedanke ist der sinnvolle Satz. \",\"pmc\":\"A thought is a proposition with a sense.\",\"ogd\":\"\",\"str\":\"A thought is a sentence with a sense.\",\"tlp\":[4]},{\"label\":\"5\",\"precision\":0,\"fontSize\":\"90px\",\"y_axis\":1,\"x_axis\":111,\"page\":1,\"ger\":\"Der Satz ist eine Wahrheitsfunktion der Elementarsätze. \",\"pmc\":\"A proposition is a truth-function of elementary propositions.\",\"ogd\":\"\",\"str\":\"A proposition is a truth-function of elementary propositions.\",\"tlp\":[5]},{\"label\":\"6\",\"precision\":0,\"fontSize\":\"90px\",\"y_axis\":1,\"x_axis\":147,\"page\":1,\"ger\":\"Die allgemeine Form der Wahrheitsfunktion ist:<br />|N(p̅0), ᾱ, N(ᾱ)|\",\"pmc\":\"The general form of a truth-function is<br />|N(p̅0), ᾱ, N(ᾱ)|\",\"ogd\":\"\",\"str\":\"The general form of a truth-function is: |N(p̄0), ᾱ, N(ᾱ)|.pt\\t \",\"tlp\":[6]},{\"label\":\"7\",\"precision\":0,\"fontSize\":\"90px\",\"y_axis\":1,\"x_axis\":179,\"page\":71,\"ger\":\"Wovon man nicht sprechen kann, darüber muß man schweigen. \",\"pmc\":\"What we cannot speak about we must pass over in silence.\",\"ogd\":\"\",\"str\":\"Of what we cannot speak we must be silent.\",\"tlp\":[7]},{\"label\":\"1.1\",\"precision\":1,\"fontSize\":\"40px\",\"y_axis\":3,\"x_axis\":1,\"page\":3,\"ger\":\"Die Welt ist die Gesamtheit der Tatsachen, nicht der Dinge. \",\"pmc\":\"The world is the totality of facts, not of things.\",\"ogd\":\"\",\"str\":\"The world is all that is the case.\",\"tlp\":[1.1]},{\"label\":\"1.11\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":3,\"x_axis\":3,\"page\":4,\"ger\":\"Die Welt ist durch die Tatsachen bestimmt und dadurch, daß es alle Tatsachen sind.\",\"pmc\":\"The world is determined by the facts, and by their being all the facts.\",\"ogd\":\"\",\"str\":\"The world is determined by the facts, and by these being all the facts.\",\"tlp\":[1.11]},{\"label\":\"1.12\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":3,\"x_axis\":5,\"page\":5,\"ger\":\"Denn die Gesamtheit der Tatsachen bestimmt was der Fall ist und auch was alles nicht der Fall ist. \",\"pmc\":\"For the totality of facts determines what is the case, and also whatever is not the case.\",\"ogd\":\"\",\"str\":\"For the totality of facts determines what is the case, and also whatever is not the case.\",\"tlp\":[1.12]},{\"label\":\"1.13\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":3,\"x_axis\":7,\"page\":4,\"ger\":\"Die Tatsachen im logischen Raum sind die Welt. \",\"pmc\":\"The facts in logical space are the world.\",\"ogd\":\"\",\"str\":\"The facts in logical space are the world.\",\"tlp\":[1.13]},{\"label\":\"2.01\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":3,\"x_axis\":11,\"page\":4,\"ger\":\"Der Sachverhalt ist eine Verbindung von Gegenständen, Sachen. \",\"pmc\":\"A state of affairs (a state of things) is a combination of objects (things).\",\"ogd\":\"\",\"str\":\"An elementary fact is a combination of objects (entities, things).\",\"tlp\":[2.01]},{\"label\":\"2.02\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":3,\"x_axis\":23,\"page\":4,\"ger\":\"Der Gegenstand ist einfach. \",\"pmc\":\"Objects are simple.\",\"ogd\":\"\",\"str\":\"An object is simple.\",\"tlp\":[2.02]},{\"label\":\"2.03\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":3,\"x_axis\":33,\"page\":5,\"ger\":\"Im Sachverhalt hängen die Gegenstände ineinander wie die Glieder einer Kette.\",\"pmc\":\"In a state of affairs objects fit into one another like the links of a chain.\",\"ogd\":\"\",\"str\":\"In an elementary fact objects are interconnected, like the links of a chain.\",\"tlp\":[2.03]},{\"label\":\"2.04\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":3,\"x_axis\":35,\"page\":5,\"ger\":\"Die Gesamtheit der bestehenden Sachverhalte ist die Welt. \",\"pmc\":\"The totality of existing states of affairs is the world.\",\"ogd\":\"\",\"str\":\"Die Gesamtheit der bestehenden Sachverhalte ist die Welt.\",\"tlp\":[2.04]},{\"label\":\"2.05\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":3,\"x_axis\":37,\"page\":5,\"ger\":\"Die Gesamtheit der bestehenden Sachverhalte bestimmt auch, welche Sachverhalte nicht bestehen.\",\"pmc\":\"The totality of existing states of affairs also determines which states of affairs do not exist.\",\"ogd\":\"\",\"str\":\"The totality of obtaining elementary facts also determines which elementary facts do not obtain.\",\"tlp\":[2.05]},{\"label\":\"2.06\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":3,\"x_axis\":39,\"page\":5,\"ger\":\"Das Bestehen und nicht Bestehen von Sachverhalten ist die Wirklichkeit. \",\"pmc\":\"The existence and non-existence of states of affairs is reality.\",\"ogd\":\"\",\"str\":\"The obtaining or non-obtaining of elementary facts is reality.\",\"tlp\":[2.06]},{\"label\":\"2.07\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":3,\"x_axis\":43,\"page\":5,\"ger\":\"Die gesamte Wirklichkeit ist die Welt. \",\"pmc\":\"The sum-total of reality is the world.\",\"ogd\":\"\",\"str\":\"The sum total of reality is the world.\",\"tlp\":[2.063]},{\"label\":\"3.001\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":3,\"x_axis\":47,\"page\":42,\"ger\":\"〟Ein Sachverhalt ist denkbar\\\" (〟vorstellbar\\\") heißt: Wir können uns ein Bild von ihm machen. \",\"pmc\":\" 'A state of affairs is thinkable (imaginable)'; what this means is that we can picture it to ourselves.\",\"ogd\":\"\",\"str\":\"“A elementary proposition is thinkable (imaginable)” means: we can imagine it.\",\"tlp\":[3.001]},{\"label\":\"4.001\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":3,\"x_axis\":70,\"page\":17,\"ger\":\"Die Gesamtheit der Sätze ist die Sprache. \",\"pmc\":\"The totality of propositions is the language.\",\"ogd\":\"\",\"str\":\"The totality of propositions is language.\",\"tlp\":[4.001]},{\"label\":\"5.001\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":3,\"x_axis\":115,\"page\":10,\"ger\":\"Jeder Satz läßt sich auffassen als Resultat einer Operation, welche mit einem anderen Satz (der Basis der Operation) vorgenommen wurde und diesen in jenen verwandelt. \",\"pmc\":\"Every proposition can be construed as the result of an operation which is performed on another proposition (which is the base of the operation) and which turns the latter into the former.\",\"ogd\":\"\",\"str\":\"Every proposition can be construed as the result of an operation which is performed on another proposition (the operation’s base) and turns the latter into the former.\",\"tlp\":[5.21]},{\"label\":\"5.002\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":3,\"x_axis\":117,\"page\":63,\"ger\":\"Das Vorkommen einer Operation im Satz kann natürlich allein nichts besagen. \",\"pmc\":\"Of course the mere occurrence of an operation in a proposition cannot say anything.\",\"ogd\":\"\",\"str\":\"Of course the mere occurrence of an operation in a proposition cannot say anything.\",\"tlp\":[5.25]},{\"label\":\"5.003\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":3,\"x_axis\":119,\"page\":11,\"ger\":\"Jeden Klammerausdruck dessen Glieder Sätze sind schreiben wir in der Form 〟(α)\\\". 〟α\\\" ist eine Variable, deren Werte die Glieder des Klammerausdruckes sind. Der Strich über dem 〟α\\\" bedeutet, daß alle Werte von α in der Klammer stehen. \",\"pmc\":\"Any bracketed proposition whose terms are propositions we write in form '(ᾱ)'. '(ᾱ)' is a variable whose values are terms of the bracketed expression. The bar over 'α' means that all values of α stand between the brackets.\",\"ogd\":\"\",\"str\":\"Any bracketed proposition whose terms are propositions we write in form “(ᾱ)”. “(ᾱ)” is a variable whose values are terms of the bracketed expression. The line over “α” means that all values of α stand between the brackets.\",\"tlp\":[5.501]},{\"label\":\"5.004\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":3,\"x_axis\":121,\"page\":11,\"ger\":\"Welche Werte α annehmen darf, wird festgesetzt.\",\"pmc\":\"What values α can take is something that is stipulated.\",\"ogd\":\"\",\"str\":\"The values of α are set by stipulation.\",\"tlp\":[\"3.316, 5.501\"]},{\"label\":\"5.005\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":3,\"x_axis\":123,\"page\":20,\"ger\":\"Die Festsetzung der Werte der Satzvariablen ist die Angabe der Sätze, welche die Variable vertritt.\",\"pmc\":\"To stipulate values for a propositional variable is to give the propositions of which the variable is the representative.\",\"ogd\":\"\",\"str\":\"Values for a sentential variable are stipulated by indicating the sentences which the variable represents.\",\"tlp\":[\"3.317, 5.501\"]},{\"label\":\"6.001\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":3,\"x_axis\":149,\"page\":74,\"ger\":\"In der allgemeinen Satzform kommt der Satz im Satz nur als W-Argument vor. \",\"pmc\":\"In the general propositional form propositions occur in other propositions only as T-arguments.\",\"ogd\":\"\",\"str\":\"In the general propositional form propositions occur in other propositions only as truth arguments.\",\"tlp\":[5.54]},{\"label\":\"6.002\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":3,\"x_axis\":154,\"page\":74,\"ger\":\"Nun scheint es aber auf den ersten Blick als könne ein Satz in einem anderen auch auf andere Weise vorkommen. \",\"pmc\":\"But at first sight it looks as if it were also possible for one proposition to occur in another in a different way.\",\"ogd\":\"\",\"str\":\"But at first sight it looks as if there were another way in which one proposition could occur in another.\",\"tlp\":[5.541]},{\"label\":\"6.003\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":3,\"x_axis\":156,\"page\":74,\"ger\":\"Besonders in gewissen psychologischen Satzformen wie 〟A glaubt, daß p\\\" oder 〟A denkt p\\\", etc. Hier scheint es nämlich oberflächlich als stünde der Satz p zu einem Gegenstand A in einer Art Relation — und in der modernen Erkenntnistheorie (Russell, Moore, etc.) sind jene Sätze auch so aufgefaßt worden. \",\"pmc\":\"Particularly with certain forms of proposition in psychology, such as 'A believes that p' or 'A has the thought p', etc. For if these are considered superficially, it looks as if the proposition p stood in some kind of relation to an object A - and in modern theory of knowledge (Russell, Moore, etc.) these propositions have actually been construed in this way.\",\"ogd\":\"\",\"str\":\"Especially in certain forms of proposition in psychology, such as “A believes that p” or “A thinks p”, etc. On the surface, it looks as if the proposition p stood in some kind of relation to an object A - and in modern theory of knowledge (Russell, Moore, etc.) these propositions have actually been construed in this way.\",\"tlp\":[5.541]},{\"label\":\"6.004\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":3,\"x_axis\":158,\"page\":74,\"ger\":\"Es ist aber klar daß 〟A glaubt , daß\\\", 〟A denkt p\\\" 〟A sagt p\\\" von der Form 〟‚p’ sagt p\\\" sind; und hier ist es klar daß es sich nicht um eine Zuordnung von einer Tatsache und einem Gegenstand sondern um die Zuordnung von Tatsachen durch Zuordnung ihrer Gegenstände handelt.\",\"pmc\":\"It is clear, however, that 'A believes that p', 'A has the thought that p', and 'A says p' are of the form '\\\"p\\\" says p'; and it is clear that this does not involve a correlation of a fact with an object but rather the correlation of facts by means of the correlation of their objects.\",\"ogd\":\"\",\"str\":\"Clearly, however, “A believes that p”, “A thinks p”, and “A says p” are of the form “‘p’ says p”; and clearly this is n0t a matter of a correlation of fact to objec,t but rather the correlation of facts by correlation of their objects.\",\"tlp\":[5.542]},{\"label\":\"6.005\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":3,\"x_axis\":160,\"page\":93,\"ger\":\"Einen Komplex wahrnehmen heißt, wahrnehmen, daß sich seine Bestandteile so und so zu einander verhalten. \",\"pmc\":\"To perceive a complex means to perceive that its constituents are related to one another in such and such a way.\",\"ogd\":\"\",\"str\":\"Perceiving a complex means perceiving the way that its constituents are related to one another.\",\"tlp\":[5.5423]},{\"label\":\"1.2\",\"precision\":1,\"fontSize\":\"40px\",\"y_axis\":5,\"x_axis\":1,\"page\":78,\"ger\":\"Die Welt zerfällt in Tatsachen. \",\"pmc\":\"The world divides into facts.\",\"ogd\":\"\",\"str\":\"What is the case—a fact—is the obtaining of elementary facts.\",\"tlp\":[1.2]},{\"label\":\"1.21\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":5,\"x_axis\":3,\"page\":78,\"ger\":\"Eines kann der Fall sein oder nicht der Fall sein und alles übrige gleichbleiben. \",\"pmc\":\"Each item can be the case or not the case while everything else remains the same.\",\"ogd\":\"\",\"str\":\"Each one can either be the case or not be the case and all else remains the same.\",\"tlp\":[1.21]},{\"label\":\"2.011\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":5,\"x_axis\":11,\"page\":49,\"ger\":\"Es ist dem Ding wesentlich der Bestandteil eines Sachverhalts sein zu können. \",\"pmc\":\"It is essential to things that they should be possible constituents of states of affairs.\",\"ogd\":\"\",\"str\":\"It is essential to a thing that it can be a constituent of an elementary fact.\",\"tlp\":[2.011]},{\"label\":\"2.0201\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":5,\"x_axis\":23,\"page\":30,\"ger\":\"Jede Aussage über Komplexe läßt sich in eine Aussage über deren Bestandteile und die Sätze zerlegen welche die Komplexe vollständig beschreiben. \",\"pmc\":\"Every statement about complexes can be resolved into a statement about their constituents and into the propositions that describe the complexes completely.\",\"ogd\":\"\",\"str\":\"Every statement about complexes can be broken down into a statement about their constituents and into the propositions that completely describe the complexes.\",\"tlp\":[2.0201]},{\"label\":\"2.021\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":5,\"x_axis\":25,\"page\":26,\"ger\":\"Die Gegenstände bilden die Substanz der Welt. <br />Darum können sie nicht zusammengesetzt sein.\",\"pmc\":\"Objects make up the substance of the world.<br />That is why they cannot be composite.\",\"ogd\":\"\",\"str\":\"Objects make up the substance of the world. That is why they cannot be composite.pt\",\"tlp\":[2.021]},{\"label\":\"2.0211\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":5,\"x_axis\":27,\"page\":27,\"ger\":\"Hätte die Welt keine Substanz so würde, ob ein Satz Sinn hat, davon abhängen, ob ein anderer Satz wahr ist.\",\"pmc\":\"If the world had no substance, then whether a proposition had sense would depend on whether another proposition was true.\",\"ogd\":\"\",\"str\":\"If the world had no substance, then whether a proposition made sense would depend on whether another proposition was true.\",\"tlp\":[2.0211]},{\"label\":\"2.0212\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":5,\"x_axis\":29,\"page\":27,\"ger\":\"Es wäre dann unmöglich ein Bild der Welt (wahr oder falsch) zu entwerfen.\",\"pmc\":\"In that case we could not sketch out any picture of the world (true or false).\",\"ogd\":\"\",\"str\":\"In that case we could not form a picture of the world (true or false).\",\"tlp\":[2.0212]},{\"label\":\"2.031\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":5,\"x_axis\":33,\"page\":5,\"ger\":\"Im Sachverhalt verhalten sich die Gegenstände in bestimmter Art und Weise zu einander. \",\"pmc\":\"In a state of affairs objects stand in a determinate relation to one another.\",\"ogd\":\"\",\"str\":\"In an elementary fact objects are combined in a definite way.\",\"tlp\":[2.031]},{\"label\":\"2.0601\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":5,\"x_axis\":39,\"page\":28,\"ger\":\"Das Bestehen von Sachverhalten nennen wir auch eine positive — , das Nichtbestehen eine negative Tatsache.\",\"pmc\":\"We also call the existence of states of affairs a positive fact, and their non-existence a negative fact.\",\"ogd\":\"\",\"str\":\"We also call the obtaining of elementary facts a positive fact, and their non-obtaining a negative fact.pt\\r?\\t29[1]\\t—\\t\\tAüL 193 (7)**  MN 219 (4)+ \\rWe can say that “~Socrates” means nothing because there is no property called ~(x).\",\"tlp\":[2.06]},{\"label\":\"2.061\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":5,\"x_axis\":41,\"page\":15,\"ger\":\"Die Sachverhalte sind von einander unabhängig. \",\"pmc\":\"States of affairs are independent of one another.\",\"ogd\":\"\",\"str\":\"Elementary facts are independent of one another.pt\",\"tlp\":[2.061]},{\"label\":\"3.01\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":5,\"x_axis\":47,\"page\":5,\"ger\":\"Die Gesamtheit der wahren Gedanken sind ein Bild der Welt.\",\"pmc\":\"The totality of true thoughts is a picture of the world.\",\"ogd\":\"\",\"str\":\"The totality of true thoughts is a picture of the world.\",\"tlp\":[3.01]},{\"label\":\"3.02\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":5,\"x_axis\":49,\"page\":7,\"ger\":\"Der Gedanke enthält die Möglichkeit der Sachlage, die er denkt.<br />Was denkbar ist, ist auch möglich.\",\"pmc\":\"A thought contains the possibility of the situation of which it is the thought.<br />What is thinkable is possible too.\",\"ogd\":\"\",\"str\":\"A thought contains the possibility of the situation of which it is the thought. What is thinkable is possible too.\",\"tlp\":[3.02]},{\"label\":\"3.03\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":5,\"x_axis\":51,\"page\":17,\"ger\":\"Wir können nichts Unlogisches denken, weil wir sonst unlogisch denken müßten.\",\"pmc\":\"Thought can never be of anything illogical, since, if it were, we should have to think illogically.\",\"ogd\":\"\",\"str\":\"We cannot think anything illogical, for otherwise we would have to think illogically.\",\"tlp\":[3.03]},{\"label\":\"3.04\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":5,\"x_axis\":53,\"page\":16,\"ger\":\"Ein a priori richtiger Gedanke wäre ein solcher, dessen Möglichkeit seine Wahrheit bedingte.\",\"pmc\":\"If a thought were correct a priori, it would be a thought whose possibility ensured its truth.\",\"ogd\":\"\",\"str\":\"An a priori correct thought would be one whose possibility ensured its truth.\",\"tlp\":[3.04]},{\"label\":\"3.05\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":5,\"x_axis\":55,\"page\":16,\"ger\":\"Nur so könnten wir a priori wissen, daß ein Gedanke wahr ist, wenn aus dem Gedanken selbst (ohne Vergleichsobjekt) seine Wahrheit zu erkennen wäre. \",\"pmc\":\"A priori knowledge that a thought was true would only be possible if its truth were recognizable from the thought itself (without anything to compare it with).\",\"ogd\":\"\",\"str\":\"One could know a priori that a thought is true only if its truth were recognizable from the thought itself (without any object of comparison).\",\"tlp\":[3.05]},{\"label\":\"4.0011\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":5,\"x_axis\":70,\"page\":30,\"ger\":\"Der Mensch besitzt die Fähigkeit Sprachen zu bauen womit sich jeder Sinn ausdrücken läßt, ohne eine Ahnung davon zu haben wie, und was jedes Wort bedeutet. Wie man auch spricht ohne zu wissen wie die einzelnen Laute hervorgebracht werden.\",\"pmc\":\"Man possesses the ability to construct languages capable of expressing every sense, without having any idea how each word has meaning or what its meaning is - just as people speak without knowing how the individual sounds are produced.\",\"ogd\":\"\",\"str\":\"Human beings have the capacity to construct languages in which every sense can be expressed, without having any idea how and what each word means,  just as we speak without knowing how the individual sounds are produced.\",\"tlp\":[4.002]},{\"label\":\"5.0011\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":5,\"x_axis\":115,\"page\":10,\"ger\":\"Analog kann man von Operationen mit mehreren Basen sprechen. 〟(F)(p)\\\" ist das Resultat der Operation 〟F( )\\\" auf die Basis p, (FWWF)(p,q) das Resultat einer Operation auf zwei Basen.\",\"pmc\":\"Similarly we can speak of an operation with several bases. '(F)(p)' is the result of the operation 'F( )' on the base p; (FTTF)(p, q) is the result of an operation on two bases.\",\"ogd\":\"\",\"str\":\"Similarly we can speak of an operation with several bases. “(F)(p)” is the result of the operation “F( )” on the base p; (FTTF )(p, q) is the result of an operation on two bases.\",\"tlp\":[\"None\"]},{\"label\":\"5.0021\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":5,\"x_axis\":117,\"page\":64,\"ger\":\"Eine Operation sagt ja nicht aus, nur ihr Resultat und dies hängt von ihrer Basis ab. \",\"pmc\":\"Indeed, no statement is made by an operation, but only by its result, and this depends on its base.\",\"ogd\":\"\",\"str\":\"Indeed, no statement is made by an operation, but only by its result, and this depends on its base.\",\"tlp\":[5.25]},{\"label\":\"5.0041\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":5,\"x_axis\":121,\"page\":20,\"ger\":\"Die Festsetzung der Werte ist die Variable. \",\"pmc\":\"The stipulation of values is the variable.\",\"ogd\":\"\",\"str\":\"The stipulation of values is the variable.pt\",\"tlp\":[3.316]},{\"label\":\"5.00501\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":5,\"x_axis\":123,\"page\":20,\"ger\":\"Die Festsetzung ist eine Beschreibung dieser Sätze.\",\"pmc\":\"The stipulation is a description of those propositions.\",\"ogd\":\"\",\"str\":\"The description of those sentences is the stipulation.\",\"tlp\":[3.317]},{\"label\":\"5.0051\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":5,\"x_axis\":125,\"page\":20,\"ger\":\"Die Festsetzung wird also nur von Zeichen nicht von deren Bedeutung handeln.\",\"pmc\":\"The stipulation will therefore be concerned only with signs, not with their meaning.\",\"ogd\":\"\",\"str\":\"The stipulation will therefore be concerned only with signs, not with their meaning.\",\"tlp\":[3.317]},{\"label\":\"6.01\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":5,\"x_axis\":149,\"page\":70,\"ger\":\"Die allgemeine Form der Operation ist:<br />|σ̅, α̅, N(α̅)|'(σ̅).\",\"pmc\":\"The general form of an operation is<br />|σ̅, α̅, N(α̅)|'(σ̅)\",\"ogd\":\"\",\"str\":\"The general form of an operation is |σ̅ , α̅, N(α̅ )|'(σ)\",\"tlp\":[6.01]},{\"label\":\"6.02\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":5,\"x_axis\":152,\"page\":70,\"ger\":\"Die allgemeine Form der ganzen Zahl ist: |O, α, α + 1|. \",\"pmc\":\"The general form of an integer is |0, α, α+1|.\",\"ogd\":\"\",\"str\":\"The general form of an integer is |0, α, α +1|.\",\"tlp\":[6.03]},{\"label\":\"6.0041\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":5,\"x_axis\":158,\"page\":75,\"ger\":\"Dies zeigt auch daß die Seele — das Subjekt etc. — wie sie in der heutigen oberflächlichen Psychologie aufgefaßt wird ein Unding ist. \",\"pmc\":\"This shows too that there is no such thing as the soul - the subject, etc. - as it is conceived in the superficial psychology of the present day.\",\"ogd\":\"\",\"str\":\"This also shows too that there is no such thing as the soul - the subject, etc. - as it is conceived in contemporary superficial psychology.\",\"tlp\":[5.5421]},{\"label\":\"6.0051\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":5,\"x_axis\":160,\"page\":93,\"ger\":\"Dies erklärt wohl auch daß man die Figur <br /><br />auf zweierlei Art als Würfel sehen kann; und alle ähnlichen Erscheinungen. Denn wir sehen eben wirklich zwei verschiedene Tatsachen. (Sehe ich erst auf die Ecke a und nur flüchtig auf b so erscheint a vorn und umgekehrt.)\",\"pmc\":\"This no doubt explains why there are two possible ways of seeing the figure<br /><br />as a cube; and all similar phenomena. For we really see two different facts.<br />(If I look in the first place at the corner marked a and only glance at b, then a appears to be in front, and vice versa.)\",\"ogd\":\"\",\"str\":\"This also explains the sort of phenomena illustrated by this figure, which can be seen as a cube in two different ways. For we really see two different facts.\\r(If I look in the first place at the corner marked a and only glance at b, then a\\rappears to be in front, and vice versa.)\",\"tlp\":[5.5423]},{\"label\":\"2.012\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":7,\"x_axis\":11,\"page\":48,\"ger\":\"In der Logik ist nichts zufällig: Wenn das Ding im Sachverhalt vorkommen kann, so muß die Möglichkeit des Sachverhalts im Ding bereits präjudiziert sein. \",\"pmc\":\"In logic nothing is accidental: if a thing can occur in a state of affairs, the possibility of the state of affairs must be written into the thing itself.\",\"ogd\":\"\",\"str\":\"In logic nothing is accidental: if a thing can occur in an elementary fact, it must already contain the possibility of that elementary fact.\",\"tlp\":[2.012]},{\"label\":\"2.01201\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":7,\"x_axis\":13,\"page\":90,\"ger\":\"Wenn die Dinge in Tatsachen vorkommen können, so muß dies schon in ihnen liegen. \",\"pmc\":\"If things can occur in facts, this possibility must be in them from the beginning.\",\"ogd\":\"\",\"str\":\"If things can occur in facts, this possibility must already be within them.\",\"tlp\":[2.0121]},{\"label\":\"2.01202\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":7,\"x_axis\":15,\"page\":91,\"ger\":\"Etwas Logisches kann nicht nur-möglich sein. Die Logik handelt von jeder Möglichkeit und alle Möglichkeiten sind ihre Tatsachen. \",\"pmc\":\"Nothing in the province of logic can be merely possible. Logic deals with every possibility and all possibilities are its facts.\",\"ogd\":\"\",\"str\":\"Something logical cannot be merely possible. Logic deals with every possibility, and all possibilities are its facts.\",\"tlp\":[2.0121]},{\"label\":\"2.01203\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":7,\"x_axis\":17,\"page\":91,\"ger\":\"Wie wir uns räumliche Gegenstände überhaupt nicht außerhalb des Raumes, zeitliche nicht außerhalb der Zeit denken können, so können wir uns keinen Gegenstand außerhalb der Möglichkeit seiner Verbindung mit anderen denken. \",\"pmc\":\"Just as we are quite unable to imagine spatial objects outside space or temporal objects outside time, so too there is no object that we can imagine excluded from the possibility of combining with others.\",\"ogd\":\"\",\"str\":\"Just as we cannot think of spatial objects outside space nor temporal objects outside time, so we cannot think of any object outside the possibility of combining with others.\",\"tlp\":[2.0121]},{\"label\":\"2.01204\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":7,\"x_axis\":19,\"page\":91,\"ger\":\"Wenn ich mir den Gegenstand im Verbande des Sachverhalts denken kann, so kann ich ihn nicht außerhalb der Möglichkeit dieses Verbandes denken. \",\"pmc\":\"If I can imagine objects combined in states of affairs, I cannot imagine them excluded from the possibility of such combinations.\",\"ogd\":\"\",\"str\":\"If I can think of an object as part of an elementary fact, I cannot think of it without the possibility of such connections.\",\"tlp\":[2.0121]},{\"label\":\"2.022\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":7,\"x_axis\":25,\"page\":27,\"ger\":\"Es ist offenbar, daß auch eine von der wirklichen noch so verschieden gedachte Welt, etwas — eine Form — mit der wirklichen gemein haben muß.\",\"pmc\":\"It is obvious that an imagined world, however different it may be from the real one, must have something - a form - in common with it.\",\"ogd\":\"\",\"str\":\"Obviously an imagined world, however different from the real world, must have something - a form - in common with it.\",\"tlp\":[2.022]},{\"label\":\"2.032\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":7,\"x_axis\":33,\"page\":13,\"ger\":\"Die Art und Weise, wie die Gegenstände im Sachverhalt zusammenhängen ist die Struktur des Sachverhaltes.\",\"pmc\":\"The determinate way in which objects are connected in a state of affairs is the structure of the state of affairs.\",\"ogd\":\"\",\"str\":\"The way in which objects are connected in an elementary fact is the structure of the elementary fact.\",\"tlp\":[2.032]},{\"label\":\"2.062\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":7,\"x_axis\":41,\"page\":16,\"ger\":\"Die Sachverhalte sind von einander unabhängig. Aus dem Bestehen oder nicht Bestehen des Einen kann nicht auf das Bestehen oder nicht Bestehen des anderen geschlossen werden.\",\"pmc\":\"From the existence or non-existence of the one it is impossible to infer the existence or non-existence of the other.\",\"ogd\":\"\",\"str\":\"From the obtaining or non-obtaining of the one it is impossible to infer the obtaining or non-obtaining of the other.\",\"tlp\":[2.062]},{\"label\":\"3.031\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":7,\"x_axis\":51,\"page\":42,\"ger\":\"Man sagte einst daß Gott alles schaffen könne, nur nichts, was den logischen Gesetzten zuwider wäre. Wir könnten nämlich von einer 〟unlogischen\\\" Welt nicht sagen wie sie aussähe. \",\"pmc\":\"It used to be said that God could create anything except what would be contrary to the laws of logic. The reason being that we could not say what an 'illogical' world would look like.\",\"ogd\":\"\",\"str\":\"As the old saying goes: God can create anything so long as it does not contradict the laws of logic. The reason being that we could not say what an “illogical” world would look like.\",\"tlp\":[3.031]},{\"label\":\"4.0012\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":7,\"x_axis\":70,\"page\":36,\"ger\":\"Die Umgangssprache ist ein Teil des menschlichen Organismus und nicht weniger kompliziert als dieser. \",\"pmc\":\"Everyday language is a part of the human organism and is no less complicated than it.\",\"ogd\":\"\",\"str\":\"Ordinary language is a part of the human organism and no less complicated than it.\",\"tlp\":[4.002]},{\"label\":\"5.0012\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":7,\"x_axis\":115,\"page\":63,\"ger\":\"Verneinung, Disjunktion, logische Multiplikation etc. sind Operationen. \",\"pmc\":\"Negation, disjunction, logical multiplication, etc., are operations.\",\"ogd\":\"\",\"str\":\"Negation, disjunction, logical multiplication, etc., are operations.\",\"tlp\":[5.2341]},{\"label\":\"5.0022\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":7,\"x_axis\":117,\"page\":64,\"ger\":\"Nur Operationen können verschwinden. (Wie z.B. die Verneinung in ~~p) \",\"pmc\":\"Only operations can vanish (e.g. negation in ~~p).\",\"ogd\":\"\",\"str\":\"Only operations can vanish (e.g. negation in ~~p).\",\"tlp\":[5.254]},{\"label\":\"5.0052\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":7,\"x_axis\":125,\"page\":20,\"ger\":\"Und nur dies ist der Festsetzung wesentlich, daß sie nur eine Beschreibung von Zeichen ist und nichts über das Bezeichnete aussagt. \",\"pmc\":\"And the only thing essential to the stipulation is that it is merely a description of signs and states nothing about what is signified.\",\"ogd\":\"\",\"str\":\"And all that is essential to the stipulation is that it merely describes the signs and states nothing about the signified.\",\"tlp\":[3.317]},{\"label\":\"6.011\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":7,\"x_axis\":149,\"page\":102,\"ger\":\"Ich definiere nun:<br />x = O0'x Def.<br />und |x, ξ, O'ξ| = |O0'x, Oν'ξ, Oν+1'ξ|<br />und O+1 = 1 Def.<br />also schreibe ich statt 〟x, O'x, O'O'x, O'O'O'x etc.\\\" 〟O0'x, O1'x, O1+1'x, O1+1+1'x, etc\\\"<br />1+1  =  2  Def.<br />1+1+1  =  3  Def. u.s.w.\",\"pmc\":\"I give the following definitions:<br />x = O0'x Def.<br />and |x, ξ, O'ξ| = |O0'x, Oν'ξ, Oν+1'ξ|<br />and O+1 = 1 Def.<br />Therefore instead of 'x, O'x, O'O'x, O'O'O'x etc.', I write: 'O0'x, O1'x, O1+1'x, O1+1+1'x, etc.'<br />1+1  =  2 Def.;<br />1+1+1  =  3 Def.; etc.\",\"ogd\":\"\",\"str\":\"I give the following definitions:\\r    x = O0'x Def. \\rand \\t|x, ξ, O'ξ | = |O 0'x , Oν'ξ , Oν+1'ξ| \\rand \\t           0+1 = 1 Def.\\rTherefore in place of “x, O'x, O'O'x, O'O'O'x etc.”, I write: “O0'x, O1'x, O1+1'x, O1+1+1'x, etc.” \\r    1+1 = 2 Def.; \",\"tlp\":[6.02]},{\"label\":\"6.0201\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":7,\"x_axis\":152,\"page\":79,\"ger\":\"Die Theorie der Klassen ist in der Mathematik ganz überflüssig. Dies hängt damit zusammen daß die Allgemeinheit die wir in der Mathematik brauchen nicht die 〟zufällige\\\" ist. \",\"pmc\":\"The theory of classes is completely superfluous in mathematics.<br />This is connected with the fact that the generality required in mathematics is not 'accidental' generality.\",\"ogd\":\"\",\"str\":\"The theory of classes is entirely superfluous in mathematics. This is connected with the fact that the generality we need in mathematics is not an “accidental” one.\",\"tlp\":[6.031]},{\"label\":\"6.0042\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":7,\"x_axis\":158,\"page\":75,\"ger\":\"Eine zusammengesetzte Seele wäre nämlich keine Seele mehr. \",\"pmc\":\"Indeed a composite soul would no longer be a soul.\",\"ogd\":\"\",\"str\":\"For a composite soul would no longer be a soul.\",\"tlp\":[5.5421]},{\"label\":\"2.0121\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":9,\"x_axis\":13,\"page\":48,\"ger\":\"Mag das Ding noch so selbständig sein, was ja nichts heißt als daß es in allen möglichen Sachlagen vorkommen kann, so ist eben diese Form der Selbständigkeit eine Form des Zusammenhangs mit dem Sachverhalt, eine Form der Unselbständigkeit. \",\"pmc\":\"However independent things may be - and this means no more than that they can occur in all possible situations - still this form of independence is a form of connection with states of affairs, a form of dependence.\",\"ogd\":\"\",\"str\":\"However independent things may be - and this means no more than that they can occur in all possible situations - still this form of independence is a form of connection with elementary facts, a form of dependence.\",\"tlp\":[2.0122]},{\"label\":\"2.0122\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":9,\"x_axis\":15,\"page\":48,\"ger\":\"Das kommt darauf hinaus, daß, im Falle Namen in — und außerhalb des Satzverbandes Bedeutung hätten, es sozusagen, nicht zu verbürgen wäre, daß sie in beiden Fällen wirklich dasselbe, im selben Sinne des Wortes, bedeuten.<br />Es scheint unmöglich zu sein, daß Worte in zwei verschiedenen Weisen auftreten, allein und im Satz.\",\"pmc\":\"What this comes to is that if it were the case that names had meaning both when combined in propositions and outside them, it would, so to speak, be impossible to guarantee that in both cases they really had the same meaning, in the same sense of the word.<br />It seems to be impossible for words to appear in two different roles: by themselves, and in propositions.\",\"ogd\":\"\",\"str\":\"What this comes to is that if it were the case that names had meaning both when combined in propositions and outside them, it would, so to speak, be impossible to guarantee that in both cases they really had the same meaning, in the same sense of the word. It seems to be impossible for words to appear in two different roles: alone, and in propositions.\",\"tlp\":[2.0122]},{\"label\":\"2.0123\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":9,\"x_axis\":17,\"page\":49,\"ger\":\"Es erschiene gleichsam als Zufall wenn dem Ding, das allein für sich besteht, nachträglich eine Sachlage passen würde. \",\"pmc\":\"It would seem to be a sort of accident, if it turned out that a situation would fit a thing that already existed entirely on its own.\",\"ogd\":\"\",\"str\":\"It would, so to speak, seem like an accident, if it turned out that a thing that could exist alone could be part of a situation.\",\"tlp\":[2.0121]},{\"label\":\"2.0124\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":9,\"x_axis\":19,\"page\":95,\"ger\":\"Wenn ich den Gegenstand kenne so kenne ich auch sämtliche Möglichkeiten seines Vorkommens in Sachverhalten.<br />Jede solche Möglichkeit muß in der Natur des Gegenstandes liegen.\",\"pmc\":\"If I know an object I also know all its possible occurrences in states of affairs.<br />Every one of these possibilities must be part of the nature of the object.\",\"ogd\":\"\",\"str\":\"If I know an object I also know all the possibilities of its occurrence in elementary facts. Every such possibility must lie in the nature of the object.\",\"tlp\":[2.0123]},{\"label\":\"2.0125\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":9,\"x_axis\":21,\"page\":95,\"ger\":\"Es kann nicht nachträglich eine neue Möglichkeit gefunden werden. \",\"pmc\":\"A new possibility cannot be discovered later.\",\"ogd\":\"\",\"str\":\"A new possibility cannot be found later on.\",\"tlp\":[2.0123]},{\"label\":\"2.0126\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":9,\"x_axis\":23,\"page\":87,\"ger\":\"Sind alle Gegenstände gegeben so sind damit auch alle möglichen Sachverhalte gegeben. \",\"pmc\":\"If all objects are given, then at the same time all possible states of affairs are also given.\",\"ogd\":\"\",\"str\":\"If all objects are given, then thereby all possible elementary facts are also given.\",\"tlp\":[2.0124]},{\"label\":\"2.023\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":9,\"x_axis\":25,\"page\":27,\"ger\":\"Diese feste Form besteht eben aus den Gegenständen.\",\"pmc\":\"Objects are just what constitute this unalterable form.\",\"ogd\":\"\",\"str\":\"This fixed form consists of objects.\",\"tlp\":[2.023]},{\"label\":\"2.0231\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":9,\"x_axis\":27,\"page\":27,\"ger\":\"Die Substanz der Welt kann nur eine Form und keine materiellen Eigenschaften bestimmen. Denn diese werden erst durch die Sätze dargestellt — erst durch die Konfiguration der Gegenstände gebildet. \",\"pmc\":\"The substance of the world can only determine a form, and not any material properties. For it is only by means of propositions that material properties are represented - only by the configuration of objects that are produced.\",\"ogd\":\"\",\"str\":\"The substance of the world can only determine a form, and not any material properties. Material properties can only be represented by means of propositions – they can only be produced by the configuration of objects.\",\"tlp\":[2.0231]},{\"label\":\"2.0232\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":9,\"x_axis\":29,\"page\":27,\"ger\":\"Beiläufig gesprochen: Die Gegenstände sind farblos. \",\"pmc\":\"In a manner of speaking, objects are colorless.\",\"ogd\":\"\",\"str\":\"Roughly speaking, objects are colourless.\",\"tlp\":[2.0232]},{\"label\":\"2.0233\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":9,\"x_axis\":31,\"page\":94,\"ger\":\"Zwei Gegenstände von der gleichen logischen Form sind — abgesehen von ihren externen Eigenschaften — von einander nur dadurch unterschieden daß sie verschieden sind.\",\"pmc\":\"If two objects have the same logical form, the only distinction between them, apart from their external properties, is that they are different.\",\"ogd\":\"\",\"str\":\"Two objects with the same logical form - apart from their external properties -  are only distinct from one another in that they are different.\",\"tlp\":[2.0233]},{\"label\":\"2.033\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":9,\"x_axis\":33,\"page\":13,\"ger\":\"Die Struktur der Tatsache besteht aus den Strukturen der Sachverhalte. \",\"pmc\":\"The structure of a fact consists of the structures of states of affairs.\",\"ogd\":\"\",\"str\":\"The structure of a fact consists of the structures of its elementary facts.pt\",\"tlp\":[2.034]},{\"label\":\"3.032\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":9,\"x_axis\":51,\"page\":42,\"ger\":\"Etwas 〟der Logik Widersprechendes\\\" in der Sprache darstellen, kann man ebensowenig, wie in der Geometrie 〟eine den Gesetzen des Raumes widersprechende Figur\\\" durch ihre Koordinaten darstellen, oder die Koordinaten eines 〟Punktes angeben welcher nicht existiert\\\".\",\"pmc\":\"It is as impossible to represent in language anything that 'contradicts logic' as it is in geometry to represent by its co-ordinates 'a figure that contradicts the laws of space', or to give the co-ordinates of 'a point that does not exist'.\",\"ogd\":\"\",\"str\":\"It is as impossible to say something that “contradicts logic” as it is to draw “a figure that contradicts the laws of space”, or to give the co-ordinates of “a point that does not exist”.\",\"tlp\":[3.032]},{\"label\":\"3.0321\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":9,\"x_axis\":53,\"page\":43,\"ger\":\"Wohl können wir einen Sachverhalt räumlich darstellen welcher den Gesetzen der Physik, aber keinen, der den Gesetzen der Geometrie zuwiderliefe.\",\"pmc\":\"Though a state of affairs that would contravene the laws of physics can be represented to us spatially, one that would contravene the laws of geometry cannot.\",\"ogd\":\"\",\"str\":\"An elementary fact contradicting the laws of physics can be presented spatially, but not one that contradicts the laws of geometry.\\r+ 43[2]\\t—\\t\\t20.11.14 (1)\\rThe reality that corresponds to the sense of a proposition cannot be anything other than its constituent parts; since we are, surely, ignorant of everything else.\",\"tlp\":[3.0321]},{\"label\":\"4.0013\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":9,\"x_axis\":70,\"page\":36,\"ger\":\"Es ist menschenunmöglich die Sprachlogik aus ihr unmittelbar zu entnehmen. \",\"pmc\":\"It is not humanly possible to gather immediately from it what the logic of language is.\",\"ogd\":\"\",\"str\":\"It is not humanly possible to immediately extract the logic of language from it.\",\"tlp\":[4.002]},{\"label\":\"5.0013\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":9,\"x_axis\":115,\"page\":11,\"ger\":\"Eine Operation die aus einer Anzahl von Sätzen eine Wahrheitsfunktion dieser Sätze macht, nennen wir 〟Wahrheitsoperation\\\" (W-Operation).\",\"pmc\":\"An operation which, from a number of propositions, produces a truth-function of those propositions we call a truth-operation (T-Operation).\",\"ogd\":\"\",\"str\":\"An operation which, from a number of propositions, produces a truth-function of those propositions we call a truth-operation (T-operation).\",\"tlp\":[5.234]},{\"label\":\"5.0053\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":9,\"x_axis\":125,\"page\":20,\"ger\":\"Wie die Beschreibung der Sätze geschieht ist unwesentlich.\",\"pmc\":\"How the description of the propositions is produced is not essential.\",\"ogd\":\"\",\"str\":\"The way in which the sentences are described is inessential.\",\"tlp\":[\"3.317, 5.501\"]},{\"label\":\"5.00531\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":9,\"x_axis\":127,\"page\":21,\"ger\":\"Wir können drei Arten der Beschreibung unterscheiden: 1) Die direkte Aufzählung 2) Die Angabe einer Funktion F(x,y…) deren sämtliche Werte die zu beschreibenden Sätze sind 3) Die Angabe von Zügen welche jene Sätze charakterisieren. \",\"pmc\":\"We can distinguish three kinds of description: 1. direct enumeration; 2. giving a function F(x, y, …) whose various values are the propositions to be described; 3. giving features which characterize those propositions.\",\"ogd\":\"\",\"str\":\"We can distinguish three kinds of description: 1. Direct enumeration. 2. Giving a function F (x , y, … ) whose various values are the propositions to be described. 3. Giving features which characterize those propositions.\",\"tlp\":[5.501]},{\"label\":\"5.00532\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":9,\"x_axis\":129,\"page\":21,\"ger\":\"Im ersten Fall können wir statt der Variablen einfach ihre (konstanten) Werte schreiben.\",\"pmc\":\"In the first case instead of the variable we can simply write its (constant) values.\",\"ogd\":\"\",\"str\":\"In the first case we can simply replace the variable with its (constant) values.\",\"tlp\":[5.501]},{\"label\":\"5.00533\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":9,\"x_axis\":131,\"page\":21,\"ger\":\"Im zweiten Fall ist die Variable ein verallgemeinerter Satz. \",\"pmc\":\"In the second case the variable is a generalized proposition.\",\"ogd\":\"\",\"str\":\"In the second case the variable is a generalized proposition.\",\"tlp\":[5.501]},{\"label\":\"5.00534\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":9,\"x_axis\":137,\"page\":21,\"ger\":\"Im dritten Falle sind die Werte der Variablen alle Sätze welche gewisse formale Eigenschaften besitzen.\",\"pmc\":\"In the third case the values of the variable are all propositions that possess certain formal properties.\",\"ogd\":\"\",\"str\":\"In the third case the values of the variable are all propositions that possess certain formal properties.\",\"tlp\":[5.501]},{\"label\":\"5.00535\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":9,\"x_axis\":139,\"page\":21,\"ger\":\"Die allgemeine Form dieser Sätze kann nur durch die Form einer Variablen dargestellt werden.\",\"pmc\":\"The general form of these propositions can be presented only by means of the form of a variable.\",\"ogd\":\"\",\"str\":\"The general form of these propositions can be presented only by means of the form of a variable.\",\"tlp\":[4.1273]},{\"label\":\"6.0043\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":9,\"x_axis\":158,\"page\":75,\"ger\":\"Die richtige Theorie des Urteiles muß zeigen, daß es unmöglich ist einen Unsinn zu urteilen. (Russells Theorie genügt dieser Bedingung nicht.) \",\"pmc\":\"The correct theory of judgment must show that it is impossible for a judgment to be a piece of nonsense. (Russell's theory does not satisfy this requirement.)\",\"ogd\":\"\",\"str\":\"The correct theory of judgment must show the impossibility of a judgment’s being a piece of nonsense. (Russell's theory does not satisfy this condition.)\",\"tlp\":[5.5422]},{\"label\":\"2.013\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":11,\"x_axis\":11,\"page\":49,\"ger\":\"Wenn ich mir ein Ding in einer Sachlage denken kann, dann kann ich es mir nicht außerhalb der Sachlage denken. \",\"pmc\":\"If I can imagine a thing in a situation, then I cannot imagine it outside the situation.\",\"ogd\":\"\",\"str\":\"If I can imagine a thing in a situation, then I cannot imagine it out of the situation.\",\"tlp\":[\"None\"]},{\"label\":\"2.01241\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":11,\"x_axis\":19,\"page\":96,\"ger\":\"Um einen Gegenstand zu kennen brauche ich zwar nicht seine externen, aber ich muß alle seine internen Eigenschaften kennen. \",\"pmc\":\"If I am to know an object though I need not know its external properties, I must know all its internal properties.\",\"ogd\":\"\",\"str\":\"To know an object, I need not know its external properties, but I must know all its internal properties.\",\"tlp\":[2.01231]},{\"label\":\"2.02331\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":11,\"x_axis\":31,\"page\":96,\"ger\":\"Beiläufig gesprochen: Entweder ein Ding hat Eigenschaften die kein anderes hat, dann kann man es ohne weiteres durch eine Beschreibung aus den anderen herausheben und darauf hinweisen; oder aber es gibt mehrere Dinge, die ihre sämtlichen Eigenschaften gemeinsam haben, dann ist es überhaupt unmöglich auf eines zu zeigen. Denn ist das Ding durch nichts hervorgehoben, so kann ich es nicht hervorheben, denn sonst ist es eben hervorgehoben.\",\"pmc\":\"In a manner of speaking: either a thing has properties that nothing else has, in which case we can immediately use a description to distinguish it from the others and refer to it; or, on the other hand, there are several things that have the whole set of their properties in common, in which case it is quite impossible to indicate one.<br />For if there is nothing to distinguish a thing, I cannot distinguish it, since if I do it will be distinguished after all.\",\"ogd\":\"\",\"str\":\"In a manner of speaking: either a thing has unique properties, and then we can immediately use a description to distinguish it from others and refer to it; or, on the other hand, there are several things that have all their properties in common, in which case it is impossible to pick out one after all.\\rFor if there is nothing to distinguish a thing, I cannot distinguish it, for otherwise it would be distinguished after all.\",\"tlp\":[2.02331]},{\"label\":\"3.1\",\"precision\":1,\"fontSize\":\"40px\",\"y_axis\":11,\"x_axis\":45,\"page\":3,\"ger\":\"Der sinnliche Ausdruck des Gedankens ist das Satzzeichen. \",\"pmc\":\"The perceptible expression of a thought is a propositional sign.\",\"ogd\":\"\",\"str\":\"A sentential sign is a perceptible expression of a thought.\",\"tlp\":[\"3.1, 3.12\"]},{\"label\":\"3.11\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":11,\"x_axis\":47,\"page\":5,\"ger\":\"Das Satzzeichen ist eine Projektion des Gedankens. \",\"pmc\":\"A propositional sign is a projection of a thought.\",\"ogd\":\"\",\"str\":\"A sentential sign is a projection of a thought.\",\"tlp\":[3.12]},{\"label\":\"3.12\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":11,\"x_axis\":49,\"page\":5,\"ger\":\"Die Projektionsmethode ist die Art und Weise der Anwendung des Satzzeichens.\",\"pmc\":\"The method of projection is the manner of applying the propositional sign.\",\"ogd\":\"\",\"str\":\"The way of applying the sentential sign is the method of projection.\",\"tlp\":[3.11]},{\"label\":\"3.13\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":11,\"x_axis\":51,\"page\":5,\"ger\":\"Die Anwendung des Satzzeichens ist das Denken seines Sinns.\",\"pmc\":\"Applying the propositional sign is [the same as] thinking of its sense.\",\"ogd\":\"\",\"str\":\"To apply the sentential sign is to think its sense.\",\"tlp\":[3.11]},{\"label\":\"3.14\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":11,\"x_axis\":53,\"page\":7,\"ger\":\"Im Satzzeichen entsprechen den Gegenständen der Wirklichkeit die einfachen Zeichen.\",\"pmc\":\"In a propositional sign the simple signs correspond to the objects of reality.\",\"ogd\":\"\",\"str\":\"In a sentential sign the simple signs correspond to the objects of reality.\",\"tlp\":[3.2]},{\"label\":\"3.15\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":11,\"x_axis\":55,\"page\":7,\"ger\":\"Das Satzzeichen besteht darin, daß sich die einfachen Zeichen in ihm auf bestimmte Art und Weise zu einander verhalten.\",\"pmc\":\"What constitutes a propositional sign is that in it the simple signs stand in a determinate relation to one another.\",\"ogd\":\"\",\"str\":\"What constitutes a sentential sign is that in it the simple signs stand in a\\rdeterminate relation to one another.pt\",\"tlp\":[3.14]},{\"label\":\"3.16\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":11,\"x_axis\":57,\"page\":8,\"ger\":\"Das Satzzeichen ist eine Tatsache. \",\"pmc\":\"A propositional sign is a fact.\",\"ogd\":\"\",\"str\":\"A sentential sign is a fact.\",\"tlp\":[3.14]},{\"label\":\"4.0014\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":11,\"x_axis\":70,\"page\":36,\"ger\":\"Sie verkleidet den Gedanken. \",\"pmc\":\"It disguises thought.\",\"ogd\":\"\",\"str\":\"It disguises thought.\",\"tlp\":[4.002]},{\"label\":\"4.00141\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":11,\"x_axis\":72,\"page\":36,\"ger\":\"Und zwar so daß man nach der äußeren Form des Kleides nicht auf die Form des bekleideten Gedankens schließen kann; weil die äußere Form des Kleides nach ganz anderen Gesichtspunkten gebaut ist als nach dem, die Form des Körpers erkennen zu lassen. \",\"pmc\":\"So much so, that from the outward form of the clothing it is impossible to infer the form of the thought beneath it, because the outward form of the clothing is not designed to reveal the form of the body, but with quite different things in view.\",\"ogd\":\"\",\"str\":\"So much so, that from the external form of the clothes one cannot infer the form of the thought beneath, because the external form of the clothes is designed not to reveal the form of the body, but from an entirely different perspective.\",\"tlp\":[4.002]},{\"label\":\"5.0014\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":11,\"x_axis\":115,\"page\":10,\"ger\":\"Fassen wir (F)(p) als Operationsresultat auf, so schreiben wir es 〟(F)'(p)\\\"; und allgemein eine Operation auf 〟a\\\" 〟b\\\" 〟c\\\"etc. O'(a,b,c, etc.). \",\"pmc\":\"If we construe (F)(p) as the result of an operation we write it as '(F)'p'; and in general an operation on 'a', 'b', 'c', etc. is written as O'(a, b, c, etc.).\",\"ogd\":\"\",\"str\":\"If we construe (F)(p) as the result of an operation we write it as “(F)'p”; and in general an operation on “a”, “b”, “c”, etc. is written as O'(a, b, c, etc.).\",\"tlp\":[\"None\"]},{\"label\":\"5.0054\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":11,\"x_axis\":125,\"page\":98,\"ger\":\"Man muß es der Variablen selber ansehen wofür sie steht. — Es muß eine ganz bestimmte Ähnlichkeit zwischen ihr und ihrem Wert bestehen. \",\"pmc\":\"It must appear from the variable itself what it stands for. - There must be a quite definite resemblance between it and its values.\",\"ogd\":\"\",\"str\":\"It must appear from the variable itself what it stands for. - There must be a quite definite similarity between it and its values.\",\"tlp\":[\"None\"]},{\"label\":\"5.005341\",\"precision\":6,\"fontSize\":\"18px\",\"y_axis\":11,\"x_axis\":137,\"page\":21,\"ger\":\"Diese zweite Art der Verallgemeinerung die man die formale nennen kann ist von Russell und Frege übersehen worden.\",\"pmc\":\"This second kind of generalization, which can be called the formal kind, was overlooked by Russell and Frege.\",\"ogd\":\"\",\"str\":\"This second kind of generalization, which can be called the formal kind, was\\roverlooked by Russell and Frege.\",\"tlp\":[5.232]},{\"label\":\"5.005351\",\"precision\":6,\"fontSize\":\"18px\",\"y_axis\":11,\"x_axis\":139,\"page\":21,\"ger\":\"Russells Darstellung ist unrichtig, sie enthält einen Circulus vitiosus.\",\"pmc\":\"The way in which Russell presents it is incorrect: it contains a vicious circle.\",\"ogd\":\"\",\"str\":\"Russell’s presentation is incorrect: it contains a vicious circle.\",\"tlp\":[4.1273]},{\"label\":\"6.012\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":11,\"x_axis\":149,\"page\":93,\"ger\":\"Der 〟Zahlbegriff\\\" ist nichts anderes als das Gemeinsame aller Zahlzeichen; er ist die allgemeine Form der Zahl. <br />Und der Begriff der Zahlengleichheit ist die allgemeine Form aller speziellen Zahlengleichheiten.\",\"pmc\":\"The 'concept of number' is simply what is common to all numerals; it is the general form of a number. <br />And the concept of numerical equality is the general form of all particular cases of numerical equality.\",\"ogd\":\"\",\"str\":\"The “concept of number” is simply what is common to all numerals, the general form of a number.\\rAnd the concept of numerical equality is the general form of all particular cases of numerical equality.\",\"tlp\":[6.022]},{\"label\":\"2.014\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":13,\"x_axis\":11,\"page\":49,\"ger\":\"Jedes Ding ist gleichsam in einem Raume möglicher Sachverhalte. Diesen Raum kann ich mir leer denken, nicht aber das Ding ohne den Raum. \",\"pmc\":\"Each thing is, as it were, in a space of possible states of affairs. This space I can imagine empty, but I cannot imagine the thing without the space.\",\"ogd\":\"\",\"str\":\"Each thing is, as it were, in a space of possible elementary facts. I can imagine this space empty, but not the thing without the space.\",\"tlp\":[2.013]},{\"label\":\"2.0141\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":13,\"x_axis\":13,\"page\":80,\"ger\":\"Das Ding sei der materielle Punkt mit dem unendlichen Raum um sich. Es ist klar daß der materielle Punkt ohne den unendlichen Raum nicht denkbar ist. \",\"pmc\":\"Suppose that things are point-masses with infinite space around them. Clearly a point-mass is unthinkable without infinite space.\",\"ogd\":\"\",\"str\":\"Suppose that things are point masses with infinite space around them. Clearly a point mass without infinite space is unthinkable.\",\"tlp\":[2.0141]},{\"label\":\"2.0142\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":13,\"x_axis\":15,\"page\":80,\"ger\":\"Der Fleck im Gesichtsfeld muß zwar nicht rot sein aber eine Farbe muß er haben; er hat sozusagen den Farbenraum um sich. Der Ton muß eine Höhe haben der Gegenstand des Tastsinnes eine Härte etc. \",\"pmc\":\"A speck in the visual field, though it need not be red, must have some color; it is, so to speak surrounded by color-space. Notes must have some pitch, objects of the sense of touch some degree of hardness, and so on.\",\"ogd\":\"\",\"str\":\"A spot in the visual field need not be red but it must have some colour; it is, so to speak, surrounded by colour-space. Notes must have some pitch, tactile objects some degree of hardness, and so on.\",\"tlp\":[2.0131]},{\"label\":\"2.024\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":13,\"x_axis\":25,\"page\":27,\"ger\":\"Die Substanz ist das, was unabhängig von dem, was der Fall ist, besteht.\",\"pmc\":\"Substance is what subsists independently of what is the case.\",\"ogd\":\"\",\"str\":\"Substance is what persists independently of what is the case.\",\"tlp\":[2.024]},{\"label\":\"3.111\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":13,\"x_axis\":47,\"page\":7,\"ger\":\"Es ist eine Projektion der Möglichkeit einer Sachlage.\",\"pmc\":\"It is a projection of the possibility of a situation.\",\"ogd\":\"\",\"str\":\"It is a projection of the possibility of a situation.\",\"tlp\":[3.11]},{\"label\":\"3.141\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":13,\"x_axis\":53,\"page\":8,\"ger\":\"Das einfache Zeichen bedeutet den Gegenstand. Er ist seine Bedeutung. \",\"pmc\":\"A simple sign means an object. The object is its meaning.\",\"ogd\":\"\",\"str\":\"A simple sign means an object. The object is its meaning.\",\"tlp\":[3.203]},{\"label\":\"3.1601\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":13,\"x_axis\":57,\"page\":38,\"ger\":\"Nur Tatsachen können einen Sinn ausdrücken, eine Klasse von Namen kann es nicht. \",\"pmc\":\"Only facts can express of a sense, a set of names cannot.\",\"ogd\":\"\",\"str\":\"Only facts can express a sense, a set of names cannot.\",\"tlp\":[3.142]},{\"label\":\"3.161\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":13,\"x_axis\":61,\"page\":26,\"ger\":\"Daß das Satzzeichen eine Tatsache ist, wird durch die gewöhnliche Ausdrucksform der Schrift oder des Druckes verschleiert. \",\"pmc\":\"Although a propositional sign is a fact, this is obscured by the usual form of expression in writing or print.\",\"ogd\":\"\",\"str\":\"That a sentential sign is a fact is concealed by the ordinary form of expression in writing or print.\",\"tlp\":[3.143]},{\"label\":\"4.0015\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":13,\"x_axis\":70,\"page\":36,\"ger\":\"So ist nach dem äußeren Schein der Umgangssprache jede Täuschung und Verwechselung möglich. \",\"pmc\":\"Thus the outward aspect of ordinary language makes every kind of illusion and confusion possible.\",\"ogd\":\"\",\"str\":\"Thus the external aspect of ordinary language makes every kind of illusion and confusion possible.\",\"tlp\":[\"None\"]},{\"label\":\"4.00151\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":13,\"x_axis\":72,\"page\":36,\"ger\":\"〟Existieren\\\" erscheint als intransitives Verbum wie 〟gehen\\\", 〟er ist\\\" klingt wie 〟er ißt\\\", 〟identisch\\\" ist ein Eigenschaftswort und 〟Weiß\\\" ein Personenname.\",\"pmc\":\" 'Exist' figures as an intransitive verb like 'go'; 'you were' sounds like 'you wear'; 'identical' is an adjective; and 'White' is a proper name.\",\"ogd\":\"\",\"str\":\"“Exist” appears as an intransitive verb like “go”; “you were” sounds like “you wear”; “identical” is an adjective; and “White” is a proper name.\",\"tlp\":[3.323]},{\"label\":\"5.0015\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":13,\"x_axis\":115,\"page\":11,\"ger\":\"〟 O' (a,b,c etc.)\\\" ist das Operationsresultat, die Operation selber bezeichne ich mit 〟O'(ξ,η,ζ etc.)\\\", wo die griechischen Buchstaben die Argumentstellen anzeigen. \",\"pmc\":\"O'(a, b, c, etc.)' is the result of the operation. The operation itself I designate by 'O'(ξ, η, ζ, etc.)', in which the Greek letters indicate the argument-places.\",\"ogd\":\"\",\"str\":\"“O'(a, b, c, etc.)” is the result of the operation. The operation itself I designate by “O'(ξ, η, ζ, etc.)”, in which the Greek letters indicate the argument-places.\",\"tlp\":[\"None\"]},{\"label\":\"5.005341\",\"precision\":6,\"fontSize\":\"18px\",\"y_axis\":13,\"x_axis\":137,\"page\":21,\"ger\":\"Diese zweite Art der Verallgemeinerung die man die formale nennen kann ist von Russell und Frege übersehen worden.\",\"pmc\":\"This second kind of generalization, which can be called the formal kind, was overlooked by Russell and Frege.\",\"ogd\":\"\",\"str\":\"This second kind of generalization, which can be called the formal kind, was\\roverlooked by Russell and Frege.\",\"tlp\":[5.232]},{\"label\":\"6.013\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":13,\"x_axis\":149,\"page\":100,\"ger\":\"Der Zahlbegriff ist die variable Zahl. \",\"pmc\":\"The concept of number is the variable number.\",\"ogd\":\"\",\"str\":\"The concept of number is the variable number.\",\"tlp\":[6.022]},{\"label\":\"2.01411\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":15,\"x_axis\":13,\"page\":80,\"ger\":\"Der Raumpunkt ist nach dieser Auffassung eine Argumentstelle. \",\"pmc\":\"On this interpretation, a spatial point is an argument-place.\",\"ogd\":\"\",\"str\":\"On this conception, a point in space is an argument place.\",\"tlp\":[2.0131]},{\"label\":\"2.025\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":15,\"x_axis\":25,\"page\":27,\"ger\":\"Sie ist Form und Inhalt.\",\"pmc\":\"It is form and content.\",\"ogd\":\"\",\"str\":\"It is form and content.\",\"tlp\":[2.025]},{\"label\":\"2.0251\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":15,\"x_axis\":27,\"page\":27,\"ger\":\"Raum und Zeit sind Formen der Gegenstände. \",\"pmc\":\"Space and time are forms of objects.\",\"ogd\":\"\",\"str\":\"Space and time are forms of objects.\",\"tlp\":[2.0251]},{\"label\":\"2.0252\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":15,\"x_axis\":29,\"page\":27,\"ger\":\"Ebenso ist die Farbe (oder Färbigkeit) eine Form der visuellen Gegenstände.\",\"pmc\":\"In the same way color (being colored) is a form of visual objects.\",\"ogd\":\"\",\"str\":\"In the same way colour (being coloured) is a form of visual objects.\",\"tlp\":[2.0251]},{\"label\":\"3.1602\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":15,\"x_axis\":57,\"page\":38,\"ger\":\"Der Satz ist kein Wörtergemisch. (Wie die Melodie kein Gemisch von Tönen) \",\"pmc\":\"A proposition is not a medley of words. (Just as a tune is not a medley of notes.)\",\"ogd\":\"\",\"str\":\"A proposition is not a jumble of words. (Just as a tune is not a jumble of notes.)\",\"tlp\":[3.141]},{\"label\":\"3.16021\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":15,\"x_axis\":59,\"page\":64,\"ger\":\"Das musikalische Thema ist ein Satz. \",\"pmc\":\"A theme in music is a proposition.\",\"ogd\":\"\",\"str\":\"A theme in music is a proposition.\",\"tlp\":[\"None\"]},{\"label\":\"3.162\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":15,\"x_axis\":61,\"page\":26,\"ger\":\"Denn im gedruckten Satz z.B. sieht das Satzzeichen nicht wesentlich verschieden aus vom Wort. \",\"pmc\":\"For in a printed proposition, for example, no essential difference is apparent between a propositional sign and a word.\",\"ogd\":\"\",\"str\":\"For in a printed sentence, for example, the sentential sign does not appear  essentially different from a word.\",\"tlp\":[3.143]},{\"label\":\"3.1621\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":15,\"x_axis\":63,\"page\":26,\"ger\":\"So war es möglich, daß Frege den Satz einen zusammengesetzten Namen nannte. \",\"pmc\":\"That is what made it possible for Frege to call a proposition a composite name.\",\"ogd\":\"\",\"str\":\"That is what made it possible for Frege to call a proposition a compound name.\",\"tlp\":[3.143]},{\"label\":\"3.1622\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":15,\"x_axis\":65,\"page\":33,\"ger\":\"Nicht: 〟das komplexe Zeichen 〟aRb\\\" sagt, daß a in der Beziehung R zu b steht\\\", sondern: daß 〟a\\\" in einer gewissen Beziehung zu 〟b\\\" steht sagt, daß aRb. \",\"pmc\":\"Instead of 'The complex sign \\\"aRb\\\" says that a stands to b in the relation R', we ought to put: That 'a' stands to 'b' in a certain relation says that aRb.\",\"ogd\":\"\",\"str\":\"Don’t say “The complex sign \\\"aRb\\\" says that a stands to b in the relation R”, but instead: That “a” stands to “b” in a certain relation says that aRb.\",\"tlp\":[3.1432]},{\"label\":\"4.0016\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":15,\"x_axis\":70,\"page\":37,\"ger\":\"Die meisten Sätze und Fragen welche über philosophische Dinge geschrieben worden sind, sind nicht falsch, sondern unsinnig. Wir können daher Fragen dieser Art überhaupt nicht beantworten, sondern nur ihre Unsinnigkeit feststellen. Die meisten Fragen und Sätze der Philosophen beruhen darauf daß wir unsere Sprachlogik nicht verstehen. \",\"pmc\":\"Most of the propositions and questions to be found in philosophical works are not false but nonsensical. Consequently we cannot give any answer to questions of this kind, but can only establish that they are nonsensical. Most of the propositions and questions of philosophers arise from our failure to understand the logic of our language.\",\"ogd\":\"\",\"str\":\"Most of the statements and questions philosophers have written are not false but nonsensical. So we cannot answer such questions at all, but can only point out their nonsensicality. Most of the questions and statements of philosophers result from not understanding the logic of our language.\",\"tlp\":[4.003]},{\"label\":\"4.00161\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":15,\"x_axis\":72,\"page\":37,\"ger\":\"Sie sind von der Art der Frage ob das Gute mehr oder weniger identisch ist als das Schöne. \",\"pmc\":\"They belong to the same class as the question whether the good is more or less identical to the beautiful.\",\"ogd\":\"\",\"str\":\"They are of the same kind as the question whether the Good is more or less identical than the Beautiful.\",\"tlp\":[4.003]},{\"label\":\"4.00162\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":15,\"x_axis\":74,\"page\":37,\"ger\":\"Alle Philosophie ist 〟Sprachkritik\\\". (allerdings nicht im Sinne Mauthners) \",\"pmc\":\"All philosophy is a 'critique of language' (though not in Mauthner's sense).\",\"ogd\":\"\",\"str\":\"All philosophy is “critique of language” (though not at all in Mauthner's sense).\",\"tlp\":[4.0031]},{\"label\":\"4.00163\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":15,\"x_axis\":76,\"page\":33,\"ger\":\"Russells Verdienst ist es gezeigt zu haben daß die scheinbare logische Form des Satzes nicht seine wirkliche sein muß. \",\"pmc\":\"It was Russell who performed the service of showing that the apparent logical form of a proposition need not be its real one.\",\"ogd\":\"\",\"str\":\"Russell’s contribution is to have shown that the apparent logical form of a sentence need not be its real form.\",\"tlp\":[4.0031]},{\"label\":\"5.0016\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":15,\"x_axis\":115,\"page\":11,\"ger\":\"Die fortgesetzte Anwendung einer Operation auf ihr eigenes Resultat, oder ihre eigenen Resultate, heißt ihre sukzessive Anwendung. (O'(O'(O'a)) ist das Resultat der (3-maligen) sukzessiven Anwendung von O'ξ auf a.) \",\"pmc\":\"The repeated application of an operation to its own result or results is called the successive application of it. (O'(O'(O'a)) is the result of (three) successive applications of O'ξ to a.)\",\"ogd\":\"\",\"str\":\"The repeated application of an operation to its own result or results is called its successive application. (O'(O'(O'a)) is the result of (three) successive applications of O'ξ to a.)\",\"tlp\":[5.2521]},{\"label\":\"5.00161\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":15,\"x_axis\":117,\"page\":102,\"ger\":\"Eine Funktion kann nicht ihr eigenes Argument sein, wohl aber kann das Resultat einer Operation ihre eigene Basis sein. \",\"pmc\":\"A function cannot be its own argument, whereas an operation can take one of its own results as its base.\",\"ogd\":\"\",\"str\":\"A function cannot be its own argument, but the result of an operation can be its own basis.\",\"tlp\":[5.251]},{\"label\":\"5.00162\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":15,\"x_axis\":119,\"page\":81,\"ger\":\"So und nur so ist das Fortschreiten in der Hierarchie von einer Type zur anderen möglich. \",\"pmc\":\"It is in this way and only in this way that the step from one type to another in the type hierarchy is possible.\",\"ogd\":\"\",\"str\":\"This is the only possible way of stepping from one type to another in the type hierarchy.\",\"tlp\":[5.252]},{\"label\":\"5.00163\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":15,\"x_axis\":123,\"page\":103,\"ger\":\"Russell und Whitehead haben die Möglichkeit dieses Fortschreitens nicht zugegeben aber immer wieder von ihr Gebrauch gemacht. \",\"pmc\":\"Russell and Whitehead did not admit the possibility of such steps, but repeatedly availed themselves of it.\",\"ogd\":\"\",\"str\":\"Russell and Whitehead did not allow such steps, but they took them again and again.\",\"tlp\":[5.252]},{\"label\":\"5.005342\",\"precision\":6,\"fontSize\":\"18px\",\"y_axis\":15,\"x_axis\":137,\"page\":21,\"ger\":\"Alle Sätze — z.B. — der Reihe: aRb,(Ex)·aRx·xRb,(Ex,y)·aRx·xRy·yRb, u.s.w. sind durch eine formale Eigenschaft charakterisiert. \",\"pmc\":\"For example, all propositions of the series: aRb, (∃x). aRx . xRb, (∃x, y). aRx . xRy . yRb, etc. are characterized by a formal property.\",\"ogd\":\"\",\"str\":\"For example, all propositions of the series: aRb, (∃x).aRx.xRb, \\r(∃x, y).aRx.xRy.yRb, etc. are characterized by a formal property.\",\"tlp\":[4.1273]},{\"label\":\"6.1\",\"precision\":1,\"fontSize\":\"40px\",\"y_axis\":15,\"x_axis\":147,\"page\":64,\"ger\":\"Die Sätze der Logik sind die Tautologien. \",\"pmc\":\"The propositions of logic are the tautologies.\",\"ogd\":\"\",\"str\":\"The propositions of logic are the tautologies.\",\"tlp\":[6.1]},{\"label\":\"6.1001\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":15,\"x_axis\":149,\"page\":64,\"ger\":\"Die Satze der Logik sagen also nichts. Sie sind die analytischen Sätze. \",\"pmc\":\"Therefore the propositions of logic say nothing. They are the analytic propositions.\",\"ogd\":\"\",\"str\":\"Therefore the propositions of logic say nothing. They are the analytic propositions.\",\"tlp\":[6.11]},{\"label\":\"6.1002\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":15,\"x_axis\":151,\"page\":66,\"ger\":\"Theorien die einen Satz der Logik sehr gehaltvoll erscheinen lassen, sind immer falsch. Die Worte 〟Wahr\\\" und 〟Falsch\\\" z.B. scheinen zwei Eigenschaften unter anderen Eigenschaften zu bezeichnen, und da scheint es eine sehr merkwürdige Tatsache zu sein daß jeder Satz eine dieser Eigenschaften hat. Das scheint nun nichts weniger als selbstverständlich, ebensowenig selbstverständlich wie etwa der Satz 〟alle Rosen sind entweder gelb oder rot\\\" klänge, auch wenn er wahr wäre. Ja, jener Satz bekommt nun ganz den Charakter eines naturwissenschaftlichen Satzes, und dies ist das sichere Anzeichen dafür, daß er falsch aufgefaßt wurde. \",\"pmc\":\"All theories that make a proposition of logic appear to have a large amount of content are false. For example, the words 'true' and 'false' seem to signify two properties among other properties, and then it seems to be a remarkable fact that every proposition has one of these properties. On this theory it seems to be anything but obvious, just as, for instance, the proposition 'All roses are either yellow or red' would not sound obvious even if it were true. Indeed, the logical proposition acquires all the characteristics of a proposition of natural science and this is the sure sign that it has been construed wrongly.\",\"ogd\":\"\",\"str\":\"Theories that make a proposition of logic appear to have a large amount of content are always false. For example, the words “true” and “false” seem to signify two properties among other properties, and then it seems to be a remarkable fact that every proposition has one of these properties. This now seems to be no more obvious than the proposition “All roses are either yellow or red” would seem, even if it were true. Indeed, the logical proposition acquires all the characteristics of a proposition of natural science, and this is a sure sign that it has been wrongly construed.\",\"tlp\":[6.111]},{\"label\":\"6.1003\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":15,\"x_axis\":153,\"page\":66,\"ger\":\"Die richtige Erklärung der logischen Sätze, muß ihnen eine einzigartige Stellung unter allen Sätzen geben. \",\"pmc\":\"The correct explanation of the propositions of logic must assign to them a unique status among all propositions.\",\"ogd\":\"\",\"str\":\"The correct explanation of logical propositions must give them a unique position among all propositions.\",\"tlp\":[6.112]},{\"label\":\"6.1004\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":15,\"x_axis\":155,\"page\":67,\"ger\":\"Die Erforschung der Logik bedeutet die Erforschung aller Gesetzmäßigkeit. Und außerhalb der Logik ist alles Zufall. \",\"pmc\":\"The exploration of logic means the exploration of everything that is subject to law. And outside logic everything is accidental.\",\"ogd\":\"\",\"str\":\"The investigation of logic means the investigation of all that is subject to law. And outside logic, all is accident.\",\"tlp\":[6.3]},{\"label\":\"2.026\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":17,\"x_axis\":25,\"page\":27,\"ger\":\"Nur wenn es Gegenstände gibt, kann es eine feste Form der Welt geben. \",\"pmc\":\"There must be obejcts, if the world is to have an unalterable form.\",\"ogd\":\"\",\"str\":\"Only if there are objects, can the world have a fixed form.\",\"tlp\":[2.026]},{\"label\":\"3.1603\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":17,\"x_axis\":57,\"page\":38,\"ger\":\"Der Satz ist artikuliert. \",\"pmc\":\"A proposition is articulated.\",\"ogd\":\"\",\"str\":\"A proposition is articulate.\",\"tlp\":[3.141]},{\"label\":\"3.163\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":17,\"x_axis\":61,\"page\":26,\"ger\":\"Sehr klar wird das Wesen des Satzzeichens, wenn wir es uns, statt aus Schriftzeichen, aus räumlichen Gegenständen (aus Tischen, Stühlen Büchern etc.) zusammensetzen.\",\"pmc\":\"The essence of a propositional sign is very clearly seen if we imagine one composed of spatial objects (such as tables, chairs, books) instead of written signs.\",\"ogd\":\"\",\"str\":\"The essence of a sentential sign becomes very clear if we consider one made up not of written signs but of spatial objects (such as tables, chairs, books).\",\"tlp\":[3.1431]},{\"label\":\"4.01\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":17,\"x_axis\":69,\"page\":8,\"ger\":\"Der Satz ist ein Bild der Wirklichkeit. \",\"pmc\":\"A proposition is a picture of reality.\",\"ogd\":\"\",\"str\":\"A proposition is a picture of reality.\",\"tlp\":[4.01]},{\"label\":\"4.02\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":17,\"x_axis\":87,\"page\":8,\"ger\":\"Dies sehen wir daraus, daß wir den Sinn des Satzzeichens verstehen, ohne daß er uns erklärt wurde. \",\"pmc\":\"We can see this from the fact that we understand the sense of a propositional sign without its having been explained to us.\",\"ogd\":\"\",\"str\":\"We can see this from the fact that we understand the sense of a \\tsentential sign without its having been explained to us.\",\"tlp\":[4.02]},{\"label\":\"4.03\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":17,\"x_axis\":89,\"page\":8,\"ger\":\"Die Bedeutungen der einfachen Zeichen der Wörter müssen uns erklärt werden damit wir sie verstehen. \",\"pmc\":\"The meanings of simple signs, words, must be explained to us if we are to understand them.\",\"ogd\":\"\",\"str\":\"The meanings of simple signs (words), must be explained to us if we are to\\runderstand them.\",\"tlp\":[4.026]},{\"label\":\"4.04\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":17,\"x_axis\":91,\"page\":8,\"ger\":\"Mit den Sätzen aber verständigen wir uns.\",\"pmc\":\"With propositions, however, we make ourselves understood.\",\"ogd\":\"\",\"str\":\"But we make ourselves understood with propositions.\",\"tlp\":[4.026]},{\"label\":\"4.05\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":17,\"x_axis\":93,\"page\":8,\"ger\":\"Es liegt im Wesen des Satzes, daß er uns einen uns(?) neuen Sinn mitteilen kann.\",\"pmc\":\"It belongs to the essence of a proposition that it should be able to communicate to us a sense which is new to us?.\",\"ogd\":\"\",\"str\":\"It is essential to a proposition that it be able to communicate \\ra new sense to us.\",\"tlp\":[4.027]},{\"label\":\"4.051\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":19,\"x_axis\":93,\"page\":42,\"ger\":\"Ein Satz muß mit alten Ausdrücken einen neuen Sinn mitteilen. \",\"pmc\":\"A proposition must use old expressions to communicate a new sense.\",\"ogd\":\"\",\"str\":\"A proposition must communicate a new sense with old words.\",\"tlp\":[4.03]},{\"label\":\"4.06\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":17,\"x_axis\":95,\"page\":8,\"ger\":\"Der Satz teilt uns eine Sachlage mit, also muß er wesentlich mit dieser Sachlage zusammenhängen.\",\"pmc\":\"A proposition communicates a situation to us, and so it must be essentially connected with that situation.\",\"ogd\":\"\",\"str\":\"A proposition communicates a situation to us, and so it must be \\t\\tessentially connected with that situation.\",\"tlp\":[4.03]},{\"label\":\"4.07\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":17,\"x_axis\":97,\"page\":8,\"ger\":\"Und der Zusammenhang ist eben, daß er ihr logisches Bild ist. \",\"pmc\":\"And the connection is precisely that it is its logical picture.\",\"ogd\":\"\",\"str\":\"And the connection is precisely that it is its logical picture.\",\"tlp\":[4.03]},{\"label\":\"4.08\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":17,\"x_axis\":101,\"page\":8,\"ger\":\"Die Wirklichkeit wird mit dem Satz verglichen. \",\"pmc\":\"Reality is compared with propositions.\",\"ogd\":\"\",\"str\":\"Reality is compared with propositions.\",\"tlp\":[4.05]},{\"label\":\"4.09\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":17,\"x_axis\":103,\"page\":8,\"ger\":\"Nur dadurch kann der Satz wahr oder falsch sein, indem er ein Bild der Wirklichkeit ist.\",\"pmc\":\"A proposition can be true or false only in virtue of being a picture of reality.\",\"ogd\":\"\",\"str\":\"A proposition can be true or false only by being a picture of reality.\",\"tlp\":[4.06]},{\"label\":\"5.0017\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":17,\"x_axis\":115,\"page\":98,\"ger\":\"Die Operation kann erst dort auftreten wo ein Satz auf logisch bedeutungsvolle Weise aus einem anderen entsteht, also schon, und erst, wo die logische Konstruktion des Satzes anfängt. \",\"pmc\":\"Operations cannot make their appearance before the point at which one proposition is generated out of another in a logically meaningful way; i.e. when and only when the logical construction of propositions begins.\",\"ogd\":\"\",\"str\":\"Operations can first arise when one proposition is generated out of another in a logically meaningful way; i.e. when and only when the logical construction of propositions begins.\",\"tlp\":[5.233]},{\"label\":\"6.101\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":17,\"x_axis\":149,\"page\":65,\"ger\":\"Es ist das besondere Merkmal der logischen Sätze daß man am Symbol allein erkennen kann, daß sie wahr sind, und diese Tatsache schließt die ganze Philosophie der Logik in sich. Und so ist es auch eine der wichtigsten Tatsachen daß sich die Wahrheit oder Falschheit der nicht-logischen Sätze nicht am Satz allein erkennen läßt.\",\"pmc\":\"It is the peculiar mark of logical propositions that one can recognize that they are true from the symbol alone, and this fact contains in itself the whole philosophy of logic. And so too it is a very important fact that the truth or falsity of non-logical propositions cannot be recognized from the propositions alone.\",\"ogd\":\"\",\"str\":\"It is the characteristic mark of logical propositions that one can recognize that they are true from the symbol alone, and this fact contains in itself the whole philosophy of logic. And so too it is one of the most important facts that the truth or falsity of nonlogical propositions cannot be recognized from the propositions alone.\",\"tlp\":[6.113]},{\"label\":\"6.102\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":17,\"x_axis\":151,\"page\":68,\"ger\":\"Dürfen denn die Gesetze der Logik selbst wieder logischen Gesetzen unterstehen? \",\"pmc\":\"Or is it possible for the laws of logic to be subject in their turn to logical laws?\",\"ogd\":\"\",\"str\":\"Or is it possible for the laws of logic in their turn to obey logical laws?\",\"tlp\":[6.123]},{\"label\":\"2.027\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":19,\"x_axis\":25,\"page\":27,\"ger\":\"Das Feste, das Bestehende und der Gegenstand sind eins.\",\"pmc\":\"Objects, the unalterable, and the subsistent are one and the same.\",\"ogd\":\"\",\"str\":\"Objects, the fixed, and the persistent are one.\",\"tlp\":[2.027]},{\"label\":\"2.0271\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":19,\"x_axis\":27,\"page\":28,\"ger\":\"Der Gegenstand ist das Feste, Bestehende; die Konfiguration ist das Wechselnde, Unbeständige.\",\"pmc\":\"Objects are what is unalterable and subsistent; their configuration is what is changing and unstable.\",\"ogd\":\"\",\"str\":\"Objects are what is fixed and persistent; their configuration is what is changing and variable.\",\"tlp\":[2.0271]},{\"label\":\"2.0272\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":19,\"x_axis\":29,\"page\":28,\"ger\":\"Die Konfiguration der Gegenstände bildet den Sachverhalt. \",\"pmc\":\"The configuration of objects produces states of affairs.\",\"ogd\":\"\",\"str\":\"The configuration of objects forms an elementary fact.\\t\\r 4.091\\t28[3]\\t 4.061 (1)\\t\\tAüL 194 (3)**\\rIf one does not notice that propositions make sense independently of the facts, one can easily believe that true and false are relations of equal value between signs and what they signify.\",\"tlp\":[2.0272]},{\"label\":\"3.1604\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":19,\"x_axis\":57,\"page\":55,\"ger\":\"Tatsachen kann man nicht benennen. \",\"pmc\":\"Facts cannot be given names.\",\"ogd\":\"\",\"str\":\"Facts cannot be named.\",\"tlp\":[3.144]},{\"label\":\"3.164\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":19,\"x_axis\":61,\"page\":26,\"ger\":\"Die gegenseitige räumliche Lage dieser Dinge drückt dann den Sinn des Satzes aus. \",\"pmc\":\"Then the spatial arrangement of these things will express the sense of the proposition.\",\"ogd\":\"\",\"str\":\"Then the spatial arrangement of these things expresses the sense of the proposition.\",\"tlp\":[3.1431]},{\"label\":\"4.0101\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":19,\"x_axis\":69,\"page\":42,\"ger\":\"Die Möglichkeit aller Gleichnisse, der ganzen Bildhaftigkeit unserer Ausdrucksweise, ruht in der Logik der Abbildung. \",\"pmc\":\"The possibility of all imagery, of all our pictorial modes of expression, is contained in the logic of depiction.\",\"ogd\":\"\",\"str\":\"The possibility of all similes, of all the imagery of our language, rests on the logic of depiction.\",\"tlp\":[4.015]},{\"label\":\"4.011\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":19,\"x_axis\":71,\"page\":25,\"ger\":\"Auf den ersten Blick scheint der Satz — wie er etwa auf dem Papier gedruckt steht — kein Bild der Wirklichkeit zu sein, von der er handelt. \",\"pmc\":\"At first sight a proposition - one set out on the printed page, for example - does not seem to be a picture of the reality with which it is concerned.\",\"ogd\":\"\",\"str\":\"At first sight a sentence – say as it is set out on the printed page – does not seem to be a picture of the reality it is about.\",\"tlp\":[4.011]},{\"label\":\"4.0111\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":19,\"x_axis\":73,\"page\":25,\"ger\":\"Aber auch die Notenschrift scheint auf den ersten Blick kein Bild der Musik zu sein und unsere Lautzeichen- (Buchstaben-) Schrift kein Bild unserer Lautsprache. \",\"pmc\":\"But no more does musical notation at first sight seem to be a picture of music, nor our phonetic notation (the alphabet) to be a picture of our speech.\",\"ogd\":\"\",\"str\":\"But neither does musical notation at first sight seem to be a picture of music, nor our phonetic notation (the letters of the alphabet) to be a picture of our spoken language.\",\"tlp\":[4.011]},{\"label\":\"4.0112\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":19,\"x_axis\":75,\"page\":25,\"ger\":\"Und doch erweisen sich diese Zeichensprachen auch im gewöhnlichen Sinne als Bilder dessen was sie darstellen. \",\"pmc\":\"And yet these sign-languages prove to be pictures, even in the ordinary sense, of what they represent.\",\"ogd\":\"\",\"str\":\"And yet these sign-languages turn out to be pictures, even in the ordinary sense, of what they represent.\",\"tlp\":[4.011]},{\"label\":\"4.0113\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":19,\"x_axis\":77,\"page\":25,\"ger\":\"Und wenn wir in das Wesentliche dieser Bildhaftigkeit eindringen, so sehen wir, daß dieselbe durch scheinbare Unregelmäßigkeiten (wie die Verwendung der musicinline ♯ und musicinline ♭ in der Notenschrift) nicht gestört wird.\",\"pmc\":\"And if we penetrate to the essence of this pictorial character, we see that it is not impaired by apparent irregularities (such as the use of ♯ and ♭ in musical notation).\",\"ogd\":\"\",\"str\":\"And if we penetrate to the essence of this pictorial character, we see that it is not hindered by apparent irregularities (such as the use of ♯ and ♭ in musical notation).pt\",\"tlp\":[4.013]},{\"label\":\"4.0114\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":19,\"x_axis\":79,\"page\":26,\"ger\":\"Denn auch diese Unregelmäßigkeiten bilden das ab was sie ausdrücken sollen, nur auf eine andere Art und Weise.\",\"pmc\":\"For even these irregularities depict what they are intended to express; only they do it in a different way.\",\"ogd\":\"\",\"str\":\"For even these irregularities depict what they are to express, only in a different way.\",\"tlp\":[4.013]},{\"label\":\"4.0115\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":19,\"x_axis\":83,\"page\":26,\"ger\":\"Um das Wesen des Satzes zu verstehen, denken wir an die Hieroglyphenschrift, die eingestandenermaßen die Tatsachen, welche sie beschreibt, abbildet. \",\"pmc\":\"In order to understand the essential nature of a proposition, we should consider hieroglyphic script, which avowedly depicts the facts it describes.\",\"ogd\":\"\",\"str\":\"To understand the essence of a proposition, consider hieroglyphic writing, which admittedly depicts the facts it describes.\",\"tlp\":[4.016]},{\"label\":\"4.0116\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":19,\"x_axis\":85,\"page\":26,\"ger\":\"Und aus ihr wurde die Buchstabenschrift, ohne das Wesentliche der Abbildung zu verlieren. \",\"pmc\":\"And alphabetic script developed out of it without losing what was essential to depiction.\",\"ogd\":\"\",\"str\":\"And from it came alphabetic writing, without losing what was essential to depiction.\",\"tlp\":[4.016]},{\"label\":\"4.021\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":19,\"x_axis\":87,\"page\":15,\"ger\":\"Der Satz ist ein Bild der Wirklichkeit; denn ich kenne die von ihm dargestellte Sachlage, wenn ich den Satz verstehe. Und den Satz verstehe ich, ohne daß mir sein Sinn erklärt wurde.\",\"pmc\":\"A proposition is a picture of reality: for if I understand a proposition, I know the situation that it represents. And I understand the proposition without having had its sense explained to me.\",\"ogd\":\"\",\"str\":\"A proposition is a picture of reality: for if I understand a proposition, I know the situation that it represents. And I understand the proposition without its sense having been explained to me.\",\"tlp\":[4.021]},{\"label\":\"4.071\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":19,\"x_axis\":97,\"page\":48,\"ger\":\"Der Satz sagt nur insoweit etwas aus als er ein Bild ist. \",\"pmc\":\"A proposition states something only in so far as it is a picture.\",\"ogd\":\"\",\"str\":\"A proposition asserts something only insofar as it is a picture.\",\"tlp\":[4.03]},{\"label\":\"4.0711\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":19,\"x_axis\":99,\"page\":48,\"ger\":\"Im Satz wird gleichsam eine Sachlage probeweise zusammengestellt. \",\"pmc\":\"In a proposition a situation is, as it were, constructed by way of experiment.\",\"ogd\":\"\",\"str\":\"In a proposition a situation is, as it were, put together as an experiment.\",\"tlp\":[4.031]},{\"label\":\"4.0712\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":19,\"x_axis\":101,\"page\":48,\"ger\":\"Man kann geradezu sagen: statt, dieser Satz hat diesen und diesen Sinn; dieser Satz stellt diese und diese Sachlage dar. \",\"pmc\":\"Instead of, 'This proposition has such and such a sense', we can simply say, 'This proposition represents such and such a situation'.\",\"ogd\":\"\",\"str\":\"Instead of “This proposition has such and such a sense”, one can say “This proposition represents such and such a situation”.\",\"tlp\":[4.031]},{\"label\":\"4.091\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":19,\"x_axis\":103,\"page\":28,\"ger\":\"Beachtet man nicht daß der Satz einen von den Tatsachen unabhängigen Sinn hat, so kann man leicht glauben daß wahr und falsch gleichberechtigte Bezeichnungen von Zeichen und Bezeichnetem sind. \",\"pmc\":\"It must not be overlooked that a proposition has a sense that is independent of the facts: otherwise one can easily suppose that true and false are relations of equal status between signs and what they signify.\",\"ogd\":\"\",\"str\":\"If one does not notice that propositions make sense independently of the facts, one can easily believe that true and false are relations of equal value between signs and what they signify.\",\"tlp\":[4.061]},{\"label\":\"4.0911\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":19,\"x_axis\":105,\"page\":28,\"ger\":\"(Man könnte dann z.B. sagen, daß 〟p\\\" auf die wahre Art bezeichnet was 〟~p\\\" auf die falsche Art. etc.) \",\"pmc\":\"(In that case one could say, for example, that 'p' signified in the true way what '~p' signified in the false way, etc.)\",\"ogd\":\"\",\"str\":\"(One could then say, for instance, that “p” truly signifies what “~p” falsely signifies, etc.).\",\"tlp\":[4.061]},{\"label\":\"5.01\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":19,\"x_axis\":113,\"page\":11,\"ger\":\"Den Elementarsatz können wir als Wahrheitsfunktion seiner selbst auffassen. \",\"pmc\":\"We can regard an elementary proposition as a truth-function of itself.\",\"ogd\":\"\",\"str\":\"We can regard an elementary proposition as a truth-function of itself.\",\"tlp\":[5.01]},{\"label\":\"5.02\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":19,\"x_axis\":115,\"page\":11,\"ger\":\"Die Wahrheitsfunktionen einer bestimmten Anzahl von Sätzen lassen sich in einem Schema folgender Art hinschreiben:<br />Wir nennen es das Schema II.\",\"pmc\":\"The truth-functions of a given number of elementary propositions can always be set out in a schema of the following kind:<br />We call it Schema No. II.\",\"ogd\":\"\",\"str\":\"The truth-functions of a given number of elementary propositions can always be set out in a schema of the following kind: We call it Schema No. II.\",\"tlp\":[5.101]},{\"label\":\"5.03\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":19,\"x_axis\":117,\"page\":12,\"ger\":\"Diejenigen Wahrheitsmöglichkeiten der W-Argumente, welche den Satz bewahrheiten nenne ich seine Wahrheitsgründe.\",\"pmc\":\"I give the name truth-grounds to those truth-possibilities of its T-arguments that make it true.\",\"ogd\":\"\",\"str\":\"I give the name “truth-grounds” to those truth-possibilities of a proposition’s truth-arguments that make it true.\",\"tlp\":[5.101]},{\"label\":\"5.04\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":19,\"x_axis\":119,\"page\":12,\"ger\":\"Sind die Wahrheitsgründe einer Anzahl von Sätzen sämtlich auch Wahrheitsgründe eines bestimmten Satzes so sagen wir die Wahrheit dieses Satzes folge aus der Wahrheit der Gesamtheit jener anderen. \",\"pmc\":\"If all the truth-grounds of a number of propositions are at the same time truth-grounds of another proposition, then we say that the truth of that proposition follows from the truth of the totality of those propositions.\",\"ogd\":\"\",\"str\":\"If the truth-grounds common to several propositions are also truth-grounds of a certain proposition, then we say that the truth of that proposition follows from the truth of the totality of those propositions.\",\"tlp\":[5.11]},{\"label\":\"5.05\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":19,\"x_axis\":125,\"page\":12,\"ger\":\"Folgt p aus q und q aus p, so sind sie ein und derselbe Satz. \",\"pmc\":\"If p follows from q and q from p, then they are one and the same proposition.\",\"ogd\":\"\",\"str\":\"If p follows from q and q follows from p, then they are one and the same proposition.\",\"tlp\":[5.141]},{\"label\":\"5.06\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":19,\"x_axis\":127,\"page\":12,\"ger\":\"Folgt ein Satz aus einem anderen, so sagt dieser mehr als jener, jener weniger als dieser.\",\"pmc\":\"If one proposition follows from another, the latter says more than the former, and the former less than the latter.\",\"ogd\":\"\",\"str\":\"If a proposition follows from another, then the latter says more than the former, and the former says less than the latter.\",\"tlp\":[5.14]},{\"label\":\"5.07\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":19,\"x_axis\":129,\"page\":12,\"ger\":\"Die Tautologie folgt aus allen Sätzen; sie sagt nichts. \",\"pmc\":\"A tautology follows from all propositions; it says nothing.\",\"ogd\":\"\",\"str\":\"A tautology follows from all propositions: it says nothing.\",\"tlp\":[5.142]},{\"label\":\"5.08\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":19,\"x_axis\":131,\"page\":37,\"ger\":\"Die Kontradiktion ist das Gemeinsame der Sätze, was kein Satz mit einem anderen gemein hat. Die Tautologie ist das Gemeinsame aller Sätze welche nichts mit einander gemein haben. \",\"pmc\":\"Contradiction is that common factor of propositions which no proposition has in common with another. Tautology is the common factor of all propositions that have nothing in common with one another.\",\"ogd\":\"\",\"str\":\"Contradiction is what propositions have in common that no proposition has in common with another. Tautology is what all propositions have in common that have nothing in common with one another.\",\"tlp\":[5.143]},{\"label\":\"5.09\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":19,\"x_axis\":133,\"page\":78,\"ger\":\"Folgt ein Satz aus einem anderen so gibt dieser jenem die Wahrscheinlichkeit 1. Sind zwei Sätze von einander unabhängig, so gibt jeder dem anderen die Wahrscheinlichkeit ½. \",\"pmc\":\"If one proposition follows from another, then the latter proposition gives to the former the probability 1. If two propositions are independent of one another, then each gives to the other the probability 1/2.\",\"ogd\":\"\",\"str\":\"If one proposition follows from another, then the latter gives the former the probability 1. If two propositions are independent of one another, then each gives the other the probability ½.\",\"tlp\":[5.152]},{\"label\":\"6.11\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":19,\"x_axis\":149,\"page\":64,\"ger\":\"Daß sie Tautologien sind, das zeigt die formalen — logischen — Eigenschaften der Sprache, der Welt. \",\"pmc\":\"The fact that they are tautologies shows the formal - logical - properties of language and the world.\",\"ogd\":\"\",\"str\":\"That they are tautologies shows the formal - logical - properties of language, of the world.\",\"tlp\":[6.12]},{\"label\":\"6.12\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":19,\"x_axis\":165,\"page\":64,\"ger\":\"Daraus ergibt sich daß die logischen Sätze nicht unbedingt notwendig sind da wir ja in einer entsprechenden Notation diestrukturellen Eigenschaften der Sätze durch das bloße Ansehen dieser Sätze erkennen können. \",\"pmc\":\"It follows from this that logical propositions are not unconditionally necessary; for in a suitable notation we can in fact recognize the structural properties of propositions by mere inspection of the propositions themselves.\",\"ogd\":\"\",\"str\":\"It follows from this that logical propositions are not unconditionally necessary; for in a suitable notation we can in fact recognize the structural properties of the propositions merely by inspecting them.\",\"tlp\":[6.122]},{\"label\":\"6.13\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":19,\"x_axis\":167,\"page\":66,\"ger\":\"Die Logik ist keine Lehre sondern ein Spiegelbild der Welt. \",\"pmc\":\"Logic is not a body of doctrine, but a mirror-image of the world.\",\"ogd\":\"\",\"str\":\"Logic is not a theory, but a mirror image of the world.\",\"tlp\":[6.13]},{\"label\":\"2.1\",\"precision\":1,\"fontSize\":\"40px\",\"y_axis\":21,\"x_axis\":9,\"page\":3,\"ger\":\"Die Tatsachen begreifen wir in Bildern.\",\"pmc\":\"Facts are grasped by us in pictures.\",\"ogd\":\"\",\"str\":\"We grasp facts by way of pictures.\",\"tlp\":[2.1]},{\"label\":\"2.11\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":21,\"x_axis\":11,\"page\":4,\"ger\":\"Das Bild stellt die Sachlage im logischen Raum, das Bestehen und nicht Bestehen von Sachverhalten, vor.\",\"pmc\":\"A picture presents a situation in logical space, the existence and non-existence of states of affairs.\",\"ogd\":\"\",\"str\":\"A picture presents a situation in logical space, the obtaining or non-obtaining of elementary facts.\",\"tlp\":[2.11]},{\"label\":\"2.12\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":21,\"x_axis\":13,\"page\":4,\"ger\":\"Das Bild ist ein Modell der Wirklichkeit. \",\"pmc\":\"A picture is a model of reality.\",\"ogd\":\"\",\"str\":\"A picture is a model of reality.\",\"tlp\":[2.12]},{\"label\":\"2.13\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":21,\"x_axis\":15,\"page\":4,\"ger\":\"Den Gegenständen entsprechen im Bild die Elemente des Bildes. \",\"pmc\":\"In a picture objects have the elements of the picture corresponding to them.\",\"ogd\":\"\",\"str\":\"In a picture the elements of the picture correspond to the objects.\",\"tlp\":[2.13]},{\"label\":\"2.14\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":21,\"x_axis\":17,\"page\":5,\"ger\":\"Das Bild besteht darin, daß sich seine Elemente in bestimmter Art und Weise zu einander verhalten.\",\"pmc\":\"What constitutes a picture is that its elements are related to one another in a determinate way.\",\"ogd\":\"\",\"str\":\"A picture consists in its elements being combined in a definite way.\",\"tlp\":[2.14]},{\"label\":\"2.15\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":21,\"x_axis\":19,\"page\":4,\"ger\":\"Das Bild ist eine Tatsache.\",\"pmc\":\"A picture is a fact.\",\"ogd\":\"\",\"str\":\"A picture is a fact.\",\"tlp\":[2.141]},{\"label\":\"2.16\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":21,\"x_axis\":23,\"page\":4,\"ger\":\"Die Tatsache muß, um Bild zu sein, etwas mit dem Abgebildeten gemeinsam haben. \",\"pmc\":\"If a fact is to be a picture, it must have something in common with what it depicts.\",\"ogd\":\"\",\"str\":\"A fact will count as a picture only if it has something in common with what it represents.\",\"tlp\":[2.16]},{\"label\":\"2.17\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":21,\"x_axis\":25,\"page\":6,\"ger\":\"Was das Bild mit der Wirklichkeit gemein haben muß um sie auf seine Art und Weise — richtig oder falsch — abbilden zu können ist seine Form der Abbildung.\",\"pmc\":\"What a picture must have in common with reality, in order to be able to depict it - correctly or incorrectly - in the way it does, is its pictorial form.\",\"ogd\":\"\",\"str\":\"What a picture must have in common with reality, to be able to depict it - correctly or incorrectly - in the way it does, is its form of depiction.\",\"tlp\":[2.17]},{\"label\":\"2.18\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":21,\"x_axis\":27,\"page\":6,\"ger\":\"Was jedes Bild welcher Form immer mit der Wirklichkeit gemein haben muß um sie überhaupt — richtig oder falsch — abbilden zu können ist die logische Form, das ist die Form der Wirklichkeit.\",\"pmc\":\"What any picture, of whatever form, must have in common with reality, in order to be able to depict it - correctly or incorrectly - in any way at all, is logical form, i.e. the structure of reality.\",\"ogd\":\"\",\"str\":\"What any picture, of whatever form, must have in common with reality,  be able to depict it - correctly or incorrectly - in any way at all, is logical form, i.e. the structure of reality.\",\"tlp\":[2.18]},{\"label\":\"2.19\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":21,\"x_axis\":29,\"page\":14,\"ger\":\"Das logische Bild kann die Welt abbilden.\",\"pmc\":\"Logical pictures can depict the world.\",\"ogd\":\"\",\"str\":\"Logical pictures can depict the world.\",\"tlp\":[2.19]},{\"label\":\"3.2\",\"precision\":1,\"fontSize\":\"40px\",\"y_axis\":21,\"x_axis\":45,\"page\":3,\"ger\":\"Das Satzzeichen mit der Art und Weise seiner Abbildung ist der Satz. \",\"pmc\":\"A propositional sign with its mode of depiction is a proposition.\",\"ogd\":\"\",\"str\":\"A proposition is a sentential sign plus its mode of depiction.\",\"tlp\":[3.12]},{\"label\":\"3.201\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":21,\"x_axis\":47,\"page\":8,\"ger\":\"Die im Satze angewandten einfachen Zeichen heißen Namen. \",\"pmc\":\"The simple signs employed in propositions are called names.\",\"ogd\":\"\",\"str\":\"The simple signs employed in propositions are called names.\",\"tlp\":[3.202]},{\"label\":\"3.202\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":21,\"x_axis\":57,\"page\":11,\"ger\":\"Nur der Satz hat Sinn, nur im Zusammenhang des Satzes hat ein Name Bedeutung. \",\"pmc\":\"Only propositions have sense, only in the nexus of a proposition does a name have a meaning.\",\"ogd\":\"\",\"str\":\"Only propositions make sense, only in the context of a proposition is a name meaningful.\",\"tlp\":[3.3]},{\"label\":\"4.0102\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":21,\"x_axis\":69,\"page\":41,\"ger\":\"Die Möglichkeit des Satzes basiert auf dem Prinzip der Vertretung von Gegenständen durch Zeichen. \",\"pmc\":\"The possibility of propositions is based on the principle that objects have signs as their representatives.\",\"ogd\":\"\",\"str\":\"The possibility of propositions is based on the principle that objects are  represented by their signs.\",\"tlp\":[4.0312]},{\"label\":\"4.01121\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":21,\"x_axis\":75,\"page\":56,\"ger\":\"Offenbar ist, daß wir einen Satz in der Form aRb als Bild empfinden. \",\"pmc\":\"It is obvious that a proposition strikes us as a picture when it is in the form aRb.\",\"ogd\":\"\",\"str\":\"Obviously, a proposition the form aRb looks like a picture.\",\"tlp\":[4.012]},{\"label\":\"4.01141\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":21,\"x_axis\":79,\"page\":92,\"ger\":\"Die Grammophonplatte, der musikalische Gedanke, die Notenschrift, die Schallwellen, stehen alle in jener abbildenden internen Beziehung zu einander die zwischen Sprache und Welt besteht. <br />Ihnen allen ist der logische Bau gemeinsam. \",\"pmc\":\"A gramophone record, the musical idea, the written notes, and the sound-waves, all stand to one another in the same internal relation of depicting that holds between language and the world.<br />They are all constructed according to a common logical pattern.\",\"ogd\":\"\",\"str\":\"The gramophone record, the musical thought, the score, the sound waves, all stand to one another in that internal pictorial relation which holds between language and the world. They all have a common logical structure.\",\"tlp\":[4.014]},{\"label\":\"4.011411\",\"precision\":6,\"fontSize\":\"18px\",\"y_axis\":21,\"x_axis\":81,\"page\":92,\"ger\":\"Wie im Märchen die zwei Jünglinge, ihre zwei Pferde und ihre Lilien. Sie sind alle in gewissem Sinne eins. \",\"pmc\":\"Like the two youths in the fairy-tale, their two horses, and their lillies. They are all in a certain sense one.\",\"ogd\":\"\",\"str\":\"Like the two youths, their two horses, and their lilies in the fairy tale. In a certain sense, they are all one.\",\"tlp\":[4.014]},{\"label\":\"4.022\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":21,\"x_axis\":87,\"page\":15,\"ger\":\"Der Satz zeigt seinen Sinn.\",\"pmc\":\"A proposition shows its sense.\",\"ogd\":\"\",\"str\":\"A proposition shows its sense.\",\"tlp\":[4.022]},{\"label\":\"4.072\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":21,\"x_axis\":97,\"page\":48,\"ger\":\"Nur insoweit ist der Satz ein Bild einer Sachlage als er logisch gegliedert ist. \",\"pmc\":\"It is only in so far as a proposition is logically segmented that it is a picture of a situation.\",\"ogd\":\"\",\"str\":\"A proposition is a picture of a situation only insofar as it is logically articulated.\",\"tlp\":[4.032]},{\"label\":\"4.0721\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":21,\"x_axis\":99,\"page\":93,\"ger\":\"Auch der Satz 〟ambulo\\\" ist zusammengesetzt, denn sein Stamm ergibt mit einer anderen Endung und seine Endung mit einem anderen Stamm einen anderen Sinn. \",\"pmc\":\"Even the proposition, Ambulo, is composite: for its stem with a different ending yiled a different sense, and so does its ending with a different stem.\",\"ogd\":\"\",\"str\":\"Even the Latin proposition “Ambulo” is composite: for with another ending its stem yields a different sense, as does its ending with another stem.\",\"tlp\":[4.032]},{\"label\":\"4.092\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":21,\"x_axis\":103,\"page\":28,\"ger\":\"〟Kann man sich nicht mit falschen Sätzen, wie bisher mit wahren verständigen? solange man nur weiß daß sie falsch gemeint sind.\\\"<br />Nein! Denn wahr ist ein Satz wenn es sich so verhält wie wir es durch ihn sagen; und wenn wir mit 〟q\\\" ~q meinen und es sich so verhält wie wir es meinen so ist 〟q\\\" in der neuen Auffassung wahr und nicht falsch. \",\"pmc\":\"Can we not make ourselves understood with false propositions just as we have done up till now with true ones? So long as it is known that they are meant to be false.<br />No! For a proposition is true if we use it to say that things stand in a certain way, and they do; and if by 'q' we mean ~q and things stand as we mean that they do, then, construed in the new way, 'q' is true and not false.<br />\",\"ogd\":\"\",\"str\":\"“Can we not make ourselves understood with false propositions just as we have done up to now with true ones, so long as we know that they are meant to be false?”\",\"tlp\":[4.062]},{\"label\":\"5.011\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":21,\"x_axis\":113,\"page\":12,\"ger\":\"Die Elementarsätze sind die Wahrheitsargumente (W-Argumente) des Satzes.\",\"pmc\":\"Elementary propositions are the truth-arguments (T-arguments) of propositions.\",\"ogd\":\"\",\"str\":\"Elementary propositions are the truth-arguments of propositions.\",\"tlp\":[5.011]},{\"label\":\"5.021\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":21,\"x_axis\":115,\"page\":77,\"ger\":\"Die Wahrheitsfunktionen lassen sich in Reihen ordnen. \",\"pmc\":\"Truth-functions can be arranged in series.\",\"ogd\":\"\",\"str\":\"Truth-functions can be arranged in series.\",\"tlp\":[5.1]},{\"label\":\"5.041\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":21,\"x_axis\":119,\"page\":12,\"ger\":\"Insbesondere folgt die Wahrheit eines Satzes p aus der Wahrheit eines anderen q wenn alle Wahrheitsgründe des ersten Wahrheitsgründe des zweiten sind. \",\"pmc\":\"In particular, the truth of a proposition p follows from the truth of another proposition q if all the truth-grounds of the former are truth-grounds of the latter.\",\"ogd\":\"\",\"str\":\"In particular, the truth of a proposition p follows from the truth of another proposition q if all the truth-grounds of the former are truth-grounds of the latter.\",\"tlp\":[5.12]},{\"label\":\"5.04101\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":21,\"x_axis\":121,\"page\":12,\"ger\":\"Wir sagen auch die Wahrheitsgründe des einen sind in denen des anderen enthalten, p folge aus q.\",\"pmc\":\"We also say the truth-grounds of the one are contained in those of the other: p follows from q.\",\"ogd\":\"\",\"str\":\"We also say the truth-grounds of the one are contained in those of the other: p follows from q.\",\"tlp\":[5.121]},{\"label\":\"5.04102\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":21,\"x_axis\":123,\"page\":37,\"ger\":\"Folgt p aus q so ist der Sinn von p im Sinne von q enthalten.\",\"pmc\":\"If p follows from q, the sense of p is contained in the sense of q.\",\"ogd\":\"\",\"str\":\"If p follows from q, the sense of p is contained in the sense of q.\",\"tlp\":[5.122]},{\"label\":\"5.04103\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":21,\"x_axis\":125,\"page\":61,\"ger\":\"Der Satz bejaht jeden Satz der aus ihm folgt. \",\"pmc\":\"A proposition affirms every proposition that follows from it.\",\"ogd\":\"\",\"str\":\"A proposition affirms every proposition that follows from it.\",\"tlp\":[5.124]},{\"label\":\"5.04104\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":21,\"x_axis\":127,\"page\":61,\"ger\":\"Zwei Sätze sind einander entgegengesetzt wenn es keinen sinnvollen Satz gibt der sie beide bejaht. \",\"pmc\":\"Two propositions are opposed to one another if there is no proposition with a sense, that affirms them both.\",\"ogd\":\"\",\"str\":\"Two propositions oppose each other if there is no meaningful proposition  that affirms both.\",\"tlp\":[5.1241]},{\"label\":\"5.04105\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":21,\"x_axis\":129,\"page\":61,\"ger\":\"Jeder Satz der einem anderen widerspricht verneint ihn. \",\"pmc\":\"Every proposition that contradicts another negates it.\",\"ogd\":\"\",\"str\":\"Every proposition that contradicts another negates it.\",\"tlp\":[5.1241]},{\"label\":\"5.081\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":21,\"x_axis\":131,\"page\":37,\"ger\":\"Die Kontradiktion verschwindet sozusagen außerhalb, die Tautologie innerhalb aller Sätze. \",\"pmc\":\"Contradiction, one might say, vanishes outside all propositions: tautology vanishes inside them.\",\"ogd\":\"\",\"str\":\"Contradiction vanishes so to speak outside all propositions, tautology inside them.\",\"tlp\":[5.143]},{\"label\":\"5.091\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":21,\"x_axis\":133,\"page\":78,\"ger\":\"Das Folgen ist ein Grenzfall des Wahrscheinlich-gemacht-Werdens. \",\"pmc\":\"Following from is a limiting case of being made probable.\",\"ogd\":\"\",\"str\":\"Following from is a limiting case of being made probable.\",\"tlp\":[5.125]},{\"label\":\"6.111\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":21,\"x_axis\":149,\"page\":64,\"ger\":\"Daß ihre Bestandteile so verknüpft eine Tautologie ergeben, das charakterisiert die Logik ihrer Bestandteile. \",\"pmc\":\"The fact that a tautology is yielded by this particular way of connecting its constituents characterizes the logic of its constituents.\",\"ogd\":\"\",\"str\":\"The fact that a tautology is yielded by this way of connecting its constituents characterizes the logic of its constituents.\",\"tlp\":[6.12]},{\"label\":\"6.131\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":21,\"x_axis\":167,\"page\":66,\"ger\":\"Die Logik ist transzendental. \",\"pmc\":\"Logic is transcendental.\",\"ogd\":\"\",\"str\":\"Logic is transcendental.\",\"tlp\":[6.13]},{\"label\":\"2.131\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":23,\"x_axis\":15,\"page\":14,\"ger\":\"Die Elemente des Bildes vertreten im Bild die Gegenstände. \",\"pmc\":\"In a picture the elements of the picture are the representatives of objects.\",\"ogd\":\"\",\"str\":\"A picture’s elements stand, in the picture, for the objects.pt\",\"tlp\":[2.131]},{\"label\":\"2.151\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":23,\"x_axis\":19,\"page\":14,\"ger\":\"Daß sich die Elemente des Bildes in bestimmter Art und Weise zu einander verhalten, stellt vor daß sich die Sachen so zu einander verhalten.\",\"pmc\":\"The fact that the elements of a picture are related to one another in a determinate way represents that things are related to one another in the same way.\",\"ogd\":\"\",\"str\":\"The definite way in which the picture elements go together represents how things are related to one another.\",\"tlp\":[2.15]},{\"label\":\"2.15101\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":23,\"x_axis\":21,\"page\":14,\"ger\":\"Dieser Zusammenhang der Elemente des Bildes heißt seine Form der Abbildung. \",\"pmc\":\"This connection of the elements of a picture is called its pictorial form.\",\"ogd\":\"\",\"str\":\"This connection of the elements of a picture is called its form of depiction.\",\"tlp\":[2.15]},{\"label\":\"2.161\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":23,\"x_axis\":23,\"page\":5,\"ger\":\"In Bild und Abgebildetem muß etwas identisch sein, damit das eine überhaupt ein Bild des anderen sein kann.\",\"pmc\":\"There must be something identical in a picture and what it depicts, to enable the one to be a picture of the other at all.\",\"ogd\":\"\",\"str\":\"Only if a picture and what it depicts contain something identical can the former be a picture of the latter.pt\",\"tlp\":[2.161]},{\"label\":\"2.171\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":23,\"x_axis\":25,\"page\":6,\"ger\":\"Es gibt verschiedene Formen der Abbildung.\",\"pmc\":\"There are various pictorial forms.\",\"ogd\":\"\",\"str\":\"There are various forms of depiction.\",\"tlp\":[\"None\"]},{\"label\":\"2.181\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":23,\"x_axis\":27,\"page\":6,\"ger\":\"Ist die Form der Abbildung die logische Form so heißt das Bild das logische Bild. \",\"pmc\":\"A picture whose pictorial form is logical form is called a logical picture.\",\"ogd\":\"\",\"str\":\"A picture whose form of depiction is logical form is called a logical picture.\",\"tlp\":[2.181]},{\"label\":\"3.20101\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":23,\"x_axis\":47,\"page\":44,\"ger\":\"Die Forderung der einfachen Zeichen ist die Forderung der Bestimmtheit des Sinnes. \",\"pmc\":\"The requirement that there be simple signs is the requirement that sense be determinate.\",\"ogd\":\"\",\"str\":\"The demand for simple signs is the demand that sense be determinate.\",\"tlp\":[3.23]},{\"label\":\"3.2011\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":23,\"x_axis\":49,\"page\":31,\"ger\":\"Namen gleichen Punkten, Sätze Pfeilen, sie haben Sinn. \",\"pmc\":\"Names are like points; propositions like arrows - they have sense.\",\"ogd\":\"\",\"str\":\"Names are like points; propositions like arrows - they have sense.\",\"tlp\":[3.144]},{\"label\":\"3.2021\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":23,\"x_axis\":57,\"page\":36,\"ger\":\"Namen lassen sich nicht definieren, sie sind Urzeichen. \",\"pmc\":\"Names are indefinable; they are primitive signs.\",\"ogd\":\"\",\"str\":\"Names are indefinable; they are primitive signs.\",\"tlp\":[3.26]},{\"label\":\"3.20211\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":23,\"x_axis\":59,\"page\":51,\"ger\":\"Jedes definierte Zeichen bezeichnet über jene Zeichen durch welche es definiert wurde. Und die Definitionen weisen den Weg. Zwei Zeichen, ein Urzeichen und ein definiertes Zeichen, können nie auf dieselbe Weise bezeichnen. Namen kann man nicht definieren. Man kann überhaupt kein Zeichen definieren, welches allein, selbständig eine Bedeutung hat. \",\"pmc\":\"Every sign that has a definition signifies via the signs that serve to define it. And the definitions point the way. Two signs cannot signify in the same manner if one is primitive and the other is a defined sign. Names cannot be defined - nor in general, can any sign that has a meaning independently and on its own.\",\"ogd\":\"\",\"str\":\"Every defined sign signifies via the signs by which it is defined; the definitions point the way. Two signs, one primitive and one defined, cannot signify in the same way. Names cannot be defined - nor in general, can any sign that has a meaning independently and on its own.\",\"tlp\":[3.261]},{\"label\":\"3.20212\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":23,\"x_axis\":61,\"page\":59,\"ger\":\"Die Bedeutungen von Urzeichen können durch Erläuterungen erklärt werden. Erläuterungen sind Sätze, welche die Urzeichen enthalten. Sie können also nur verstanden werden, wenn die Bedeutungen dieser Zeichen bereits bekanntsind. \",\"pmc\":\"The meanings of primitive signs can be explained by means of elucidations. Elucidations are propositions that contain the primitive signs. So they can only be understood if the meanings of those signs are already known.\",\"ogd\":\"\",\"str\":\"The meanings of primitive signs can be explained by means of elucidations. Elucidations are propositions containing the primitive signs. So they can only be understood if the meanings of those signs are already known.\",\"tlp\":[3.263]},{\"label\":\"4.0103\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":23,\"x_axis\":69,\"page\":41,\"ger\":\"Mein Grundgedanke ist, daß die 〟logischen Konstanten\\\" nicht vertreten. Daß sich die Logik der Tatsachen nicht vertreten läßt. \",\"pmc\":\"My fundamental idea is that the 'logical constants' are not representatives; that there can be no representatives of the logic of facts.\",\"ogd\":\"\",\"str\":\"My fundamental thought is that the “logical constants” are not representatives; that the logic of facts cannot be represented.\",\"tlp\":[4.0312]},{\"label\":\"4.01122\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":23,\"x_axis\":75,\"page\":79,\"ger\":\"Hier ist die Bezeichnungsweise offenbar ein Gleichnis des Bezeichneten. \",\"pmc\":\"In this case the mode of signification is obviously a likeness of what is signified.\",\"ogd\":\"\",\"str\":\"Here the mode of signification is obviously a likeness of the signified.\",\"tlp\":[4.012]},{\"label\":\"4.023\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":23,\"x_axis\":87,\"page\":15,\"ger\":\"Der Satz zeigt, wie es sich verhält, wenn er wahr ist. \",\"pmc\":\"A proposition shows how things stand if it is true.\",\"ogd\":\"\",\"str\":\"A proposition shows how things stand, if it is true.\",\"tlp\":[4.023]},{\"label\":\"4.0231\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":23,\"x_axis\":89,\"page\":47,\"ger\":\"Die Wirklichkeit muß durch den Satz auf ja oder nein fixiert sein; dazu muß sie durch ihn vollständig beschreiben werden. \",\"pmc\":\"A proposition must restrict reality to two alternatives: yes or no; in order to do that, it must describe reality completely.\",\"ogd\":\"\",\"str\":\"A proposition must restrict reality to two alternatives: yes or no. To do that, it must describe reality completely.\",\"tlp\":[4.023]},{\"label\":\"4.0232\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":23,\"x_axis\":91,\"page\":47,\"ger\":\"Der Satz ist die Beschreibung eines Sachverhalts. \",\"pmc\":\"A proposition is a description of a state of affairs.\",\"ogd\":\"\",\"str\":\"A proposition is a description of an elementary fact.\",\"tlp\":[4.023]},{\"label\":\"4.073\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":23,\"x_axis\":97,\"page\":48,\"ger\":\"Am Satz muß geradesoviel zu unterscheiden sein als an der Sachlage die er darstellt. \",\"pmc\":\"In a proposition there must be exactly as many distinguishable parts as in the situation that it represents.\",\"ogd\":\"\",\"str\":\"In a proposition there must be exactly as many distinguishable parts as in the situation that it represents.\",\"tlp\":[4.04]},{\"label\":\"4.0921\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":21,\"x_axis\":105,\"page\":28,\"ger\":\"Daß aber die Zeichen 〟q\\\" und 〟~q\\\" das gleiche sagen können ist wichtig. Denn es zeigt daß dem Zeichen 〟~\\\" in der Wirklichkeit nichts entspricht. \",\"pmc\":\"But it is important that the signs 'q' and '~q' can say the same thing. For it shows that nothing in reality corresponds to the sign '~'.\",\"ogd\":\"\",\"str\":\"But it is important that the signs “p” and “~p” can say the same thing. For it shows that the sign “~” corresponds to nothing in reality.\",\"tlp\":[4.0621]},{\"label\":\"4.0922\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":21,\"x_axis\":107,\"page\":28,\"ger\":\"Daß in einem Satz die Verneinung vorkommt ist noch kein Merkmal seines Sinnes. ( ~~p=p). \",\"pmc\":\"The occurrence of negation in a proposition is not enough to characterize its sense (~~p = p).\",\"ogd\":\"\",\"str\":\"That negation occurs in a proposition is not a characteristic mark of its sense (~~p = p).\",\"tlp\":[4.0621]},{\"label\":\"4.0923\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":21,\"x_axis\":109,\"page\":37,\"ger\":\"Die Sätze p und ~p haben entgegengesetzten Sinn aber es entspricht ihnen eine und dieselbe Wirklichkeit. \",\"pmc\":\"The propositions 'p' and '~p' have opposite sense, but there corresponds to them one and the same reality.\",\"ogd\":\"\",\"str\":\"The propositions “p” and “~p” have opposite senses, but one and the same reality corresponds to them.\",\"tlp\":[4.0621]},{\"label\":\"5.012\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":23,\"x_axis\":113,\"page\":35,\"ger\":\"Es liegt nahe die Argumente von Funktionen mit den Indexen von Namen zu verwechseln. Ich erkenne nämlich sowohl am Argument wie am Index die Bedeutung des sie enthaltenden Zeichens. In Russells 〟+c\\\" ist z.B. 〟c\\\" ein Index der darauf hinweist daß das ganze Zeichen das Additionszeichen für Kardinalzahlen ist. Aber dies beruht auf einer willkürlichen Übereinkunft und man könnte statt 〟+c\\\" auch ein einfaches Zeichen wählen: in 〟~p\\\" aber ist 〟p\\\" nicht ein Index sondern ein Argument; der Sinn von 〟~p\\\" kann nicht verstanden werden ohne daß vorher der Sinn von p verstanden worden wäre. Im Namen 〟Julius Cäsar\\\" ist 〟Julius\\\" ein Index. (Der Index ist immer ein Teil einer Beschreibung des Gegenstandes dessen Namen wir ihm anhängen. (Der Cäsar aus dem Geschlecht der Julier.)) \",\"pmc\":\"The arguments of functions are readily confused with the affixes of names. For both arguments and affixes enable me to recognize the meaning of the signs containing them. For example, when Russell writes '+c', the 'c' is an affix which indicates the sign as a whole is the addition-sign for cardinal numbers. But that is the result of an arbitrary convention and it would be quite possible to choose a simple sign instead of '+c'; in '~p', however, 'p' is not an affix but an argument; the sense of '~p' cannot be understood unless the sense of p has been understood already. In the name 'Julius Caesar' 'Julius' is an affix. (An affix is always part of a description of the object to whose name we attach it. (The Caesar of the Julian gens.))\",\"ogd\":\"\",\"str\":\"It is quite natural to confuse the arguments of functions with the indexes of names. For I recognize equally well from the argument and the index what is meant by the signs containing them. In Russell’s “+c”, for instance, “c” is an index indicating that the whole  sign is the addition sign for cardinal numbers. But that is due to an arbitrary convention and we could have chosen a simple sign instead of “+c”; in “~p”, however, “p” is not an index but an argument; the sense of “~p” cannot be understood unless one already understands the sense of p. In the name “Julius Caesar” “Julius” is an index. (An index is always part of a description of the object to whose name we attach it. (The Caesar of the Julian gens.))\",\"tlp\":[5.02]},{\"label\":\"5.022\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":23,\"x_axis\":115,\"page\":77,\"ger\":\"Das ist die Grundlage der Wahrscheinlichkeitslehre. \",\"pmc\":\"That is the foundation of the theory of probability.\",\"ogd\":\"\",\"str\":\"That is the foundation for the theory of probability.\",\"tlp\":[5.1]},{\"label\":\"5.041021\",\"precision\":6,\"fontSize\":\"18px\",\"y_axis\":23,\"x_axis\":123,\"page\":31,\"ger\":\"Wenn ein Gott eine Welt erschafft, worin gewisse Sätze wahr sind, so schafft er damit auch schon eine Welt in welcher alle Folgesätze stimmen. Und ähnlich könnte er keine Welt schaffen worin der Satz p wahr ist ohne seine sämtlichen Gegenstände zu schaffen.\",\"pmc\":\"If a god creates a world in which certain propositions are true, then by that very act he also creates a world in which all the propositions that follow come true. And similarly he could not create a world in which the proposition p was true without creating all its objects.\",\"ogd\":\"\",\"str\":\"If a god creates a world in which certain propositions are true, he thereby creates a world in which all the propositions that follow from them are true. And similarly he could not create a world in which proposition p was true without creating all its objects.\",\"tlp\":[5.123]},{\"label\":\"5.041031\",\"precision\":6,\"fontSize\":\"18px\",\"y_axis\":23,\"x_axis\":125,\"page\":61,\"ger\":\"〟p·q\\\" ist einer der Sätze welche 〟p\\\" bejahen und zugleich einer der Sätze welche 〟q\\\" bejahen. \",\"pmc\":\" 'p.q' is one of the propositions that affirm 'p' and at the same time one of the propositions that affirm 'q'.\",\"ogd\":\"\",\"str\":\"“p.q” is one of the propositions that affirm “p” while also being one of the propositions that affirm “q”.\",\"tlp\":[5.1241]},{\"label\":\"5.082\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":23,\"x_axis\":131,\"page\":37,\"ger\":\"Die Kontradiktion ist die äußere Grenze der Sätze, die Tautologie ist ihr substanzloser Mittelpunkt.\",\"pmc\":\"Contradiction is the outer limit of propositions: tautology is the unsubstantial point at their centre.\",\"ogd\":\"\",\"str\":\"Contradiction is the outer limit of propositions, tautology their substanceless centre.\",\"tlp\":[5.143]},{\"label\":\"5.092\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":23,\"x_axis\":133,\"page\":78,\"ger\":\"So ist die Wahrscheinlichkeit eine Verallgemeinerung. \",\"pmc\":\"It is in this way that probability is a generalization.\",\"ogd\":\"\",\"str\":\"Thus probability is a generalization.\",\"tlp\":[5.156]},{\"label\":\"6.112\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":23,\"x_axis\":149,\"page\":64,\"ger\":\"Damit Sätze auf bestimme Art und Weise verknüpft eine Tautologie ergeben, dazu müssen sie bestimmte Eigenschaften der Struktur haben. Daß sie so verbunden eine Tautologie ergeben zeigt also daß sie diese Eigenschaften der Struktur besitzen. \",\"pmc\":\"If propositions are to yield a tautology when they are connected in a certain way, they must have certain structural properties. So their yielding a tautology when combined in this way shows that they possess these structural properties.\",\"ogd\":\"\",\"str\":\"If propositions are to yield a tautology when they are connected in a certain way, they must have certain structural properties. That they yield a tautology when combined in this way shows therefore that they possess these structural properties.\",\"tlp\":[6.12]},{\"label\":\"6.1121\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":23,\"x_axis\":151,\"page\":67,\"ger\":\"Daß z.B. p und ~p einander widersprechen zeigt sich an der Tautologie 〟~(p·~p)\\\". \",\"pmc\":\"For example, the fact that p and ~p contradict one another is manifest in the tautology '~(p.~p)'.\",\"ogd\":\"\",\"str\":\"For example, that p and ~p contradict one another shows itself in the tautology “~(p .~p)”.\",\"tlp\":[6.1201]},{\"label\":\"6.11211\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":25,\"x_axis\":151,\"page\":67,\"ger\":\"Es ist jetzt klar daß es nicht, wie Russell meinte; für jede 〟Type\\\" ein eigenes 〟Gesetz des Widerspruchs\\\" geben muß, sondern daß eines genügt, da es auf sich selbst nicht angewendet werden braucht.\",\"pmc\":\"It is now clear that there need not be, as Russell thought, a special \\\"law of contradiction\\\" for each 'type'; that one law is enough, since it need not be applied to itself.\",\"ogd\":\"\",\"str\":\"It is now clear that there need not be, as Russell thought, a special 'law of contradiction' for each 'type'; rather, that one law is enough, since it need not be applied to itself.\",\"tlp\":[6.123]},{\"label\":\"6.121\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":23,\"x_axis\":165,\"page\":65,\"ger\":\"Ergeben z.B. zwei Sätze p und q in der Verbindung p ⊃ q eine Tautologie so ist klar daß dann q aus p folgt. Daß z.B. 〟q\\\" aus 〟p ⊃ q·p\\\" folgt ersehen wir aus jenen beiden Sätzen selbst aber wir können es auch so zeigen indem wir sie zu 〟p ⊃ q·p .⊃. q\\\" verbinden und nun zeigen daß dies eine Tautologie ist. \",\"pmc\":\"If, for example, two propositions p and q in the combination p⊃q yield a tautology, then it is clear in that case q follows from p.<br />For example, we see from the two propositions themselves that 'q' follows from 'p⊃q.p', but it is also possible to show it in this way: we combine them to form 'p⊃q.p.⊃.q', and then show that this is a tautology.\",\"ogd\":\"\",\"str\":\"If, for example, two propositions p and q combine in p⊃q to yield a tautology, then clearly q follows from p. For instance, that “q” follows from “p⊃q.p” can be seen from the two propositions themselves, but we can also show it by combining them to form “p⊃q.p.⊃.q”, and then showing that this is a tautology.\",\"tlp\":[6.1221]},{\"label\":\"6.1211\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":23,\"x_axis\":167,\"page\":65,\"ger\":\"Die logischen Sätze demonstrieren die logischen Eigenschaften der Sätze indem sie sie zu nichtssagenden Sätzen verbinden. \",\"pmc\":\"Logical propositions demonstrate the logical properties of propositions by combining them so as to form propositions that say nothing.\",\"ogd\":\"\",\"str\":\"Logical propositions demonstrate the logical properties of propositions, by combining them into propositions that say nothing.\",\"tlp\":[6.121]},{\"label\":\"6.1212\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":23,\"x_axis\":169,\"page\":65,\"ger\":\"Diese Methode könnte man auch eine Nullmethode nennen: Im logischen Satz werden Sätze mit einander in's Gleichgewicht gebracht und der Zustand des Gleichgewichts zeigt dann an wie diese Sätze logisch beschaffen sein müssen. \",\"pmc\":\"This method could also be called a zero-method. In a logical proposition, propositions are brought into equilibrium with one another, and the state of equilibrium then indicates what the logical constituttion of these propositions must be.\",\"ogd\":\"\",\"str\":\"This method could also be called a zero-method. In a logical proposition, propositions are brought into equilibrium with one another, and the state of equilibrium then shows how these propositions must be logically composed.\",\"tlp\":[6.121]},{\"label\":\"6.1213\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":23,\"x_axis\":171,\"page\":65,\"ger\":\"Der sinnvolle Satz sagt etwas aus, und sein Beweis zeigt daß es so ist; in der Logik ist jeder Satz die Form eines Beweises. \",\"pmc\":\"A proposition that has sense states something, which is shown by its proof to be so. In logic every proposition is the form of a proof.\",\"ogd\":\"\",\"str\":\"A proposition that has sense says that something is the case, and its proof shows that it is so. In logic every proposition is the form of a proof.\",\"tlp\":[6.1264]},{\"label\":\"6.1214\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":23,\"x_axis\":173,\"page\":66,\"ger\":\"Jeder logische Satz ist ein in Zeichen dargestellter Modus ponens. (Und den Modus ponens kann man nicht durch einen Satz ausdrücken). \",\"pmc\":\"Every logical proposition is a modus ponens represented in signs. (And one cannot express the modus ponens by means of a proposition.)\",\"ogd\":\"\",\"str\":\"Every logical proposition is a modus ponens represented in signs. (And the modus ponens cannot be expressed by a proposition.)\",\"tlp\":[6.1264]},{\"label\":\"6.1215\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":23,\"x_axis\":175,\"page\":68,\"ger\":\"Nun wird klar warum man oft fühlte, als wären die 〟logischen Wahrheiten\\\" von uns zu 〟fordern\\\": wir können sie nämlich insofern fordern als wir eine genügende Notation fordern können. \",\"pmc\":\"Now it becomes clear why people have often felt as if it were for us to 'postulate' the 'truths of logic'. The reason is that we can postulate them in so far as we can postulate an adequate notation.\",\"ogd\":\"\",\"str\":\"Now it becomes clear why people have often felt as though “logical truths” must be “postulated” by us. Namely, we can postulate them in so far as we can postulate an adequate notation.\",\"tlp\":[6.1223]},{\"label\":\"6.1216\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":23,\"x_axis\":177,\"page\":66,\"ger\":\"Es wird jetzt auch klar warum die Logik die Lehre von den Formen und vom Schließen genannt wurde.\",\"pmc\":\"It also becomes clear why logic was called the theory of forms and of inference.\",\"ogd\":\"\",\"str\":\"Now it also becomes clear why logic was called the theory of forms and of inference.\",\"tlp\":[6.1224]},{\"label\":\"2.2\",\"precision\":1,\"fontSize\":\"40px\",\"y_axis\":25,\"x_axis\":9,\"page\":3,\"ger\":\"Das Bild hat mit dem Abgebildeten die logische Form der Abbildung gemein.\",\"pmc\":\"A picture has logico-pictorial form in common with what it depicts.\",\"ogd\":\"\",\"str\":\"What a picture shares with what it depicts is the logical form of depiction.\",\"tlp\":[2.2]},{\"label\":\"2.201\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":25,\"x_axis\":11,\"page\":6,\"ger\":\"Das Bild bildet die Wirklichkeit ab, indem es eine Möglichkeit des Bestehens und nicht Bestehens von Sachverhalten darstellt.\",\"pmc\":\"A picture depicts reality by representing a possibility of existence and non-existence of states of affairs.\",\"ogd\":\"\",\"str\":\"A picture depicts reality by representing a possibility of existence and non-existence of elementary facts.\",\"tlp\":[2.201]},{\"label\":\"2.202\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":25,\"x_axis\":13,\"page\":6,\"ger\":\"Das Bild stellt eine mögliche Sachlage im logischen Raum dar.\",\"pmc\":\"A picture represents a possible situation in logical space.\",\"ogd\":\"\",\"str\":\"A picture represents a possible situation in logical space.\",\"tlp\":[2.202]},{\"label\":\"2.203\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":25,\"x_axis\":15,\"page\":6,\"ger\":\"Das Bild enthält die Möglichkeit der Sachlage, die es darstellt. \",\"pmc\":\"A picture contains the possibility of the situation that it represents.\",\"ogd\":\"\",\"str\":\"A picture contains the possibility of the situation that it represents.\",\"tlp\":[2.203]},{\"label\":\"2.1512\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":25,\"x_axis\":19,\"page\":14,\"ger\":\"Das Bild ist so mit der Wirklichkeit verknüpft, es reicht bis zu ihr.\",\"pmc\":\"That is how a picture is attached to reality; it reaches right out to it.\",\"ogd\":\"\",\"str\":\"In this way a picture makes contact with, or reaches out to, reality.\",\"tlp\":[2.1511]},{\"label\":\"2.172\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":25,\"x_axis\":25,\"page\":14,\"ger\":\"Das Bild kann jede Wirklichkeit abbilden, deren Form es hat. \",\"pmc\":\"A picture can depict any reality whose form it has.<br />A spatial picture can depict anything spatial, etc.\",\"ogd\":\"\",\"str\":\"A picture can depict any reality whose form it has. A spatial picture, anything spatial, etc.\",\"tlp\":[2.171]},{\"label\":\"2.182\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":25,\"x_axis\":27,\"page\":6,\"ger\":\"Jedes Bild ist auch ein logisches. (Dagegen ist z.B. nicht jedes Bild ein räumliches.)\",\"pmc\":\"Every picture is at the same time a logical one. (On the other hand, not every picture is, for example, a spatial one.)\",\"ogd\":\"\",\"str\":\"Every picture is also a logical one. (On the other hand, not every picture is, for example, a spatial one.)\",\"tlp\":[2.182]},{\"label\":\"3.20102\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":25,\"x_axis\":47,\"page\":44,\"ger\":\"Die Analyse der Zeichen muß einmal zu einem Ende kommen, weil die Zeichen, wenn sie überhaupt etwas ausdrücken sollen, auf eine ein für allemal fertige Weise bedeuten müssen. \",\"pmc\":\"The analysis of signs must come to an end at some point, because if signs are to express anything at all, meaning must belong to them in a way that is once and for all complete.\",\"ogd\":\"\",\"str\":\"The analysis of signs must come to an end at some point, because if signs are to express anything at all, meaning must belong to them in a way that is once and for all complete.\",\"tlp\":[\"None\"]},{\"label\":\"3.2012\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":25,\"x_axis\":49,\"page\":29,\"ger\":\"Es kann nie das gemeinsame Merkmal zweier Gegenstände anzeigen, daß wir sie mit demselben Namen, aber durch zwei verschiedene Bezeichnungsweisen bezeichnen. Denn der Name ist ja willkürlich; man könnte also auch zwei verschiedene Namen wählen, und wo bliebe dann das Gemeinsame in der Bezeichnung. \",\"pmc\":\"It can never indicate the common characteristic of two objects that we designate them by the same name but by means of two different modes of designation.<br />For the name, of course, is arbitrary. So we could choose two different names instead, and then what would be left in common on the signifying side?\",\"ogd\":\"\",\"str\":\"Signifying two objects by the same name but using two different modes of signification can never indicate a common characteristic. \\rFor the name is of course arbitrary. So we could choose two different names instead, and then where would there be what was in common in the signifying?\",\"tlp\":[3.322]},{\"label\":\"3.20121\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":25,\"x_axis\":51,\"page\":24,\"ger\":\"Den Satz sowie jeden Teil eines solchen, nenne ich kurz 〟Symbol\\\".\",\"pmc\":\"For the sake of brevity I call a proposition as well as any part of a proposition a symbol.\",\"ogd\":\"\",\"str\":\"To put it concisely: I call a proposition as well as any part of a proposition a symbol.\",\"tlp\":[3.31]},{\"label\":\"3.20122\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":25,\"x_axis\":53,\"page\":24,\"ger\":\"Jedes Symbol ist ein Satz oder ein Teil eines Satzes also das was Sätze mit einander gemein haben.\",\"pmc\":\"Every symbol is a proposition or a part of a proposition: thus symbols are what propositions can have in common with one another.\",\"ogd\":\"\",\"str\":\"Every symbol is a proposition or a part of a proposition: thus symbols are what propositions have in common with one another.\",\"tlp\":[3.31]},{\"label\":\"3.202111\",\"precision\":6,\"fontSize\":\"18px\",\"y_axis\":25,\"x_axis\":59,\"page\":90,\"ger\":\"Obwohl jedes Wort über seine Definitionen bedeutet so heißt das doch nur so viel, daß diese Definitionen nötig sind um in der Zeichensprache darzustellen, wie der Gedanke den das Wort ausdrücken hilft, durch die Sprache vollständig abgebildet wird. Die Definitionen können aber auch verschwiegen werden und das Wort verliert dadurch seine Bedeutung nicht, denn es steht ja trotzdem in derselben Beziehung zu den Gegenständen, die durch die Definition abgebildet wird, nur daß wir diese Beziehung nicht eigens abbilden. Hierdurch wird natürlich die Zeichensprache oft vereinfacht, ihr Verständnis immer erschwert, denn das Maßgebende liegt nun außerhalb der Zeichen in der nicht ausgedrückten Beziehung zu ihren Gegenständen. \",\"pmc\":\"Although every word has meaning via its definitions, this only means that these definitions are necessary in order to present in our sign-language the full linguistic depiction of the thought to whose expression the word contributes. But the definitions can be left tacit and the word does not then lose its meaning, since it still stands in the same relation to the objects which are depicted by means of the definitions - only we do not specifically depict that relation. Naturally this often simplifies the sign-language and makes the understanding of it more and more difficult, because the decisive factor now lies outside the signs in something that is not expressed - their relation to their objects.\",\"ogd\":\"\",\"str\":\"Although every word has meaning via its definitions, this only means that these definitions are necessary to present in our sign language the full linguistic depiction of the thought to whose expression the word contributes. But the definitions can be left tacit and the word does not then lose its meaning, since it still stands in the same relation to the objects depicted by means of the definitions - only we do not specifically depict that relation. Naturally this often simplifies the sign language and makes understanding it much harder, for the decisive factor now lies outside the signs in the unstated relation to their objects.\",\"tlp\":[\"None\"]},{\"label\":\"4.1\",\"precision\":1,\"fontSize\":\"40px\",\"y_axis\":25,\"x_axis\":67,\"page\":3,\"ger\":\"Der Satz stellt das Bestehen und nicht Bestehen der Sachverhalte dar. \",\"pmc\":\"Propositions represent the existence and non-existence of states of affairs.\",\"ogd\":\"\",\"str\":\"A proposition represents the obtaining or non-obtaining of elementary facts.\",\"tlp\":[4.1]},{\"label\":\"4.1001\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":25,\"x_axis\":70,\"page\":8,\"ger\":\"Die Gesamtheit der wahren Sätze ist die Weltbeschreibung.\",\"pmc\":\"The totality of true propositions is the description of the world.\",\"ogd\":\"\",\"str\":\"The totality of true propositions is a world description.pt\",\"tlp\":[\"None\"]},{\"label\":\"4.024\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":25,\"x_axis\":87,\"page\":15,\"ger\":\"Und er sagt, daß es sich so verhält.\",\"pmc\":\"And it says that they do so stand.\",\"ogd\":\"\",\"str\":\"And it says that that is how they are.\",\"tlp\":[4.022]},{\"label\":\"4.02321\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":25,\"x_axis\":91,\"page\":47,\"ger\":\"Wie die Beschreibung eines Gegenstandes nach seinen externen Eigenschaften so beschreibt der Satz die Wirklichkeit nach ihren internen Eigenschaften. \",\"pmc\":\"Just as a description of an object describes it by giving its external properties, so a proposition describes reality by its internal properties.\",\"ogd\":\"\",\"str\":\"Just as a description describes an object by its external properties, so a proposition describes reality by its internal properties.\",\"tlp\":[4.023]},{\"label\":\"4.074\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":29,\"x_axis\":97,\"page\":48,\"ger\":\"Die beiden müssen die gleiche logische (mathematische) Mannigfaltigkeit besitzen. (Vergl. Hertz' 〟Mechanik\\\") \",\"pmc\":\"The two must possess the same logical (mathematical) multiplicity. (Compare Hertz's Mechanics.)\",\"ogd\":\"\",\"str\":\"They must both possess the same logical (mathematical) multiplicity. (Compare Hertz's Mechanics.)\",\"tlp\":[4.04]},{\"label\":\"4.0741\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":29,\"x_axis\":99,\"page\":96,\"ger\":\"Diese mathematische Mannigfaltigkeit kann man natürlich nicht selbst wieder abbilden, da jedes Bild von ihr diese Mannigfaltigkeit selbst besitzen muß. Aus ihr kann man beim Abbilden nicht heraus. \",\"pmc\":\"This mathematical multiplicity, of course, cannot itself be the subject of depiction because any picture of it must itself possess that multiplicity. One cannot get away from it when depicting.\",\"ogd\":\"\",\"str\":\"Naturally, this mathematical multiplicity cannot itself be depicted because any picture of it must have that multiplicity itself. One cannot get away from it when depicting.\",\"tlp\":[4.041]},{\"label\":\"4.0742\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":29,\"x_axis\":101,\"page\":76,\"ger\":\"Wollten wir das, was wir durch 〟(x)·fx\\\" ausdrücken, z.B. durch Vorsetzen eines Indexes vor 〟fx\\\" ausdrücken — etwa so 〟Alg·fx\\\", es würde nicht genügen — wir wüßten nicht was verallgemeinert wurde.<br />Wollten wir es durch einen Index am 〟x\\\" anzeigen — etwa so 〟f(xa)\\\" — es würde auch nicht genügen — wir wüßten nicht den Bereich der Allgemeinheitsbezeichnung.<br />Wollten wir es durch Einführen einer Marke in die Argumentstellen versuchen — etwa so 〟(A,A)·F(A,A)\\\" — es würde nicht genügen — wir könnten die Identität der Variablen nicht feststellen — u.s.w.<br />Alle diese Bezeichnungsweisen genügen nicht, weil sie nicht die notwendige mathematische Mannigfaltigkeit haben.\",\"pmc\":\"If we wanted to express what we now write as '(x).fx', say, by putting an affix in front of 'fx' - for instance by writing 'Gen.fx' - it would not be adequate: we should not know what was being generalized.<br />If we wanted to signalize it with an affix attached to the 'x' - for instance by writing '(xg)' - that would not be adequate either: we should not know the scope of the generality-sign.<br />If we were to try to do it by introducing a mark into the argument places -for instance, by writing '(G, G).F(G, G)' - it would not be adequate: we should not be able to establish the identity of the variables. And so on.<br />All these modes of signifying are inadequate because they lack the necessary mathematical multiplicity.\",\"ogd\":\"\",\"str\":\"If we wanted to express what is expressed by “(x).fx”, say by putting an index in front of “fx” such as “Gen.fx” - it would not work, for we would not know what was generalized.\\rIf we tried to indicate it by adding an index to the “x” - for instance by writing “f(xg)” – it still would not work, for we would not know the scope of the generality sign.\\rIf we tried to do it by introducing a mark into the argument places – such as “(G, G).F (G, G)” - it would not work: we could not determine the identity of the variables. And so on.\\rAll these ways of signifying are inadequate because they do not have the necessary mathematical multiplicity.\",\"tlp\":[4.0411]},{\"label\":\"4.0743\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":29,\"x_axis\":103,\"page\":77,\"ger\":\"Aus demselben Grund genügt die idealistische Erklärung des Sehens der räumlichen Beziehungen durch die 〟Raumbrille\\\" nicht, weil sie nicht die Mannigfaltigkeit dieser Beziehungen erklären kann. \",\"pmc\":\"For the same reason the idealist's appeal to 'spatial spectacles' is inadequate to explain the seeing of spatial relations, because it cannot explain the multiplicity of these relations.\",\"ogd\":\"\",\"str\":\"Likewise, the idealist's explanation of the seeing of spatial relations through “spatial glasses” does not work, because it cannot explain the multiplicity of these relations.\",\"tlp\":[4.0412]},{\"label\":\"4.094\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":23,\"x_axis\":103,\"page\":29,\"ger\":\"Ein Bild zur Erklärung des Wahrheitsbegriffes: Schwarzer Fleck auf weißem Papier. Die Form des Fleckes kann man beschreiben indem man für jeden Punkt der Fläche angibt, ob er weiß oder schwarz ist. Der Tatsache daß ein Punkt schwarz ist entspricht eine positive — der, daß ein Punkt weiß (nicht schwarz) ist eine negative Tatsache. Bezeichne ich einen Punkt der Fläche (einen Fregeschen Wahrheitswert), so entspricht dies der Annahme die zur Beurteilung aufgestellt wird etc. etc.<br />Um aber sagen zu können ein Punkt sei schwarz oder weiß, muß ich vorerst wissen wann man einen Punkt schwarz und wann man ihn weiß nennt; um sagen zu können 〟p\\\" ist wahr (oder falsch) muß ich bestimmt haben unter welchen Umständen ich p wahr nenne, und damit bestimme ich den Sinn des Satzes.<br />Der Punkt an dem das Gleichnis hinkt ist nun der: Wir können auf einen Punkt des Papiers zeigen auch ohne zu wissen was weiß und schwarz ist; einem Satz ohne Sinn aber entspricht gar nichts, denn er bezeichnet kein Ding (Wahrheitswert) dessen Eigenschaften etwa 〟falsch\\\" oder 〟wahr\\\" hießen; das Verbum eines Satzes ist nicht 〟ist wahr\\\" oder 〟ist falsch\\\" — wie Frege glaubte —, sondern das was 〟wahr ist\\\" muß das Verbum schon enthalten.\",\"pmc\":\"An analogy to illustrate the concept of truth: imagine a black spot on white paper. You can describe the shape of the spot by saying, for each point on the sheet, whether it is black or white. To the fact that a point is black there corresponds a positive fact, and to the fact that a point is white (not black), a negative fact. If I designate a point on the sheet (a truth-value according to Frege), then this corresponds to the supposition that is put forward for judgment, etc. etc.<br />But in order to be able to say that a point is black or white, I must first know when a point is called black, and when white: in order to be able to say, 'p' is true (or false), I must have determined in what circumstances I call p true, and in so doing I determine the sense of the proposition.<br />Now the point where the simile breaks down is this: we can indicate a point on the paper even if we do not know what black and white are, but if a proposition has no sense, nothing corresponds to it, since it does not designate a thing (a truth-value) which might have properties called 'false' or 'true'. The verb of a proposition is not 'is true' or 'is false', as Frege thought: rather, that which 'is true' must already contain the verb.\",\"ogd\":\"\",\"str\":\"An analogy to illustrate the concept of truth.  A black spot on white paper; the form of the spot can be described by saying for each point on the sheet whether it is black or white. To the fact that a point is black there corresponds a positive fact, and to the fact that a point is white (not black), a negative fact. If I designate a point on the sheet (a Fregean truth-value), then this corresponds to the supposition that is put forward for judgment, etc. etc.\\rHowever, to be able to say that a point is black or white, I must first know when a point is called black, and when white: I cannot say “p” is true (or false) unless I have determined in what circumstances I call p true, and in so doing I determine the sense of the proposition.\\rNow the point where the simile breaks down is this: we can pick a point on the paper even if we don’t know what black and white are, but if a sentence makes no sense, nothing at all corresponds to it, for it designates no thing (a truth-value) which might have properties called “false” or “true”. The verb of a proposition is not “is true” or “is false”, as Frege thought: rather, that which “is true” must already contain the verb.\",\"tlp\":[4.063]},{\"label\":\"5.013\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":25,\"x_axis\":113,\"page\":39,\"ger\":\"Die Verwechslung von Argument und Index liegt, wenn ich mich nicht irre, der Theorie Freges von der Bedeutung der Sätze und Funktionen zugrunde. Für Frege waren die Sätze der Logik Namen und deren Argumente die Indexe dieser Namen. \",\"pmc\":\"If I am not mistaken, Frege's theory about the meaning of propositions and functions is based on the confusion between an argument and an affix. Frege regarded the propositions of logic as names, and their arguments as the affixes for those names.\",\"ogd\":\"\",\"str\":\"If I am not mistaken, Frege's theory about the meaning of propositions and functions is based on the confusion between an argument and an index. For Frege the propositions of logic are names and their arguments are the indexes for those names.\",\"tlp\":[5.02]},{\"label\":\"5.023\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":25,\"x_axis\":115,\"page\":77,\"ger\":\"Sei in einem Schema II Wr die Anzahl der 〟W\\\" in der Kolonne des Satzes r; Wrs die Anzahl derjenigen 〟W\\\" in der Kolonne des Satzes s die in gleichen Reihen mit 〟W\\\" in der Kolonne von r stehen. Der Satz 〟r\\\" gibt dann dem Satz s die Wahrscheinlichkeit Wrs/Wr.\",\"pmc\":\"In a schema like II, let Tr be the number of 'T's' in the column of the proposition r, and let Trs be the number of 'T's' in the column of the proposition s that stand in rows in which the column of the proposition r has 'T's'. Then the proposition 'r' gives to the proposition s the probability Trs/Tr.\",\"ogd\":\"\",\"str\":\"In a schema like II, let Tr be the number of “T's” in the column of the proposition r, and let Trs be the number of “T's” in the column of the proposition s that stand in rows in which the column of the proposition r has “T's”. Then the proposition “r” gives to the proposition s the probability Trs/Tr.\",\"tlp\":[5.151]},{\"label\":\"5.0411\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":25,\"x_axis\":121,\"page\":16,\"ger\":\"Daß ein Satz aus einem anderen folgt, ersehen wir aus der Struktur der Sätze. \",\"pmc\":\"When one proposition follows from another, we can see this from the structure of the propositions.\",\"ogd\":\"\",\"str\":\"That one proposition follows from another we see from the structure of the propositions.\",\"tlp\":[5.13]},{\"label\":\"5.0412\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":25,\"x_axis\":123,\"page\":16,\"ger\":\"Folgt p aus q so kann ich aus q auf p schließen, p aus q folgern.\",\"pmc\":\"If p follows from q, I can make an inference from q to p, deduce p from q.\",\"ogd\":\"\",\"str\":\"If p follows from q, I can infer from q to p, deduce p from q.\",\"tlp\":[5.132]},{\"label\":\"5.0413\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":25,\"x_axis\":125,\"page\":17,\"ger\":\"Die Art des Schlusses ist allein aus den beiden Sätzen zu entnehmen. \",\"pmc\":\"The nature of inference can be gathered only from the two propositions.\",\"ogd\":\"\",\"str\":\"The method of inference can only be drawn from the two propositions.\",\"tlp\":[5.132]},{\"label\":\"5.0414\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":25,\"x_axis\":127,\"page\":17,\"ger\":\"Nur sie selbst können den Schluß rechtfertigen.\",\"pmc\":\"They themselves are the only possible justification of the inference.\",\"ogd\":\"\",\"str\":\"Only they themselves can justify the inference.\",\"tlp\":[5.132]},{\"label\":\"5.0415\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":25,\"x_axis\":129,\"page\":16,\"ger\":\"Alles Folgern geschieht a priori.\",\"pmc\":\"All deductions are made a priori.\",\"ogd\":\"\",\"str\":\"All deductions takes place a priori.\",\"tlp\":[5.133]},{\"label\":\"5.093\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":25,\"x_axis\":133,\"page\":78,\"ger\":\"Sie involviert eine allgemeine Beschreibung einer Satzform. \",\"pmc\":\"It involves a general description of a propositional form.\",\"ogd\":\"\",\"str\":\"It involves a general description of a propositional form.\",\"tlp\":[5.156]},{\"label\":\"5.0931\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":25,\"x_axis\":135,\"page\":78,\"ger\":\"Nur in Ermanglung der Gewißheit gebrauchen wir die Wahrscheinlichkeit. Wenn wir zwar eine Tatsache nicht vollkommen kennen aber wohl etwas über ihre Form wissen.\",\"pmc\":\"We use probability only in default of certainty - if our knowledge of fact is not indeed complete, but we do know something about its form.\",\"ogd\":\"\",\"str\":\"We use probability only in place of certainty - if our knowledge of a fact is incomplete, but we do know something about its form.\",\"tlp\":[5.156]},{\"label\":\"5.0932\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":25,\"x_axis\":137,\"page\":78,\"ger\":\"Es gibt keine besondere logische Konstante die den Wahrscheinlichkeitssätzen eigen wäre. \",\"pmc\":\"There is no special logical constant peculiar to probability propositions.\",\"ogd\":\"\",\"str\":\"There is no special logical constant unique to probability propositions.\",\"tlp\":[5.1511]},{\"label\":\"5.0933\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":25,\"x_axis\":139,\"page\":78,\"ger\":\"Der Wahrscheinlichkeitssatz ist gleichsam ein Auszug aus Elementarsätzen. \",\"pmc\":\"A probability proposition is a sort of excerpt from elementary propositions.\",\"ogd\":\"\",\"str\":\"A probability proposition is, as it were, an excerpt from elementary propositions.\",\"tlp\":[5.156]},{\"label\":\"5.0934\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":25,\"x_axis\":141,\"page\":78,\"ger\":\"Was sich in den Sätzen über Wahrscheinlichkeit durch das Experiment bestätigen läßt kann nicht Mathematik sein. \",\"pmc\":\"Anything in propositions about probability that can be confirmed by experiment cannot be mathematical.\",\"ogd\":\"\",\"str\":\"Anything in propositions about probability that can be confirmed by experiment cannot be mathematical.\",\"tlp\":[5.154]},{\"label\":\"6.1122\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":23,\"x_axis\":153,\"page\":68,\"ger\":\"Es ist klar daß man zu demselben Zweck statt der Tautologien auch die Kontradiktionen verwenden könnte. \",\"pmc\":\"It is clear that one could achieve the same purpose by using contradictions instead of tautologies.\",\"ogd\":\"\",\"str\":\"Clearly we could have used for this purpose contradictions instead of tautologies.\",\"tlp\":[6.1202]},{\"label\":\"6.12111\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":25,\"x_axis\":167,\"page\":68,\"ger\":\"Dies wirft ein Licht auf die Frage, warum die logischen Sätze nicht durch die Erfahrung bestätigt werden können ebensowenig wie sie durch die Erfahrung widerlegt werden können. Nicht nur muß ein Satz der Logik durch keine mögliche Erfahrung widerlegt werden können, sondern er darf auch nicht durch eine solche bestätigt werden können. \",\"pmc\":\"This throws some light on the question why logical propositions cannot be confirmed by experience any more than they can be refuted by it. Not only must a proposition of logic be irrefutable by any possible experience, it must also be unconfirmable by any possible experience.\",\"ogd\":\"\",\"str\":\"This throws light on the question why logical propositions can no more be confirmed by experience than they can be refuted by it. Not only must a proposition of logic be  incapable of being contradicted by any possible experience, it must likewise be unconfirmable by any possible experience.\",\"tlp\":[6.1222]},{\"label\":\"2.21\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":27,\"x_axis\":11,\"page\":4,\"ger\":\"Das Bild stimmt mit der Wirklichkeit überein oder nicht; es ist richtig oder unrichtig, wahr oder falsch. \",\"pmc\":\"A picture agrees with reality or fails to agree; it is correct or incorrect, true or false.\",\"ogd\":\"\",\"str\":\"A picture agrees with reality or fails to agree; it is correct or incorrect, true or false.\",\"tlp\":[2.21]},{\"label\":\"2.22\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":27,\"x_axis\":13,\"page\":4,\"ger\":\"Das Bild stellt dar, was es darstellt, unabhängig von seiner Wahr- oder Falschheit, durch die Form der Abbildung.\",\"pmc\":\"What a picture represents it represents independently of its truth or falsity, by means of its pictorial form.\",\"ogd\":\"\",\"str\":\"A picture represents what it represents, independently of its truth or falsehood, by means of its form of depiction.\",\"tlp\":[2.22]},{\"label\":\"2.1513\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":27,\"x_axis\":19,\"page\":14,\"ger\":\"Es ist wie ein Maßstab an die Wirklichkeit angelegt.\",\"pmc\":\"It is laid against reality like a measure.\",\"ogd\":\"\",\"str\":\"It is applied to reality like a ruler.  \",\"tlp\":[2.1512]},{\"label\":\"2.15131\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":27,\"x_axis\":21,\"page\":14,\"ger\":\"Nur die äußersten Punkte der Teilstriche berühren den zu messenden Gegenstand.\",\"pmc\":\"Only the end-points of the graduating lines actually touch the object that is to be measured.\",\"ogd\":\"\",\"str\":\"Only the end points of the marks on the ruler touch the object being measured.\",\"tlp\":[2.15121]},{\"label\":\"2.173\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":27,\"x_axis\":25,\"page\":16,\"ger\":\"Seine Form der Abbildung aber kann das Bild nicht abbilden; es weist sie auf.\",\"pmc\":\"A picture cannot, however, depict its pictorial form: it displays it.\",\"ogd\":\"\",\"str\":\"A picture cannot, however, depict its form of depiction: it displays it.\",\"tlp\":[2.172]},{\"label\":\"3.20103\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":27,\"x_axis\":47,\"page\":60,\"ger\":\"Man könnte die Bestimmtheit auch so fordern: Wenn ein Satz Sinn haben soll, so muß vorerst die syntaktische Verwendung jedes seiner Teile festgelegt sein. — Man kann z.B. nicht erst nachträglich daraufkommen, daß ein Satz aus ihm folgt. Sondern, welche Sätze aus ihm folgen muß vollkommen feststehen, ehe dieser Satz einen Sinn haben kann. \",\"pmc\":\"The requirement of determinateness could also be formulated in the following way: if a proposition is to have sense, the syntactical employment of each of its parts must have been established in advance. For example, if cannot occur to one only subsequently that a certain proposition follows from it. Before a proposition can have a sense, it must be completely settled what propositions follow from it.\",\"ogd\":\"\",\"str\":\"The requirement of determinacy could also be put as follows: if a proposition is to have sense, the syntactic role of each of its parts must have been settled beforehand. For instance, it cannot occur to one only later on that a certain proposition follows from it. Before a proposition can have a sense, it must be completely settled what propositions follow from it.\",\"tlp\":[\"None\"]},{\"label\":\"3.2013\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":27,\"x_axis\":49,\"page\":53,\"ger\":\"Das Zeichen ist der sinnlich wahrnehmbare Teil des Symbols. Zwei verschiedene Symbole können also das Zeichen (Schriftzeichen oder Lautzeichen etc.) mit einander gemein haben — sie bezeichnen dann auf verschiedene Art und Weise. \",\"pmc\":\"A sign is the part of a symbol that can be perceived. So one and the same sign (written or spoken etc.) can be common to two different symbols - in which case they will signify in different ways.\",\"ogd\":\"\",\"str\":\"A sign is the perceptible part of a symbol. Two different symbols can therefore have one and the same sign (written or spoken etc.)  in common - in which case each will signify in a different way.\",\"tlp\":[\"3.32, 3.321\"]},{\"label\":\"3.201221\",\"precision\":6,\"fontSize\":\"18px\",\"y_axis\":27,\"x_axis\":53,\"page\":31,\"ger\":\"〟A\\\" ist der selbe Buchstabe wie 〟A\\\". Dies ist für unsere Sprache von großer Wichtigkeit. \",\"pmc\":\" 'A' is the same letter as 'A'. This is of great importance for our language.\",\"ogd\":\"\",\"str\":\"“A” is the same letter as “A”. This is of great importance for our language.\",\"tlp\":[3.203]},{\"label\":\"4.10011\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":27,\"x_axis\":70,\"page\":17,\"ger\":\"Die Gesamtheit der wahren Sätze kann man auch die gesamte Naturwissenschaft nennen (oder die Gesamtheit der Naturwissenschaften). \",\"pmc\":\"The totality of true propositions can also be called the whole of natural science (or the whole corpus of the natural sciences).\",\"ogd\":\"\",\"str\":\"The totality of true propositions can also be called the whole of natural science (or the totality of the natural sciences).pt\",\"tlp\":[4.11]},{\"label\":\"4.025\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":27,\"x_axis\":87,\"page\":31,\"ger\":\"Einen Satz verstehen heißt, wissen was der Fall ist, wenn er wahr ist.<br />Man kann ihn also verstehen ohne zu wissen ob er wahr ist. \",\"pmc\":\"To understand a proposition means to know what is the case if it is true.<br />One can understand it, therefore, without knowing whether it is true.\",\"ogd\":\"\",\"str\":\"To understand a proposition means to know what is the case if it is true.\",\"tlp\":[4.024]},{\"label\":\"4.02322\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":27,\"x_axis\":91,\"page\":47,\"ger\":\"Der Satz konstruiert eine Welt mit Hilfe seines logischen Gerüstes und darum kann man am Satz auch sehen, wie sich alles Logische verhielte, wenn er wahr wäre. Man kann aus einem falschen Satz Schlüsse ziehen. \",\"pmc\":\"A proposition constructs a world with the help of its logical scaffolding, so that one can actually see from the proposition how everything would stand in logic, if it were true. One can draw inferences from a false proposition.\",\"ogd\":\"\",\"str\":\"A proposition constructs a world with the help of its logical scaffolding, so that one can actually see from the proposition all the logical features of reality, if it is true. One can draw inferences from a false proposition.\",\"tlp\":[4.023]},{\"label\":\"4.095\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":25,\"x_axis\":103,\"page\":45,\"ger\":\"Jeder Satz muß schon Sinn haben; die Bejahung kann ihn ihm nicht geben, denn sie bejaht ja gerade den Sinn. Und dasselbe gilt von der Verneinung, etc. \",\"pmc\":\"Every proposition must already have sense: it cannot be given sense by affirmation. Indeed its sense is just what is affirmed. And the same applies to negation.\",\"ogd\":\"\",\"str\":\"Every proposition must already have sense; assertion cannot give it a sense, for its sense is just what is asserted. And the same goes for negation, etc.\",\"tlp\":[4.064]},{\"label\":\"4.0951\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":25,\"x_axis\":105,\"page\":40,\"ger\":\"Man könnte sagen: die Verneinung bezieht sich schon auf den logischen Ort, den der verneinte Satz bestimmt. Der verneinende Satz bestimmt einen anderen logischen Ort als der verneinte. \",\"pmc\":\"One could say that negation must be related to the logical place determined by the negated proposition.<br />The negating proposition determines a logical place different from that of the negated proposition.\",\"ogd\":\"\",\"str\":\"One could say: the negation must be already related to the logical place determined by the negated proposition. The negating proposition determines a different logical place from the negated proposition.\",\"tlp\":[4.0641]},{\"label\":\"4.0952\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":25,\"x_axis\":107,\"page\":40,\"ger\":\"Der verneinende Satz bestimmt seinen logischen Ort mit Hilfe des logischen Ortes des verneinten Satzes indem er jenen als außerhalb diesem liegend beschreibt.\",\"pmc\":\"The negating proposition determines its logical place with the help of the logical place of the negated proposition. For it describes it as lying outside the latter's logical place.\",\"ogd\":\"\",\"str\":\"The negating proposition determines its logical place using the logical place of the negated proposition by describing it as lying outside the latter's logical place.\",\"tlp\":[4.0641]},{\"label\":\"4.0953\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":25,\"x_axis\":109,\"page\":41,\"ger\":\"Daß man den verneinenden Satz wieder verneinen kann zeigt schon, daß das, was verneint wird, schon ein Satz, und nicht erst die Vorbereitung zu einem Satze ist. \",\"pmc\":\"The negating proposition can be negated again, and this in itself shows that what is negated is already a proposition, and not merely something that is preliminary to a proposition.\",\"ogd\":\"\",\"str\":\"That the negated proposition can be negated again shows that what is negated is already a proposition, and not just something preliminary to a proposition.\",\"tlp\":[4.0641]},{\"label\":\"5.1\",\"precision\":1,\"fontSize\":\"40px\",\"y_axis\":27,\"x_axis\":111,\"page\":10,\"ger\":\"Sind alle Sätze Wahrheitsfunktionen (W-Funktionen) von Elementarsätzen so folgt hieraus daß sie auch Wahrheitsfunktionen von einander sind. \",\"pmc\":\"If all propositions are truth-functions (T-functions) of elementary propositions, it follows that they are also truth-functions of one another.\",\"ogd\":\"\",\"str\":\"If all propositions are truth-functions of elementary propositions, it follows that they are also truth-functions of one another.\",\"tlp\":[\"None\"]},{\"label\":\"5.101\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":27,\"x_axis\":113,\"page\":32,\"ger\":\"Der Sinn einer Wahrheitsfunktion von p ist eine Funktion des Sinnes von p. \",\"pmc\":\"The sense of a truth-function of p is a function of the sense of p.\",\"ogd\":\"\",\"str\":\"The sense of a truth-function of p is a function of the sense of p.\",\"tlp\":[5.2341]},{\"label\":\"5.042\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":27,\"x_axis\":119,\"page\":12,\"ger\":\"Jeder Satz folgt aus sich selbst. \",\"pmc\":\"Every proposition follows from itself.\",\"ogd\":\"\",\"str\":\"Every proposition follows from itself.\",\"tlp\":[\"None\"]},{\"label\":\"5.04111\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":27,\"x_axis\":121,\"page\":52,\"ger\":\"Folgt ein Satz aus anderen, so wird dies durch gewisse Beziehungen ausgedrückt, in welchen die Formen jener Sätze zu einander stehen; und zwar brauchen wir sie nicht erst in diese Beziehung zu setzen, indem wir sie in einem Satz mit einander verbinden, sondern diese Beziehungen sind intern und bestehen, sobald, und dadurch daß, jene Satzzeichen bestehen. \",\"pmc\":\"If one proposition follows from others, this is expressed by certain relations in which the forms of the propositions stand to one another: nor is it necessary for us to set up this relation between them, by combining them with one another in a single proposition; on the contrary, the relations are internal, and their existence is an immediate result of the existence of the propositional signs.\",\"ogd\":\"\",\"str\":\"If one proposition follows from others, this is expressed by certain relations in which the forms of those propositions stand to one another: nor need we to set up this relation between them, by combining them with one another in a single proposition. On the contrary, the relations are internal, and  exist simultaneously with, and through, the existence of the sentential signs.\",\"tlp\":[5.131]},{\"label\":\"5.04141\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":27,\"x_axis\":127,\"page\":17,\"ger\":\"〟Schlußgesetze\\\" welche — wie bei Frege und Russell — die Schlüsse rechtfertigen sollen sind sinnlos, und wären überflüssig. \",\"pmc\":\" 'Laws of inference', which are supposed to justify inferences, as in the works of Frege and Russell, have no sense, and would be superfluous.\",\"ogd\":\"\",\"str\":\"“Laws of inference”, which—as in Frege and Russell—are supposed to justify inferences, are senseless and would be superfluous.\",\"tlp\":[5.132]},{\"label\":\"5.09311\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":27,\"x_axis\":135,\"page\":94,\"ger\":\"Ein Satz kann zwar ein unvollständiges Bild einer gewissen Sachlage sein, aber er ist immer ein vollständiges Bild. \",\"pmc\":\"A proposition may well be an incomplete picture of a certain situation, but it is always a complete picture of something.\",\"ogd\":\"\",\"str\":\"A proposition may well be an incomplete picture of a certain situation, but it is always a complete picture.\",\"tlp\":[5.156]},{\"label\":\"6.113\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":27,\"x_axis\":149,\"page\":67,\"ger\":\"Die logischen Sätze beschreiben das Gerüste der Welt, oder vielmehr, sie stellen es dar. Sie 〟handeln\\\" von nichts. Sie setzen voraus, daß Namen Bedeutung, und Elementarsätze Sinn haben: und dies ist ihre Verbindung mit der Welt. Es ist klar, daß es etwas über die Welt anzeigen muß, daß gewisse Verbindungen von Symbolen — welche notwendigerweise einen bestimmten Charakter haben — Tautologien sind. Hierin liegt das Entscheidende. Wir sagten, manches an den Zeichen die wir gebrauchen wäre willkürlich, manches nicht. In der Logik drückt nur dieses aus: das heißt aber, in der Logik drücken nicht wir mit Hilfe der Zeichen aus, was wir wollen, sondern in der Logik sagt die Natur dernaturnotwendigen Zeichen selbst aus: Wenn wir die logische Syntax irgend einer Zeichensprache kennen, dann sind bereits alle logischen Sätze gegeben. \",\"pmc\":\"The propositions of logic describe the scaffolding of the world, or rather they represent it. They have no 'subject-matter'. They presuppose that names have meaning and elementary propositions have sense; and that is their connection with the world. It is clear that something about the world must be indicated by the fact that certain combinations of symbols - which necessarily have a determinate character - are tautologies. This contains the decisive point. We have said that some things are arbitary in the signs that we use and that some things are not. In logic it is only the latter that express: but that means that logic is not a field in which we express what we wish with the help of signs, but rather one in which the nature of the natural and inevitable signs speaks for itself. If we know the logical syntax of any sign-language, then we have already been given all the logical propositions.\",\"ogd\":\"\",\"str\":\"The logical propositions describe the scaffolding of the world, or rather, they represent it. They are not “about” anything. They presuppose that names  mean something and elementary propositions make sense: and this is their connection with the world. Clearly, that certain combinations of symbols, symbols with a necessarily determinate character, are tautologies indicates something about the world. That’s the decisive point. We have said that in the signs we use, some things are arbitary, some things are not. In logic it is only the latter that express: but that means that in logic it is not we who express what we want by means of of signs, but rather in logic the nature of the inevitably necessary signs speaks for itself. If we know the logical syntax of any sign language, then all the logical propositions are already given.\",\"tlp\":[6.124]},{\"label\":\"6.1131\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":27,\"x_axis\":151,\"page\":68,\"ger\":\"Es ist möglich, und zwar auch nach der alten Logik, von vornherein eine Beschreibung aller 〟wahren\\\" logischen Sätze zu geben. \",\"pmc\":\"It is possible - indeed possible even in the old logic - to give in advance a description of all 'true' logical propositions.\",\"ogd\":\"\",\"str\":\"It is possible - indeed possible even in the old logic - to give from the start a description of all “true” logical propositions.\",\"tlp\":[6.125]},{\"label\":\"6.1132\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":27,\"x_axis\":153,\"page\":68,\"ger\":\"Darum kann es in der Logik auch nie Überraschungen geben. \",\"pmc\":\"Hence there can never be suprises in logic.\",\"ogd\":\"\",\"str\":\"Hence there can never be suprises in logic.\",\"tlp\":[6.1251]},{\"label\":\"6.1133\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":27,\"x_axis\":155,\"page\":68,\"ger\":\"Ob ein Satz der Logik angehört kann man berechnen, indem man die logischen Eigenschaften des Symbols berechnet.\",\"pmc\":\"One can calculate whether a proposition belongs to logic, by calculating the logical properties of the symbol.\",\"ogd\":\"\",\"str\":\"By calculating the logical properties of the symbol, one can calculate whether a proposition belongs to logic.\",\"tlp\":[6.126]},{\"label\":\"6.1134\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":27,\"x_axis\":157,\"page\":69,\"ger\":\"Und dies tun wir wenn wir einen logischen Satz 〟beweisen\\\". Denn ohne uns um einen Sinn oder Bedeutung zu kümmern bilden wir den logischen Satz aus anderen nach bloßen Zeichenregeln. \",\"pmc\":\"And this is what we do when we 'prove' a logical proposition. For, without bothering about sense or meaning, we construct the logical proposition out of others using only rules that deal with signs.\",\"ogd\":\"\",\"str\":\"And that’s what we do when we “prove” a logical proposition. For, without bothering about sense or meaning, we construct the logical proposition out of others using only rules for signs.\",\"tlp\":[6.126]},{\"label\":\"6.1135\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":27,\"x_axis\":159,\"page\":70,\"ger\":\"Alle Sätze der Logik sind gleichberechtigt es gibt unter ihnen nicht wesentlich Grundgesetze und abgeleitete Sätze.<br />Jede Tautologie zeigt selbst daß sie eine Tautologie ist. \",\"pmc\":\"All the propositions of logic are of equal status: it is not the case that some of them are essentially primitive propositions and others essentially derived propositions.<br />Every tautology itself shows that it is a tautology.\",\"ogd\":\"\",\"str\":\"All propositions in logic are of equal rank, rather than some being essentially primitive propositions from which others are derived. Every tautology itself shows that it is a tautology.\",\"tlp\":[6.127]},{\"label\":\"6.1136\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":27,\"x_axis\":163,\"page\":69,\"ger\":\"Immer kann man aber die Logik so auffassen daß jeder Satz sein eigener Beweis ist. \",\"pmc\":\"However it is always possible to construe logic in such a way that every proposition is its own proof.\",\"ogd\":\"\",\"str\":\"However, logic can always be conceived in such a way that every proposition is its own proof.\",\"tlp\":[6.1265]},{\"label\":\"6.12112\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":27,\"x_axis\":167,\"page\":71,\"ger\":\"Das sogenannte Gesetz der Induktion kann jedenfalls kein logisches Gesetz sein, denn es ist offenbar ein sinnvoller Satz. — Und darum kann es auch kein Gesetz a priori sein. \",\"pmc\":\"The so-called law of induction cannot possibly be a law of logic, since it is obviously a proposition with sense. Nor, therefore, can it be an a priori law.\",\"ogd\":\"\",\"str\":\"The so-called law of induction cannot possibly be a law of logic, for obviously it is a meaningful proposition. And so it cannot be an a priori law either.\",\"tlp\":[6.31]},{\"label\":\"2.221\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":29,\"x_axis\":13,\"page\":6,\"ger\":\"Was das Bild darstellt, ist sein Sinn.\",\"pmc\":\"What a picture represents is its sense.\",\"ogd\":\"\",\"str\":\"What a picture represents is its sense.\",\"tlp\":[2.221]},{\"label\":\"2.1514\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":29,\"x_axis\":19,\"page\":14,\"ger\":\"Nach dieser Auffassung gehört also zum Bild auch noch die abbildende Beziehung die es zum Bild macht.\",\"pmc\":\"So a picture, conceived in this way, also includes the pictorial relationship, which makes it into a picture.\",\"ogd\":\"\",\"str\":\"A picture, conceived in this way, also includes the pictorial relationship which makes the picture a picture.\",\"tlp\":[2.1513]},{\"label\":\"2.174\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":29,\"x_axis\":25,\"page\":17,\"ger\":\"Das Bild stellt sein Objekt von außerhalb dar, (sein Standpunkt ist seine Form der Darstellung) darum stellt das Bild sein Objekt richtig oder falsch dar. \",\"pmc\":\"A picture represents its subject from a position outside it. (Its standpoint is its representational form.) That is why a picture represents its subject correctly or incorrectly.\",\"ogd\":\"\",\"str\":\"A picture represents its subject from the outside. (Its point of view is its form of representation.) That is how it represents its subject correctly or incorrectly.\",\"tlp\":[2.173]},{\"label\":\"3.20104\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":29,\"x_axis\":47,\"page\":41,\"ger\":\"Der Satz, welcher vom Komplex handelt steht in interner Beziehung zum Satze, der von dessen Bestandteil handelt. \",\"pmc\":\"A proposition about a complex stands in an internal relation to a proposition about a constituent of the complex.\",\"ogd\":\"\",\"str\":\"A proposition about a complex stands in an internal relation to a proposition about a constituent part.\",\"tlp\":[3.24]},{\"label\":\"3.2014\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":29,\"x_axis\":49,\"page\":54,\"ger\":\"In der Umgangssprache kommt es ungemein häufig vor daß dasselbe Wort auf verschiedene Art und Weise bezeichnen — also verschiedenen Symbolen angehören — kann oder doch daß zwei Wörter die auf verschiedene Art und Weise bezeichnen äußerlich auf gleiche Art und Weise im Satze angewendet werden. \",\"pmc\":\"Now in everyday language it very frequently happens that the same word can have different modes of signification - and so belong to different symbols; or that two words that have different modes of signification are employed in propositions in what is superficially the same way.\",\"ogd\":\"\",\"str\":\"Now in ordinary language it very often happens that the same word signifies in different ways - and so belongs to different symbols - or that two words that signify in different ways are applied in sentences in what looks like the same way.\",\"tlp\":[3.323]},{\"label\":\"3.20141\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":29,\"x_axis\":51,\"page\":54,\"ger\":\"So erscheint das Wort 〟ist\\\" als Kopula, als Gleichheitszeichen und als Ausdruck der Existenz; das Wort 〟Grün\\\" als Eigenschaftswort und als Personenname; 〟Identisch\\\" wird wie ein Eigenschaftswort angewandt etc. etc.. Im Satze 〟Grün ist Grün\\\" (wo 〟ist\\\" die Kopula bedeutet) haben das erste und das letzte Wort nicht einfach verschiedene Bedeutung sondern es sind verschiedene Symbole. \",\"pmc\":\"Thus the word 'is' figures as the copula, as a sign for identity, and as an expression for existence; the word 'Green' figures as an adjective and as the proper name of a person; 'identical' is employed as an adjective, etc. etc. In the proposition 'Green is green' (when 'is' means the copula) the first word and the last do not merely have different meanings; they are different symbols.\",\"ogd\":\"\",\"str\":\"Thus the word “is” appears as a copula, as a sign for identity, and as an expression for existence; the word “Green” figures as an adjective and as the proper name of a person; “identical” is employed as an adjective, etc. etc. In the proposition “Green is green” (when “is” means the copula) not only do the first word and the last have different meanings, they are different symbols.\",\"tlp\":[3.323]},{\"label\":\"3.20142\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":29,\"x_axis\":53,\"page\":54,\"ger\":\"So entstehen leicht die fundamentalsten Verwechslungen (deren die ganze Philosophie voll ist). \",\"pmc\":\"In this way the most fundamental confusions are easily produced (the whole of philosophy is full of them).\",\"ogd\":\"\",\"str\":\"This is how the most fundamental confusions easily arise (all philosophy is full of them).\",\"tlp\":[3.324]},{\"label\":\"4.10012\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":29,\"x_axis\":70,\"page\":18,\"ger\":\"Die Philosophie ist keine der Naturwissenschaften.\",\"pmc\":\"Philosophy is not one of the natural sciences.\",\"ogd\":\"\",\"str\":\"Philosophy is not one of the natural sciences.\",\"tlp\":[4.111]},{\"label\":\"4.026\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":29,\"x_axis\":87,\"page\":32,\"ger\":\"Man versteht ihn, wenn man seine Bestandteile versteht. \",\"pmc\":\"It is understood by anyone who understands its constituents.\",\"ogd\":\"\",\"str\":\"One understands it if one understands its constituents.\",\"tlp\":[4.024]},{\"label\":\"4.0261\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":29,\"x_axis\":89,\"page\":49,\"ger\":\"Wohlgemerkt: Die Übersetzung einer Sprache in eine andere geht nicht so vor sich, daß man jeden Satz der einen in einen der anderen übersetzt, sondern nur die Satzbestandteile werden übersetzt. \",\"pmc\":\"Note that when translating one language into another, we do not proceed by translating each proposition of the one into one belonging to the other, but merely by translating the constituents of propositions.\",\"ogd\":\"\",\"str\":\"Note that translating one language into another is not a matter of translating each proposition of the one into one of the other: rather, it is only the constituents that are translated.\",\"tlp\":[4.025]},{\"label\":\"4.0262\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":29,\"x_axis\":91,\"page\":90,\"ger\":\"Und das Wörterbuch übersetzt nicht nur Substantiva sondern auch Zeit- und Eigenschafts- Bindeworte etc.; und es behandelt sie alle gleich. \",\"pmc\":\"And the dictionary translates not only substantives, but also verbs, adjectives, and conjunctions, etc.; and it treats them all in the same way.\",\"ogd\":\"\",\"str\":\"And the dictionary translates not only substantives, but also verbs, adjectives, and conjunctions, etc.; and it treats them all alike.\",\"tlp\":[4.025]},{\"label\":\"5.11\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":29,\"x_axis\":113,\"page\":10,\"ger\":\"Die Schemata haben auch dann eine Bedeutung, wenn 〟p\\\" 〟q\\\" 〟r\\\" etc. nicht Elementarsätze sind.\",\"pmc\":\"The schemata in 4.31 have a meaning even when 'p', 'q', 'r', etc. are not elementary propositions.\",\"ogd\":\"\",\"str\":\"The schemas in 4.31 are meaningful even when “p”, “q”, “r”, etc. are not elementary propositions.\",\"tlp\":[5.31]},{\"label\":\"5.12\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":29,\"x_axis\":115,\"page\":10,\"ger\":\"Und es ist leicht zu sehen, daß das Satzzeichen erster Art, auch wenn p, q etc. W-Funktionen von Elementarsätzen sind, eine W-Funktion von Elementarsätzen ausdrückt. \",\"pmc\":\"And it is easy to see that a propositional sign of the first kind expresses a single T-function of elementary propositions even when p, q, etc. are T-functions of elementary propositions.\",\"ogd\":\"\",\"str\":\"And it is easy to see that a sentential sign of the first kind expresses a single truth-function of elementary propositions even when “p”, “q”, etc. are truth-functions of elementary propositions.\",\"tlp\":[5.32]},{\"label\":\"5.043\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":29,\"x_axis\":119,\"page\":16,\"ger\":\"Aus einem Elementarsatz läßt sich kein anderer folgern.\",\"pmc\":\"One elementary proposition cannot be deduced from another.\",\"ogd\":\"\",\"str\":\"From an elementary proposition, no other can be deduced.\",\"tlp\":[5.134]},{\"label\":\"5.04112\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":29,\"x_axis\":121,\"page\":52,\"ger\":\"Wenn wir von p ∨ q und ~p auf q schließen, so ist hier durch die Bezeichnungsweise die Beziehung der Satzformen von 〟p ∨ q\\\" und 〟~p\\\" verhüllt. Schreiben wir aber statt 〟p ∨ q\\\" 〟p|q ·|· p|q\\\" und statt 〟~p\\\" 〟p|p\\\" (p|q = weder p noch q) so wird der innere Zusammenhang offenbar.\",\"pmc\":\"When we infer q from p∨q and ~p, the relation between the propositional forms of 'p∨q' and '~p' is masked, in this ase, by our mode of signifying. But if instead of 'p∨q' we write 'p|q.|.p|q', and instead of '~p', 'p|p' (p|q = neither p nor q), then the inner connection becomes obvious.\",\"ogd\":\"\",\"str\":\"When from p ∨q and ~p we infer q, the relation between the propositional forms of “p ∨q” and “~p” is concealed, by our mode of signifying. But if instead of “p ∨q” we write “p |q.|.p|q”, and instead of “~p”, “p|p” (p|q = neither p nor q), then the inner connection becomes obvious.\",\"tlp\":[5.1311]},{\"label\":\"6.11341\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":29,\"x_axis\":157,\"page\":69,\"ger\":\"Der Beweis der logischen Sätze besteht darin, daß wir sie aus anderen logischen Sätzen durch sukzessive Anwendung gewisser Operationen entstehen lassen die aus den ersten immer wieder Tautologien macht. (Und zwar folgen aus einer Tautologie nur Tautologien.)\",\"pmc\":\"The proof of logical propositions consists in the following process: we produce them out of other logical propositions by successively applying certain operations that always make further tautologies out of the initial ones. (And in fact only tautologies follow from a tautology.)\",\"ogd\":\"\",\"str\":\"Here is how we prove a logical proposition: we generate it from other logical propositions by successively applying certain operations that always produce further tautologies from the first. (And only tautologies follow from a tautology.)\",\"tlp\":[6.126]},{\"label\":\"6.113501\",\"precision\":6,\"fontSize\":\"18px\",\"y_axis\":29,\"x_axis\":159,\"page\":94,\"ger\":\"Es ist klar daß die Anzahl der 〟logischen Grundgesetze\\\" willkürlich ist denn man könnte die Logik ja aus einemGrundgesetz ableiten indem man einfach z.B. aus Freges Grundgesetzen das logische Produkt bildet. <br />(Frege hätte vielleicht gesagt daß dieses Grundgesetz nun nicht mehr unmittelbar einleuchte. Aber es ist merkwürdig daß ein so exakter Denker wie Frege sich auf den Grad des Einleuchtens als Kriterium des logischen Satzes berufen hat.)\",\"pmc\":\"It is clear that the number of the 'primitive propositions of logic' is arbitrary, since one could derive logic from a single primitive proposition, e.g. by simply constructing the logical product of Frege's primitive propositions.<br />(Frege would perhaps have said that we should then no longer have an immediately self-evident primitive proposition. But it is remarkable that a thinker as rigorous as Frege appealed to the degree of self-evidence as the criterion of a logical proposition.)\",\"ogd\":\"\",\"str\":\"It is clear that the number of “basic laws of logic” is arbitrary, since we could derive logic from a single primitive proposition simply by constructing, for example, the logical product of Frege's basic laws.\\r(Frege might say that this basic law would no longer be immediately self-evident. But what is amazing is that a thinker as precise as Frege appealed to the degree of self-evidence as a criterion of a logical proposition.)\",\"tlp\":[6.1271]},{\"label\":\"6.11351\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":29,\"x_axis\":161,\"page\":70,\"ger\":\"Der Beweis in der Logik ist nur ein mechanisches Hilfsmittel zum leichteren Erkennen der Tautologie wo sie kompliziert ist. \",\"pmc\":\"Proof in logic is merely a mechanical expedient to facilitate the recognition of tautologies in complicated cases.\",\"ogd\":\"\",\"str\":\"Proof in logic is merely a mechanical expedient enabling the recognition of a tautology in complicated cases.\",\"tlp\":[6.1262]},{\"label\":\"6.122\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":29,\"x_axis\":165,\"page\":65,\"ger\":\"Im Leben ist es ja nie der logische Satz, den wir brauchen, sondern wir benützen den logischen Satz nur um aus Sätzen welche nicht der Logik angehören auf andere zu schließen die gleichfalls nicht der Logik angehören. \",\"pmc\":\"Indeed in real life a logical proposition is never what we want. Rather, we make use of logical propositions only in inferences from propositions that do not belong to logic to others that likewise do not belong to logic.\",\"ogd\":\"\",\"str\":\"Indeed in everyday life we never need logical propositions. Rather, we make se of logical propositions only to infer from propositions that are not part of logic to others that also are not logical.\",\"tlp\":[6.211]},{\"label\":\"6.1221\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":29,\"x_axis\":167,\"page\":69,\"ger\":\"In der Philosophie führt die Frage 〟wozu gebrauchen wir eigentlich jenes Wort, jenen Satz\\\" immer wieder zu wertvollen Einsichten. \",\"pmc\":\"In philosophy the question, 'What do we actually use this word or this proposition for?' repeatedly leads to valuable insights.\",\"ogd\":\"\",\"str\":\"In philosophy the question, “How do we actually use this word or this proposition?” repeatedly leads to valuable insights.\",\"tlp\":[6.211]},{\"label\":\"2.222\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":31,\"x_axis\":13,\"page\":6,\"ger\":\"In seiner Übereinstimmung oder nicht Übereinstimmung seines Sinnes mit der Wirklichkeit besteht seine Wahrheit oder Falschheit. \",\"pmc\":\"The agreement and disagreement of its sense with reality constitutes its truth or falsity.\",\"ogd\":\"\",\"str\":\"The agreement and disagreement of its sense with reality constitutes its truth or falsehood.\",\"tlp\":[2.222]},{\"label\":\"2.1515\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":31,\"x_axis\":19,\"page\":14,\"ger\":\"Die abbildende Beziehung besteht aus den Zuordnungen der Elemente des Bildes und der Sachen.\",\"pmc\":\"The pictorial relationship consists of the correlation of the picture's elements with things.\",\"ogd\":\"\",\"str\":\"The pictorial relationship consists of the correlation of the picture's elements with things.\",\"tlp\":[2.1514]},{\"label\":\"2.175\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":31,\"x_axis\":25,\"page\":17,\"ger\":\"Das Bild kann sich aber nicht außerhalb seiner Form der Darstellung stellen.\",\"pmc\":\"A picture cannot, however, place itself outside its representational form.\",\"ogd\":\"\",\"str\":\"A picture cannot, however, place itself outside its form of representation.\",\"tlp\":[2.174]},{\"label\":\"3.20105\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":31,\"x_axis\":47,\"page\":58,\"ger\":\"Der Komplex kann nur durch seine Beschreibung gegeben sein, und diese wird stimmen oder nicht stimmen. Der Satz in welchem von einem Komplex die Rede ist, wird, wenn dieser nicht existiert, nicht unsinnig sondern einfach falsch sein. \",\"pmc\":\"A complex can be given only by its description, which will be right or wrong. A proposition that mentions a complex will not be nonsensical, if the complex does not exist, but simply false.\",\"ogd\":\"\",\"str\":\"A complex can be given only by its description, which either will fit or not fit. A proposition that mentions a complex that does not exist will not be nonsensical, merely false.\",\"tlp\":[3.24]},{\"label\":\"3.201411\",\"precision\":6,\"fontSize\":\"18px\",\"y_axis\":31,\"x_axis\":51,\"page\":79,\"ger\":\"Wir reden von etwas, aber auch davon, daß etwas geschieht. \",\"pmc\":\"We speak of something but also of something's happening.\",\"ogd\":\"\",\"str\":\"We speak of something but also of something's happening.\",\"tlp\":[3.323]},{\"label\":\"4.10013\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":31,\"x_axis\":70,\"page\":18,\"ger\":\"Das Wort 〟Philosophie\\\" muß etwas bedeuten, das über oder unter, aber nicht neben den Naturwissenschaften steht.\",\"pmc\":\"The word 'philosophy' must mean something whose place is above or below the natural sciences, not beside them.\",\"ogd\":\"\",\"str\":\"The word “philosophy” must mean something that stands above or below the natural sciences, not alongside them.\",\"tlp\":[4.111]},{\"label\":\"5.04113\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":31,\"x_axis\":121,\"page\":52,\"ger\":\"Daß man aus (x)·ϕx auf ϕa schließen kann, das zeigt, wie die Allgemeinheit auch im Zeichen 〟(x)·ϕx\\\" vorhanden ist. \",\"pmc\":\"The possibility of inference from (x).ϕx to ϕa shows how the symbol '(x).ϕx' itself has generality in it.\",\"ogd\":\"\",\"str\":\"That we can infer from (x).ϕx to ϕa shows that the symbol “(x).ϕx” itself  already has generality in it.\",\"tlp\":[5.1311]},{\"label\":\"6.114\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":31,\"x_axis\":149,\"page\":68,\"ger\":\"Das Anzeichen des logischen Satzes ist nicht die Allgemeingültigkeit. Allgemein sein heißt ja nur: zufälligerweise für alle Dinge gelten. \",\"pmc\":\"The mark of a logical proposition is not general validity.<br />To be general means no more than to be accidentally valid for all things.\",\"ogd\":\"\",\"str\":\"General validity is not the mark of logical propositions. To be general only means to be accidentally valid for all things.\",\"tlp\":[6.1231]},{\"label\":\"6.1141\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":31,\"x_axis\":151,\"page\":68,\"ger\":\"Ein unverallgemeinerter Satz kann ja ebensowohl tautologisch sein als ein verallgemeinerter. \",\"pmc\":\"An ungeneralized proposition can be tautological just as well as a generalized one.\",\"ogd\":\"\",\"str\":\"An ungeneralized proposition can be a tautology just as well as a generalized one.\",\"tlp\":[6.1231]},{\"label\":\"6.1142\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":31,\"x_axis\":153,\"page\":69,\"ger\":\"Die logische Allgemeingültigkeit könnte man wesentlich nennen, im Gegensatz zu jener zufälligen, etwa des Satzes 〟alle Menschen sind sterblich\\\". Sätze wie Russells Axiom of reducibility sind nicht logische Sätze, und dies erklärt unser Gefühl , nämlich, daß sie, wenn wahr, so doch nur durch einen günstigen Zufall wahr sein könnten. \",\"pmc\":\"The general validity of logic might be called essential, in contrast with the accidental general validity of such propositions as 'All men are mortal'. Propositions like Russell's axiom of reducibility are not logical propositons, and this explains our feeling that, even if they were true, their truth could only be the result of a fortunate accident.\",\"ogd\":\"\",\"str\":\"We could call the general validity of logic essential, as opposed to the accidental general validity of such propositions as “All people are mortal”. Propositions like Russell's axiom of reducibility are not logical propositions, and this explains our feeling that, if true, that could only be a lucky fluke.\",\"tlp\":[6.1232]},{\"label\":\"6.1143\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":31,\"x_axis\":155,\"page\":69,\"ger\":\"Es läßt sich eine Welt denken, in der das Axiom of reducibility nicht gilt. Es ist aber klar daß die Logik nichts mit der Frage zu schaffen hat ob unsere Welt wirklich so ist oder nicht. \",\"pmc\":\"It is possible to imagine a world in which the axiom of reducibility is not valid. It is clear, however, that logic has nothing to do with the question whether our world really is like that or not.\",\"ogd\":\"\",\"str\":\"We can imagine a world in which the axiom of reducibility is not valid. But clearly, logic has nothing to do with the question whether our world is really like that or not.\",\"tlp\":[6.1233]},{\"label\":\"6.11342\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":31,\"x_axis\":157,\"page\":70,\"ger\":\"Natürlich ist diese Art, zu zeigen, daß Sätze Tautologien sind der Logik durchaus unwesentlich. Schon weil die Sätze von welchen der Beweis ausgeht ja ohne Beweis zeigen müssen daß sie Tautologien sind. \",\"pmc\":\"Of course this way of showing that propositions are tautologies is not at all essential to logic, if only because the propositions from which the proof starts must show without any proof that they are tautologies.\",\"ogd\":\"\",\"str\":\"Naturally this way of showing that propositions are tautologies is quite inessential to logic. For the propositions from which the proof starts must show without any proof that they are tautologies.\",\"tlp\":[6.126]},{\"label\":\"6.11352\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":31,\"x_axis\":161,\"page\":70,\"ger\":\"Es wäre ja auch zu merkwürdig wenn man einen sinnvollen Satz logisch aus anderen beweisen könnte und einen logischen Satz auch. Es ist von vornherein klar daß der logische Beweis eines sinnvollen Satzes und der Beweis in der Logik zwei ganz verschiedene Sachen sein müssen. \",\"pmc\":\"Indeed, it would be altogether remarkable if a proposition that had sense could be proved logically from others, and so too could a logical proposition. It is clear from the start that a logical proof of a proposition that has sense and a proof in logic must be two entirely different things.\",\"ogd\":\"\",\"str\":\"Indeed, it would be quite incredible if a meaningful proposition could be proved logically from others just as a logical proposition can. Clearly, proving logically that a meaningful proposition is true is completely different from a proof in logic.\",\"tlp\":[6.1263]},{\"label\":\"2.223\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":33,\"x_axis\":13,\"page\":14,\"ger\":\"Um zu erkennen, ob das Bild wahr oder falsch ist, müssen wir es mit der Wirklichkeit vergleichen.\",\"pmc\":\"In order to tell whether a picture is true or false we must compare it with reality.\",\"ogd\":\"\",\"str\":\"To see whether a picture is true or false we must compare it with reality.\",\"tlp\":[2.223]},{\"label\":\"2.1516\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":33,\"x_axis\":19,\"page\":14,\"ger\":\"Diese Zuordnungen sind gleichsam die Fühler der Bildelemente, mit denen das Bild die Wirklichkeit berührt.\",\"pmc\":\"These correlations are, as it were, the feelers of the picture's elements, with which the picture touches reality.\",\"ogd\":\"\",\"str\":\"These correlations are, as it were, the antennae of the picture's elements, which put the picture in touch with reality.\",\"tlp\":[2.1515]},{\"label\":\"3.20106\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":33,\"x_axis\":47,\"page\":58,\"ger\":\"Daß ein einfaches Symbol einen Komplex bezeichnet, kann man aus einer Unbestimmtheit in den Sätzen sehen, worin es vorkommt. Wir wissen, durch diesen Satz ist noch nicht alles bestimmt. Die Allgemeinheitsbezeichnung enthält ja ein Urbild.\",\"pmc\":\"When a simple symbol signifies a complex, this can be seen from an indeterminateness in the propositions in which it occurs. In such cases we know that the proposition leaves something undetermined. In fact the generality-sign contains a prototype.\",\"ogd\":\"\",\"str\":\"When a simple symbol signifies a complex, this can be seen in an indeterminateness in the propositions in which it occurs. We then know that everything is not yet determined by the proposition. Indeed, the generality sign contains a prototype.\",\"tlp\":[3.24]},{\"label\":\"3.201412\",\"precision\":6,\"fontSize\":\"18px\",\"y_axis\":33,\"x_axis\":51,\"page\":95,\"ger\":\"Die stillschweigenden Abmachungen zum Verständnis unserer Sprache sind enorm kompliziert zu jedem Satz wird viel hinzu gedacht, was nicht ausgesprochen wird. <br />Ist mit 〟A\\\" ein Mensch gemeint so ist der Satz 〟A sitzt\\\" zulässig, aber nicht wenn A dieses Buch bezeichnet. — Ist aber ein Satz ganz zerlegt dann müssen für alles was vom Verständnis seiner Form abhängt die Bedeutungen seiner Teile belanglos sein.\",\"pmc\":\"The tacit conventions on which the understanding of our language depends are enormously complicated. With every proposition much is supplied in thought which is not put into words.<br />If 'A' is used to mean a person, the proposition, 'A is sitting', is admissible, but not if 'A' signifies this book. - But once a proposition is completely analyzed, everything that depends upon the understanding of its form must be unaffected by the meanings of its parts.\",\"ogd\":\"\",\"str\":\"The unspoken conventions involved in understanding our language are extremely complicated. Much is added in thought to each proposition and not put into words.\\rIf “A” is used to mean a person, the proposition, “A is sitting”, is admissible, but not if “A” signifies this book. - But if a proposition is fully analyzed, everything that depends upon the understanding of its form must be unaffected by the meanings of its parts.\",\"tlp\":[4.002]},{\"label\":\"4.10014\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":33,\"x_axis\":70,\"page\":18,\"ger\":\"Der Zweck der Philosophie ist die logische Klärung der Gedanken. \",\"pmc\":\"Philosophy aims at the logical clarification of thoughts.\",\"ogd\":\"\",\"str\":\"The goal of philosophy is the logical clarification of thoughts.\",\"tlp\":[4.112]},{\"label\":\"5.044\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":33,\"x_axis\":119,\"page\":16,\"ger\":\"Auf keine Weise kann aus dem Bestehen irgend einer Sachlage, auf das Bestehen einer von ihr gänzlich verschiedenen Sachlage geschlossen werden. \",\"pmc\":\"There is no possible way of making an inference from the existence of one situation to the existence of another, entirely different situation.\",\"ogd\":\"\",\"str\":\"In no way can an inference be made from the existence of one situation to the existence of another entirely different situation.\",\"tlp\":[5.135]},{\"label\":\"5.0441\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":33,\"x_axis\":121,\"page\":16,\"ger\":\"Einen Kausalnexus der einen solchen Schluß rechtfertigte gibt es nicht. \",\"pmc\":\"There is no causal nexus to justify such an inference.\",\"ogd\":\"\",\"str\":\"There is no causal nexus to justify any such inference.\",\"tlp\":[5.136]},{\"label\":\"5.0442\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":33,\"x_axis\":123,\"page\":16,\"ger\":\"Die Ereignisse der Zukunft können wir nicht wissen.\",\"pmc\":\"The events of the future cannot be known.\",\"ogd\":\"\",\"str\":\"Future events cannot be known.\",\"tlp\":[5.1361]},{\"label\":\"5.0443\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":33,\"x_axis\":125,\"page\":16,\"ger\":\"Der Glaube an den Kausalnexus ist der Aberglaube.\",\"pmc\":\"Belief in the causal nexus is superstition.\",\"ogd\":\"\",\"str\":\"Superstition is belief in the causal nexus.\",\"tlp\":[5.1361]},{\"label\":\"5.0444\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":33,\"x_axis\":127,\"page\":41,\"ger\":\"Die Willensfreiheit besteht darin, daß zukünftige Ereignisse jetzt nicht gewußt werden können. Nur dann könnten wir sie wissen, wenn die Kausalität eine innere Notwendigkeit wäre, wie die, des logischen Schlusses. — Der Zusammenhang von Wissen und Gewußtem ist der, der logischen Notwendigkeit.\",\"pmc\":\"The freedom of the will consists in the impossibility of knowing events that still lie in the future. We could know them only if causality were an inner necessity like that of logical inference. - The connection between knowledge and what is known is that of logical necessity.\",\"ogd\":\"\",\"str\":\"Freedom of the will consists in the impossibility of our knowing future events now. We could know them only if causality were an inner necessity like that of logical inference. - The connection between knowledge and the known is that of logical necessity.\",\"tlp\":[5.1362]},{\"label\":\"6.11343\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":33,\"x_axis\":157,\"page\":70,\"ger\":\"In der Logik sind Prozeß und Resultat äquivalent. (darum keine Überraschung). \",\"pmc\":\"In logic process and result are equivalent. (Hence the absence of surprise.)\",\"ogd\":\"\",\"str\":\"In logic process and result are equivalent. (Hence, no surprises.)\",\"tlp\":[6.1261]},{\"label\":\"2.224\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":35,\"x_axis\":13,\"page\":14,\"ger\":\"Aus dem Bild allein ist nicht zu erkennen, ob es wahr oder falsch ist. \",\"pmc\":\"It is impossible to tell from the picture alone whether it is true or false.\",\"ogd\":\"\",\"str\":\"We cannot see whether the picture is true or false just by looking at it.\",\"tlp\":[2.224]},{\"label\":\"3.20107\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":35,\"x_axis\":47,\"page\":59,\"ger\":\"Die Zusammenfassung des Symbols eines Komplexes in ein einfaches Symbol kann durch eine Definition ausgedrückt werden. \",\"pmc\":\"The contraction of a symbol for a complex into a simple symbol can be expressed in a definition.\",\"ogd\":\"\",\"str\":\"The contraction of a symbol for a complex into a simple symbol can be expressed in a definition.\",\"tlp\":[3.24]},{\"label\":\"3.2015\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":35,\"x_axis\":49,\"page\":54,\"ger\":\"Um solchen Irrtümern zu entgehen, müssen wir eine Zeichensprache verwenden welche sie ausschließt, indem sie nicht das gleiche Zeichen in verschiedenen Symbolen und Zeichen welche auf verschiedene Art bezeichnen nicht äußerlich auf gleiche Art, verwendet. Eine Zeichensprache also, die der logischen Grammatik — der logischen Syntax — gehorcht. \",\"pmc\":\"In order to avoid such errors we must make use of a sign-language that excludes them by not using the same sign for different symbols and by not using in a superficially similar way signs that have different modes of signification: that is to say, a sign-language that is governed by logical grammar - by logical syntax.\",\"ogd\":\"\",\"str\":\"To avoid such errors we must use a sign-language that excludes them by not using the same sign for different symbols and by not using signs that signify in different ways in what looks like the same way. That is to say, a sign-language governed by logical grammar - by logical syntax.\",\"tlp\":[3.325]},{\"label\":\"3.20151\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":35,\"x_axis\":51,\"page\":54,\"ger\":\"Die Begriffsschrift Freges und Russells ist eine solche Sprache, die allerdings — wie sich zeigen wird — noch nicht alle Fehler ausschließt.\",\"pmc\":\"The conceptual notation of Frege and Russell is such a language, though it is true - as will be shown - that it fails to exclude all mistakes.\",\"ogd\":\"\",\"str\":\"Frege’s and Russell’s conceptual notation is such a language that, howevever – as will be shown – still does not exclude all mistakes.\",\"tlp\":[3.325]},{\"label\":\"3.20152\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":35,\"x_axis\":53,\"page\":55,\"ger\":\"In der logischen Syntax darf nie die Bedeutung eines Zeichens eine Rolle spielen; sie muß sich aufstellen lassen, ohne daß hiebei von der Bedeutung eines Zeichens die Rede wäre, sie darf nur die Beschreibung der Symbole voraussetzen. — Von dieser Bemerkung sehen wir in Russells 〟Theory of Types\\\" hinüber: Der Irrtum Russells zeigt sich darin, daß er bei der Aufstellung der Zeichenregeln die Bedeutungen von Zeichen nennen mußte. \",\"pmc\":\"In logical syntax the meaning of a sign should never play a role. It must be possible to establish logical syntax without mentioning the meaning of a sign: only the description of expressions may be presupposed. From this observation we turn to Russell's 'theory of types'. It can be seen that Russell must be wrong, because he had to specify by name the meanings of signs when establishing rules for them.\",\"ogd\":\"\",\"str\":\"The meaning of a sign should never play a role in logical syntax. It must be possible to set up logical syntax without mentioning the meaning of a sign: only the description of symbols may be presupposed. From this observation we get a further perspective on Russell's “theory of types”.  Russell’s error is shown by the fact that in formulating his rules for signs, he had to mention his signs’ meanings.\",\"tlp\":[\"3.33, 3.331\"]},{\"label\":\"4.10015\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":35,\"x_axis\":70,\"page\":18,\"ger\":\"Die Philosophie ist keine Lehre sondern eine Tätigkeit.\",\"pmc\":\"Philosophy is not a body of doctrine but an activity.\",\"ogd\":\"\",\"str\":\"Philosophy is not a theory but an activity.\",\"tlp\":[4.112]},{\"label\":\"4.100151\",\"precision\":6,\"fontSize\":\"18px\",\"y_axis\":35,\"x_axis\":72,\"page\":49,\"ger\":\"Ein philosophisches Werk besteht wesentlich aus Erläuterungen. \",\"pmc\":\"A philosophical work consists essentially of elucidations.\",\"ogd\":\"\",\"str\":\"A philosophical work consists essentially of elucidations.\",\"tlp\":[4.112]},{\"label\":\"4.100152\",\"precision\":6,\"fontSize\":\"18px\",\"y_axis\":35,\"x_axis\":74,\"page\":33,\"ger\":\"Erkenntnistheorie ist die Philosophie der Psychologie. \",\"pmc\":\"Theory of knowledge is the philosophy of psychology.\",\"ogd\":\"\",\"str\":\"Theory of knowledge is the philosophy of psychology.\",\"tlp\":[4.1121]},{\"label\":\"4.100153\",\"precision\":6,\"fontSize\":\"18px\",\"y_axis\":35,\"x_axis\":76,\"page\":33,\"ger\":\"Die Psychologie ist der Philosophie nicht verwandter als irgend eine andere Naturwissenschaft. \",\"pmc\":\"Psychology is no more closely related to philsoophy than any other natural science.\",\"ogd\":\"\",\"str\":\"Psychology is no more related to philosophy than is any other natural science.\",\"tlp\":[4.1121]},{\"label\":\"4.100154\",\"precision\":6,\"fontSize\":\"18px\",\"y_axis\":35,\"x_axis\":78,\"page\":33,\"ger\":\"Die Philosophie begrenzt das bestreitbare Gebiet der Naturwissenschaft. \",\"pmc\":\"Philosophy sets limits to the much disputed sphere of natural science.\",\"ogd\":\"\",\"str\":\"Philosophy limits the much disputed domain of natural science.\",\"tlp\":[4.113]},{\"label\":\"5.2\",\"precision\":1,\"fontSize\":\"40px\",\"y_axis\":35,\"x_axis\":111,\"page\":10,\"ger\":\"Jede W-Funktion von W-Funktionen ist eine Funktion von Elementarsätzen, ein Satz.\",\"pmc\":\"Every T-function of T-functions is a T-function of elementary propositions, a proposition.\",\"ogd\":\"\",\"str\":\"Every truth-function of truth-functions is a truth-function of elementary propositions, a proposition.pt\",\"tlp\":[5.3]},{\"label\":\"5.21\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":35,\"x_axis\":113,\"page\":36,\"ger\":\"Hier zeigt es sich daß es logische Gegenstände, logische Konstante, nicht gibt. \",\"pmc\":\"At this point it becomes manifest that there are no 'logical objects' or 'logical constants'.\",\"ogd\":\"\",\"str\":\"It is here that it becomes clear that there are no such things as logical objects, logical constants.\",\"tlp\":[5.4]},{\"label\":\"5.22\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":35,\"x_axis\":115,\"page\":36,\"ger\":\"Denn: Alle W-Funktionen von W-Funktionen sind identisch, welche eine und die selbe W-Funktion von Elementarsätzen sind. \",\"pmc\":\"The reason is that T-functions of T-functions are identical whenever they are one and the same T-functions of elementary propositions.\",\"ogd\":\"\",\"str\":\"For all truth-functions of truth-functions are identical, whenever they are one and the same truth-function of elementary propositions.\",\"tlp\":[5.41]},{\"label\":\"5.23\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":35,\"x_axis\":121,\"page\":38,\"ger\":\"Die W-Funktionen sind keine materiellen Funktionen. \",\"pmc\":\"T-functions are not material functions.\",\"ogd\":\"\",\"str\":\"Truth-functions are not material functions.\",\"tlp\":[5.44]},{\"label\":\"5.04441\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":35,\"x_axis\":127,\"page\":94,\"ger\":\"〟A weiß, daß p\\\" ist tautologisch wenn p eine Tautologie ist. \",\"pmc\":\" 'A knows that p' is tautological, if p is a tautology.\",\"ogd\":\"\",\"str\":\"“A knows that p” is tautological, if p is a tautology.\",\"tlp\":[5.1362]},{\"label\":\"6.2\",\"precision\":1,\"fontSize\":\"40px\",\"y_axis\":35,\"x_axis\":147,\"page\":101,\"ger\":\"Die Mathematik ist eine logische Methode. \",\"pmc\":\"Mathematics is a logical method.\",\"ogd\":\"\",\"str\":\"Mathematics is a logical method.\",\"tlp\":[6.2]},{\"label\":\"6.21\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":35,\"x_axis\":149,\"page\":101,\"ger\":\"Die Logik der Welt, die die logischen Sätze in den Tautologien zeigen, zeigt die Mathematik in den Gleichungen. \",\"pmc\":\"The logic of the world, which is shown in tautologies by logical propositions, is shown in equations by mathematics.\",\"ogd\":\"\",\"str\":\"The logic of the world, which is shown in tautologies by logical propositions, is shown in equations by mathematics.\",\"tlp\":[6.22]},{\"label\":\"6.22\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":35,\"x_axis\":151,\"page\":101,\"ger\":\"Die Mathematik ist eine Methode der Logik. \",\"pmc\":\"Mathematics is a method of logic.\",\"ogd\":\"\",\"str\":\"Mathematics is a method of logic.\",\"tlp\":[6.234]},{\"label\":\"6.23\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":35,\"x_axis\":153,\"page\":79,\"ger\":\"Wenn zwei Ausdrücke durch das 〟=\\\" Zeichen verbunden werden so heißt das, sie sind durch einander ersetzbar. Ob dies aber der Fall ist, muß sich an den beiden Ausdrücken selbst zeigen. \",\"pmc\":\"If two expressions are combined by means of the '=' sign, that means that they can be substituted for one another. But it must be manifest in the two expressions themselves whether this is the case or not.\",\"ogd\":\"\",\"str\":\"If two expressions are combined by means of the “=” sign, that means that they can be substituted for one another. But whether this is the case must show itself in the two expressions themselves.\",\"tlp\":[6.23]},{\"label\":\"6.24\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":35,\"x_axis\":157,\"page\":100,\"ger\":\"Die Methode der Mathematik zu ihren Gleichungen zu kommen ist die Substitutionsmethode. <br />Denn die Gleichungen drücken die Ersetzbarkeit zweier Ausdrücke aus und wir schreiten von einer Anzahl von Gleichungen zu neuen Gleichungen vor indem wir den Gleichungen entsprechend die einen Ausdrücke durch andere ersetzen.\",\"pmc\":\"The method by which mathematics arrives at its equations is the method of substitution.<br />For equations express the substitutability of two expressions and, starting from a number of equations, we advance to new equations by substituting different expressions in accordance with the equations.\",\"ogd\":\"\",\"str\":\"The way mathematics arrives at its equations is the method of substitution.\\rFor equations express the substitutability of two expressions and we procede from a number of equations to new ones, by substituting different expressions in accordance with the equations.\",\"tlp\":[6.24]},{\"label\":\"2.225\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":37,\"x_axis\":13,\"page\":14,\"ger\":\"Ein a priori wahres Bild gibt es nicht. \",\"pmc\":\"There are no pictures that are true a priori.\",\"ogd\":\"\",\"str\":\"There are no pictures that are true a priori.\",\"tlp\":[2.225]},{\"label\":\"3.20108\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":37,\"x_axis\":47,\"page\":44,\"ger\":\"Es gibt eine und nur eine vollständige Analyse des Satzes. \",\"pmc\":\"A proposition has one and only one complete analysis.\",\"ogd\":\"\",\"str\":\"A proposition has one and only one complete analysis.\",\"tlp\":[3.25]},{\"label\":\"3.2016\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":37,\"x_axis\":49,\"page\":25,\"ger\":\"Jedes Zeichen kann als Satzvariable dargestellt werden.\",\"pmc\":\"Every sign can be presented as a propositional variable.\",\"ogd\":\"\",\"str\":\"Every sign can be represented as a sentential variable.\",\"tlp\":[3.314]},{\"label\":\"4.10016\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":37,\"x_axis\":70,\"page\":18,\"ger\":\"Das Resultat der Philosophie sind nicht 〟philosophische Sätze\\\" sondern das Klarwerden von Sätzen.\",\"pmc\":\"Philosophy does not result in 'philosophical propositions', but rather in the clarification of propositions.\",\"ogd\":\"\",\"str\":\"Philosophy does not result in “philosophical propositions”, but rather in making propositions clear.\",\"tlp\":[4.112]},{\"label\":\"4.100161\",\"precision\":6,\"fontSize\":\"18px\",\"y_axis\":37,\"x_axis\":72,\"page\":18,\"ger\":\"Die Philosophie soll die Gedanken, die sonst, gleichsam, trübe und verschwommen sind, klar machen und scharf abgrenzen. \",\"pmc\":\"Without philosophy thoughts are, as it were, cloudy and indistinct: its task is to make them clear and to give them sharp boundaries.\",\"ogd\":\"\",\"str\":\"Philosophy should make clear and sharpen the boundaries of thoughts that are otherwise opaque and blurred.\",\"tlp\":[4.112]},{\"label\":\"4.1001531\",\"precision\":7,\"fontSize\":\"18px\",\"y_axis\":37,\"x_axis\":76,\"page\":41,\"ger\":\"Entspricht nicht mein Studium der Zeichensprache dem Studium der Denkprozesse, welches die Philosophen für die Philosophie der Logik immer für so wesentlich hielten? Nur verwickelten sie sich meistens in unwesentliche psychologische Untersuchungen und eine analoge Gefahr gibt es auch bei meiner Methode. \",\"pmc\":\"Does not my study of sign-language correspond to the study of thought-processes, which philosophers always used to consider so essential to the philosophy of logic? Only in most cases they got entangled in unessential psychological investigations, and with my method too there is an analogous risk.\",\"ogd\":\"\",\"str\":\"Does not my study of sign-language correspond to the study of thought-processes, which philosophers always used to consider so essential to the philosophy of logic? Only more often than not they got involved in inessential psychological investigations, and there is an analogous danger for my method.\",\"tlp\":[4.1121]},{\"label\":\"5.2201\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":37,\"x_axis\":115,\"page\":30,\"ger\":\"Daß ∨, ⊃, etc. nicht Beziehungen im Sinne von Rechts und Links etc. sind, leuchtet dem unbefangenen Geist ein. \",\"pmc\":\"It is self-evident to an unprejudiced mind that ∨, ⊃, etc. are not relations in the sense in which right and left, etc. are relations.\",\"ogd\":\"\",\"str\":\"That ∨, ⊃, etc. are not relations in the sense in which right and left, etc. are relations, is obvious to an unprejudiced mind.\",\"tlp\":[5.42]},{\"label\":\"5.221\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":37,\"x_axis\":117,\"page\":30,\"ger\":\"Die Möglichkeit des kreuzweisen Definierens der logischen 〟Urzeichen\\\" Freges und Russells zeigt schon, daß dies keine Urzeichen sind; und schon erst recht, daß sie keine Relationen bezeichnen. \",\"pmc\":\"The interdefinability of Frege's and Russell's 'primitive signs' of logic is enough to show that they are not primitive signs, still less signs for relations.\",\"ogd\":\"\",\"str\":\"The interdefinability of Frege's and Russell's “primitive signs” of logic shows by itself that they are not primitive, still less signs for relations.\",\"tlp\":[5.42]},{\"label\":\"5.2211\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":37,\"x_axis\":119,\"page\":30,\"ger\":\"Und es ist offenbar daß das 〟⊃\\\" welches wir durch 〟·\\\" und 〟∨\\\" definieren, identisch ist mit dem durch welches wir 〟∨\\\" mit 〟·\\\" definieren und daß dieses 〟·\\\" mit dem ersten identisch ist. u.s.w. \",\"pmc\":\"And it is obvious that the '⊃' defined by means of '.' and '∨' is identical with the one that figures with '.' in the definition of '∨'; and that the second '.' is identical with the first one; and so on.\",\"ogd\":\"\",\"str\":\"And it is obvious that the “⊃” that we define by means of “.” and “∨” is identical with that by which we define “.” by means of “∨”; and that this second “.” is identical with the first, and so on.\",\"tlp\":[5.42]},{\"label\":\"5.231\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":37,\"x_axis\":121,\"page\":32,\"ger\":\"Wenn man z.B. eine Bejahung durch doppelte Verneinung erzeugen kann, ist dann die Verneinung — in irgend einem Sinn — in der Bejahung enthalten? Verneint ~~p ~p, oder bejaht es p; oder beides? \",\"pmc\":\"For example, an affirmation can be produced by double negation: in such a case does it follow that in some sense negation is contained in affirmation? Does ~~p negate ~p, or does it affirm p - or both?\",\"ogd\":\"\",\"str\":\"If, for instance, an affirmation can be produced by double negation, is the negation—in any sense—contained in the affirmation? Does ~~p negate ~p, or does it affirm p, or both?\",\"tlp\":[5.44]},{\"label\":\"5.04442\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":37,\"x_axis\":127,\"page\":34,\"ger\":\"Wenn daraus daß ein Satz uns einleuchtet nicht folgt daß er wahr ist, so ist das Einleuchten auch keine Rechtfertigung für unseren Glauben an seine Wahrheit. \",\"pmc\":\"If the truth of a proposition does not follow from the fact that it is self-evident to us, then its self-evidence in no way justifies our belief in its truth.\",\"ogd\":\"\",\"str\":\"If the truth of a proposition does not follow from the fact that it is obvious to us, then obviousness in no way justifies our belief in its truth.\",\"tlp\":[5.1363]},{\"label\":\"6.211\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":37,\"x_axis\":149,\"page\":79,\"ger\":\"Russell, Whitehead, und Frege haben das Wesentliche der mathematischen Methode mit Gleichungen zu arbeiten nicht verstanden. Auf dieser Methode beruht es, daß jeder mathematische Satz sich von selbst versteht oder unsinnig ist. \",\"pmc\":\"Russell, Whitehead, and Frege did not understand the essential characteristic of the mathematical method of employing equations. It is a consequence of this method that every mathematical proposition must go without saying or be nonsensical.\",\"ogd\":\"\",\"str\":\"Russell, Whitehead, and Frege did not understand the essence of the mathematical method of working with equations. It is a consequence of this method that every mathematical proposition must be self-evident or nonsensical.\",\"tlp\":[6.2341]},{\"label\":\"6.231\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":37,\"x_axis\":153,\"page\":100,\"ger\":\"Die Frage ob man zur Lösung der mathematischen Probleme die Anschauung braucht muß dahin beantwortet werden, daß eben die Sprache hier die nötige Anschauung liefert. \",\"pmc\":\"The question whether intuition is needed for the solution of mathematical problems must be given the answer that in this case language itself provides the necessary intuition.\",\"ogd\":\"\",\"str\":\"The answer to the question whether we need intuition to solve mathematical problems must be: here language itself affords the necessary intuition.\",\"tlp\":[6.233]},{\"label\":\"3.2017\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":39,\"x_axis\":49,\"page\":96,\"ger\":\"Den Satz fasse ich — wie Frege und Russell — als Funktion der in ihm enthaltenen Symbole auf. \",\"pmc\":\"Like Frege and Russell I contrue a proposition as a function of the symbols contained in it.\",\"ogd\":\"\",\"str\":\"Like Frege and Russell I construe a proposition as a function of the symbols it contains.\",\"tlp\":[3.318]},{\"label\":\"3.20171\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":39,\"x_axis\":51,\"page\":34,\"ger\":\"Kein Satz kann etwas über sich selbst aussagen, weil das Satzzeichen nicht in sich selbst enthalten sein kann. (Das ist die ganze 〟Theory of Types\\\".) \",\"pmc\":\"No proposition can make a statement about itself, because a propositional sign cannot be contained in itself. (That is the whole of the 'theory of types'.)\",\"ogd\":\"\",\"str\":\"No proposition can make a statement about itself, because a sentential sign cannot be contained in itself. (That is the whole of the “theory of types”.)\",\"tlp\":[3.332]},{\"label\":\"3.20172\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":39,\"x_axis\":53,\"page\":88,\"ger\":\"Eine Funktion kann darum nicht ihr eigenes Argument sein weil das Funktionszeichen bereits das Urbild seines Arguments enthält und es sich also nicht selbst enthalten kann. \",\"pmc\":\"The reason why a function cannot be its own argument is that the sign for a function already contains the prototype of its argument, and so it cannot contain itself.\",\"ogd\":\"\",\"str\":\"A function cannot be its own argument because the function sign already contains the prototype of its argument, and so it cannot contain itself.\",\"tlp\":[3.333]},{\"label\":\"3.20173\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":39,\"x_axis\":55,\"page\":88,\"ger\":\"Nehmen wir nämlich an die Funktion F(fξ) könnte ihr eigenes Argument sein, dann gäbe es also einen Satz: 〟F{F(fξ)}\\\", und in diesem müßten die äußere Funktion F und die innere F verschiedene Bedeutung haben, denn die innere hat die Form Φ(fξ) die äußere die Form ψ{Φ(fξ)}. Gemeinsam ist den beiden Funktionen nur der Buchstabe 〟F\\\", der aber allein nichts bezeichnet.\",\"pmc\":\"For let us suppose that the function F(fξ) could be its own argument: in that case there would be a proposition 'F(F(ξ)', in which the outer function F and the inner F would have to have a different meaning, since the inner one has the form Φ(fξ) and the outer one has the form ψ{Φ(fξ)}. Only the letter 'F' is common to the two functions, but the letter by itself signifies nothing.\",\"ogd\":\"\",\"str\":\"For let us suppose that the function F (fξ) could be its own argument: there would then be a proposition “F(F(ξ)”, in which case the outer function F and inner function F must have different meanings, since the inner one has the form Φ(fξ) and the outer one has the form ψ{Φ(fξ)}. The two functions have only the letter “F “ in common, which by itself signifies nothing.\",\"tlp\":[3.333]},{\"label\":\"4.10017\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":39,\"x_axis\":70,\"page\":18,\"ger\":\"Sie wird so das Denkbare abgrenzen und damit das Undenkbare.\",\"pmc\":\"In this way it will set limits to what can be thought; and, in doing so, to what cannot be thought.\",\"ogd\":\"\",\"str\":\"It should mark off the thinkable and thereby the unthinkable.\",\"tlp\":[4.114]},{\"label\":\"4.100171\",\"precision\":6,\"fontSize\":\"18px\",\"y_axis\":39,\"x_axis\":72,\"page\":18,\"ger\":\"Sie wird das Undenkbare von innen, durch das Denkbare, begrenzen. \",\"pmc\":\"It will set limits to what cannot be thought by working outwards through what can be thought.\",\"ogd\":\"\",\"str\":\"It should mark off the unthinkable by working through the thinkable from within.\",\"tlp\":[4.114]},{\"label\":\"5.222\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":39,\"x_axis\":117,\"page\":30,\"ger\":\"Daß aus einer Tatsache p unendlich viele andere folgen sollten, nämlich ~~p, ~~~~p, etc. ist doch von vornherein kaum zu glauben. \",\"pmc\":\"Even at first sight it seems scarcely credible that there should follow from one fact p infinitely many others, namely, ~~p, ~~~~p, etc.\",\"ogd\":\"\",\"str\":\"Even at first sight it seems scarcely credible that from one fact p infinitely many others should follow, namely, ~~p, ~~~~p, etc.\",\"tlp\":[5.43]},{\"label\":\"5.232\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":39,\"x_axis\":121,\"page\":38,\"ger\":\"Der Satz ~~p handelt nicht von der Verneinung wie von einem Gegenstand; wohl aber ist die Möglichkeit der Verneinung in der Bejahung bereits präjudiziert.\",\"pmc\":\"The proposition ~~p is not about negation, as if negation were an object: on the other hand, the possiblity of negation is already written into affirmation.\",\"ogd\":\"\",\"str\":\"The proposition ~~p is not about negation as an object, but the possibility of negation is already presupposed in affirmation.\",\"tlp\":[5.44]},{\"label\":\"6.212\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":39,\"x_axis\":149,\"page\":79,\"ger\":\"Wir bilden nämlich mittelst der Operationen Ausdrücke und behaupten die Identität ihrer Bedeutung. \",\"pmc\":\"For we construct expressions by means of operations and assert that they have the same meaning.\",\"ogd\":\"\",\"str\":\"For we construct expressions by means of operations and assert that they have the same meaning.\",\"tlp\":[\"None\"]},{\"label\":\"6.232\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":39,\"x_axis\":153,\"page\":100,\"ger\":\"Es ist eine Eigenschaft der Bejahung daß man sie als doppelte Verneinung auffassen kann. <br />Es ist eine Eigenschaft von 1+1+1+1 daß man es als (1+1) + (1+1) auffassen kann.\",\"pmc\":\"It is a property of affirmation that it can be construed as double negation.<br />It is a property of 1+1+1+1 that it can be construed as (1+1)+(1+1).\",\"ogd\":\"\",\"str\":\"A property of affirmation that it can be conceived as double negation.\",\"tlp\":[6.2321]},{\"label\":\"3.201731\",\"precision\":6,\"fontSize\":\"18px\",\"y_axis\":41,\"x_axis\":55,\"page\":90,\"ger\":\"Dies wird sofort klar wenn wir statt 〟F{F(fξ)}\\\" schreiben 〟(Eϕ)·F{ϕη}· ϕη=Fη\\\". \",\"pmc\":\"This immediately becomes clear if instead of 'F{F(fξ)}' we write '(∃ϕ).F{ϕη}.ϕη=Fη'.\",\"ogd\":\"\",\"str\":\"This immediately becomes clear if instead of “F{F(fξ)}” we write “(∃ϕ).F{ϕη}.ϕη=Fη”.\",\"tlp\":[3.333]},{\"label\":\"4.10018\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":41,\"x_axis\":70,\"page\":18,\"ger\":\"Sie wird das Unsagbare bedeuten, indem sie das Sagbare klar darstellt.\",\"pmc\":\"It will signify what cannot be said, by presenting clearly what can be said.\",\"ogd\":\"\",\"str\":\"It will signify the unsayable, by clearly representing the sayable.\",\"tlp\":[4.115]},{\"label\":\"5.223\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":41,\"x_axis\":117,\"page\":37,\"ger\":\"Dies ist aber nicht weniger merkwürdig als daß die unendliche Anzahl der Sätze der Logik (der Mathematik) aus einem halben Dutzend 〟Grundgesetzen\\\" folgt! \",\"pmc\":\"But this is no less remarkable than that the infinite number of propositions of logic (mathematics) follow from half a dozen 'primitive propositions'.\",\"ogd\":\"\",\"str\":\"And it seems even stranger that the infinite number of propositions of logic (mathematics) follow from half a dozen “primitive propositions”.\",\"tlp\":[5.43]},{\"label\":\"5.233\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":41,\"x_axis\":121,\"page\":51,\"ger\":\"Und gäbe es einen Gegenstand der 〟~\\\" hieße so müßte ~~p etwas anderes sagen als p. Denn der eine Satz würde dann eben von ~ handeln der andere nicht.\",\"pmc\":\"And if there were an object called ~, it would follow that ~~p said something different from what p said, just because the one proposition would then be about ~ and the other would not.\",\"ogd\":\"\",\"str\":\"And if there were an object called ~, then ~~p would have to say something different from what p says. For the one proposition would then be about ~ and the other would not.\",\"tlp\":[5.441]},{\"label\":\"5.2331\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":41,\"x_axis\":123,\"page\":51,\"ger\":\"Dieses Verschwinden der scheinbaren logischen Konstanten tritt auch ein, wenn 〟~(Ex)·~ϕx\\\" dasselbe sagt wie 〟(x).ϕx\\\" oder 〟(Ex)·ϕx·x=a\\\" dasselbe wie 〟ϕa\\\". \",\"pmc\":\"This vanishing of apparent logical constants also occurs in the case of '~(∃x).~ϕx', which says the same as '(x).ϕx', and in the case of '(∃x).ϕx. x=a', which says the same thing as 'ϕa'.\",\"ogd\":\"\",\"str\":\"This disappearance of apparent logical constants also happens with “~(∃x).~ϕx”, which is equivalent to “(x).ϕx”, and in the case of “(∃x).ϕx.x=a”, which is equivalent to “ϕa”.\",\"tlp\":[5.441]},{\"label\":\"3.21\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":43,\"x_axis\":47,\"page\":5,\"ger\":\"Der Satz ist die Projektion nach ihrer Methode. \",\"pmc\":\"A proposition is a projection with the method governing it.\",\"ogd\":\"\",\"str\":\"A proposition is a projection in accordance with its method of projection.\",\"tlp\":[3.12]},{\"label\":\"3.22\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":43,\"x_axis\":51,\"page\":24,\"ger\":\"Der Satz besitzt wesentliche und zufällige Züge. \",\"pmc\":\"A proposition possesses essential and accidental features.\",\"ogd\":\"\",\"str\":\"A proposition has essential and accidental features.\",\"tlp\":[3.34]},{\"label\":\"3.23\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":43,\"x_axis\":53,\"page\":24,\"ger\":\"Zufällig sind die Züge die von der besonderen Art der Hervorbringung des Satzzeichens herrühren.<br />Wesentlich diejenigen, welche allein den Satz befähigen seinen Sinn auszudrücken.\",\"pmc\":\"Accidental features are those that result from the particular way in which the propositional sign it produced.<br />Essential features are those without which the proposition could not express its sense.\",\"ogd\":\"\",\"str\":\"Accidental features are those that are due to the particular way the sentential sign is produced. Essential features are those without which the sense of the proposition would be lost.pt\",\"tlp\":[3.34]},{\"label\":\"3.24\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":43,\"x_axis\":55,\"page\":25,\"ger\":\"Das Wesentliche am Satz ist also das, was allen Sätzen, welche den gleichen Sinn ausdrücken können, gemeinsam ist.\",\"pmc\":\"So what is essential in a proposition is what all propositions that can express the same sense have in common.\",\"ogd\":\"\",\"str\":\"So what is essential about a proposition is what all sentences that can express the same sense have in common.\",\"tlp\":[3.341]},{\"label\":\"3.25\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":43,\"x_axis\":59,\"page\":50,\"ger\":\"Definitionen sind Regeln der Übersetzung von einer Sprache in eine andere. <br />Jede richtige Zeichensprache muß sich in jede andere nach solchen Regeln übersetzen lassen: dies ist, was sie alle gemeinsam haben.\",\"pmc\":\"Definitions are rules for translating from one language into another.<br />Any correct sign-language must be translatable into any other in accordance with such rules: it is this that all have in common.\",\"ogd\":\"\",\"str\":\"Definitions are rules for translating from one language into another.\\rAny correct sign-language must be translatable into any other according to such rules. This is what they all have in common.\",\"tlp\":[3.343]},{\"label\":\"4.10019\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":43,\"x_axis\":70,\"page\":36,\"ger\":\"Alles was überhaupt gedacht werden kann, kann klar gedacht werden. Alles was sich aussprechen läßt, läßt sich klar aussprechen. \",\"pmc\":\"Everything that can be thought at all can be thought clearly. Everything that can be put into words can be put clearly.\",\"ogd\":\"\",\"str\":\"Everything that can be thought at all can be thought clearly. Everything that can be put into words can be put clearly.\",\"tlp\":[4.116]},{\"label\":\"5.224\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":43,\"x_axis\":117,\"page\":37,\"ger\":\"Alle Sätze der Logik sagen aber dasselbe. Nämlich nichts. \",\"pmc\":\"But in fact all the propositions of logic say the same thing, to wit nothing.\",\"ogd\":\"\",\"str\":\"But all the propositions of logic say the same thing. Namely, nothing.\",\"tlp\":[5.43]},{\"label\":\"5.234\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":43,\"x_axis\":121,\"page\":36,\"ger\":\"Wenn uns ein Satz gegeben ist, so sind mit ihm auch schon alle seine Wahrheits-Funktionen gegeben. \",\"pmc\":\"If we are given a proposition, then with it we are also given all its truth-functions.\",\"ogd\":\"\",\"str\":\"If we are given a proposition, then with it we are also given all its truth-functions.\",\"tlp\":[5.442]},{\"label\":\"6.3\",\"precision\":1,\"fontSize\":\"40px\",\"y_axis\":43,\"x_axis\":147,\"page\":71,\"ger\":\"Das Kausalitätsgesetz ist kein Gesetz sondern die Form eines Gesetzes. \",\"pmc\":\"The law of causality is not a law but the form of a law.\",\"ogd\":\"\",\"str\":\"[Sentence crossed out]\",\"tlp\":[6.32]},{\"label\":\"6.31\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":43,\"x_axis\":149,\"page\":71,\"ger\":\"〟Kausalitätsgesetz\\\", das ist ein Gattungsname. Und wie es in der Mechanik, sagen wir, Minimum-Gesetze gibt, — etwa der kleinsten Wirkung — so gibt es in der Physik ein Kausalitätsgesetz, ein Gesetz von der Kausalitäts-Form. \",\"pmc\":\" 'Law of causality' - that is a general name. And just as in mechanics, for example, there are 'minimum-principles', such as the law of least action, so too in physics there is a law of causality, a law of the causal form.\",\"ogd\":\"\",\"str\":\"“Law of causality”  is a generic name. And just as in mechanics there are, for instance, minimum-laws, such as that of least action, so too in physics there is a law of causality, a law of the causal form.\",\"tlp\":[6.321]},{\"label\":\"6.32\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":43,\"x_axis\":151,\"page\":71,\"ger\":\"Wir glauben nicht a priori an ein Erhaltungsgesetz sondern wir wissen a priori die Möglichkeit seiner logischen Form. \",\"pmc\":\"We do not have an a priori belief in a law of conservation, but rather a priori knowledge of the possibility of its logical form.\",\"ogd\":\"\",\"str\":\"We do not believe a priori in a law of conservation, rather we know a priori the possibility of a logical form.\",\"tlp\":[6.33]},{\"label\":\"6.33\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":43,\"x_axis\":153,\"page\":71,\"ger\":\"Alle jene Sätze wie der Satz vom Grunde, von der Kontinuität in der Natur, vom kleinsten Aufwand in der Natur, etc., etc. alle diese sind Einsichten a priori über die mögliche Formgebung der Sätze der Wissenschaft.\",\"pmc\":\"All such propositions, including the principle of sufficient reason, the laws of continuity in nature and of least effort in nature, etc. etc. - all these are a priori insights about the forms in which the propositions of science can be cast.\",\"ogd\":\"\",\"str\":\"All such propositions, including the principle of sufficient reason, the laws of continuity in nature and of least effort in nature, etc. etc. - all these are a priori insights about possible forms of scientific propositions.\",\"tlp\":[6.34]},{\"label\":\"6.34\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":43,\"x_axis\":155,\"page\":73,\"ger\":\"Und hier sehen wir nun die gegenseitige Stellung von Logik und Mechanik (man könnte das Netz auch aus verschiedenartigen Figuren bestehen lassen). Daß sich ein Bild, wie das vorhin erwähnte durch ein Netz von gegebener Form beschreiben läßt sagt über das Bild nichts aus. (denn dies gilt für jedes Bild dieser Art). Das aber charakterisiert das Bild, daß es sich durch ein bestimmtes Netz von bestimmter Feinheit vollständig beschreiben läßt. <br />So auch sagt es nichts über die Welt aus, daß sie sich durch die Newtonsche Mechanik beschreiben läßt; wohl aber daß sie sich so durch jene beschreiben läßt, wie dies eben der Fall ist. Auch das sagt etwas über die Welt daß sie sich durch die eine Mechanik einfacher beschreiben läßt als durch die andere.\",\"pmc\":\"And here we can see the relative position of logic and mechanics. (The net might also consist of more than one kind of mesh.) The possibility of describing a picture like the one mentioned above with a net of a given form tells us nothing about the picture. (For that is true of all such pictures.) But what does characterize a picture is that it can be described completely by a particular net with a particular size of mesh.<br />Similarly the possibility of describing the world by means of Newtonian mechanics tells us nothing about the world: but what does tell us something about it is the precise way in which it is possible to describe it by these means. We are also told something about the world by the fact that it can be described more simply with one system of mechanics than with another.\",\"ogd\":\"\",\"str\":\"And here we can see the position of logic in relation to mechanics. (We could also construct the net from different kinds of mesh.) That such a a picture can be described by a net of a given form tells us nothing about the picture. (For this holds of every picture of this kind.) But what does characterize a picture is that it can be described completely by a specific net of a specific fineness. \\rLikewise, that the world can be described by Newtonian mechanics tells us nothing about the world: but what does tell us something about it is that the world can be described in precisely this way. We are also told something about the world by the fact that it can be described more simply in one system of mechanics than in another.\",\"tlp\":[6.342]},{\"label\":\"6.35\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":43,\"x_axis\":159,\"page\":74,\"ger\":\"Obwohl die Flecke in unserem Bild geometrische Figuren sind, so kann doch selbstverständlich die Geometrie gar nichts über ihre tatsächliche Form und Lage sagen. Das Netz aber ist rein geometrisch, alle seine Eigenschaften können a priori angegeben werden. \",\"pmc\":\"Although the spots in our picture are geometrical figures, nevertheless geometry can obviously say nothing at all about their actual form and position. The network, however, is purely geometrical; all its properties can be given a priori.\",\"ogd\":\"\",\"str\":\"Although the spots in our picture are geometrical figures, geometry can obviously say nothing about their actual form and position. But the network is purely geometrical; all its properties can be given a priori.\",\"tlp\":[6.35]},{\"label\":\"6.36\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":43,\"x_axis\":161,\"page\":74,\"ger\":\"Gesetze wie der Satz vom Grunde etc. handeln vom Netz nicht von dem was das Netz beschreibt. \",\"pmc\":\"Laws like the principle of sufficient reason, etc., are about the net and not about what the net describes.\",\"ogd\":\"\",\"str\":\"Laws like the principle of sufficient reason, etc. are about the net and not about what the net describes.\",\"tlp\":[6.35]},{\"label\":\"6.37\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":43,\"x_axis\":167,\"page\":96,\"ger\":\"Einen Zwang nach dem eines geschehen müßte, weil etwas anderes geschehen ist, gibt es nicht. Es gibt nur einelogische Notwendigkeit. \",\"pmc\":\"There is no compulsion making one thing happen because another has happened. The only necessity that exists is logical necessity\",\"ogd\":\"\",\"str\":\"Nothing makes one thing happen because something else has happened. The only kind of necessity is logical necessity.\",\"tlp\":[6.37]},{\"label\":\"3.2101\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":45,\"x_axis\":47,\"page\":43,\"ger\":\"Der Satz bestimmt einen Ort im logischen Raum. Die Existenz dieses logischen Ortes ist durch die Existenz der Bestandteile allein verbürgt, durch die Existenz des sinnvollen Satzes. \",\"pmc\":\"A proposition determines a place in logical space. The existence of this logical place is guaranteed by the mere existence of the constituents - by the existence of the proposition with a sense.\",\"ogd\":\"\",\"str\":\"A proposition determines a place in logical space. The existence of this logical place is guaranteed by the mere existence of the constituent parts - by the existence of the sentence with a sense.\",\"tlp\":[3.4]},{\"label\":\"3.211\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":45,\"x_axis\":49,\"page\":25,\"ger\":\"Zum Satz gehört alles, was zur Projektion gehört; aber nicht das Projizierte.\",\"pmc\":\"A proposition includes all that the projection includes, but not what is projected.\",\"ogd\":\"\",\"str\":\"A sentence has everything the projection has, except what is projected.\",\"tlp\":[3.13]},{\"label\":\"3.241\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":45,\"x_axis\":55,\"page\":25,\"ger\":\"Und ebenso ist allgemein das Wesentliche am Zeichen das, was alle Zeichen, die denselben Zweck erfüllen können gemeinsam haben. \",\"pmc\":\"And similarly, in general, what is essential in a sign is what all signs that can serve the same purpose have in common.\",\"ogd\":\"\",\"str\":\"Likewise, generally, what is essential about a sign is what all signs that can serve the same purpose have in common.\",\"tlp\":[3.341]},{\"label\":\"3.2411\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":45,\"x_axis\":57,\"page\":59,\"ger\":\"Man könnte also sagen: Der eigentliche Name ist das, was alle Symbole die den Gegenstand bezeichnen können gemeinsam haben. Es würde sich so sukzessive ergeben daß keinerlei Zusammensetzung für den Namen wesentlich ist. \",\"pmc\":\"So one could say that the real name of an object was what all symbols that could signify it had in common. Thus, one by one, all kinds of composition would prove to be unessential to a name.\",\"ogd\":\"\",\"str\":\"So one could say that the real name is what all symbols that could signify an object have in common. It would then follow, step by step, that no kind of composition was essential to a name.\",\"tlp\":[3.3411]},{\"label\":\"3.251\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":45,\"x_axis\":59,\"page\":55,\"ger\":\"Das was am Symbol bezeichnet, ist das Gemeinsame aller jener Symbole durch welches das erste den Regeln der logischen Syntax zufolge ersetzt werden kann. \",\"pmc\":\"What signifies in a symbol is what is common to all the symbols that the rules of logical syntax allow us to substitute for it.\",\"ogd\":\"\",\"str\":\"A symbol signifies in virtue of what is common to all those symbols by which it can be replaced according to the rules of logical syntax.\",\"tlp\":[3.344]},{\"label\":\"3.2511\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":45,\"x_axis\":61,\"page\":50,\"ger\":\"Man kann das Gemeinsame aller Notationen für die Wahrheitsfunktionen so ausdrücken: es ist ihnen gemeinsam daß sie sich alle — z.B. — durch die Notation von ~ξ und ξ ∨ η ersetzen lassen.\",\"pmc\":\"We can express what is common to all notations for truth-functions in the following way: they have in common that, for example, the notation that uses ~ξ and ξ ∨ η can be substituted for any of them.\",\"ogd\":\"\",\"str\":\"We can express what is common to all notations for truth-functions in the following way: for instance, they have in common that they all can be replaced by a notation that uses ~ξ and ξ∨η.\",\"tlp\":[3.3441]},{\"label\":\"3.2512\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":45,\"x_axis\":63,\"page\":51,\"ger\":\"Hiermit ist die Art und Weise gekennzeichnet, wie eine spezielle mögliche Notation uns allgemeine Aufschlüsse geben kann. \",\"pmc\":\"This serves to characterize the way in which something general can be disclosed by the possibility of a specific notation.\",\"ogd\":\"\",\"str\":\"This indicates the way in which a special possible notation can provide us with general information.\",\"tlp\":[3.3441]},{\"label\":\"3.2513\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":45,\"x_axis\":65,\"page\":60,\"ger\":\"Die Regeln der logischen Syntax müssen sich von selbst verstehen, wenn man nur weiß wie ein jedes Zeichen bezeichnet. \",\"pmc\":\"The rules of logical syntax must go without saying, once we know how each individual sign signifies.\",\"ogd\":\"\",\"str\":\"The rules of logical syntax must be self-evident, once we know how every single sign signifies.\",\"tlp\":[3.334]},{\"label\":\"4.101\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":45,\"x_axis\":69,\"page\":16,\"ger\":\"Der Satz kann die gesamte Wirklichkeit darstellen, aber er kann nicht das darstellen, was er mit der Wirklichkeit gemein haben muß um sie darstellen zu können, die logische Form.\",\"pmc\":\"Propositions can represent the whole of reality, but they cannot represent what they must have in common with reality in order to be able to represent it, logical form.\",\"ogd\":\"\",\"str\":\"Propositions can represent the whole of reality, but they cannot represent what they must have in common with reality to be able to represent it—logical form.pt\",\"tlp\":[4.12]},{\"label\":\"4.102\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":45,\"x_axis\":71,\"page\":17,\"ger\":\"Der Satz kann die logische Form nicht darstellen, sie spiegelt sich in ihm.\",\"pmc\":\"Propositions cannot represent logical form: it is mirrored in them.\",\"ogd\":\"\",\"str\":\"Propositions cannot represent logical form: it is mirrored in them.\",\"tlp\":[4.102]},{\"label\":\"4.103\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":45,\"x_axis\":73,\"page\":17,\"ger\":\"Der Satz stellt die logische Form nicht dar, er weist sie auf; er zeigt sie.\",\"pmc\":\"Propositions do not represent logical form: they display it; they show it.\",\"ogd\":\"\",\"str\":\"Propositions do not represent logical form: they display it; they show it.\",\"tlp\":[4.121]},{\"label\":\"4.104\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":45,\"x_axis\":75,\"page\":17,\"ger\":\"Um die logische Form darstellen zu können müßten wir uns mit dem Satz außerhalb der Logik aufstellen können, d.h. außerhalb der Welt. \",\"pmc\":\"In order to be able to represent logical form, we should have to be able to station ourselves with propositions somewhere outside logic, that is to say outside the world.\",\"ogd\":\"\",\"str\":\"To be able to represent logical form, we would have to be able to put ourselves with propositions outside logic, that is, outside the world.\",\"tlp\":[4.12]},{\"label\":\"5.3\",\"precision\":1,\"fontSize\":\"40px\",\"y_axis\":45,\"x_axis\":111,\"page\":11,\"ger\":\"Es läßt sich zeigen, daß jede Wahrheitsfunktion ein Resultat der sukzessiven Anwendung der Operation (W )'(α̅) ist.\",\"pmc\":\"It can be shown that every truth-function is a result of successive applications of the operation (T)'(ᾱ).\",\"ogd\":\"\",\"str\":\"It can be shown that every truth-function is a result of successive applications of the operation (T    )'(ᾱ).\",\"tlp\":[\"5.5, 5.32\"]},{\"label\":\"5.3001\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":45,\"x_axis\":113,\"page\":13,\"ger\":\"Wir nennen diese Operation die Negation der Werte von α und schreiben kurz statt (W)(α): N(α̅).\",\"pmc\":\"We call this operation the negation of the values of ᾱ and for brevity write (W)(α): N(ᾱ).\",\"ogd\":\"\",\"str\":\"We call this operation the negation of the values of ᾱ and for brevity write N(ᾱ) instead of (T     )(α).\",\"tlp\":[\"5.5, 5.502\"]},{\"label\":\"5.3002\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":45,\"x_axis\":115,\"page\":13,\"ger\":\"N(α) verneint sämtliche Werte von α.\",\"pmc\":\"N(ᾱ) negates all the values of α.\",\"ogd\":\"\",\"str\":\"N(ᾱ) negates all the values of α.\",\"tlp\":[\"5.5, 5.502\"]},{\"label\":\"5.3003\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":45,\"x_axis\":117,\"page\":83,\"ger\":\"Da sich offenbar leicht ausdrücken läßt, wie mit dieser Operation sich Sätze bilden lassen und wie Sätze nicht zu bilden sind, so muß dies auch irgendwie exakt auszudrücken sein. \",\"pmc\":\"It is obvious that we can easily express how propositions may be constructed with this operation, and how they may not be constructed; so there must be some way of expressing this exactly.\",\"ogd\":\"\",\"str\":\"Obviously, it is easy to express how propositions may and may not be constructed using this operation. So there must be some way of expressing this exactly.\",\"tlp\":[5.503]},{\"label\":\"6.311\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":45,\"x_axis\":149,\"page\":71,\"ger\":\"Man hat ja auch davon eine Ahnung gehabt daß es ein 〟Gesetz der kleinsten Wirkung\\\" geben müsse, ehe man genau wußte wie es lautete. <br />(Hier wie immer stellt sich das Aprioristische als etwas rein Logisches heraus.)\",\"pmc\":\"Indeed people even surmised that there must be a 'law of least action' before they knew exactly how it went.<br />(Here, as always, what is a priori proves to be something purely logical.)\",\"ogd\":\"\",\"str\":\"Indeed people had an idea that there must be a “law of least action” before they knew exactly what it was. (Here, as always, what is a priori turns out to be something purely logical.)\",\"tlp\":[6.3211]},{\"label\":\"6.331\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":45,\"x_axis\":153,\"page\":72,\"ger\":\"Die Newtonsche Mechanik z.B. bringt die Weltbeschreibung auf eine einheitliche Form. Denken wir uns eine weiße Fläche, auf der unregelmäßige schwarze Flecken wären. Wir sagen nun: Was immer für ein Bild hiedurch entsteht, immer werde ich seiner Beschreibung beliebig nahe kommen können, indem ich die Fläche mit einem entsprechend feinen quadratischen Netzwerk bedecke und nun von jedem Quadrat sage, daß es weiß oder schwarz ist. Ich werde auf diese Weise die Beschreibung der Fläche auf eine einheitliche Form gebracht haben. Diese Form ist beliebig, denn ich hätte mit dem gleichen Erfolge ein Netz mit dreieckigen oder sechseckigen Maschen verwenden können. Es kann sein daß die Beschreibung mit Hilfe eines Dreiecks-Netzes einfacher geworden wäre; das heißt daß wir die Fläche mit einem gröberen Dreiecksnetz genauer beschreiben könnten als mit einem feineren quadratischen (oder umgekehrt) u.s.w.. Denverschiedenen Netzen entsprechen verschiedene Systeme der Weltbeschreibung. Die Mechanik bestimmt eine Form der Weltbeschreibung indem sie sagt: Alle Sätze der Weltbeschreibung müssen aus einer Anzahl gegebener Sätze — den mechanischen Axiomen — auf eine gegebene Art und Weise erhalten werden. Hierdurch liefert sie die Bausteine zum Bau des wissenschaftlichen Gebäudes und sagt: Welches Gebäude immer Du aufführen willst, jedes mußt du irgendwie mit diesen und nur diesen Bausteinen zusammenbringen.<br />(Wie man mit dem Zahlensystem jede beliebige Anzahl, so muß ich mit dem System der Mechanik jeden beliebigen Satz der Physik hinschreiben können.)\",\"pmc\":\"Newtonian mechanics, for example, imposes a unified form on the description of the world. Let us imagine a white surface with irregular black spots on it. We then say that whatever kind of picture these make, I shall be able to approximate as closely as I wish to the description of it by covering the surface with a sufficiently fine square mesh, and then saying of every square whether it is black or white. In this way I shall have imposed a unified form on the description of the surface. The form is optional, since I could have achieved the same result by using a net with a triangular or hexagonal mesh. Possibly the use of a triangular mesh would have made the description simpler: that is to say, it might be that we could describe the surface more accurately with a coarse triangular mesh than with a fine square mesh (or conversely), and so on. The differing nets correspond to different systems for describing the world. Mechanics determines one form of description of the world by saying that all propositions used in the description of the world must be obtained in a given way from a given set of propositions - the axioms of mechanics. It thus supplies the bricks for building the edifice of science, and it says, 'Any building that you want to erect, whatever it may be, must somehow be constructed with these bricks, and with these alone'.<br />(Just as with the number-system we must be able to write down any number we wish, so with the system of mechanics we must be able to write down any proposition of physics that we wish.)\",\"ogd\":\"\",\"str\":\"Newtonian mechanics, for instance, puts world description into a uniform form. Imagine a white surface with irregular black spots. We then say: whatever kind of picture these make, I can always get as near as I like to its description, provided I cover the surface with a sufficiently fine square mesh, and then say of every square whether it is white or black. In this way I put the description of the surface into a uniform form. The form is arbitrary, because I could have just as well applied a net with a triangular or hexagonal mesh. It might be that the description would then have been simpler, that is, we might well described the surface more accurately with a coarser triangular mesh than with a finer square mesh or vice versa, and so on. The different nets correspond to different systems of describing the world. Mechanics determines a form of world description by saying: all propositions used in the description of the world must be obtained in a given way from a given set of propositions - the mechanical axioms. In this way it supplies the bricks for building the edifice of science, and says: Whatever building that you want to erect, must somehow be constructed with these, and only these, bricks.\\r(Just as within the number system we must be able to write down any arbitrary number, so within the system of mechanics we must be able to write down any arbitrary proposition ofphysics.)\",\"tlp\":[6.341]},{\"label\":\"6.341\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":45,\"x_axis\":155,\"page\":73,\"ger\":\"Die Mechanik ist ein Versuch alle wahren Sätze die wir zur Weltbeschreibung brauchen, nach einem Plane zu konstruieren.\",\"pmc\":\"Mechanics is an attempt to construct according to a single plan all the true propositions that we need for the description of the world.\",\"ogd\":\"\",\"str\":\"Mechanics is an attempt to construct according to a single plan all true propositions we need for the description of the world.\",\"tlp\":[6.343]},{\"label\":\"6.3411\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":45,\"x_axis\":157,\"page\":87,\"ger\":\"Durch den ganzen logischen Apparat hindurch, sprechen die physikalischen Sätze doch von den Gegenständen der Welt. \",\"pmc\":\"The propositions of physics, with all their logical apparatus, still speak, however indirectly, about the objects of the world.\",\"ogd\":\"\",\"str\":\"The propositions of physics, despite all their logical apparatus, still speak  about the objects of the world.\",\"tlp\":[6.3431]},{\"label\":\"6.3412\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":45,\"x_axis\":159,\"page\":98,\"ger\":\"Wir dürfen nicht vergessen daß die Weltbeschreibung durch die Mechanik immer die ganz allgemeine ist. Es ist in ihr z.B. nie von bestimmten materiellen Punkten die Rede sondern immer nur von irgend welchen. \",\"pmc\":\"We ought not to forget that any description of the world by means of mechanics will be of the completely general kind. For example, it will never mention particular point-masses: it will only talk about any point-masses whatsoever.\",\"ogd\":\"\",\"str\":\"Don’t forget that any description of the world by means of mechanics will always be completely general. For instance, it will never any mention particular point masses, but rather any point masses whatsoever.\",\"tlp\":[6.3432]},{\"label\":\"6.361\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":45,\"x_axis\":161,\"page\":98,\"ger\":\"Wenn es ein Kausalitätsgesetz gäbe, so könnte es lauten: 〟Es gibt Naturgesetze\\\". \",\"pmc\":\"If there were a law of causality, it might be put in the following way: 'There are laws of nature.'\",\"ogd\":\"\",\"str\":\"If there were a law of causality, it might go like this: “There are laws of nature.”\",\"tlp\":[6.36]},{\"label\":\"6.371\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":45,\"x_axis\":167,\"page\":81,\"ger\":\"Der ganzen modernen Weltanschauung liegt die Täuschung zu Grunde, daß die sogenannten Naturgesetze die Erklärungen der Naturerscheinungen seien.\",\"pmc\":\"The whole modern conception of the world is founded on the illusion that the so-called laws of nature are the explanations of natural phenomena.\",\"ogd\":\"\",\"str\":\"The whole modern world view is based on the illusion that the so-called laws of nature explain natural phenomena.\",\"tlp\":[6.371]},{\"label\":\"3.2102\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":47,\"x_axis\":47,\"page\":43,\"ger\":\"Das Satzzeichen und die logischen Koordinaten: das ist der logische Ort. \",\"pmc\":\"The propositional sign with logical co-ordinates - that is the logical place.\",\"ogd\":\"\",\"str\":\"The sentential sign with logical co-ordinates - that is the logical place.\",\"tlp\":[3.41]},{\"label\":\"3.212\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":47,\"x_axis\":49,\"page\":25,\"ger\":\"Also die Möglichkeit des Projizierten, aber nicht dieses selbst. \",\"pmc\":\"Therefore, though what is projected is not itself included, its possibility is.\",\"ogd\":\"\",\"str\":\"Therefore, the possibility of what is projected is in the sentence, but not the  projection itself.\",\"tlp\":[3.13]},{\"label\":\"3.242\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":47,\"x_axis\":55,\"page\":44,\"ger\":\"An unseren Notationen ist zwar etwas willkürlich, aber das ist nicht willkürlich: daß, wenn wir etwas willkürlich bestimmt haben, dann etwas anderes der Fall sein muß. (Dies hängt von dem Wesen der Notation ab.) \",\"pmc\":\"Although there is something arbitrary in our notation, this much is not arbitrary - that when we have determined one thing arbitrarily, something else is necessarily the case. (This derives from the essence of notation.)\",\"ogd\":\"\",\"str\":\"In our notations there is indeed something arbitrary, but this is not arbitrary - that if we have determined anything arbitrarily, then something else must be the case. (This results from the essence of notation.)\",\"tlp\":[3.342]},{\"label\":\"3.2421\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":47,\"x_axis\":57,\"page\":44,\"ger\":\"Eine besondere Bezeichnungsweise mag unwichtig sein, aber wichtig ist es immer daß diese eine möglicheBezeichnungsweise ist. \",\"pmc\":\"A particular mode of signifying may be unimportant but it is always important that it is one possible mode of signifying.\",\"ogd\":\"\",\"str\":\"A particular mode of signifying may be unimportant but it is always important that it is a possible mode of signifying.\",\"tlp\":[3.33421]},{\"label\":\"3.252\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":47,\"x_axis\":59,\"page\":55,\"ger\":\"Um das Symbol im Zeichen zu erkennen muß man auf den Gebrauch achten. \",\"pmc\":\"In order to recognize a symbol in its sign we must observe how it is ued.\",\"ogd\":\"\",\"str\":\"To recognize a symbol in its sign we must observe how it is used.\",\"tlp\":[3.326]},{\"label\":\"3.2521\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":47,\"x_axis\":61,\"page\":60,\"ger\":\"Wird ein Zeichen nicht gebraucht, so ist es bedeutungslos. Das ist der Sinn der Devise Occams. \",\"pmc\":\"If a sign is useless, it is meaningless. That is the point of Occam's maxim.\",\"ogd\":\"\",\"str\":\"An unused sign is meaningless. That is the point of Occam's razor.\",\"tlp\":[3.328]},{\"label\":\"3.2522\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":47,\"x_axis\":63,\"page\":81,\"ger\":\"Wenn sich alles so verhält als hätte ein Zeichen Bedeutung, dann hat es auch Bedeutung. \",\"pmc\":\"If everything behaves as if a sign had meaning, then it does have meaning.\",\"ogd\":\"\",\"str\":\"If everything behaves as if a sign had meaning, then it does have meaning.\",\"tlp\":[3.328]},{\"label\":\"4.1011\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":47,\"x_axis\":69,\"page\":56,\"ger\":\"Beiläufig gesprochen: Ein Satz kann nur sagen wie ein Ding ist, nicht was es ist. \",\"pmc\":\"In a manner of speaking, a proposition can only say how a thing is, not what it is.\",\"ogd\":\"\",\"str\":\"Roughly speaking: A proposition can only say how a thing is, not what it is.\",\"tlp\":[3.221]},{\"label\":\"4.1031\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":47,\"x_axis\":73,\"page\":41,\"ger\":\"Was gezeigt werden kann, kann nicht gesagt werden. \",\"pmc\":\"What can be shown, cannot be said.\",\"ogd\":\"\",\"str\":\"What can be shown, cannot be said.\",\"tlp\":[4.1212]},{\"label\":\"5.301\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":47,\"x_axis\":113,\"page\":32,\"ger\":\"Hat die Logik Grundbegriffe, so müssen sie von einander unabhängig sein. Ist ein Grundbegriff eingeführt so muß er in allen Verbindungen eingeführt sein worin er überhaupt vorkommt. Man kann ihn also nicht zuerst für eine Verbindung, dann nocheinmal für eine andere einführen. Z.B.: Ist die Verneinung eingeführt so müssen wir sie jetzt in Sätzen von der Form ~p ebenso verstehen, wie in Sätzen wie ~(p ∨ q) (oder (Ex).~ϕx) u.a.. Wir dürfen sie nicht erst für die eine Klasse von Fällen, dann für die andere einführen, denn es bliebe dann zweifelhaft ob ihre Bedeutung in beiden Fällen die gleiche wäre und es wäre kein Grund vorhanden in beiden Fällen die selbe Art der Zeichenverbindung zu benützen.<br />(Kurz, für die Einführung der Urzeichen gilt mutatis mutandis dasselbe was Frege (Grundgesetze der Arithmetik) für die Einführung von Zeichen durch Definitionen gesagt hat.)\",\"pmc\":\"If logic has primitive ideas, they must be independent of one another. If a primitive idea has been introduced, it must have been introduced in all the combinations in which it ever occurs. It cannot, therefore, be introduced first for one combination and later re-introduced for one another. For example, once negation has been introduced, we must understand it both in propositions of the form ~p and in propositions like ~(p∨q), (or (∃x).~ϕx), etc. We must not introduce it first for the one class of cases and then for the other, since it would then be left in doubt whether its meaning were the same in both cases, and no reason would have been given for combining the signs in the same way in both cases.<br />(In short, Frege's remarks about introducing signs by means of definitions (in The Fundamental Laws of Arithmetic) also apply, mutatis mutandis, to the introduction of primitive signs.)\",\"ogd\":\"\",\"str\":\"If logic has primitive ideas, they must be independent of one another. If a primitive idea is introduced, it must be introduced for all the contexts in which it occurs at all. One cannot, therefore, introduce it first for one context and then again for one another. For instance, once negation is introduced, we must understand it both in propositions of the form ~p and in propositions like ~(p ∨q), (or (∃x).~ϕx), etc. We cannot introduce it first for one class of cases and then for the other, since it would then remain doubtful whether its meaning were the same in both cases, and there would be no reason for using the same kind of connective in both cases.\\r(In short, what Frege said about introducing signs by means of definitions (in The Fundamental Laws of Arithmetic) also applies, mutatis mutandis, to the introduction of primitive signs.)\",\"tlp\":[5.451]},{\"label\":\"5.302\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":47,\"x_axis\":115,\"page\":38,\"ger\":\"Wenn man die logischen Urzeichen richtig einführte so hätte man damit auch schon den Sinn aller ihrer Kombinationen eingeführt; also nicht nur 〟p∨q\\\" sondern auch schon 〟~(p∨~q)\\\" etc. etc. Man hätte damit auch schon die Wirkung aller nur möglichen Kombinationen von Klammern eingeführt. Und damit wäre es klar geworden, daß die eigentlichen allgemeinen Urzeichen nicht die 〟p∨q\\\" (Ex)·ϕx etc. sind sondern die allgemeinste Form ihrer Kombinationen. \",\"pmc\":\"If we introduced primitive signs of logic properly, then we should have introudced at the same time the sense of all combinations of them; i.e. not only 'p∨q' but '~(p∨~q)' as well, etc., etc. We should also have introduced at the same time the effect of all possible combinations of brackets. And thus it would have been made clear that the real general primitive signs are not 'p∨q', (∃x).ϕx), etc. but the most general form of their combinations.\",\"ogd\":\"\",\"str\":\"If we introduced primitive signs of logic properly, then we would have introduced the sense of all their combinations at the same time; that is, not only “p∨q” but also “~(p∨~q)”, etc., etc. We should also have introduced at the same time the effect of all possible combinations of brackets. And we would have thereby made clear that the proper general primitive signs are not “p∨q”, (∃x).ϕx, etc. but the most general form of their combinations.\",\"tlp\":[5.46]},{\"label\":\"5.303\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":47,\"x_axis\":119,\"page\":47,\"ger\":\"Es ist klar, daß alles was sich überhaupt von vornherein über die Form aller Sätze sagen läßt, sich auf einmal sagen lassen muß. \",\"pmc\":\"It is clear that whatever we can say in advance about the form of all propositions, we must be able to say all at once.\",\"ogd\":\"\",\"str\":\"Clearly, whatever can be said from the start about the form of all propositions, must be sayable all at once.\",\"tlp\":[5.47]},{\"label\":\"5.304\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":47,\"x_axis\":121,\"page\":46,\"ger\":\"Die eine logische Konstante ist das, was alle Sätze, ihrer Natur nach, gemeinsam haben. \",\"pmc\":\"The sole logical constant is what all propositions, by their very nature, have in common.\",\"ogd\":\"\",\"str\":\"The sole logical constant is what all propositions, by their nature, have in common.\",\"tlp\":[5.47]},{\"label\":\"5.305\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":47,\"x_axis\":123,\"page\":47,\"ger\":\"Das aber ist die allgemeine Satzform. \",\"pmc\":\"But that is the general propositional form.\",\"ogd\":\"\",\"str\":\"But that is the general propositional form.\",\"tlp\":[5.47]},{\"label\":\"5.306\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":47,\"x_axis\":125,\"page\":47,\"ger\":\"Die allgemeine Satzform ist das Wesen des Satzes. \",\"pmc\":\"The general propositional form is the essence of a proposition.\",\"ogd\":\"\",\"str\":\"The general propositional form is the essence of a proposition.\",\"tlp\":[5.471]},{\"label\":\"5.307\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":47,\"x_axis\":127,\"page\":51,\"ger\":\"Die Beschreibung der allgemeinsten Satzform ist die Beschreibung des einen und einzigen allgemeinen Urzeichens der Logik. \",\"pmc\":\"The description of the most general propositional form is the description of the one and only general primitive sign in logic.\",\"ogd\":\"\",\"str\":\"The description of the most general propositional form is the description of the one and only general primitive sign in logic.\",\"tlp\":[5.472]},{\"label\":\"6.362\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":47,\"x_axis\":161,\"page\":98,\"ger\":\"Aber freilich kann man das nicht sagen; es zeigt sich. \",\"pmc\":\"But of course that cannot be said; it makes itself manifest.\",\"ogd\":\"\",\"str\":\"But of course that cannot be said: it shows itself.\",\"tlp\":[6.36]},{\"label\":\"6.372\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":47,\"x_axis\":167,\"page\":82,\"ger\":\"So bleiben sie bei den Naturgesetzen als bei etwas Unantastbarem stehen, wie die Älteren bei Gott und dem Schicksal. <br />Und sie haben ja beide, recht und unrecht. Die Alten sind allerdings insofern klarer als sie einen klaren Abschluß anerkennen, während es bei dem neuen System scheinen soll als sei alles erklärt. \",\"pmc\":\"Thus people today stop at the laws of nature, treating them as something inviolable, just as God and Fate were treated in past ages.<br />And in fact both are right and both wrong: though the view of the ancients is clearer in so far as they have a clear and acknowledged terminus, while the modern system tries to make it look as if everything were explained.\",\"ogd\":\"\",\"str\":\"So moderns stop at the laws of nature, treating them as sacrosanct, which is how the ancients treated God and Fate. And actually they are both right, and both wrong.  But the ancients were much clearer in that they recognised a clear terminus, while the moderns make it seem as if everything is explained.\",\"tlp\":[6.372]},{\"label\":\"3.2103\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":49,\"x_axis\":47,\"page\":43,\"ger\":\"Der geometrische und der logische Ort stimmen darin überein, daß beide die Möglichkeit einer Existenz sind. \",\"pmc\":\"In geometry and logic alike a place is a possibility: something can exist in it.\",\"ogd\":\"\",\"str\":\"In both geometry and logic, a place is a possibility: something can exist in it.\",\"tlp\":[3.411]},{\"label\":\"3.213\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":49,\"x_axis\":49,\"page\":25,\"ger\":\"Im Satz ist also sein Sinn noch nicht enthalten, wohl aber die Möglichkeit ihn auszudrücken.\",\"pmc\":\"A proposition, therefore, does not actually contain its sense, but does contain the possibility of expressing it.\",\"ogd\":\"\",\"str\":\"And so a sentence does not yet contain its sense, but it does contain the possibility of expressing that sense.\",\"tlp\":[3.13]},{\"label\":\"3.2131\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":49,\"x_axis\":51,\"page\":25,\"ger\":\"〟Der Inhalt der Satzes\\\" heißt der Inhalt des sinnvollen Satzes.\",\"pmc\":\" 'The content of a proposition' means the content of a proposition that has sense.\",\"ogd\":\"\",\"str\":\"“The content of a sentence” means the content of a sentence that makes sense.\",\"tlp\":[3.13]},{\"label\":\"3.24211\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":49,\"x_axis\":57,\"page\":44,\"ger\":\"Und so verhält es sich in der ganzen Philosophie: das Einzelne erweist sich immer wieder als unwichtig aber die Möglichkeit jedes Einzelnen gibt uns einen Aufschluß über das Wesen der Welt. \",\"pmc\":\"And that is so throughout philosophy: again and again the individual case turns out to be unimportant, but the possibility of each individual case discloses something about the essence of the world.\",\"ogd\":\"\",\"str\":\"And that’s the way it is throughout philosophy: again and again the particular case turns out to be unimportant, but the possibility of each particular case discloses something essential about the world.\",\"tlp\":[3.3421]},{\"label\":\"3.253\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":49,\"x_axis\":59,\"page\":58,\"ger\":\"Zeichen kennzeichnen die Gemeinsamkeit einer Form und eines Inhalts. — Sie bestimmen erst mit ihrer syntaktischen Verwendung zusammen eine logische Form. \",\"pmc\":\"A sign marks the sharing of a single form and a single content. It does not determine a logical form unless it is taken together with its syntactical employment.\",\"ogd\":\"\",\"str\":\"A sign marks the sharing of a single form and a single content. It determines a logical form only together with its use according to syntax.\",\"tlp\":[\"3.31, 3.327\"]},{\"label\":\"3.2531\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":49,\"x_axis\":61,\"page\":59,\"ger\":\"Das Zeichen des Komplexes löst sich auch bei der Analyse nicht willkürlich auf, sodaß etwa seine Auflösung in jedem Satzgefüge eine andere wäre. \",\"pmc\":\"Nor does analysis resolve the sign for a complex in an arbitrary way: for instance, it would not have a different resolution every time that it was incorporated in a different proposition.\",\"ogd\":\"\",\"str\":\"Analysis does not give an arbitrary resolution of the sign for a complex: for instance, it would not have a different resolution in every propositional structure.\",\"tlp\":[3.3442]},{\"label\":\"4.1021\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":49,\"x_axis\":71,\"page\":17,\"ger\":\"Was sich in der Sprache spiegelt, kann sie nicht darstellen.\",\"pmc\":\"What finds its reflection in langauge, language cannot represent.\",\"ogd\":\"\",\"str\":\"Language reflects what it cannot represent.\",\"tlp\":[4.121]},{\"label\":\"4.1032\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":49,\"x_axis\":73,\"page\":61,\"ger\":\"Jetzt verstehen wir auch, warum man immer fühlte, daß wir im Besitz einer richtigen logischen Auffassung wären, wenn nur alles in unserem Symbolismus stimmte. \",\"pmc\":\"Now too we understand why people have always felt that if only everything in our symbolism were all right, we should have a correct logical point of view.\",\"ogd\":\"\",\"str\":\"Now too we understand why people have always felt that if only everything in our symbolism were all right, we would have the right logical conception.\",\"tlp\":[4.1213]},{\"label\":\"5.30201\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":49,\"x_axis\":115,\"page\":47,\"ger\":\"Von tiefer Bedeutung ist die scheinbar unwichtige Tatsache, daß die logischen Scheinbeziehungen wie ∨ und ⊃ der Klammern bedürfen; im Gegensatz zu den wirklichen Beziehungen. \",\"pmc\":\"Thought it seems unimportant, it is in fact of deep significance that the pseudo-relations of logic, such as ∨ and ⊃, need brackets - unlike real relations.\",\"ogd\":\"\",\"str\":\"The apparently unimportant fact that logical pseudorelations like ∨ and ⊃, need brackets - unlike real relations - is deeply significant.\",\"tlp\":[5.461]},{\"label\":\"5.3031\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":49,\"x_axis\":119,\"page\":51,\"ger\":\"Sind ja schon in Elementarsatz alle logischen Operationen enthalten. Denn ϕa=(Ex)·ϕx·x=a. \",\"pmc\":\"An elementary proposition really contains all logical operations in itself. For ϕa=(∃x).ϕx. x=a.\",\"ogd\":\"\",\"str\":\"An elementary proposition already contains all logical operations. For ϕa = (∃x).ϕx.x =a.\",\"tlp\":[5.47]},{\"label\":\"5.3061\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":49,\"x_axis\":125,\"page\":47,\"ger\":\"Das Wesen des Satzes angeben, heißt, das Wesen aller Beschreibung angeben, also das Wesen der Welt. \",\"pmc\":\"To give the essence of a proposition means to give the essence of all description, and thus the essence of the world.\",\"ogd\":\"\",\"str\":\"To give the essence of a proposition means to give the essence of all description, and thus the essence of the world.\",\"tlp\":[5.4711]},{\"label\":\"5.3071\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":49,\"x_axis\":127,\"page\":80,\"ger\":\"Die Anzahl der nötigen Grundoperationen hängt nur von unserer Notation ab. \",\"pmc\":\"The number of fundamental operations that are necessary depends solely on our notation.\",\"ogd\":\"\",\"str\":\"The number of fundamental operations we need depends solely on our notation.\",\"tlp\":[5.474]},{\"label\":\"6.363\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":49,\"x_axis\":161,\"page\":98,\"ger\":\"In der Ausdrucksweise Hertz's könnte man sagen: nur gesetzmäßige Zusammenhänge sind denkbar. \",\"pmc\":\"One might say, using Hertz's terminology, that only connections that are subject to law are thinkable.\",\"ogd\":\"\",\"str\":\"In Hertz's terminology, we might say: Only lawful connections are thinkable.\",\"tlp\":[6.361]},{\"label\":\"6.3631\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":49,\"x_axis\":163,\"page\":98,\"ger\":\"Wir können keinen Vorgang mit dem 〟Ablauf der Zeit\\\" vergleichen — diesen gibt es nicht —, sondern nur mit einem anderen Vorgang (etwa mit dem Gang des Chronometers).<br />Daher ist die Beschreibung des zeitlichen Verlaufs nur so möglich, daß wir uns auf einen anderen Vorgang stützen.\",\"pmc\":\"We cannot compare a process with 'the passage of time' - there is no such thing - but only with another process (such as the working of a chronometer).<br />Hence we can describe the lapse of time only by relying on some other process.\",\"ogd\":\"\",\"str\":\"We cannot compare any process with “the passage of time” - there is no such thing - but only with another process (such as the movement of a chronometer).\\rSo it is only possible to give a description of the lapse of time if we rely on some other process.\",\"tlp\":[6.3611]},{\"label\":\"6.3632\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":49,\"x_axis\":165,\"page\":99,\"ger\":\"Ganz Analoges gilt für den Raum. Wo man z.B. sagt es könne keines von zwei Ereignissen (die sich gegenseitig ausschließen) eintreten, weil keine Ursache vorhanden sei warum das eine eher als das andere eintreten solle, da handelt es sich in Wirklichkeit darum, daß man gar nicht eines der beiden Ereignisse beschreiben kann, wenn nicht irgend eine Asymmetrie vorhanden ist. Und wenn eine solche Asymmetrie vorhanden ist, so können wir diese als Ursache des Eintreffens des einen und Nicht-Eintreffens des anderen auffassen. \",\"pmc\":\"Something exactly analogous applies to space: e.g. when people say that neither of two events (which exclude one another) can occur, because there is nothing to cause the one to occur rather than the other, it is really a matter of our being unable describe one of the two events unless there is some sort of asymmetry to be found. And if such an asymmetry is found, we can regard it as the cause of the occurrence of the one and the non-occurrence of the other.\",\"ogd\":\"\",\"str\":\"The same is true of space. When, for instance, we say that neither of two (mutually exclusive) events can occur, because there is no cause why one  rather than the other should occur, it is really a matter of our being unable describe one of the two events unless there is some sort of asymmetry. And if there is such an asymmetry, we can regard it as the cause of the occurrence of the one and the nonoccurrence of the other.\",\"tlp\":[6.3611]},{\"label\":\"6.373\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":49,\"x_axis\":167,\"page\":82,\"ger\":\"Die Welt ist unabhängig von meinem Willen. \",\"pmc\":\"The world is independent of my will.\",\"ogd\":\"\",\"str\":\"The world is independent of my will.\",\"tlp\":[6.373]},{\"label\":\"3.2104\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":51,\"x_axis\":47,\"page\":43,\"ger\":\"Obwohl der Satz nur einen Ort des logischen Raumes bestimmen darf, so muß doch durch ihn schon der ganze logische Raum gegeben sein.<br />(Sonst würden durch Verneinung, Disjunktion, etc. immer neue Elemente — in Koordination — eingeführt.)\",\"pmc\":\"A proposition can determine only one place in logical space: nevertheless the whole of logical space must already be given by it.<br />(Otherwise negation, disjunction, etc., would introduce more and more new elements - in co-ordination.)\",\"ogd\":\"\",\"str\":\"Although a proposition may determine only one place in logical space, the whole logical space must already be given by it.\\r(Otherwise negation, disjunction, etc., would introduce more and more new elements - in coordination.)\",\"tlp\":[3.42]},{\"label\":\"3.214\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":51,\"x_axis\":49,\"page\":25,\"ger\":\"Im Satz ist die Form seines Sinnes enthalten, aber nicht dessen Inhalt. \",\"pmc\":\"A proposition contains the form, but not the content, of its sense.\",\"ogd\":\"\",\"str\":\"A sentence contains the form of its sense, but not its content.\",\"tlp\":[3.13]},{\"label\":\"3.2141\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":51,\"x_axis\":51,\"page\":43,\"ger\":\"Das logische Gerüst um das Bild herum bestimmt den logischen Raum. \",\"pmc\":\"The logical scaffolding surrounding a picture determines logical space.\",\"ogd\":\"\",\"str\":\"The logical scaffolding around a picture determines logical space.\",\"tlp\":[3.42]},{\"label\":\"3.2142\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":51,\"x_axis\":53,\"page\":43,\"ger\":\"Der Satz durchgreift den ganzen logischen Raum. \",\"pmc\":\"The force of a proposition reaches through the whole of logical space.\",\"ogd\":\"\",\"str\":\"A proposition reaches through the whole of logical space.\",\"tlp\":[3.2142]},{\"label\":\"4.1022\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":51,\"x_axis\":71,\"page\":19,\"ger\":\"Was sich in der Sprache ausdrückt, können wir nicht durch sie ausdrücken.\",\"pmc\":\"What expresses itself in language, we cannot express by means of language.\",\"ogd\":\"\",\"str\":\"That which expresses itself in language, we cannot express by means of language.\",\"tlp\":[4.121]},{\"label\":\"4.10221\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":51,\"x_axis\":73,\"page\":19,\"ger\":\"Die logische Struktur der Sachlage spiegelt sich also im Satz — wir können sie nicht durch die Sprache ausdrücken — der Satz zeigt sie. \",\"pmc\":\"So the logical structure of a situation is mirrored in a proposition - we cannot express it by means of language - the proposition shows it.\",\"ogd\":\"\",\"str\":\"So the logical structure of a situation is mirrored in a proposition - we cannot express it by means of language - the proposition shows it.\",\"tlp\":[\"None\"]},{\"label\":\"4.10222\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":51,\"x_axis\":75,\"page\":19,\"ger\":\"Wir können in gewissem Sinne von Eigenschaften-der-Struktur der Tatsachen bzw. von Relationen ihrer Strukturen reden.\",\"pmc\":\"In a certain sense we can talk about structural properties of facts or about structural relations between them.\",\"ogd\":\"\",\"str\":\"In a certain sense we can talk about structural properties of facts or about structural relations between them.\",\"tlp\":[4.122]},{\"label\":\"4.10223\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":51,\"x_axis\":77,\"page\":19,\"ger\":\"Nur kann das Bestehen solcher Eigenschaften und Relationen nicht durch Sätze behauptet werden, sondern es zeigt sich in den Sätzen welche die Strukturen darstellen. \",\"pmc\":\"Only it is impossible to assert by means of propositions that such properties and relations exist: rather, they make themselves manifest in the propositions that represent the structures.\",\"ogd\":\"\",\"str\":\"However it is impossible to assert by means of propositions that such properties and relations obtain: rather, this shows itself in the propositions that represent the structures.\",\"tlp\":[4.122]},{\"label\":\"4.10224\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":51,\"x_axis\":79,\"page\":19,\"ger\":\"Das Bestehen einer internen Eigenschaft einer möglichen Sachlage wird nicht durch einen Satz ausgedrückt, sondern es drückt sich in dem sie darstellenden Satz durch eine interne Eigenschaft des Satzes aus.\",\"pmc\":\"The existence of an internal property of a possible situation is not expressed by means of a proposition: rather, it expresses itself in the proposition representing the situation, by means of an internal property of the proposition.\",\"ogd\":\"\",\"str\":\"The obtaining of an internal property of a possible situation is not expressed by means of a proposition: rather, it expresses itself in the proposition representing the situation, by means of an internal property of the proposition.pt\",\"tlp\":[4.124]},{\"label\":\"4.10225\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":51,\"x_axis\":81,\"page\":20,\"ger\":\"Das Bestehen einer internen Relation zwischen möglichen Sachlagen drückt sich sprachlich durch eine interne Relation zwischen den sie darstellenden Sätzen aus.\",\"pmc\":\"The existence of an internal relation between possible signs expresses itself in language by means of an internal relation between the propositions representing them.\",\"ogd\":\"\",\"str\":\"That an internal relation obtains between possible situations expresses itself in language by means of an internal relation between the propositions representing them.\",\"tlp\":[4.125]},{\"label\":\"4.10226\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":51,\"x_axis\":87,\"page\":23,\"ger\":\"Daß etwas unter einen formalen Begriff als dessen Gegenstand fällt, kann nicht durch einen Satz ausgedrückt werden.<br />Es zeigt sich an dem Zeichen dieses Gegenstandes selbst. (Der Name zeigt daß er einen Gegenstand bezeichnet, das Zahlzeichen daß es eine Zahl bezeichnet.)\",\"pmc\":\"When something falls under a formal concept as one of its objects, this cannot be expressed by means of a proposition.<br />It (this) is shown in the very sign for this object.<br />(A name shows that it signifies an object, a sign for a number that it signifies a number.)\",\"ogd\":\"\",\"str\":\"Something’s being an instance of a formal concept cannot be expressed by a proposition. \\rIt is shown by the sign for the object itself. \\r(A name shows that it signifies an object, a numeral that it signifies a number.)pt\",\"tlp\":[4.126]},{\"label\":\"4.10227\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":51,\"x_axis\":91,\"page\":24,\"ger\":\"Die Satzvariable bezeichnet also den formalen Begriff und ihre Werte, die Gegenstände welche unter diesen Begriff fallen.\",\"pmc\":\"So the propositional variable signifies the formal concept, and its values signify the objects that fall under the concept.\",\"ogd\":\"\",\"str\":\"So the sentential variable signifies the formal concept, and its values signify the objects that are its instances.\",\"tlp\":[4.127]},{\"label\":\"5.30202\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":51,\"x_axis\":115,\"page\":92,\"ger\":\"Die logischen Operationszeichen sind Interpunktionen. \",\"pmc\":\"Signs for logical operations are punctuation-marks.\",\"ogd\":\"\",\"str\":\"The logical operation signs are punctuation marks.\",\"tlp\":[5.4611]},{\"label\":\"5.3021\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":51,\"x_axis\":117,\"page\":35,\"ger\":\"Alle Zahlen der Logik müssen sich rechtfertigen lassen. \",\"pmc\":\"All numbers in logic stand in need of justification.\",\"ogd\":\"\",\"str\":\"All use of numbers in logic requires justification.\",\"tlp\":[5.453]},{\"label\":\"5.3032\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":51,\"x_axis\":119,\"page\":55,\"ger\":\"Wo Zusammengesetztheit ist, da ist Argument und Funktion, und wo diese sind, sind bereits alle logischen Konstanten.\",\"pmc\":\"Wherever there is compositeness, argument and function are present, and where these are present, we already have all the logical constants.\",\"ogd\":\"\",\"str\":\"Wherever there is compositeness, there is argument and function, and where these are present, all the logical constants are already there.\",\"tlp\":[5.47]},{\"label\":\"5.3062\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":51,\"x_axis\":125,\"page\":52,\"ger\":\"Die Logik muß für sich selber sorgen. \",\"pmc\":\"Logic must look after itself.\",\"ogd\":\"\",\"str\":\"Logic must take care of itself.\",\"tlp\":[5.473]},{\"label\":\"5.3072\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":51,\"x_axis\":127,\"page\":80,\"ger\":\"Es handelt sich nur darum ein Zeichensystem von einer bestimmten Anzahl von Dimensionen — von einer bestimmtenmathematischen Mannigfaltigkeit — zu bilden. \",\"pmc\":\"It is only a matter of constructing a system of signs with a particular number of dimensions - with a particular mathematical multiplicity.\",\"ogd\":\"\",\"str\":\"It is only a matter of constructing a system of signs with a particular number of dimensions - with a particular mathematical multiplicity.\",\"tlp\":[5.475]},{\"label\":\"6.36321\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":51,\"x_axis\":165,\"page\":99,\"ger\":\"Das Kantsche Problem von der rechten und linken Hand die man nicht zur Deckung bringen kann, besteht schon in der Ebene, ja im eindimensionalen Raum wo die beiden kongruenten Figuren a und b auch nicht zur Deckung gebracht werden können ohne <br /><br />aus diesem Raum herausbewegt zu werden.\",\"pmc\":\"Kant's problem about the right hand and left hand, which cannot be made to coincide, exists even in two dimensions. Indeed, it exists in one-dimensional space in which the two congruent figures, a and b, cannot be made to coincide unless they are moved out of this space.\",\"ogd\":\"\",\"str\":\"The Kantian problem of the right and left hands that cannot coincide already arises in two dimensions, and even in one-dimensional space where two congruent figures, a and b, cannot be made to coincide without \\t\\t\\t                 a                      b      \\r\\t\\r        moving them out of this space.\",\"tlp\":[6.36111]},{\"label\":\"6.374\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":51,\"x_axis\":167,\"page\":82,\"ger\":\"Auch wenn alles was wir wünschen geschähe, so wäre dies doch nur, sozusagen, eine Gnade des Schicksals, denn es ist kein logischer Zusammenhang zwischen Willen und Welt der dies verbürgte und den angenommenen physikalischen könnten wir doch nicht selbst wieder wollen. \",\"pmc\":\"Even if all we wish for were to happen, still this would only be a favor granted by fate, so to speak: for there is no logical connection between the will and the world, which would guarantee it, and the supposed physical connection itself is surely not something that we could will.\",\"ogd\":\"\",\"str\":\"Even if all we wish for were to happen, still this would only be a favour of fate, so to say, for there is no logical connection between the will and the world that could guarantee it, and the supposed physical connection itself is surely not something we could will.\",\"tlp\":[6.374]},{\"label\":\"3.3\",\"precision\":1,\"fontSize\":\"40px\",\"y_axis\":53,\"x_axis\":45,\"page\":6,\"ger\":\"Das angewandte, gedachte, Satzzeichen ist der Gedanke.\",\"pmc\":\"A propositional sign, applied and thought out, is a thought.\",\"ogd\":\"\",\"str\":\"A sentential sign, applied and thought out, is a thought.\",\"tlp\":[3.5]},{\"label\":\"4.11\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":53,\"x_axis\":69,\"page\":8,\"ger\":\"Der Satz behauptet das Bestehen der Sachlage deren Möglichkeit er darstellt. \",\"pmc\":\"A proposition asserts the existence of the situation whose possibility it represents.\",\"ogd\":\"\",\"str\":\"A proposition asserts that the situation obtains whose possibility it represents.\",\"tlp\":[\"None\"]},{\"label\":\"4.102211\",\"precision\":6,\"fontSize\":\"18px\",\"y_axis\":53,\"x_axis\":73,\"page\":19,\"ger\":\"So zeigt ein Satz 〟ϕ(a)\\\" daß in seinem Sinn der Gegenstand a vorkommt, die Sätze 〟ϕb\\\" und 〟ζb\\\" daß in ihren Sinnen derselbe Gegenstand vorkommt. \",\"pmc\":\"Thus the proposition 'ϕ(a)' shows that the object a occurs in its sense and the propositions 'ϕb' and 'ψb' show that the same object occurs in their senses.\",\"ogd\":\"\",\"str\":\"Thus the proposition “ϕ(a)” shows that the object a occurs in its sense //it is about a// and the propositions “ϕb” and “ψb” show that the same object occurs in their senses //they are about the same object//.\",\"tlp\":[4.1211]},{\"label\":\"4.102231\",\"precision\":6,\"fontSize\":\"18px\",\"y_axis\":53,\"x_axis\":77,\"page\":20,\"ger\":\"Statt Eigenschaft der Struktur sagen wir auch 〟interne Eigenschaft\\\", statt Relation der Strukturen 〟interne Relation\\\".\",\"pmc\":\"Instead of 'structural property' we also say 'internal property'; instead of 'structural relation', 'internal relation'.\",\"ogd\":\"\",\"str\":\"Instead of “structural property” we also say “internal property”; instead of “structural relation”, “internal relation”.\",\"tlp\":[4.122]},{\"label\":\"4.102241\",\"precision\":6,\"fontSize\":\"18px\",\"y_axis\":53,\"x_axis\":79,\"page\":24,\"ger\":\"Es wäre ebenso unsinnig dem Satz eine formale Eigenschaft zuzusprechen als sie ihm abzusprechen.\",\"pmc\":\"It would be just as nonsensical to assert that a proposition had a formal property as to deny it.\",\"ogd\":\"\",\"str\":\"It would be just as nonsensical to ascribe formal property a proposition as to deny it.\",\"tlp\":[4.124]},{\"label\":\"4.1022501\",\"precision\":7,\"fontSize\":\"18px\",\"y_axis\":53,\"x_axis\":81,\"page\":21,\"ger\":\"Hier erledigt sich nun die Streitfrage ob alle Relationen intern oder extern seien. \",\"pmc\":\"Here we have the answer to the vexed question 'whether all relations are internal or external'.\",\"ogd\":\"\",\"str\":\"Now this settles the disputed question “whether all relations are internal or external”.\",\"tlp\":[4.1251]},{\"label\":\"4.102251\",\"precision\":6,\"fontSize\":\"18px\",\"y_axis\":53,\"x_axis\":83,\"page\":95,\"ger\":\"Reihen, welche durch interne Relationen geordnet sind nenne ich Formenreihen.\",\"pmc\":\"I call a series that is ordered by an internal relation a series of forms.\",\"ogd\":\"\",\"str\":\"A series ordered by an internal relation I call a formal series.\",\"tlp\":[4.1252]},{\"label\":\"4.1022511\",\"precision\":7,\"fontSize\":\"18px\",\"y_axis\":53,\"x_axis\":85,\"page\":101,\"ger\":\"Die Glieder der Formenreihe sind nach einem formalen Gesetz gebildet.\",\"pmc\":\"The terms of a series of forms are constructed in accordance with a formal law.\",\"ogd\":\"\",\"str\":\"The terms of a series of forms are constructed in accordance with a formal law.\",\"tlp\":[\"None\"]},{\"label\":\"4.102261\",\"precision\":6,\"fontSize\":\"18px\",\"y_axis\":53,\"x_axis\":87,\"page\":22,\"ger\":\"Die formalen Begriffe können ja nicht wie die eigentlichen Begriffe durch eine Funktion dargestellt werden. \",\"pmc\":\"Formal concepts cannot, in fact, be represented by means of a function, as proper concepts can.\",\"ogd\":\"\",\"str\":\"Unlike proper concepts, formal concepts cannot be represented by a function.\",\"tlp\":[4.126]},{\"label\":\"4.102271\",\"precision\":6,\"fontSize\":\"18px\",\"y_axis\":53,\"x_axis\":91,\"page\":22,\"ger\":\"In ähnlichem Sinne ist jede Variable das Zeichen eines formalen Begriffes. \",\"pmc\":\"In a similar sense, every variable is the sign for a formal concept.\",\"ogd\":\"\",\"str\":\"In a similar sense, each variable is the sign of a formal concept.pt\",\"tlp\":[4.1271]},{\"label\":\"5.3073\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":53,\"x_axis\":127,\"page\":80,\"ger\":\"Es ist ja klar daß es sich hier nicht um eine Anzahl von Grundbegriffen handelt die bezeichnet werden müssen, sondern nur um den Ausdruck einer Regel. \",\"pmc\":\"It is clear, of course, that this is not a question of a number of primitive ideas that have to be signified, but only of the expression of a rule.\",\"ogd\":\"\",\"str\":\"Clearly, the issue here is not how many primitive concepts must be signified, but rather the expression of a rule.\",\"tlp\":[5.476]},{\"label\":\"6.364\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":53,\"x_axis\":161,\"page\":100,\"ger\":\"Was sich beschreiben läßt das kann auch geschehen, und was das Kausalitätsgesetz ausschließen soll, das läßt sich auch nicht beschreiben. \",\"pmc\":\"What can be described can also happen: and what the law of causailty is meant to exclude cannot even be described.\",\"ogd\":\"\",\"str\":\"What can be described can also happen, and what the law of causality is meant to exclude cannot even be described.\",\"tlp\":[3.362]},{\"label\":\"6.36322\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":53,\"x_axis\":165,\"page\":99,\"ger\":\"Rechte und linke Hand sind tatsächlich vollkommen kongruent. Und daß man sie nicht zur Deckung bringen kann hat damit nichts zu tun.\",\"pmc\":\"The right hand and the left hand are in fact completely congruent. It is quite irrelevant that they cannot be made to coincide.\",\"ogd\":\"\",\"str\":\"The right hand and left hands are in fact completely congruent. It is quite\\rirrelevant that they cannot be made to coincide.\",\"tlp\":[6.36111]},{\"label\":\"6.375\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":53,\"x_axis\":167,\"page\":87,\"ger\":\"Wie es nur eine logische Notwendigkeit gibt, so gibt es auch nur eine logische Unmöglichkeit.\",\"pmc\":\"Just as the only necessity that exists is logical necessity, so too the only impossibility that exists is logical impossibility.\",\"ogd\":\"\",\"str\":\"Just as there is only logical necessity, so too there is only logical impossibility.\",\"tlp\":[6.375]},{\"label\":\"6.3751\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":53,\"x_axis\":169,\"page\":88,\"ger\":\"Daß z.B. zwei Farben zugleich an einem Ort des Gesichtsfeldes sind ist unmöglich und zwar logisch unmöglich denn es ist durch die logische Struktur der Farbe bedingt.<br />Denken wir daran wie sich dieser Widerspruch in der Physik darstellt: ungefähr so daß ein Teilchen nicht zu gleicher Zeit zwei Geschwindigkeiten haben kann d.h. daß es nicht zu gleicher Zeit an zwei Orten sein kann d.h. daß Teilchen an verschiedenen Orten zu einer Zeit nicht dasselbe Teilchen sein können. \",\"pmc\":\"For example, the simultaneous presence of two colors at the same place in the visual field is impossible, in fact logically impossible, since it is subject to the logical structure of color.<br />Let us now think how this contradiction appears in physics: more or less as follows - a particle cannot have two velocities at the same time; that is to say, particles that are in different places at the same time cannot be the same particle.\",\"ogd\":\"\",\"str\":\"For instance, for two colours to be at the same place in the visual field simultaneously is impossible, indeed logically impossible, for it is subject to the logical structure of colour. Let us look at how this contradiction appears in physics: roughly, that a particle cannot have two velocities at the same time; that is to say, particles in different places at the same time cannot be the same particle. \",\"tlp\":[6.3751]},{\"label\":\"6.3752\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":53,\"x_axis\":171,\"page\":94,\"ger\":\"Es ist klar daß das logische Produkt zweier Elementarsätze weder eine Tautologie noch eine Kontradiktion sein kann (〟Aist grün und A ist rot\\\" ist eine Kontradiktion). \",\"pmc\":\"It is clear that the logical product of two elementary propositions can neither be a tautology nor a contradiction. ('A is green and A is red' is a contradiction.)\",\"ogd\":\"\",\"str\":\"Clearly, the logical product of two elementary propositions can neither be a tautology nor a contradiction. (“A is green and A is red” is a contradiction.)\",\"tlp\":[6.3751]},{\"label\":\"4.102212\",\"precision\":6,\"fontSize\":\"18px\",\"y_axis\":55,\"x_axis\":73,\"page\":19,\"ger\":\"Zwei Sätze, welche einander widersprechen zeigen dies, ebenso zeigt es sich in den Sätzen, wenn einer aus anderen folgt. u.s.w. \",\"pmc\":\"Two propositions which contradict one another show that they do so. Similarly when one proposition follows from others, this is shown in the propositions themselves. And so on.\",\"ogd\":\"\",\"str\":\"Two propositions which contradict one another show that they do so. Likewise, if one proposition follows from others, this is shown in the propositions themselves. And so on.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               \",\"tlp\":[4.1211]},{\"label\":\"4.102232\",\"precision\":6,\"fontSize\":\"18px\",\"y_axis\":55,\"x_axis\":77,\"page\":22,\"ger\":\"Hier erledigt sich nun die Streitfrage ob alle Relationen intern oder extern seien.\",\"pmc\":\"I introduce these expressions in order to indicate the source of the confusion between structural relations and relations proper (external relations) which is very widespread among philosophers.\",\"ogd\":\"\",\"str\":\"I introduce these expressions to show the reason for the confusion between structural relations and proper (external) relations, so common among philosophers.\",\"tlp\":[4.122]},{\"label\":\"4.102252\",\"precision\":6,\"fontSize\":\"18px\",\"y_axis\":55,\"x_axis\":83,\"page\":79,\"ger\":\"So ist die Zahlenreihe nicht nach einer externen sondern nach einer internen Relation geordnet. \",\"pmc\":\"Thus the order of the number-series is not governed by an external relation, but by an internal relation.\",\"ogd\":\"\",\"str\":\"Thus the the number series is ordered not by an external relation, but by an internal relation. \",\"tlp\":[4.1252]},{\"label\":\"4.102262\",\"precision\":6,\"fontSize\":\"18px\",\"y_axis\":55,\"x_axis\":87,\"page\":22,\"ger\":\"Denn ihre Merkmale, die formalen Eigenschaften werden ja nicht durch Funktionen ausgedrückt. \",\"pmc\":\"For their characteristics, formal properties, are not, in fact, expressed by means of functions.\",\"ogd\":\"\",\"str\":\"This is because their characteristic marks—formal properties—are not expressed by functions.\",\"tlp\":[4.126]},{\"label\":\"4.102272\",\"precision\":6,\"fontSize\":\"18px\",\"y_axis\":55,\"x_axis\":91,\"page\":24,\"ger\":\"Denn jede Variable stellt eine konstante Form dar, welche alle ihre Werte besitzen und die als formale Eigenschaft dieser Werte aufgefaßt werden kann. \",\"pmc\":\"For every variable represents a constant form that all its values possess, and this can be regarded as a formal property of those values.\",\"ogd\":\"\",\"str\":\"For every variable represents a constant form that all its values possess, and this can be regarded as a formal property of those values.\",\"tlp\":[4.1271]},{\"label\":\"4.1022721\",\"precision\":7,\"fontSize\":\"18px\",\"y_axis\":55,\"x_axis\":93,\"page\":23,\"ger\":\"So ist der variable Name x das eigentliche Zeichen des Scheinbegriffes: Gegenstand.\",\"pmc\":\"Thus the variable name x is the proper sign for the pseudo-concept, object.\",\"ogd\":\"\",\"str\":\"Thus the variable name x is the proper sign of the pseudo-concept “object”.\",\"tlp\":[4.1272]},{\"label\":\"4.1022722\",\"precision\":7,\"fontSize\":\"18px\",\"y_axis\":55,\"x_axis\":95,\"page\":23,\"ger\":\"Wo immer das Wort Gegenstand (oder Ding, Sache etc.) richtig gebraucht wird, wird es in der Begriffsschrift durch denvariablen Namen ausgedrückt.\",\"pmc\":\"Wherever the word, object (thing, etc.), is correctly used, it is expressed in conceptual notation by a variable name.\",\"ogd\":\"\",\"str\":\"Wherever the word, object (or thing, entity, etc.), is correctly used, it is expressed in conceptual notation by a variable name.\",\"tlp\":[4.1272]},{\"label\":\"4.1022723\",\"precision\":7,\"fontSize\":\"18px\",\"y_axis\":55,\"x_axis\":97,\"page\":23,\"ger\":\"Z.B. in dem Satz 〟es gibt 2 Gegenstände, welche…\\\" durch 〟(Ex,y)...\\\". \",\"pmc\":\"For example, in the proposition 'There are 2 objects which…', it is expressed by <br />'(∃x, y)…'.\",\"ogd\":\"\",\"str\":\"For example, in the proposition “There are 2 objects such that…”, by “(∃x, y)…”.\",\"tlp\":[4.1272]},{\"label\":\"4.1022724\",\"precision\":7,\"fontSize\":\"18px\",\"y_axis\":55,\"x_axis\":99,\"page\":23,\"ger\":\"Wo immer es anders also als eigentliches Begriffswort gebraucht wird entstehen unsinnige Scheinsätze. \",\"pmc\":\"Wherever it is used in a different way, that is as a proper concept-word, nonsensical psuedo-propositions are the result.\",\"ogd\":\"\",\"str\":\"Wherever it is used otherwise, that is as a proper concept-word, nonsensical psuedo-propositions are the result.\",\"tlp\":[4.1272]},{\"label\":\"4.1022725\",\"precision\":7,\"fontSize\":\"18px\",\"y_axis\":55,\"x_axis\":101,\"page\":23,\"ger\":\"So kann man z.B. nicht sagen 〟Es gibt Gegenstände\\\", wie man etwa sagt 〟Es gibt Bücher\\\". Und ebensowenig: 〟Es gibt 100 Gegenstände.\\\" oder 〟Es gibt ‭א0 Gegenstände.\\\". \",\"pmc\":\"So one cannot say, for example, 'There are objects', as one might say, 'There are books'. And it is just as impossible to say, 'There are 100 objects', or, 'There are 0א objects'.\",\"ogd\":\"\",\"str\":\"So for instance one cannot say “There are objects”, as one might say, “There are books”. And it is equally impossible to say, “There are 100 objects” or “There are א0 objects”.\",\"tlp\":[4.1272]},{\"label\":\"4.1022726\",\"precision\":7,\"fontSize\":\"18px\",\"y_axis\":55,\"x_axis\":103,\"page\":23,\"ger\":\"Was vom Wort 〟Gegenstand\\\" gilt, gilt auch entsprechend von den Worten 〟Komplex\\\", 〟Tatsache\\\", 〟Funktion\\\", 〟Zahl\\\" etc. etc. \",\"pmc\":\"What applies to the word 'object' also applies to the words 'complex', 'fact', 'function', 'number', etc., etc. in an analogous way.\",\"ogd\":\"\",\"str\":\"What applies to the word “object” also applies similarly to the words “complex”, “fact”, “function”, “number”, etc., etc. \",\"tlp\":[4.1272]},{\"label\":\"4.1022727\",\"precision\":7,\"fontSize\":\"18px\",\"y_axis\":55,\"x_axis\":105,\"page\":23,\"ger\":\"Alle diese Wörter bezeichnen im weiteren Sinne formale Begriffe und sie alle werden in der Begriffsschrift durchVariable, nicht durch Funktionen oder Klassen, dargestellt. \",\"pmc\":\"All these words signify, in the wider sense, formal concepts, and they are all represented in conceptual notation by variables, not by functions or classes.\",\"ogd\":\"\",\"str\":\"All these words signify, in the wider sense, formal concepts, and they are all represented in conceptual notation by variables, not by functions or classes.\",\"tlp\":[4.1272]},{\"label\":\"4.1022728\",\"precision\":7,\"fontSize\":\"18px\",\"y_axis\":55,\"x_axis\":107,\"page\":23,\"ger\":\"Ausdrücke wie 〟1 ist eine Zahl\\\", 〟es gibt nur eine 0\\\" und alle ähnlichen sind unsinnig. \",\"pmc\":\" '1 is a number', 'There is only one 0', and all similar expressions are nonsensical.\",\"ogd\":\"\",\"str\":\"“1 is a number”, “There is only one 0”, and all similar expressions are nonsensical.\",\"tlp\":[4.1272]},{\"label\":\"4.1022729\",\"precision\":7,\"fontSize\":\"18px\",\"y_axis\":55,\"x_axis\":109,\"page\":96,\"ger\":\"Die logischen Formen sind zahllos. \",\"pmc\":\"Logical forms are without number.\",\"ogd\":\"\",\"str\":\"Logical forms are without number.\",\"tlp\":[4.128]},{\"label\":\"5.3063\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":55,\"x_axis\":125,\"page\":52,\"ger\":\"Ein mögliches Zeichen muß auch bezeichnen können. Alles was in der Logik möglich ist, ist auch erlaubt. (Der Satz 〟Sokrates ist Plato\\\" ist unsinnig weil wir eine willkürliche Bestimmung nicht getroffen haben, aber nicht darum, weil das Zeichen an und für sich unerlaubt wäre): Wir können uns in gewissem Sinne nicht in der Logik irren.\",\"pmc\":\"If a sign is possible, then it is also capable of signifying. Whatever is possible in logic is also permitted. (The reason why the proposition 'Socrates is Plato' is nonsensical is because we have failed to make an arbitrary determination, and not because we the sign, in itself, would be illegitimate.) In a certain sense, we cannot make mistakes in logic.\",\"ogd\":\"\",\"str\":\"If a sign is possible, it is also capable of signifying. Whatever is possible in logic is also permitted. (“Socrates is Plato” is nonsense because we have not made an arbitrary determination, and not because the sign, in itself, would be illegitimate.) In a certain sense, we cannot go wrong in logic.\",\"tlp\":[5.473]},{\"label\":\"5.30631\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":55,\"x_axis\":127,\"page\":53,\"ger\":\"Das Einleuchten, von dem Russell so viel sprach, kann nur dadurch in der Logik entbehrlich werden, daß die Sprache selbst jeden logischen Fehler verhindert. — Die Apriorizität der Logik besteht darin, daß nicht unlogisch gedacht werden kann. \",\"pmc\":\"Self-evidence, which Russell talked about so much, can become dispensable in logic, only because language itself prevents every logical mistake. - What makes logic a priori is the impossibility of illogical thought.\",\"ogd\":\"\",\"str\":\"The self-evidence that Russell talked about so much, can be dispensed with in logic, only because language itself prevents every logical mistake. – That logic is a priori consists in this: one cannot think illogically.\",\"tlp\":[5.4731]},{\"label\":\"5.30632\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":55,\"x_axis\":129,\"page\":58,\"ger\":\"Wir können einem Zeichen nicht den unrechten Sinn geben. \",\"pmc\":\"We cannot give a sign the wrong sense.\",\"ogd\":\"\",\"str\":\"We cannot give a sign the wrong sense.\",\"tlp\":[5.4732]},{\"label\":\"5.30633\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":55,\"x_axis\":131,\"page\":60,\"ger\":\"Okkams Devise ist natürlich keine willkürliche, oder durch ihren praktischen Erfolg gerechtfertigte, Regel: Sie besagt, daßunnötige Zeicheneinheiten nichts bedeuten. \",\"pmc\":\"Occam's maxim is, of course, not an arbitrary rule, nor one that is justified by its success in practice: its point is that unnecessary units in a sign-language are logically meaningless.\",\"ogd\":\"\",\"str\":\"Naturally, Occam's razor is no arbitrary rule, nor one that is justified by its practical success: its point is that unnecessary units in a sign language mean nothing.\",\"tlp\":[5.47321]},{\"label\":\"5.30634\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":55,\"x_axis\":133,\"page\":60,\"ger\":\"Zeichen die einen Zweck erfüllen sind logisch äquivalent. Zeichen die keinen Zweck erfüllen logisch bedeutungslos. \",\"pmc\":\"Signs that serve one purpose are logically equivalent, and signs that serve none are logically meaningless.\",\"ogd\":\"\",\"str\":\"Signs that serve one purpose are logically equivalent, and signs that serve none are logically meaningless.\",\"tlp\":[5.47321]},{\"label\":\"6.36323\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":55,\"x_axis\":165,\"page\":100,\"ger\":\"Den rechten Handschuh könnte man an die linke Hand ziehen wenn man ihn im vierdimensionalen Raum umdrehen könnte. \",\"pmc\":\"A right-hand glove could be put on the left hand, if it could be turned round in four-dimensional space.\",\"ogd\":\"\",\"str\":\"A right-hand glove could be put on the left hand, if it could be turned round in four-dimensional space.\",\"tlp\":[6.36111]},{\"label\":\"4.102233\",\"precision\":6,\"fontSize\":\"18px\",\"y_axis\":57,\"x_axis\":77,\"page\":21,\"ger\":\"Eine interne Eigenschaft einer Tatsache können wir auch einen Zug dieser Tatsache nennen. (In dem Sinn in welchem wir etwa von Gesichtszügen sprechen.)\",\"pmc\":\"An internal property of a fact can also be called a feature of that fact (in the sense in which we speak of facial features, for example).\",\"ogd\":\"\",\"str\":\"An internal property of a fact can also be called a feature of that fact (in the sense that we speak of facial features).\",\"tlp\":[4.122]},{\"label\":\"4.1022331\",\"precision\":7,\"fontSize\":\"18px\",\"y_axis\":57,\"x_axis\":79,\"page\":95,\"ger\":\"Eine Eigenschaft ist intern wenn es undenkbar ist, daß ihr Gegenstand sie nicht besitzt.<br />(Diese blaue Farbe und jene stehen in der internen Relation von heller und dunkler eo ipso. Es ist undenkbar, daß diese beiden Gegenstände nicht in dieser Relation stünden.)\",\"pmc\":\"A property is internal if it is unthinkable that its object should not possess it.<br />(This shade of blue and that one stand, eo ipso, in the internal relation of lighter to darker. It is unthinkable that these two objects should not stand in this relation.)\",\"ogd\":\"\",\"str\":\"A property is internal if it is unthinkable for its object to not possess it.\\r(This shade of blue and that one stand, eo ipso, in the internal relation of lighter to darker. It is unthinkable that these two objects should not stand in this relation.)\",\"tlp\":[4.123]},{\"label\":\"4.102253\",\"precision\":6,\"fontSize\":\"18px\",\"y_axis\":57,\"x_axis\":83,\"page\":21,\"ger\":\"In dem Sinne in welchem wir von formalen Eigenschaften sprechen, können wir nun auch von formalen Begriffen reden.\",\"pmc\":\"We can now talk about formal concepts, in the same sense that we speak of formal properties.\",\"ogd\":\"\",\"str\":\"In the same sense that we can speak of formal properties, we can now talk of formal concepts.pt\",\"tlp\":[4.126]},{\"label\":\"4.102263\",\"precision\":6,\"fontSize\":\"18px\",\"y_axis\":57,\"x_axis\":87,\"page\":22,\"ger\":\"Der Ausdruck der formalen Eigenschaft ist ein Zug einer Satzstruktur. \",\"pmc\":\"The expression for a formal property is a feature of a propositional structure.\",\"ogd\":\"\",\"str\":\"The expression of a formal property is a feature of a propositional structure.\",\"tlp\":[4.126]},{\"label\":\"4.1022631\",\"precision\":7,\"fontSize\":\"18px\",\"y_axis\":57,\"x_axis\":89,\"page\":31,\"ger\":\"Formen kann man nicht dadurch von einander unterscheiden, daß man sagt die eine habe diese, die andere aber jene Eigenschaft; denn dies setzt voraus daß es einen Sinn habe beide Eigenschaften von beiden Formen auszusagen. \",\"pmc\":\"It is impossible to distinguish forms from one another by saying that one has this property and another that property; for this presupposes that it makes sense to ascribe either property to either form.\",\"ogd\":\"\",\"str\":\"Forms cannot be distinguished from one another by saying that one has this property, the other that, for this presupposes that it makes sense to ascribe either property to either form.\",\"tlp\":[4.1241]},{\"label\":\"4.102273\",\"precision\":6,\"fontSize\":\"18px\",\"y_axis\":57,\"x_axis\":91,\"page\":24,\"ger\":\"〟Gegenstand\\\", 〟Komplex\\\", 〟Tatsache\\\", 〟Zahl\\\", etc. etc. sind nicht Begriffsnamen — wie Russell glaubte — sondern Variable. \",\"pmc\":\" 'Object', 'complex', 'fact', 'number', etc. etc. are not names of concepts - as Russell believed - but variables.\",\"ogd\":\"\",\"str\":\"“Object”, “complex”, “fact”, “number”, etc. etc. are not names of concepts - as Russell believed - but variables.\",\"tlp\":[4.1272]},{\"label\":\"4.10227251\",\"precision\":8,\"fontSize\":\"18px\",\"y_axis\":57,\"x_axis\":101,\"page\":24,\"ger\":\"Und es ist unsinnig von der 〟Anzahl aller Gegenstände\\\" zu sprechen.\",\"pmc\":\"And it is nonsensical to speak of the 'total number of objects'.\",\"ogd\":\"\",\"str\":\"And it is nonsense to speak of the “total number of objects”.\",\"tlp\":[4.1272]},{\"label\":\"4.10227281\",\"precision\":8,\"fontSize\":\"18px\",\"y_axis\":57,\"x_axis\":107,\"page\":96,\"ger\":\"Es ist ebenso unsinnig zu sagen 〟Es gibt nur eine 1\\\" als es unsinnig wäre zu sagen: 〟2 + 2 ist um 3 Uhr gleich 4\\\". \",\"pmc\":\"It is just as nonsensical to say, 'There is only one 1', as it would be to say, '2+2 at 3 o'clock equals 4'.\",\"ogd\":\"\",\"str\":\"It is just as nonsensical to say, “There is only one 1”, as it would be to say, “2+2 at 3 o'clock equals 4”.\",\"tlp\":[4.1272]},{\"label\":\"4.10227291\",\"precision\":8,\"fontSize\":\"18px\",\"y_axis\":57,\"x_axis\":109,\"page\":96,\"ger\":\"Darum gibt es in der Logik keine ausgezeichneten Zahlen und darum gibt es keinen philosophischen Monismus, oder Dualismus, etc.. \",\"pmc\":\"Hence there are no privileged numbers in logic, and hence there is no possibility of philosophical monism or dualism, etc.\",\"ogd\":\"\",\"str\":\"Therefore there are no pre-eminent numbers in logic, and therefore there is no philosophical monism or dualism, etc.\",\"tlp\":[4.128]},{\"label\":\"5.3064\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":57,\"x_axis\":125,\"page\":53,\"ger\":\"Frege sagt: Jeder rechtmäßig gebildete Satz muß einen Sinn haben; und ich sage: jeder mögliche Satz ist rechtmäßig gebildet, und wenn er keinen Sinn hat so kann das nur daran liegen, daß wir einigen seiner Bestandteile keine Bedeutung gegeben haben. Wenn wir auch glauben es getan zu haben. \",\"pmc\":\"Frege says that any legitimately constructed proposition must have a sense. And I say that any possible proposition is legitimately constructed, and, if it has no sense, that can only be because we have failed to give a meaning to some of its constituents.<br />Even if we think we have done so.\",\"ogd\":\"\",\"str\":\"Frege says: any legitimately constructed proposition must have a sense. And I say: any possible proposition is well-formed, and, if it doesn’t make sense, that can only be because we have failed to give a meaning to some of its constituents. Even if we think we have.\",\"tlp\":[5.4733]},{\"label\":\"5.30641\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":57,\"x_axis\":127,\"page\":53,\"ger\":\"So sagt 〟Sokrates ist identisch\\\" darum nichts, weil wir dem Wort 〟identisch\\\" als Eigenschaftswort keineBedeutung gegeben haben. Denn, wenn es als Gleichheitszeichen auftritt, symbolisiert es auf ganz andere Art und Weise — die bezeichnende Beziehung ist eine andere — also ist auch das Zeichen in beiden Fällen ganz verschieden; die beiden Zeichen haben nur ihren sichtbaren Teil, zufällig, mit einander gemein. \",\"pmc\":\"Thus the reason why 'Socrates is identical' says nothing is that we have not given any adjectival meaning to the word 'identical'. For when it appears as a sign for identity, it symbolizes in an entirely different way - the signifying relation is a different one - therefore the signs also are entirely different in the two cases: the two signs have only their visible part in common, and that is an accident.\",\"ogd\":\"\",\"str\":\"Thus the reason why “Socrates is identical” says nothing is that we have given no adjectival meaning to the word “identical”. For when it appears as a sign for identity, it symbolizes in an entirely different way - the signifying relation is different - therefore the signs  in the two cases are entirely different, too: the two signs have only their visible part in common by accident.\",\"tlp\":[5.4733]},{\"label\":\"6.365\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":57,\"x_axis\":161,\"page\":101,\"ger\":\"Der Vorgang der Induktion besteht darin, daß wir das einfachste Gesetz annehmen das mit unseren Erfahrungen in Einklang zu bringen ist. \",\"pmc\":\"The procedure of induction consists in accepting as true the simplest law that can be reconciled with our experiences.\",\"ogd\":\"\",\"str\":\"The process of induction consists in our adopting the simplest law that can be reconciled with our experience.\",\"tlp\":[3.363]},{\"label\":\"6.3651\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":57,\"x_axis\":163,\"page\":101,\"ger\":\"Dies hat aber keinen logischen sondern nur einen psychologischen Grund. \",\"pmc\":\"This, however, has no logical justification but only a psychological one.\",\"ogd\":\"\",\"str\":\"This, however, has no logical basis but only a psychological one.\",\"tlp\":[3.3631]},{\"label\":\"6.3652\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":57,\"x_axis\":165,\"page\":101,\"ger\":\"Es ist aber klar daß kein Grund vorhanden ist zu glauben es werde nun auch wirklich der einfachste Fall eintreten.\",\"pmc\":\"It is, however, clear that there are no grounds for believing that the simplest eventuality will in fact be realized.\",\"ogd\":\"\",\"str\":\"Yet clearly there are no grounds for believing that the simplest outcome will really happen.\",\"tlp\":[3.3631]},{\"label\":\"4.102234\",\"precision\":6,\"fontSize\":\"18px\",\"y_axis\":59,\"x_axis\":77,\"page\":21,\"ger\":\"Ein Zug charakterisiert eine Klasse von Tatsachen; wenn sie, und nur sie ihn besitzen. \",\"pmc\":\"A feature characterizes a class of facts, if they and only they possess it.\",\"ogd\":\"\",\"str\":\"A feature characterizes a class of facts, if they and only they possess it.\",\"tlp\":[\"None\"]},{\"label\":\"4.102254\",\"precision\":6,\"fontSize\":\"18px\",\"y_axis\":59,\"x_axis\":83,\"page\":22,\"ger\":\"Ich führe diese Ausdrücke ein um den Grund der bei den Philosophen sehr verbreiteten Verwechslung zwischen den Relationen der Struktur und den eigentlichen (externen) Relationen zu zeigen. \",\"pmc\":\"I introduce this expression in order to exhibit the source of the confusion between formal concepts and concepts proper, which pervades the whole of traditional logic.\",\"ogd\":\"\",\"str\":\"I introduce this expression to make clear the the confusion of formal concepts and proper concepts, which runs through all of the old logic.\",\"tlp\":[4.126]},{\"label\":\"4.102264\",\"precision\":6,\"fontSize\":\"18px\",\"y_axis\":59,\"x_axis\":87,\"page\":22,\"ger\":\"Das Zeichen des Merkmals eines formalen Begriffes ist also der charakteristische Zug aller Sätze deren Sinne unter den Begriff fallen. \",\"pmc\":\"So the sign for the characteristic of a formal concept is the distinctive feature of all propositions whose senses fall under the concept.\",\"ogd\":\"\",\"str\":\"So the sign for the characteristic mark of a formal concept is the distinctive feature of all propositions whose senses fall under the concept.\",\"tlp\":[4.126]},{\"label\":\"4.102274\",\"precision\":6,\"fontSize\":\"18px\",\"y_axis\":59,\"x_axis\":91,\"page\":30,\"ger\":\"Verwandeln wir einen Bestandteil eines Satzes in eine Variable, so gibt es eine Klasse von Sätzen welche sämtlich Werte des so entstandenen variablen Satzes sind. Diese Klasse hängt im allgemeinen noch davon ab, was wir, nach willkürlicher Übereinkunft mit Teilen jenes Satzes meinen. Verwandeln wir aber alle jene Zeichen in Variable, deren Bedeutung willkürlich bestimmt wurde, so gibt es nun noch immer eine solche Klasse. Diese aber ist nun von keiner Übereinkunft abhängig sondern nur noch von der Natur des Satzes. Sie entspricht einem logischen Urbild — einer logischem Form.\",\"pmc\":\"If we turn a constituent of a proposition into a variable, there is a class of propositions all of which are values of the resulting variable proposition. In general, this class too will be dependent on the meaning that our arbitrary conventions have given to parts of the original proposition. But if all the signs in it that have arbitrarily determined meanings are turned into variables, we shall still get a class of this kind. This one, however, is not dependent on any convention, but solely on the nature of the proposition. It corresponds to a logical prototype - a logical form.\",\"ogd\":\"\",\"str\":\"If we turn a constituent of a proposition into a variable, the resulting variable proposition will have a class of propositions as its values. In general, this class still depends on what we, by arbitrary convention, mean by parts of that original proposition. But if we turn all the signs in it that have arbitrarily determined meanings into variables,there will still always be such a class. This one, however, is not dependent on any convention, but solely on the nature of the proposition. It corresponds to a logical prototype - a logical form.\",\"tlp\":[3.315]},{\"label\":\"4.10227252\",\"precision\":8,\"fontSize\":\"18px\",\"y_axis\":59,\"x_axis\":101,\"page\":35,\"ger\":\"Die Frage nach der Existenz einer Form ist immer unsinnig. \",\"pmc\":\"To ask whether a form exists is always nonsensical.\",\"ogd\":\"\",\"str\":\"To ask whether a form exists is always nonsensical.\",\"tlp\":[4.1274]},{\"label\":\"5.3022\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":59,\"x_axis\":117,\"page\":40,\"ger\":\"Oder vielmehr es muß sich herausstellen daß es in der Logik keine Zahlen gibt. \",\"pmc\":\"Or rather, it must become evident that there are no numbers in logic.\",\"ogd\":\"\",\"str\":\"Or rather, it must become evident that there are no numbers in logic.\",\"tlp\":[5.453]},{\"label\":\"5.30221\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":59,\"x_axis\":119,\"page\":48,\"ger\":\"Es gibt keine bevorzugten Zahlen. \",\"pmc\":\"There are no preferred numbers.\",\"ogd\":\"\",\"str\":\"There are no preferred numbers.\",\"tlp\":[5.453]},{\"label\":\"5.30222\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":59,\"x_axis\":121,\"page\":49,\"ger\":\"In der Logik gibt es kein Nebeneinander, kann es keine Klassifikation geben. \",\"pmc\":\"In logic there is no co-ordinate status, and there can be no classification.\",\"ogd\":\"\",\"str\":\"In logic there is no juxtaposition, and no classification can be given.\",\"tlp\":[5.454]},{\"label\":\"5.30223\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":59,\"x_axis\":123,\"page\":87,\"ger\":\"In der Logik kann es nicht Allgemeineres und Spezielleres geben. \",\"pmc\":\"In logic there can be no distinction between the general and the specific.\",\"ogd\":\"\",\"str\":\"In logic, no distinction can be made between the general and the specific.\",\"tlp\":[5.454]},{\"label\":\"5.30224\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":59,\"x_axis\":125,\"page\":60,\"ger\":\"Die Lösungen der logischen Probleme müssen einfach sein, denn sie setzen den Standard der Einfachheit. \",\"pmc\":\"The solutions of the problems of logic must be simple, since they set the standard of simplicity.\",\"ogd\":\"\",\"str\":\"The solutions to logical problems must be simple, since they set the standard of simplicity.\",\"tlp\":[5.4541]},{\"label\":\"5.30225\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":59,\"x_axis\":127,\"page\":76,\"ger\":\"Die Menschen haben immer geahnt, daß es ein Gebiet von Fragen geben müsse, worin die Antworten — a priori — symmetrisch, und zu einem abgeschlossenen, regelmäßigen Gebilde vereint-liegen.<br />Ein Gebiet in dem der Satz gilt: simplex sigillum veri.\",\"pmc\":\"Men have always had a presentiment that there must be a realm in which the answers to questions are symmetrically combined - a priori to form a self-contained system.<br />A realm subject ot the law: Simplex sigillum veri.\",\"ogd\":\"\",\"str\":\"People have always thought that there must be a realm in which the answers to questions combine symmetrically - a priori - into a closed regular structure.\\rA realm ruled by the law: Simplicity is the sign of truth.\",\"tlp\":[5.4541]},{\"label\":\"6.4\",\"precision\":1,\"fontSize\":\"40px\",\"y_axis\":59,\"x_axis\":147,\"page\":71,\"ger\":\"Alle Sätze sind gleichwertig. \",\"pmc\":\"All propositions are of equal value.\",\"ogd\":\"\",\"str\":\"All propositions are of equal value.\",\"tlp\":[6.4]},{\"label\":\"6.41\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":59,\"x_axis\":149,\"page\":75,\"ger\":\"Der Sinn der Welt muß außerhalb ihr liegen. In der Welt ist alles wie es ist und geschieht alles wie es geschieht, es gibt inihr keinen Wert — und wenn es ihn gäbe so hätte er keinen Wert. <br />Wenn es einen Wert gibt der Wert hat, so muß er außerhalb alles Geschehens und So-Seins liegen. Denn alles Geschehen und So-Sein ist zufällig.<br />Was es nicht-zufällig macht, kann nicht in der Welt liegen, denn sonst wäre dies wieder zufällig.<br />Es muß außerhalb der Welt liegen.\",\"pmc\":\"The sense of the world must lie outside the world. In the world everything is as it is, and everything happens as it does happen: in it no value exists. - And if it did exist, it would have no value.<br />If there is any value that does have value, it must lie outside the whole sphere of what happens and is the case. For all that happens and is the case is accidental.<br />What makes it non-accidental cannot lie within the world, since if it did it would itself be accidental.<br />It must lie outside the world.\",\"ogd\":\"\",\"str\":\"The sense of the world must lie outside the world. In the world everything is as it is, and everything happens as it does happen: there is no value in it - and if there were any, it would have no value. \\rIf there is any value that does have value, it must lie outside all happening and being this way or that. For all happening and being this way or that is accidental. \\rWhat makes it non-accidental cannot lie within the world, since if it did it would itself be accidental. It must lie outside the world.\",\"tlp\":[6.41]},{\"label\":\"6.42\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":59,\"x_axis\":151,\"page\":75,\"ger\":\"Darum kann es auch keine Sätze der Ethik geben. Sätze können nichts Höheres ausdrücken. \",\"pmc\":\"And so it is impossible for there to be propositions of ethics.<br />Propositions can express nothing that is higher.\",\"ogd\":\"\",\"str\":\"Hence also there can be no ethical propositions. Propositions cannot express anything higher.\",\"tlp\":[6.42]},{\"label\":\"6.43\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":59,\"x_axis\":155,\"page\":75,\"ger\":\"Es gibt allerdings Unaussprechliches. Dies zeigt sich, es ist das Mystische. \",\"pmc\":\"There are, indeed, things that cannot be put into words. They make themselves manifest. They are what is mystical.\",\"ogd\":\"\",\"str\":\"The inexpressible does exist. It shows itself. It is what is mystical.\",\"tlp\":[6.522]},{\"label\":\"6.44\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":59,\"x_axis\":157,\"page\":82,\"ger\":\"Wenn das gute oder böse Wollen die Welt ändert so kann es nur die Grenzen der Welt ändern nicht die Tatsachen; nicht das was durch die Sprache ausgedrückt werden kann, sondern was die Sprache ausdrückt. \",\"pmc\":\"If the good or bad exercise of the will does alter the world, it can alter only the limits of the world, not the facts; not what can be expressed by means of language, but only what language expresses.\",\"ogd\":\"\",\"str\":\"If good or bad willing changes the world, it can only change the limits of the world, not the facts; not what can be expressed in language, but only what language expresses.\",\"tlp\":[6.43]},{\"label\":\"6.36521\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":59,\"x_axis\":165,\"page\":101,\"ger\":\"Daß die Sonne morgen aufgehen wird ist eine Hypothese; und das heißt, wir wissen nicht ob sie aufgehen wird.\",\"pmc\":\"It is a hypothesis that the sun will rise tomorrow: and this means that we do not know whether it will rise.\",\"ogd\":\"\",\"str\":\"That the sun will rise tomorrow is a hypothesis, and this means that we do not know whether it will rise.\\r+ 101[8]\\t—\\rSuppose an urn contains an equal number of white and black balls. Then I can establish by experiment that the number of white balls drawn and the number of black balls drawn approach each other as the draw continues.\\rSo this is not a mathematical truth.\",\"tlp\":[6.36311]},{\"label\":\"4.102265\",\"precision\":6,\"fontSize\":\"18px\",\"y_axis\":61,\"x_axis\":87,\"page\":22,\"ger\":\"Und der Ausdruck des formalen Begriffes also eine Satzvariable in welcher nur dieser charakteristische Zug konstant ist. \",\"pmc\":\"And so the expression for a formal concept is a propositional variable in which this distinctive feature alone is constant.\",\"ogd\":\"\",\"str\":\"And so the expression for a formal concept is a propositional variable in which this distinctive feature alone is constant.\",\"tlp\":[4.126]},{\"label\":\"4.10227253\",\"precision\":8,\"fontSize\":\"18px\",\"y_axis\":61,\"x_axis\":101,\"page\":35,\"ger\":\"Denn kein Satz kann eine solche Frage beantworten. \",\"pmc\":\"For no proposition can be the answer to such a question.\",\"ogd\":\"\",\"str\":\"For no proposition can be the answer to such a question.\",\"tlp\":[4.1274]},{\"label\":\"5.3023\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":61,\"x_axis\":117,\"page\":39,\"ger\":\"Wenn es mehr als ein logisches Urzeichen gibt so muß eine richtige Logik deren Stellung zu einander klar machen und ihr Dasein rechtfertigen. Der Bau der Logik aus ihren Urzeichen muß klar werden. \",\"pmc\":\"If there is more than one primitive sign of logic, then any logic that fails to show clearly how they are placed relative to one another and to justify their existence will be incorrect. The construction of logic out of its primitive signs must be made clear.\",\"ogd\":\"\",\"str\":\"If there is more than one primitive sign of logic, then any correct logic must clearly show their relative status and justify their existence. The construction of logic out of its primitive signs must be made clear.\",\"tlp\":[5.45]},{\"label\":\"5.30231\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":61,\"x_axis\":119,\"page\":39,\"ger\":\"Die Einführung eines neuen Behelfs im Symbolismus der Logik muß immer ein folgenschweres Ereignis sein. Kein neuer Behelf darf in die Logik — sozusagen, mit ganz unschuldiger Miene — in Klammern oder unter dem Striche, eingeführt werden. So kommen in den 〟Principia Mathematica\\\" von Russell und Whitehead Definitionen und Grundgesetze in Worten vor. Warum hier plötzlich Worte? Dies bedürfte einer langen Rechtfertigung. Sie fehlt und muß fehlen da das Vorgehen tatsächlich unerlaubt ist. \",\"pmc\":\"The introduction of any new device into the symbolism of logic is necessarily a momentous event. In logic a new device should not be introduced in brackets or in a footnote with what one might call a completely innocent air.<br />Thus in Russell and Whitehead's Principia Mathematica there occur definitions and primitive propositions expressed in words. Why this sudden appearance of words? It would require a long justification, but none is given, or could be given, since the procedure is in fact illicit.\",\"ogd\":\"\",\"str\":\"The introduction of any new device into the symbolism of logic must always be a momentous event. In logic a new device should not be introduced in brackets or in a footnote with, so to speak, an entirely innocent expression. Thus in Principia Mathematica Russell and Whitehead’s definitions and primitive propositions are expressed in words. Why suddenly words here? It requires a long justification. But they don’t give any, and can’t, since the procedure is actually illegitimate.\",\"tlp\":[5.452]},{\"label\":\"6.421\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":61,\"x_axis\":151,\"page\":83,\"ger\":\"Es ist klar daß sich die Ethik nicht aussprechen läßt. \",\"pmc\":\"It is clear that ethics cannot be put into words.\",\"ogd\":\"\",\"str\":\"Clearly, ethics cannot be put into words.\",\"tlp\":[6.421]},{\"label\":\"6.431\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":61,\"x_axis\":155,\"page\":85,\"ger\":\"Die Anschauung der Welt sub specie aeterni ist ihre Anschauung als — begrenztes — Ganzes. \",\"pmc\":\"To view the world sub specie aeterni is to view it as a whole - a limited whole.\",\"ogd\":\"\",\"str\":\"To view the world under the form of eternity is to view it as a – limited – whole.\",\"tlp\":[6.45]},{\"label\":\"6.441\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":61,\"x_axis\":157,\"page\":82,\"ger\":\"Kurz die Welt muß dann dadurch überhaupt eine andere werden. Sie muß sozusagen als Ganzes abnehmen oder zunehmen. \",\"pmc\":\"In short the effect must be that it becomes an altogether different world. It must, so to speak, wax and wane as a whole.\",\"ogd\":\"\",\"str\":\"In short the world must thereby become another altogether. It must, so to speak, wax or wane as a whole.\",\"tlp\":[6.43]},{\"label\":\"6.4411\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":61,\"x_axis\":159,\"page\":83,\"ger\":\"Die Welt des Glücklichen ist eine andere als die des Unglücklichen. \",\"pmc\":\"The world of the unhappy man is a different one from that of the unhappy man.\",\"ogd\":\"\",\"str\":\"The world of the happy is another world from that of the unhappy.\",\"tlp\":[6.43]},{\"label\":\"6.4412\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":61,\"x_axis\":161,\"page\":84,\"ger\":\"Der erste Gedanke bei der Aufstellung eines ethischen Gesetzes von der Form 〟Du sollst …\\\" ist: 〟Und was dann, wenn ich es nicht tue\\\"? Es ist aber klar daß die Ethik nichts mit Strafe und Lohn im gewöhnlichen Sinn zu tun hat. Also muß diese Frage nach den Folgen einer Handlung belanglos sein. Zum mindesten dürfen diese Folgen nicht Ereignisse sein. Denn etwas muß doch an jener Fragestellung richtig sein. Es muß zwar eine Art von ethischem Lohn und ethischer Strafe geben, aber diese müssen in der Handlung selbst liegen.<br />(Und das ist auch klar, daß der Lohn etwas Angenehmes, die Strafe etwas Unangenehmes sein muß.) \",\"pmc\":\"When an ethical law of the form 'Thou shalt…' is laid down, one's first thought is, 'And what if I do not do it?' It is clear, however, that ethics has nothing to do with punishment and reward in the usual sense of the terms. So our question about the consequences of an action must be unimportant. At least those consequences should not be events. For there must be something right about the question we posed. There must indeed be a kind of ethical reward and punishment, but they must reside in the action itself.<br />(And it is also clear that the reward must be something pleasant and the punishment something unpleasant.)\",\"ogd\":\"\",\"str\":\"When an ethical law of the form “Thou shalt…” is laid down, one's first thought is, “So then what if I don’t do it?” But clearly ethics has nothing to do with punishment and reward in the ordinary sense. So this question about the consequences of an action must be irrelevant. At least these consequences could not be events. For there must be something right about that question after all. There must be a kind of ethical reward and punishment, but these must be involved in the action itself. (And it is clear also that the reward must be something pleasant, the punishment something unpleasant.)\",\"tlp\":[6.422]},{\"label\":\"4.2\",\"precision\":1,\"fontSize\":\"40px\",\"y_axis\":63,\"x_axis\":67,\"page\":3,\"ger\":\"Der Sinn des Satzes ist seine Übereinstimmung, und nicht Übereinstimmung, mit den Möglichkeiten des Bestehens und nicht Bestehens der Sachverhalte.\",\"pmc\":\"The sense of a proposition is its agreement, and disagreement, with possibilities of existence and non-existence of states of affairs.\",\"ogd\":\"\",\"str\":\"The sense of a proposition is its agreement or disagreement with possibilities of obtaining and non-obtaining of elementary facts.\",\"tlp\":[4.2]},{\"label\":\"4.21\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":63,\"x_axis\":69,\"page\":8,\"ger\":\"Der einfachste Satz — der Elementarsatz — behauptet das Bestehen eines Sachverhalts.\",\"pmc\":\"The simplest kind of proposition, an elementary proposition, asserts the existence of a state of affairs.\",\"ogd\":\"\",\"str\":\"An elementary proposition, the simplest proposition, asserts that an elementary fact obtains.\",\"tlp\":[4.21]},{\"label\":\"4.22\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":63,\"x_axis\":71,\"page\":9,\"ger\":\"Der Elementarsatz besteht aus Namen. Er ist ein Zusammenhang, eine Verkettung, von Namen. \",\"pmc\":\"An elementary proposition consists of names. It is a nexus, a concatenation, of names.\",\"ogd\":\"\",\"str\":\"An elementary proposition consists of names. It is a connection, a concatenation, of names.\",\"tlp\":[4.23]},{\"label\":\"4.23\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":63,\"x_axis\":83,\"page\":9,\"ger\":\"Ist der Elementarsatz wahr so besteht der Sachverhalt, ist der Elementarsatz falsch, so besteht der Sachverhalt nicht.\",\"pmc\":\"If an elementary proposition is true, the state of affairs exists: if an elementary proposition is false, the state of affairs does not exist.\",\"ogd\":\"\",\"str\":\"If an elementary proposition is true, the elementary fact obtains; if it is false, the elementary fact does not obtain.\",\"tlp\":[4.25]},{\"label\":\"4.24\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":63,\"x_axis\":85,\"page\":9,\"ger\":\"Bezüglich des Bestehens und nicht Bestehens von n Sachverhalten gibt es <em>K</em><sub>n</sub> =  <sup>0</sup>&sum;<sup>n</sup> <em>v</em> (<sup>n</sup><sub>v</sub>) Möglichkeiten.\",\"pmc\":\"For n states of affairs, there are <em>K</em><sub>n</sub> =  <sup>0</sup>&sum;<sup>n</sup> <em>v</em> (<sup>n</sup><sub>v</sub>) possibilities of existence and non-existence.\",\"ogd\":\"\",\"str\":\"For n elementary facts, there are K n = 0∑n v (n v ) possibilities of obtaining and non-obtaining.\",\"tlp\":[4.27]},{\"label\":\"4.25\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":63,\"x_axis\":87,\"page\":9,\"ger\":\"Es können alle möglichen Kombinationen der Sachverhalte bestehen, — die anderen nicht bestehen. \",\"pmc\":\"Of these states of affairs any possible combination can exist and the remainder not exist.\",\"ogd\":\"\",\"str\":\"Any possible combination of n elementary facts can obtain, and the remainder not obtain.\",\"tlp\":[4.25]},{\"label\":\"4.26\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":63,\"x_axis\":89,\"page\":9,\"ger\":\"Diesen Kombinationen entsprechen ebensoviele Möglichkeiten der Wahrheit — und Falschheit — von n Elementarsätzen.\",\"pmc\":\"There correspond to these combinations the same number of possibilities of truth - and falsity - for n elementary propositions.\",\"ogd\":\"\",\"str\":\"There correspond to these combinations the same number of possibilities of truth - and falsehood - for n elementary propositions.\",\"tlp\":[4.28]},{\"label\":\"4.10227254\",\"precision\":8,\"fontSize\":\"18px\",\"y_axis\":63,\"x_axis\":101,\"page\":35,\"ger\":\"Man kann also z.B. nicht fragen: 〟Gibt es unanalysierbare Subjekt-Prädikat Sätze?\\\". (oder 〟2-stellige Relationen\\\" oder 〟Relationen zwischen Relationen\\\" etc.). \",\"pmc\":\"So, for example, the question, 'Are there unanalyzable subject-predicate propositions?' (or 'relations with two terms' or 'relations between relations', etc.) cannot be asked.\",\"ogd\":\"\",\"str\":\"So, for example, one cannot ask: “Are there unanalyzable subject-predicate propositions?” (or “relations with two terms” or “relations between relations”, etc.).\",\"tlp\":[4.1274]},{\"label\":\"5.3024\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":63,\"x_axis\":117,\"page\":39,\"ger\":\"Die Benützung der Klammern mit jenen scheinbaren Urzeichen deutet ja schon darauf hin, daß diese nicht die wirklichen Urzeichen sind. Und es wird doch wohl niemand glauben, daß die Klammern eine selbständige Bedeutung haben. \",\"pmc\":\"Indeed, the use of brackets with these apparently primitive signs is itself an indication that they are not the real primitive signs. And surely no one is going to believe that brackets have an independent meaning.\",\"ogd\":\"\",\"str\":\"The use of brackets with these apparently primitive signs already indicates that they are not the real primitive signs. And surely no one could believe that brackets have an independent meaning.\",\"tlp\":[5.461]},{\"label\":\"6.422\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":63,\"x_axis\":151,\"page\":83,\"ger\":\"Die Ethik ist transzendental. \",\"pmc\":\"Ethics is transcendental.\",\"ogd\":\"\",\"str\":\"Ethics is transcendental.\",\"tlp\":[6.421]},{\"label\":\"6.4221\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":63,\"x_axis\":153,\"page\":83,\"ger\":\"Ethik und Ästhetik sind eins. \",\"pmc\":\"Ethics and aesthetics are one and the same.\",\"ogd\":\"\",\"str\":\"Ethics and aesthetics are one.\",\"tlp\":[6.421]},{\"label\":\"6.432\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":63,\"x_axis\":155,\"page\":86,\"ger\":\"Das Gefühl der Welt als begrenztes Ganzes ist das Mystische. \",\"pmc\":\"Feeling the world as a limited whole - it is this that is mystical.\",\"ogd\":\"\",\"str\":\"The feeling of the world as a limited whole is the mystical feeling.\",\"tlp\":[6.45]},{\"label\":\"6.442\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":63,\"x_axis\":157,\"page\":83,\"ger\":\"Wie auch beim Tod die Welt sich nicht ändert sondern aufhört. \",\"pmc\":\"So too at death the world does not alter, but comes to an end.\",\"ogd\":\"\",\"str\":\"In death, too, the world does not change, but comes to an end.\",\"tlp\":[6.431]},{\"label\":\"6.4421\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":63,\"x_axis\":159,\"page\":83,\"ger\":\"Der Tod ist kein Ereignis des Lebens. \",\"pmc\":\"Death is not an event in life.\",\"ogd\":\"\",\"str\":\"Death is not an event in life.\",\"tlp\":[6.4311]},{\"label\":\"6.4422\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":63,\"x_axis\":161,\"page\":83,\"ger\":\"Wenn man unter Ewigkeit nicht unendliche Zeitdauer sondern Unzeitlichkeit versteht, dann lebt der ewig der in der Gegenwart lebt. \",\"pmc\":\"If we take eternity to mean not infinite temporal duration but timelessness, then eternal life belongs to those who live in the present.\",\"ogd\":\"\",\"str\":\"If we mean by eternity not infinite temporal duration but timelessness, then to live eternally is to live in the present.\",\"tlp\":[6.4311]},{\"label\":\"6.4423\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":63,\"x_axis\":163,\"page\":92,\"ger\":\"Die zeitliche Unsterblichkeit der Seele des Menschen, das heißt also ihr ewiges Fortleben auch nach dem Tode ist nicht nur auf keine Weise verbürgt sondern vor allem leistet diese Annahme gar nicht das was man immer mit ihr erreichen wollte. Wird denn dadurch ein Rätsel gelöst daß ich ewig fortlebe? Ist denn dieses ewige Leben dann nicht ebenso rätselhaft wie das gegenwärtige? Die Lösung des Rätsels des Lebens in Raum und Zeit liegt außerhalb von Raum und Zeit. (Nicht Probleme der Naturwissenschaft sind ja zu lösen.) \",\"pmc\":\"Not only is there no guarantee of the temporal immorality of the human soul, that is to say of its eternal survival after death; but, in any case, this assumption completely fails to accomplish the purpose for which it has always been intended. Or is some riddle solved by my surviving for ever? Is not this eternal life itself as much of a riddle as our present life? The solution of the riddle of life in space and time lies outside space and time. (It is certainly not the solution of any problems of natural science that is required.)\",\"ogd\":\"\",\"str\":\"Not only is there no guarantee of the temporal immorality of the human soul, that is to say, its eternal survival after death; but, in any case, this assumption could never have the desired effect. Is a riddle solved by my surviving forever? Isn’t eternal life itself as much of a riddle as our present life? The solution of the riddle of life in space and time lies outside space and time. (It is certainly not problems of natural science that have to be solved.)\",\"tlp\":[6.4312]},{\"label\":\"4.221\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":65,\"x_axis\":71,\"page\":9,\"ger\":\"Der Name kommt im Satz nur im Zusammenhang des Elementarsatzes vor. \",\"pmc\":\"It is only in the nexus of an elementary proposition that a name occurs in a proposition.\",\"ogd\":\"\",\"str\":\"A name occurs in a proposition only in the context of an elementary proposition.\",\"tlp\":[4.24]},{\"label\":\"4.2211\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":65,\"x_axis\":73,\"page\":15,\"ger\":\"Gegenstandsnamen deute ich im Folgenden durch die Buchstaben x,y,z,u,v,w an. (?) \",\"pmc\":\"In what follows I indicate names of objects by the letters x, y, z, u, v, w.\",\"ogd\":\"\",\"str\":\"In what follows I indicate names of objects by the letters x, y, z, u, v, w.  \",\"tlp\":[4.24]},{\"label\":\"4.2212\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":65,\"x_axis\":75,\"page\":15,\"ger\":\"Die Elementarsätze deute ich im Folgenden allgemein durch die Buchstaben p,q,r,s,t, oder (wie Frege) als Funktion ihrer Gegenstände in der Form 〟ϕ(x)\\\", 〟ϕ(x,y)\\\" etc. an. (?) \",\"pmc\":\"Generally in what follows I indicate elementary propositions by the letters p, q, r, s, t, or else (like Frege) I write them as functions of their objects in the form 'ϕ(x)', 'ϕ(x, y)', etc.\",\"ogd\":\"\",\"str\":\"Generally in what follows I indicate elementary propositions by the letters p, q, r, s, t, or (like Frege) as functions of their objects in the form “ϕ(x)”, “ϕ(x,y)”, etc. \",\"tlp\":[4.24]},{\"label\":\"4.2213\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":65,\"x_axis\":77,\"page\":15,\"ger\":\"Gebrauche ich zwei Namen in einer und derselben Bedeutung, oder zwei Satzzeichen in einem Sinn, so drücke ich dies aus indem ich zwischen beide das Zeichen 〟=\\\" setze. \",\"pmc\":\"When I use two names with one and the same meaning, or two propositional signs with a single sense, I express this by putting the sign '=' between them.\",\"ogd\":\"\",\"str\":\"When I use two names with one and the same meaning, or two sentential signs with a single sense, I express this by putting the sign “=” between them.\",\"tlp\":[4.241]},{\"label\":\"4.2214\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":65,\"x_axis\":79,\"page\":15,\"ger\":\"Ausdrücke von der Form a=b sind also nur Behelfe der Darstellung, sie sagen nichts über die Bedeutung oder den Sinn der Zeichen 〟a\\\" oder 〟b\\\" aus. \",\"pmc\":\"Expressions of the form a=b are, therefore, mere representational devices. They state nothing about the meaning or the sense of the signs 'a' and 'b'.\",\"ogd\":\"\",\"str\":\"Expressions of the form a =b are, therefore, only expedient aids in representation. They state nothing about the meaning or the sense of the signs “a” and “b”.\",\"tlp\":[4.242]},{\"label\":\"4.2215\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":65,\"x_axis\":81,\"page\":46,\"ger\":\"Können wir zwei Namen verstehen, ohne zu wissen ob sie dasselbe Ding oder verschiedene Dinge bezeichnen? — Können wir einen Satz, worin zwei Namen vorkommen verstehen ohne zu wissen, ob sie dasselbe oder verschiedenes bedeuten? \",\"pmc\":\"Can we understand two names without knowing whether they signify the same thing or different things? Can we understand a proposition in which two names occur without knowing whether their meaning is the same or different?\",\"ogd\":\"\",\"str\":\"Can we understand two names without knowing whether they signify the same thing or different things? – Can we understand a proposition containing two names without knowing whether their meaning is the same or different?\",\"tlp\":[4.243]},{\"label\":\"4.231\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":65,\"x_axis\":83,\"page\":9,\"ger\":\"Die Angabe aller wahren Elementarsätze beschreibt die Welt vollständig.\",\"pmc\":\"If all true elementary propositions are given, the result is a complete description of the world.\",\"ogd\":\"\",\"str\":\"To give all true elementary propositions is to describe the world completely.\",\"tlp\":[4.26]},{\"label\":\"5.31\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":65,\"x_axis\":113,\"page\":13,\"ger\":\"Hat α nur einen Wert, p, so ist N(α̅) das Russellsche ~p, hat es zwei Werte p und q, ~p·~q.\",\"pmc\":\"If α has only one value, p, then N(ᾱ) is Russell's ~p; if it has two values, then N(ᾱ) is ~p .~q.\",\"ogd\":\"\",\"str\":\"If α has only one value, p, then N(ᾱ) is Russell's ~p; if it has two values, then N(ᾱ) is ~p.~q.\",\"tlp\":[5.51]},{\"label\":\"5.32\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":65,\"x_axis\":123,\"page\":13,\"ger\":\"Sind die Werte von α sämtliche Werte einer Funktion ϕ(x) für alle Werte von x so bedeutet 〟N(α̅)\\\" ~(∃x)·ϕ(x).\",\"pmc\":\"If α has as its values all the values of a function ϕx, then 'N(ᾱ)' means ~(∃x).ϕx.\",\"ogd\":\"\",\"str\":\"If α has as its values all the values of a function ϕx , then “N(ᾱ)” means ~(∃x).ϕx.\\ron 4.401\",\"tlp\":[5.52]},{\"label\":\"5.33\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":65,\"x_axis\":131,\"page\":18,\"ger\":\"Gleichheit des Gegenstandes drücke ich durch Gleichheit des Zeichens aus, und nicht mit Hilfe eines Gleichheitszeichen. Verschiedenheit der Gegenstände durch Verschiedenheit der Zeichen. \",\"pmc\":\"Identity of object I express by identity of sign, and not by using a sign for identity. Difference of objects I express by difference of signs.\",\"ogd\":\"\",\"str\":\"Identity of object I express by identity of sign, and not by means of a sign of identity. Difference of objects I express by difference of signs.\",\"tlp\":[5.53]},{\"label\":\"5.34\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":65,\"x_axis\":137,\"page\":56,\"ger\":\"Wir müssen nun die Frage nach allen möglichen Formen der Elementarsätze a priori beantworten. \",\"pmc\":\"We now have to answer a priori the question about all the possible forms of elementary propositions.\",\"ogd\":\"\",\"str\":\"The question about all the possible forms of elementary propositions must now be answered a priori.\",\"tlp\":[5.55]},{\"label\":\"6.5\",\"precision\":1,\"fontSize\":\"40px\",\"y_axis\":65,\"x_axis\":147,\"page\":75,\"ger\":\"Zu einer Antwort, die man nicht aussprechen kann, kann man auch die Frage nicht aussprechen. <br />Das Rätsel gibt es nicht.<br />Wenn sich eine Frage überhaupt stellen läßt so kann sie auch beantwortet werden.\",\"pmc\":\"When the answer cannot be put into words, neither can the question be put into words.<br />The riddle does not exist.<br />If a question can be framed at all, it is also possible to answer it.\",\"ogd\":\"\",\"str\":\"If the answer cannot be put into words, the question, too, cannot be put into words. The riddle does not exist. \\rIf a question can be framed at all, then it can also be answered.\",\"tlp\":[6.5]},{\"label\":\"6.51\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":65,\"x_axis\":149,\"page\":50,\"ger\":\"Skeptizismus ist nicht unwiderleglich, sondern offenbar unsinnig, wenn er bezweifeln will, wo nicht gefragt werden kann.<br />Denn Zweifel kann nur bestehen, wo eine Frage besteht; eine Frage nur, wo eine Antwort besteht, und diese nur wo etwas gesagt werden kann. \",\"pmc\":\"Skepticism is not irrefutable, but not obviously nonsensical, when it tries to raise doubts where no questions can be asked.<br />For doubt can exist only where a question exists, a question only where an answer exists, and an answer only where something can be said.\",\"ogd\":\"\",\"str\":\"Skepticism is not irrefutable, but obviously nonsensical, insofar as it tries to raise doubts where no questions can be asked. For doubt can only exist provided there is a question, a question only provided there is an answer, and an answer only provided something can be said.\",\"tlp\":[6.51]},{\"label\":\"6.52\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":65,\"x_axis\":151,\"page\":76,\"ger\":\"Wir fühlen daß selbst, wenn alle möglichen wissenschaftlichen Fragen beantwortet sind unsere Lebensprobleme noch gar nicht berührt sind. Freilich bleibt dann eben keine Frage mehr; und eben dies ist die Antwort. \",\"pmc\":\"We feel that even when all possible scientific questions have been answered, the problems of life remain completely untouched. Of course there are then no questions left, and this is itself the answer.\",\"ogd\":\"\",\"str\":\"We feel that even if all possible scientific questions were answered, the problems of life would still not have been touched at all. To be sure, there would then be no question left, and just this is the answer.\",\"tlp\":[6.52]},{\"label\":\"6.53\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":65,\"x_axis\":155,\"page\":85,\"ger\":\"Die richtige Methode der Philosophie wäre eigentlich die: Nichts zu sagen als was sich sagen läßt also Sätze der Naturwissenschaft — also etwas was mit Philosophie nichts zu tun hat —, und dann immer, wenn ein anderer etwasMetaphysisches sagen wollte ihm nachweisen, daß er gewissen Zeichen in seinen Sätzen keine Bedeutung gegeben hat.\",\"pmc\":\"The correct method in philosophy would really be the following: to say nothing except what can be said, i.e. propositions of natural science - i.e. something that has nothing to do with philosophy - and then, whenever someone else wanted to say something metaphysical, to demonstrate to him that he had failed to give a meaning to certain signs in his propositions.\",\"ogd\":\"\",\"str\":\"The right method in philosophy would really be to say nothing except what can be said, i.e. propositions of natural science – i.e. something that has nothing to do with philosophy – and then, to prove to those wanting to say something metaphysical that they had failed to give a meaning to certain signs in their sentences.\",\"tlp\":[6.53]},{\"label\":\"6.54\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":65,\"x_axis\":157,\"page\":86,\"ger\":\"Meine Sätze erläutern dadurch daß sie der welcher mich versteht am Ende als unsinnig erkennt wenn er durch sie — auf ihnen — über sie hinausgestiegen ist. (Er muß sozusagen die Leiter wegwerfen nachdem er auf ihr hinaufgestiegen ist.) \",\"pmc\":\"My propositions serve as elucidations in the following way: anyone who understands me eventually recognizes them as nonsensical, when he has used them - as steps - to climb up beyond them. (He must, so to speak, throw away the ladder after he has climbed up it.)\",\"ogd\":\"\",\"str\":\"My sentences are elucidatory in the following way: to understand me you must recognize my sentences—once you have climbed out through them, on them, over them—as nonsense. (You must, so to speak, throw away the ladder after you have climbed up it.)\",\"tlp\":[6.54]},{\"label\":\"6.55\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":65,\"x_axis\":159,\"page\":86,\"ger\":\"Er muß diese Sätze überwinden dann kommt er auf der richtigen Stufe zur Welt.\",\"pmc\":\"He must transcend these propositions, and then he will approach the world on the right level.\",\"ogd\":\"\",\"str\":\"You must overcome these sentences, and then you will approach the world on the right level//in the right way//.\",\"tlp\":[6.54]},{\"label\":\"6.44221\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":65,\"x_axis\":161,\"page\":96,\"ger\":\"Unser Leben ist eben so endlos wie unser Gesichtsfeld grenzenlos ist. \",\"pmc\":\"Our life has no end in just the way in which our visual field has no limits.\",\"ogd\":\"\",\"str\":\"Our life has no end, just as our visual field has no limits.\",\"tlp\":[6.4311]},{\"label\":\"6.44231\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":65,\"x_axis\":163,\"page\":92,\"ger\":\"Wie die Welt ist, ist hier vollkommen gleichgültig. Gott offenbart sich nicht in der Welt. \",\"pmc\":\"How things are in the world is here a matter of complete indifference. God does not reveal himself in the world.\",\"ogd\":\"\",\"str\":\"How the world is, is here a matter of complete indifference. God does not reveal himself in the world.\",\"tlp\":[6.432]},{\"label\":\"4.222\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":67,\"x_axis\":71,\"page\":9,\"ger\":\"Ausdrücke wie 〟a=a\\\", oder von diesem abgeleitete, welche dem obigen zu widersprechen scheinen sind weder Elementarsätze noch sonst sinnvolle Zeichen wie sich später zeigen wird.\",\"pmc\":\"Expressions like 'a=a', and those derived from it, which seem to conflict with the above, are neither elementary propositions nor is there any other way in which they have sense, as will become evident later.\",\"ogd\":\"\",\"str\":\"Expressions like “a=a”, or those derived from them, which seem to contradict the above, are neither elementary propositions, nor is there any other way in which they could make sense. (This will be shown later.)\",\"tlp\":[4.243]},{\"label\":\"4.22121\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":67,\"x_axis\":75,\"page\":102,\"ger\":\"〟a=b\\\" heißt also das Zeichen 〟a\\\" ist durch das Zeichen 〟b\\\" ersetzbar. \",\"pmc\":\"So 'a=b' means the sign 'b' can be substituted for the sign 'a'.\",\"ogd\":\"\",\"str\":\"So “a =b” means the sign “b” can be substituted for the sign “a”.\",\"tlp\":[4.241]},{\"label\":\"4.22131\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":67,\"x_axis\":77,\"page\":24,\"ger\":\"Auch die Vertauschbarkeit zweier beliebiger Satzteile drücke ich kurz auf die gleiche Art und Weise aus.\",\"pmc\":\"For the sake of brevity I also express the interchangeability of any two parts of propositions in the same way.\",\"ogd\":\"\",\"str\":\"For the sake of brevity I also express the interchangeability of any two parts of propositions in the same way.\",\"tlp\":[\"None\"]},{\"label\":\"4.22151\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":67,\"x_axis\":81,\"page\":46,\"ger\":\"Kenne ich etwa die Bedeutung eines englischen und eines gleichbedeutenden deutschen Wortes, so ist es unmöglich, daß ich nicht weiß, daß die beiden gleichbedeutend sind; es ist unmöglich daß ich sie nicht ineinander übersetzen kann. … \",\"pmc\":\"Suppose I know the meaning of an English word and of a German word that means the same: then it is impossible for me to be unaware that they do mean the same; I must be capable of translating either into the other.\",\"ogd\":\"\",\"str\":\"If I know the meaning of an English word and of a German word that means the same then it is impossible for me not to know that they mean the same; it is impossible for me not to be able to translate them into the other.\",\"tlp\":[4.243]},{\"label\":\"4.232\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":67,\"x_axis\":83,\"page\":9,\"ger\":\"Die Welt ist vollständig beschrieben durch die Angabe aller Elementarsätze plus der Angabe welche von ihnen wahr und welche falsch sind. \",\"pmc\":\"The world is completely described by giving all elementary propositions, and adding which of them are true and which false.\",\"ogd\":\"\",\"str\":\"The world is completely described by giving all elementary propositions, and adding which of them are true and which false.\",\"tlp\":[4.26]},{\"label\":\"5.3101\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":67,\"x_axis\":113,\"page\":50,\"ger\":\"Muß das Zeichen des negativen Satzes mit dem Zeichen des positiven gebildet werden? Warum sollte man den negativen Satz nicht durch eine negative Tatsache ausdrücken können? (Etwa: Wenn 〟a\\\" nicht in einer bestimmten Beziehung zu 〟b\\\" steht, soll das ausdrücken daß nicht aRb der Fall ist.) \",\"pmc\":\"Must the sign of a negative proposition be constructed with that of the positive proposition? Why should it not be possible to express a negative proposition by means of a negative fact? (E.g. suppose that 'a' does not stand in a certain relation to 'b'; then this is to express that not-aRb is the case.)\",\"ogd\":\"\",\"str\":\"Must the sign of a negative proposition be constructed with that of the positive proposition? Why should it not be possible to express a negative proposition by means of a negative fact? (For instance, if “a” does not stand in a certain relation to “b” it could express that not-aRb is the case.)\",\"tlp\":[5.5151]},{\"label\":\"5.311\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":67,\"x_axis\":115,\"page\":61,\"ger\":\"Wie kann die allumfassende weltspiegelnde Logik so spezielle Haken und Manipulationen gebrauchen? Nur indem sich alle diese zu einem unendlich feinen Netzwerk zu dem großen Spiegel verknüpfen. \",\"pmc\":\"How can logic - all-embracing logic, which mirrors the world - use such peculiar crotchets and contrivances? Only because they are all connected with one another in an infinitely fine network, the great mirror.\",\"ogd\":\"\",\"str\":\"How can an all-embracing world-reflecting logic use such contrived hooks and manipulations? Only because they are all connected together in an infinitely fine network, the great mirror.\",\"tlp\":[5.511]},{\"label\":\"5.3201\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":67,\"x_axis\":123,\"page\":87,\"ger\":\"Ich trenne den Begriff 〟Alle\\\" von der Wahrheitsfunktion.<br />Frege und Russell haben die Allgemeinheit in Verbindung mit dem logischen Produkt oder der logischen Summe eingeführt. So wurde es schwer die Sätze (Ex)·ϕx und (x)·ϕx , in welchen beide Ideen beschlossen liegen, zu verstehen.\",\"pmc\":\"I dissociate the concept all from truth-functions.<br />Frege and Russell introduced generality in association with the logical product or logical sum. This made it difficult to understand the propositions '(∃x).ϕx' and '(x).ϕx', in which both ideas are embedded.\",\"ogd\":\"\",\"str\":\"I dissociate the concept all from truth-functions.\\rFrege and Russell introduced generality together with logical product or logical sum. This made the propositions “(∃x).ϕx” and “(x).ϕx”, which involve both ideas, difficult to understand.\",\"tlp\":[5.521]},{\"label\":\"5.321\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":67,\"x_axis\":127,\"page\":34,\"ger\":\"Das Eigentümliche der Allgemeinheitsbezeichnung ist erstens, daß sie auf ein logisches Urbild hinweist und zweitens, daß sie Konstante hervorhebt. \",\"pmc\":\"What is peculiar to the generality-sign is first, that it indicates a logical prototype, and secondly, that it gives prominence to constants.\",\"ogd\":\"\",\"str\":\"What is peculiar about  the generality sign is first, that it indicates a logical prototype, and second, that it draws attention to constants.\",\"tlp\":[5.522]},{\"label\":\"5.3301\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":67,\"x_axis\":131,\"page\":34,\"ger\":\"Daß die Identität keine Relation zwischen Gegenständen ist leuchtet ein. \",\"pmc\":\"It is self-evident that identity is not a relation between objects.\",\"ogd\":\"\",\"str\":\"It is obvious that identity is not a relation between objects.\",\"tlp\":[5.5301]},{\"label\":\"5.331\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":67,\"x_axis\":133,\"page\":18,\"ger\":\"Ich schreibe also nicht 〟F(a,b)·a=b\\\", sondern 〟F(a,a)\\\" [oder 〟F(b,b)\\\"] und nicht 〟F(a,b)·a≠b\\\", sondern 〟F(a,b)\\\".\",\"pmc\":\"Thus I do not write 'F(a, b).a=b', but 'F(a, a)' (or 'F(b, b)'); and not 'F(a, b).a≠b', but 'F(a, b)'.\",\"ogd\":\"\",\"str\":\"Thus I do not write “F (a, b).a =b”, but “F (a, a)” (or “F (b, b)”); and not “F (a, b).a≠b”, but “F (a, b)”.\",\"tlp\":[5.531]},{\"label\":\"5.341\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":67,\"x_axis\":137,\"page\":56,\"ger\":\"Unser Grundsatz ist, daß sich jede Frage die sich überhaupt durch die Logik entscheiden läßt, sich ohne weiteres entscheiden lassen muß. (Und wenn wir in die Lage kommen, ein solches Problem durch Ansehen der Welt beantworten zu müssen so zeigt dies daß wir auf grundfalscher Fährte sind.) \",\"pmc\":\"Our fundamental principle is that whenever a question can be decided by logic at all it must be possible to decide it without more ado. (And if we get into a position where we have to look at the world for an answer to such a problem, that shows that we are on a completely wrong track.)\",\"ogd\":\"\",\"str\":\"Our fundamental principle is this: whenever a question can be answered by using logic it must be possible to answer it just like that. (And if ever we have to look at the world for a solution to such a problem, that shows we are on a completely wrong track.)\",\"tlp\":[5.551]},{\"label\":\"6.521\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":67,\"x_axis\":151,\"page\":83,\"ger\":\"Die Lösung des Problems des Lebens merkt man am Verschwinden dieses Problems. \",\"pmc\":\"The solution of the problem of life is seen in the vanishing of the problem.\",\"ogd\":\"\",\"str\":\"The solution of the problem of life is the vanishing of the problem.\",\"tlp\":[6.521]},{\"label\":\"6.5211\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":67,\"x_axis\":153,\"page\":83,\"ger\":\"Ist nicht dies der Grund, warum Menschen, denen der Sinn des Lebens nach langen Zweifeln klar wurde, warum diese dann nicht sagen konnten worin dieser Sinn bestand? \",\"pmc\":\"Is not this the reason why those who have found after a long period of doubt that the sense of life became clear to them have then been unable to say what constituted that sense?\",\"ogd\":\"\",\"str\":\"Isn’t this why those to whom, after prolonged doubts, the meaning of life became clear have been unable to say what that meaning is?\",\"tlp\":[6.521]},{\"label\":\"6.531\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":67,\"x_axis\":155,\"page\":86,\"ger\":\"Diese Methode wäre für den anderen unbefriedigend — er hätte nicht das Gefühl daß wir ihn Philosophie lehrten — aber sie wäre die einzig streng richtige. \",\"pmc\":\"Although it would not be satisfying to the other person - he would not have the feeling that we were teaching him philosophy - this method would be the only strictly correct one.\",\"ogd\":\"\",\"str\":\"Although they wouldn’t be satisfied - they would feel we weren’t teaching them any philosophy – this method would be the only strictly right one.\",\"tlp\":[6.53]},{\"label\":\"6.44232\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":67,\"x_axis\":163,\"page\":93,\"ger\":\"Nicht wie die Welt ist, ist das Mystische, sondern daß sie ist.\",\"pmc\":\"It is not how things are in the world that is mystical, but that it exists.\",\"ogd\":\"\",\"str\":\"It is not how the world is that is mystical, but that it is.\\r+ 93[2]\\t—\\rJust as, in descriptive geometry, the rule enabling me to find the position of a point in space from the position of its projections is simply an expression of the law of projection.\",\"tlp\":[6.44]},{\"label\":\"4.3\",\"precision\":1,\"fontSize\":\"40px\",\"y_axis\":69,\"x_axis\":67,\"page\":3,\"ger\":\"Die Wahrheitsmöglichkeiten der Elementarsätze bedeuten die Möglichkeiten des Bestehens und nicht Bestehens der Sachverhalte. \",\"pmc\":\"Truth-possibilities of elementary propositions mean possibilities of existence and non-existence of states of affairs.\",\"ogd\":\"\",\"str\":\"Truth-possibilities of elementary propositions mean possibilities of obtaining or non-obtaining of elementary facts.\",\"tlp\":[4.3]},{\"label\":\"4.31\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":69,\"x_axis\":69,\"page\":9,\"ger\":\"Die Wahrheitsmöglichkeiten können wir durch ein Schema folgender Art darstellen: ( 〟p\\\", 〟q\\\", 〟r\\\" sind Elementarsätze. 〟W\\\" bedeutet 〟wahr\\\", 〟F\\\" 〟falsch\\\" die Reihen der 〟W\\\" und 〟F\\\" unter der Reihe der Elementarsätze bedeuten in leicht verständlicher Symbolik deren Wahrheitsmöglichkeiten.)<br /> p  | q  | r          <br />W | W | W<br />F  | W | W          p | q          <br />W | F  | W         W | W        p<br />W | W | F           F | W        W<br /> F |  F  | W        W | F          F<br /> F | W  | F          F | F<br />W | F   | F<br /> F | F   | F<br />Wir nennen dies das Schema I.\",\"pmc\":\"We can represent truth-possibilities by a schema of the following kind ('p', 'q', and 'r' are elementary propositions. 'T' means 'true', 'F' means 'false'; the rows of 'T's' and 'F's' under the row of elementary propositons symbolize their truth-possibilities in a way that can be easily understood):<br />p | q | r          <br />T | T | T<br />F | T | T          p | q          <br />T | F | T          T | T          p<br />T | T | F          F | T          T<br />F | F | T          T | F          F<br />F | T | F          F | F<br />T | F | F<br />F | F | F<br />We call this Schema I.\",\"ogd\":\"\",\"str\":\"We can represent truth-possibilities by the following kind of schema: (“p”, “q”, and “r” are elementary propositions. “T” means “true”, “F” “false”. The rows of “T’s” and “F’s” under the row of elementary propositions set out their truth-possibilities in a symbolism that can easily be understood):\\rp\\tq\\tr\\t\\tp\\tq\\t\\tp\\rT\\tT\\tT\\t\\tT\\tT\\t\\tT\\rF\\tT\\tT\\t\\tF\\tT\\t\\tF\\rT\\tF\\tT\\t\\tT\\tF\\t\\rT\\tT\\tF\\t\\tF\\tF\\t\\rF\\tF\\tT\\t\\rF\\tT\\tF\\t\\rT\\tF\\tF\\t\\rF\\tF\\tF\\t\\r\\rWe call this Schema I.pt\",\"tlp\":[4.31]},{\"label\":\"4.22122\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":69,\"x_axis\":75,\"page\":102,\"ger\":\"Führe ich durch eine Gleichung ein neues Zeichen α ein indem ich sage es solle ein bereits bekanntes Zeichen β ersetzen so schreibe ich die Gleichung — Definition — (nach Russell) in der Form α=β Def. \",\"pmc\":\"If I use an equation to introduce a new sign α, saying that it shall serve as a substitute for a sign β that is already known, then, like Russell, I write the equation - definition - in the form α = β Def.\",\"ogd\":\"\",\"str\":\"If I use an equation to introduce a new sign α, saying that it will be a substitute for some already known sign β, then, like Russell, I write the definition of the equation in the form α = β Def.\",\"tlp\":[4.241]},{\"label\":\"5.3102\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":69,\"x_axis\":113,\"page\":50,\"ger\":\"Aber auch hier ist ja der negative Satz indirekt durch den positiven gebildet. \",\"pmc\":\"But really even in this case the negative proposition is constructed by an indirect use of the positive.\",\"ogd\":\"\",\"str\":\"Yet even in this case the negative proposition is constructed by indirectly relying on the positive.\",\"tlp\":[5.5151]},{\"label\":\"5.312\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":69,\"x_axis\":115,\"page\":61,\"ger\":\"〟~p\\\" ist wahr wenn 〟p\\\" falsch ist. Also in dem wahren Satz 〟~p\\\" ist 〟p\\\" ein falscher Satz. Wie kann ihn nun der Haken 〟~\\\" mit der Wirklichkeit zum Stimmen bringen? \",\"pmc\":\" '~p' is true if 'p' is false. Therefore, in the proposition '~p', when it is true, 'p' is a false proposition. How then can the crochet '~' make it agree with reality?\",\"ogd\":\"\",\"str\":\"“~p” is true if “p” is false. Therefore, in the proposition “~p”, when true, “p” is false. How then can the hook “~” make it agree with reality?\",\"tlp\":[5.512]},{\"label\":\"5.3202\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":69,\"x_axis\":123,\"page\":86,\"ger\":\"Wenn die Gegenstände gegeben sind, so sind uns damit auch schon alle Gegenstände gegeben. \",\"pmc\":\"If objects are given, then at the same time we are given all objects.\",\"ogd\":\"\",\"str\":\"Once objects are given, that itself gives us all objects.\",\"tlp\":[5.524]},{\"label\":\"5.322\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":69,\"x_axis\":127,\"page\":63,\"ger\":\"Die Allgemeinheitsbezeichnung tritt als Argument auf. \",\"pmc\":\"The generality-sign makes its appearance as an argument.\",\"ogd\":\"\",\"str\":\"The generality sign appears as an argument.\",\"tlp\":[5.523]},{\"label\":\"5.3221\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":69,\"x_axis\":129,\"page\":76,\"ger\":\"Jener Präzedenzfall auf den man sich immer berufen möchte, muß schon im Symbol selber liegen. \",\"pmc\":\"The precedent to which we are constantly inclined to appeal must reside in the symbol itself.\",\"ogd\":\"\",\"str\":\"The generality sign appears as an argument.\",\"tlp\":[5.525]},{\"label\":\"5.3302\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":69,\"x_axis\":131,\"page\":34,\"ger\":\"Dies wird sehr klar, wenn man z.B. den Satz (x):ϕ(x)⊃x=a betrachtet. Was dieser Satz sagt ist einfach, daß nur a der Funktion ϕ genügt und nicht daß nur solche Dinge ϕ genügen welche eine gewisse Beziehung zu a haben. <br />Man könnte nun freilich sagen daß eben nur a diese Beziehung zu a habe, aber um dies auszudrücken brauchten wir das Gleichheitszeichen selber.\",\"pmc\":\"This becomes very clear if one considers, for example, the proposition (x):ϕx ⊃ x = a. What this proposition says is simply that only a satisfies the function ϕ, and not that only things that have a certain relation to a satisfy ϕ.<br />Of course, it might then be said that only a did have this relation to a; but in order to express that, we should need the identity-sign itself.\",\"ogd\":\"\",\"str\":\"This becomes very clear if one considers, for example, the proposition (x):ϕx⊃x=a. What this proposition says is simply that only a satisfies function ϕ, not that only things that have a certain relation to a satisfy ϕ. Of course, one might then say that only a has this relation to a; but this would have to be expressed using the identity sign itself.\",\"tlp\":[5.5301]},{\"label\":\"5.332\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":69,\"x_axis\":133,\"page\":18,\"ger\":\"Und analog, nicht 〟(∃x,y)·F(x,y)·x=y\\\", sondern (∃x)·F(x,x)\\\" und nicht 〟(∃x,y)·F(x,y)·x≠y\\\", sondern 〟(∃x,y)·F(x,y)\\\". (Also statt dem Russellschen 〟(∃x,y)·F(x,y)\\\": 〟(∃x,y)·F(x,y) v (x)·F(x,x)\\\".)\",\"pmc\":\"And analogously I do not write '(∃x, y).F(x, y).x=y', but '(∃x).F(x, x)'; and not '(∃x, y).F(x, y).x≠y', but '(∃x, y).F(x, y)'.<br />(So Russell's '(∃x, y).F(x, y)' becomes '(∃x, y).F(x, y) v (∃x).F(x, x)'.)\",\"ogd\":\"\",\"str\":\"And analogously: not “(∃x, y).F(x, y).x=y”, but “(∃x).F(x, x)”; and not “(∃x, y).F(x, y).x≠y”, but “(∃x, y).F(x, y)”.\\r(So instead of Russell's “(∃x, y).F(x, y)”: “(∃x, y).F(x, y) v (∃x).F(x, x)”.)\",\"tlp\":[5.532]},{\"label\":\"5.3321\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":69,\"x_axis\":135,\"page\":18,\"ger\":\"Statt 〟(x)·Fx⊃x=a\\\" schreiben wir also z.B. 〟Fa: ~(∃x,y)·Fx·Fy\\\". Und der Satz 〟Nur ein x befriedigt F(x̂)\\\" lautet: 〟(∃x)·Fx: ~(∃x,y)·Fx·Fy\\\".\",\"pmc\":\"Thus, for example, instead of '(x).Fx ⊃ x=a' we write 'Fa:~(∃xy).Fx.Fy'. And the proposition, 'Only one x satisfies F(x̂)', will read '(∃x).Fx:~(∃x, y).Fx.Fy'.\",\"ogd\":\"\",\"str\":\"Instead of “(x).Fx ⊃ x=a” we therefore write “Fa:~(∃xy).Fx.Fy”. And the proposition, “Only one x satisfies F(x̂ )”, will be “(∃x).Fx:~(∃x, y).Fx.Fy”.pt\",\"tlp\":[5.5321]},{\"label\":\"5.342\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":69,\"x_axis\":137,\"page\":58,\"ger\":\"Die 〟Erfahrung\\\" die wir zum Verstehen der Logik brauchen ist nicht die daß sich etwas so und so verhält sondern daß etwas ist, aber das ist eben keine Erfahrung. \",\"pmc\":\"The 'experience' that we need in order to understand logic is not that something or other is the state of things, but that something is: that, however, is not an experience.\",\"ogd\":\"\",\"str\":\"The “experience” we need to understand logic is not that such and such is the case, but that something is. But that is not an experience.\",\"tlp\":[5.552]},{\"label\":\"4.4\",\"precision\":1,\"fontSize\":\"40px\",\"y_axis\":71,\"x_axis\":67,\"page\":3,\"ger\":\"Der Satz ist der Ausdruck der Übereinstimmung und nicht Übereinstimmung mit den Wahrheitsmöglichkeiten der Elementarsätze. \",\"pmc\":\"A proposition is an expression of agreement and disagreement with truth-possibilities of elementary propositions.\",\"ogd\":\"\",\"str\":\"A proposition is an expression of agreement or disagreement with truth-possibilities of elementary propositions.\",\"tlp\":[4.4]},{\"label\":\"4.4001\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":71,\"x_axis\":69,\"page\":33,\"ger\":\"Es ist von vornherein wahrscheinlich daß die Einführung der Elementarsätze für das Verständnis aller anderen Satzarten grundlegend ist. Ja das Verständnis der allgemeinen Sätze hängt fühlbar von dem der Elementarsätze ab. \",\"pmc\":\"It immediately strikes one as probable that the introduction of elementary propositions provides the basis for understanding all other kinds of proposition. Indeed the understanding of general propositions palpably depends on the understanding of elementary propositions.\",\"ogd\":\"\",\"str\":\"It is likely that the introduction of elementary propositions provides the basis for understanding all other kinds of proposition. Indeed understanding general propositions obviously depends on understanding elementary propositions.\",\"tlp\":[4.411]},{\"label\":\"5.3103\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":71,\"x_axis\":113,\"page\":50,\"ger\":\"Der positive Satz muß die Existenz des negativen Satzes voraussetzen und umgekehrt. \",\"pmc\":\"The positive proposition necessarily presupposes the existence of the negative proposition, and vice versa.\",\"ogd\":\"\",\"str\":\"The positive proposition necessarily presupposes the existence of the negative proposition, and vice versa.\",\"tlp\":[5.5151]},{\"label\":\"5.313\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":71,\"x_axis\":115,\"page\":61,\"ger\":\"Dasjenige was in 〟~p\\\" verneint ist aber nicht das 〟~\\\" sondern dasjenige was allen Zeichen dieser Notation welche 〟p\\\" verneinen gemeinsam ist. <br />Also die gemeinsame Regel nach welcher ~p, ~~~p, ~p∨~p, ~p·~p, etc. etc. (ad inf.) gebildet werden. Und dies Gemeinsame spiegelt die Verneinung wieder.\",\"pmc\":\"But in '~p' it is not '~' that negates; it is rather what is common to all the signs of this notation that negate 'p'.<br />That is to say the common rule that governs the construction of ~p, ~~~p, ~p∨~p, ~p.~p, etc., etc. (ad inf.). And this common factor mirrors negation.\",\"ogd\":\"\",\"str\":\"What negates in “~p” is not the “~”: rather, the negating is done by what all the signs of this notation have in common. That is, the common rule governing the construction of ~p, ~~~p, ~p ∨~p, ~p .~p, etc., etc. (ad inf.). And this common factor mirrors negation.\",\"tlp\":[5.512]},{\"label\":\"5.3131\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":71,\"x_axis\":117,\"page\":61,\"ger\":\"Man könnte sagen: Das Gemeinsame aller Symbole, die sowohl p als auch q bejahen ist der Satz 〟p·q\\\". Das Gemeinsame aller Symbole, die entweder p, oder q bejahen ist der Satz 〟p ∨ q\\\".\",\"pmc\":\"We might say that what is common to all symbols that affirm both p and q is the proposition 'p.q'; and that what is common to all symbols that affirm either p or q is the proposition 'p ∨ q'.\",\"ogd\":\"\",\"str\":\"It could be said that the proposition “p.q” is what is common to all symbols that affirm both p and q. The proposition “p∨q” is what is common to all symbols that affirm either p or q.\",\"tlp\":[5.513]},{\"label\":\"5.3132\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":71,\"x_axis\":119,\"page\":62,\"ger\":\"Und so kann man sagen: Zwei Sätze sind einander entgegengesetzt wenn sie nichts mit einander gemein haben, und: jeder Satz hat nur ein Negativ weil es nur einen Satz gibt der ganz außerhalb ihm liegt. \",\"pmc\":\"And thus we can say that two propositions are opposed to one another if they have nothing in common with one another, and that every proposition has only one negative, since there is only one proposition that lies completely outside it.\",\"ogd\":\"\",\"str\":\"And thus we can say: Two propositions are opposed to one another if they have nothing in common, and: every proposition has only one negative, since there is only one proposition that lies entirely outside it.\",\"tlp\":[5.513]},{\"label\":\"5.3133\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":71,\"x_axis\":121,\"page\":62,\"ger\":\"Es zeigt sich so auch in der neuen Notation, daß 〟q:p∨~p\\\" dasselbe sagt wie 〟q\\\". Daß 〟p∨~p\\\" nichts sagt. \",\"pmc\":\"Thus in the new notation too it is manifest that 'q:p∨~p' says the same thing as 'q', that 'p∨~p' says nothing.\",\"ogd\":\"\",\"str\":\"Thus in the new notation, too, that “q:p ∨~p” says the same as “q” shows itself, and that “p ∨~p” says nothing.\",\"tlp\":[5.513]},{\"label\":\"5.3203\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":71,\"x_axis\":123,\"page\":83,\"ger\":\"Wenn die Elementarsätze gegeben sind, so sind damit auch alle Elementarsätze gegeben. \",\"pmc\":\"If elementary propositions are given, then at the same time all elementary propositions are given.\",\"ogd\":\"\",\"str\":\"If elementary propositions are given, then thereby all elementary propositions are given.\",\"tlp\":[5.524]},{\"label\":\"5.323\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":71,\"x_axis\":127,\"page\":62,\"ger\":\"Man kann die Welt vollständig durch vollkommen verallgemeinerte Sätze beschreiben, d.h. also ohne irgend einen Namen von vornherein einem bestimmten Gegenstand zuzuordnen. \",\"pmc\":\"We can describe the world completely by means of fully generalized propositions, i.e. without first correlating any name with a particular object.\",\"ogd\":\"\",\"str\":\"The world can be completely described using fully generalized propositions, that is without first correlating any name with a particular object.\",\"tlp\":[5.526]},{\"label\":\"5.3303\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":71,\"x_axis\":131,\"page\":34,\"ger\":\"Russells Definition von 〟=\\\" genügt nicht; weil man nach ihr nicht sagen kann, zwei Gegenstände haben alle Eigenschaften gemeinsam. (Selbst wenn dieser Satz nie richtig ist, hat er doch Sinn.)\",\"pmc\":\"Russell's definition of '=' is inadequate, because according to it we cannot say that two objects have all their properties in common. (Even if this proposition is never correct, it still has sense.)\",\"ogd\":\"\",\"str\":\"Russell's definition of “=“ won’t do, because it doesn’t let us say that two objects have all their properties in common. (Even if this proposition is never correct, it still makes sense.)\\r+?35[1]\\t—\\t\\tAL 206 (4)+\\rA common form is not a common constituent.\",\"tlp\":[5.5302]},{\"label\":\"5.333\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":71,\"x_axis\":133,\"page\":19,\"ger\":\"Das Gleichheitszeichen ist also kein wesentlicher Bestandteil der Begriffsschrift. \",\"pmc\":\"The identity-sign, therefore, is not an essential constituent of conceptual notation.\",\"ogd\":\"\",\"str\":\"Therefore the identity sign is not an essential component of conceptual notation.\",\"tlp\":[5.533]},{\"label\":\"5.343\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":71,\"x_axis\":137,\"page\":58,\"ger\":\"Die Logik ist vor jeder Erfahrung — daß etwas so ist. \",\"pmc\":\"Logic is prior to every experience - that something is so.\",\"ogd\":\"\",\"str\":\"Logic is prior to every experience - that something is so.\",\"tlp\":[5.552]},{\"label\":\"5.3431\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":71,\"x_axis\":139,\"page\":58,\"ger\":\"Sie ist vor dem Wie nicht vor dem Was. \",\"pmc\":\"It is prior to the question 'How?', not prior to the question 'What?'.\",\"ogd\":\"\",\"str\":\"It is before the How, not before the What.\",\"tlp\":[5.552]},{\"label\":\"5.3432\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":71,\"x_axis\":141,\"page\":58,\"ger\":\"Und wenn dies nicht so wäre wie könnten wir die Logik anwenden? Man könnte sagen: Wenn es eine Logik gäbe auch wenn es keine Welt gäbe, wie könnte es dann eine Logik geben da es eine Welt gibt? \",\"pmc\":\"And if this were not so, how could we apply logic? We might put it this way: if there would be a logic even if there were no world, how then could there be a logic given that there is a world?\",\"ogd\":\"\",\"str\":\"And if this were not so, how could we apply logic? We could put it this way: if there would be a logic even if there were no world, how could there be a logic given that there is a world?\",\"tlp\":[5.5521]},{\"label\":\"4.401\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":73,\"x_axis\":69,\"page\":12,\"ger\":\"Bezüglich der Übereinstimmung und nicht Übereinstimmung eines Satzes mit den Wahrheitsmöglichkeiten von n Elementarsätzen gibt es Ln= Möglichkeiten.\",\"pmc\":\"For n elementary propositions there are Ln ways in which a proposition can agree or disagree with their truth-possibilities.\",\"ogd\":\"\",\"str\":\"There are Ln ways in which a proposition can agree or disagree with the truth-possibilities of n elementary propositions.pt\",\"tlp\":[4.42]},{\"label\":\"5.314\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":73,\"x_axis\":115,\"page\":87,\"ger\":\"Ist eine Notation festgelegt so gibt es in ihr eine Regel, nach der alle p verneinenden Sätze gebildet werden, eine Regel nach der alle p bejahenden Sätze gebildet werden, eine Regel nach der alle p oder q bejahenden Sätze gebildet werden u.s.f.. Diese Regeln sind den Symbolen äquivalent und in ihnen spiegelt sich ihr Sinn wieder. \",\"pmc\":\"Once a notation has been established, there will be in it a rule governing the construction of all propositions that negate p, a rule governing the construction of all propositions that affirm p, and a rule governing the construction that affirm all propositions that affirm p or q; and so on. These rules are equivalent to the symbols; and in them their sense is mirrored.\",\"ogd\":\"\",\"str\":\"If a notation is established, there is in it a rule that governs how all propositions that negate p are constructed, a rule that governs the construction of all propositions that affirm p, a rule that governs the construction of all propositions that affirm p or q, and so on. These rules are equivalent to the symbols and in them their sense is mirrored.\",\"tlp\":[5.514]},{\"label\":\"5.3204\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":73,\"x_axis\":123,\"page\":20,\"ger\":\"Es ist unrichtig den Satz 〟(∃x)·ϕx\\\" — wie Russell dies tut — in Worten durch 〟ϕx ist möglich\\\" wiederzugeben. \",\"pmc\":\"It is incorrect to render the proposition '(∃x).ϕx' in the words, '(∃x).ϕx is possible', as Russell does.\",\"ogd\":\"\",\"str\":\"It is wrong to render the proposition “(∃x).ϕx” in the words, “ϕx is possible”, as Russell does.\",\"tlp\":[5.525]},{\"label\":\"5.32041\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":73,\"x_axis\":125,\"page\":20,\"ger\":\"Gewißheit, Möglichkeit, oder Unmöglichkeit einer Sachlage wird nicht durch einen Satz ausgedrückt, sondern dadurch, daß eine Tautologie, ein sinnvoller Satz, oder eine Kontradiktion die Sachlage darstellt.\",\"pmc\":\"The certainty, possibility, or impossibility of a situation is not expressed by a proposition, but by whether what represents the situation is a tautology, a proposition with sense, or a contradiction.\",\"ogd\":\"\",\"str\":\"The certainty, possibility, or impossibility of a situation is not expressed by a proposition, but by whether what represents the situation is a tautology, a proposition with sense, or a contradiction.\",\"tlp\":[5.525]},{\"label\":\"5.324\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":73,\"x_axis\":127,\"page\":63,\"ger\":\"Um dann auf die gewöhnliche Ausdrucksweise zu kommen muß man einfach nach einem Ausdruck 〟es gibt ein und nurein x welches …\\\" sagen: und dies x ist A. \",\"pmc\":\"Then, in order to arrive at the customary mode of expression, we simply need to add, after an expression like, 'There is one and only one x such that…', the words: and that x is A.\",\"ogd\":\"\",\"str\":\"To arrive at the ordinary mode of expression, then, we simply need to say  after an expression such as “There is one and only one x such that…”: and that x is A.\",\"tlp\":[5.526]},{\"label\":\"5.3304\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":73,\"x_axis\":131,\"page\":40,\"ger\":\"Beiläufig gesprochen: von zwei Dingen zu sagen sie seien identisch ist ein Unsinn, und von einem zu sagen es sei identisch mit sich selbst, sagt gar nichts. \",\"pmc\":\"Roughly speaking, to say of two things that they are identical is nonsense, and to say of one thing that it is identical with itself is to say nothing at all.\",\"ogd\":\"\",\"str\":\"Roughly speaking, to say of two things that they are identical is nonsense, and to say of one thing that it is identical with itself is to say nothing at all.\",\"tlp\":[5.5303]},{\"label\":\"5.334\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":73,\"x_axis\":133,\"page\":19,\"ger\":\"Und nun sehen wir daß Scheinsätze wie: 〟a=a\\\", 〟a=b·b=c.⊃.a=c\\\", 〟(x)·x=x\\\", 〟(∃x)·x=a\\\", etc. sich in einer richtigen Begriffsschrift gar nicht hinschreiben lassen.\",\"pmc\":\"And now we see that in a correct conceptual notation psuedo-propositions like 'a=a', 'a=b.b=c.⊃.a=c', '(x).x=x', '(∃x).x=a', etc. cannot even be written down.\",\"ogd\":\"\",\"str\":\"And now we see that pseudo-propositions like “a =a”, “a =b . b = c .⊃a =c”, “(x).x=x”, “(∃x ).x =a”, etc. cannot even be written down using correct conceptual notation.\",\"tlp\":[5.534]},{\"label\":\"5.3341\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":73,\"x_axis\":135,\"page\":19,\"ger\":\"Damit erledigen sich auch alle Probleme, die an solche Scheinsätze geknüpft waren. \",\"pmc\":\"This also disposes of all the problems that were connected with such pseudo-propositions.\",\"ogd\":\"\",\"str\":\"This also clears up all the problems that were connected with such pseudo-propositions.\",\"tlp\":[5.535]},{\"label\":\"5.3342\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":73,\"x_axis\":137,\"page\":39,\"ger\":\"Es gibt gewisse Fälle wo man in Versuchung gerät, Ausdrücke von der Form a=a oder p⊃p u.dergl. zu benützen; und zwar geschieht dies, wenn man gerne von dem Urbild Satz, Ding, etc. reden möchte. So hat Russell in den 〟Principles of Mathematics\\\" den Unsinn 〟p ist ein Satz\\\" in Symbolen durch 〟p⊃p\\\" wiedergegeben und als Hypothese vor gewisse Sätze gestellt damit deren Argumentstellen nur von Sätzen besetzt werden könnten.\",\"pmc\":\"There are certain cases in which one is tempted to use expressions of the form a=a or p⊃p and the like, and in fact this happens when one would like to talk about prototypes, e.g. about proposition, thing, etc. Thus in Russell's Principles of Mathematics 'p is a proposition' - which is nonsense - was given the symbolic rendering 'p⊃p', and placed as a hypothesis in front of certain propositions in order to exclude from their argument-places everything but propositions.\",\"ogd\":\"\",\"str\":\"There are certain cases in which one is tempted to use expressions of the form a =a or p ⊃p and the like. For instance, this happens when one wants to talk about prototypes: proposition, thing, etc. So Russell in his Principles of Mathematics rendered nonsense such as “p is a proposition” symbolically as “p ⊃p”, and places it in front of certain propositions as an antecedent hypothesis in order to indicate their argument-places can only be filled by propositions.\",\"tlp\":[5.5351]},{\"label\":\"5.3343\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":73,\"x_axis\":139,\"page\":40,\"ger\":\"Es ist schon darum Unsinn die Hypothese p⊃p vor einen Satz zu stellen um ihm Argumente der richtigen Form zu sichern, weil die Hypothese für einen Nicht-Satz als Argument nicht falsch sondern unsinnig wird, und weil der Satz selbst durch die unrichtige Gattung von Argumenten unsinnig wird, also sich selbst ebensogut oder so schlecht vor den unrechten Argumenten bewahrt wie die zu diesem Zweck angehängte sinnlose Hypothese. \",\"pmc\":\"It is nonsense to place the hypothesis p⊃p in front of a proposition, in order to ensure that its arguments shall have the right form, if only because with a non-proposition as argument the hypothesis becomes not false but nonsensical, and because arguments of the wrong kind make the proposition itself nonsensical, so that it preserves itself from wrong arguments just as well, or as badly, as the hypothesis without sense that was appended for that purpose.\",\"ogd\":\"\",\"str\":\"It is nonsense to use p ⊃p as an antecedent hypothesis to ensure that its consequent arguments have the right form. For with a non-proposition as argument the antecedent hypothesis becomes not false but nonsensical, and because using the wrong sort of arguments makes the proposition itself nonsensical. So in this way it saves itself from the wrong arguments just as well, or as badly, as the senseless hypothesis attached for this purpose.\",\"tlp\":[5.5351]},{\"label\":\"5.3344\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":73,\"x_axis\":141,\"page\":43,\"ger\":\"Ebenso wollte man 〟Es gibt keine Dinge\\\" ausdrücken durch 〟~(Ex)·x=x\\\". Aber selbst wenn dies ein Satz wäre, wäre nicht auch wahr, wenn es zwar 〟Dinge gäbe\\\" aber diese nicht mit sich selbst identisch wären?\",\"pmc\":\"In the same way people have wanted to express 'There are no things' by writing '~(∃x).x=x'. But even if this were a proposition, would it not be equally true if in fact 'there were things' but they were not identical with themselves?\",\"ogd\":\"\",\"str\":\"Likewise, people have wanted to express “There are no things” by writing “~(∃x).x=x”. If this were actually a proposition, wouldn’t it be just as true if “there were things” but no thing was identical with itself?\",\"tlp\":[5.5352]},{\"label\":\"4.4011\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":75,\"x_axis\":69,\"page\":13,\"ger\":\"<em>L</em><sub>n</sub> =  <sup>0</sup>&sum;<em><sup>Kn</sup></em> <em>μ</em> (<em><sup>Kn</sup></em><em><sub>μ</sub></em>)\",\"pmc\":\"<em>L</em><sub>n</sub> =  <sup>0</sup>&sum;<em><sup>Kn</sup></em> <em>μ</em> (<em><sup>Kn</sup></em><em><sub>μ</sub></em>)\",\"ogd\":\"\",\"str\":\"Ln = 0∑Kn μ (Knμ)  [Equation editing needed]\",\"tlp\":[4.42]},{\"label\":\"5.315\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":75,\"x_axis\":115,\"page\":62,\"ger\":\"Es muß sich an unseren Satzzeichen zeigen, daß das, was durch 〟∨\\\" 〟·\\\" etc. mit einander verbunden ist, Satzzeichen sein müssen. <br />Und dies ist auch der Fall, denn das Symbol 〟p\\\" und 〟q\\\" setzt ja selbst das 〟∨\\\", 〟.\\\", etc. voraus. Wenn das Zeichen 〟p\\\" in 〟p ∨ q\\\" nicht für ein komplexes Zeichen steht, dann kann es allein nicht Sinn haben; dann können aber auch die mit 〟p\\\" gleichsinnigen Zeichen 〟p ∨ p\\\", 〟p·p\\\" etc. keinen Sinn haben. Wenn aber 〟p ∨ p\\\" keinen Sinn hat dann kann auch p ∨ q keinen Sinn haben.\",\"pmc\":\"It must be manifest in our propositional signs that it can only be propositional signs that are combined with one another by '∨', '.', etc.<br />And this is indeed the case, since the symbol in 'p' and 'q' itself presupposes '∨', '.', etc. If the sign 'p' in 'p∨q' does not stand for a complex sign, then it cannot have sense by itself: but in that case the signs 'p∨p', 'p.p', etc., which have the same sense as 'p', must also lack sense. But if 'p∨p' has no sense, then 'p∨q' cannot have sense either.\",\"ogd\":\"\",\"str\":\"It must show itself in our sentential signs that it can only be sentential signs that are connected by “∨”, “.”, etc.\\rAnd this is indeed so, for the symbol in “p” and “q” itself presupposes “∨”, “.”, etc. If the sign “p” in “p∨q” does not stand for a complex sign, then it cannot make sense by itself: but then the signs “p∨p”, “p.p”, etc., which have the same sense as “p”, must also not make sense. However, if “p∨p” makes no sense, then “p∨q” cannot make sense either.\",\"tlp\":[5.515]},{\"label\":\"5.325\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":75,\"x_axis\":127,\"page\":63,\"ger\":\"Ein vollkommen verallgemeinerter Satz ist wie jeder andere Satz zusammengesetzt. (Dies zeigt sich daran daß wir in 〟(Ex,f)·fx\\\" 〟f〟 und 〟x\\\" getrennt erwähnen müssen.) Beide stehen unabhängig in bezeichnenden Beziehungen zur Welt wie im unverallgemeinerten Satz. \",\"pmc\":\"A fully generalized proposition, like every other proposition, is composite. (This is shown by the fact that in '(∃x, f).fx' we have to mention 'f' and 'x' separately.) They both, independently, stand in signifying relations to the world, just as is the case in an ungeneralized proposition.\",\"ogd\":\"\",\"str\":\"A fully generalized proposition is composite, just like every other proposition. (This shows itself in our needing to mention “f ” and “x” separately “(∃x,f).fx”. Both symbols independently stand in signifying relations to the world, as in an ungeneralized proposition.\",\"tlp\":[5.5261]},{\"label\":\"5.3251\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":75,\"x_axis\":129,\"page\":63,\"ger\":\"Kennzeichen des zusammengesetzten Symbols: es hat etwas mit anderen Zeichen gemeinsam. \",\"pmc\":\"It is the mark of a composite symbol that it has something in common with other signs.\",\"ogd\":\"\",\"str\":\"The mark of a composite symbol: it has something in common with other signs.\",\"tlp\":[5.5261]},{\"label\":\"5.33411\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":75,\"x_axis\":135,\"page\":55,\"ger\":\"Alle Probleme, die Russells Axiom of infinity mit sich bringt sind schon hier zu lösen. \",\"pmc\":\"The solution of all the problems that Russell's axiom of infinity brings with it can be given at this point.\",\"ogd\":\"\",\"str\":\"All the problems with Russell's axiom of infinity can now be solved here.\",\"tlp\":[5.535]},{\"label\":\"4.41\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":77,\"x_axis\":69,\"page\":6,\"ger\":\"Die Übereinstimmung mit den Wahrheitsmöglichkeiten können wir dadurch ausdrücken indem wir ihnen im Schema etwa das Abzeichen 〟W\\\" (〟Wahr\\\") zuordnen. \",\"pmc\":\"We can express agreement with truth-possibilities by correlating the mark 'T' ('true') with them in the schema.\",\"ogd\":\"\",\"str\":\"We can express agreement with truth-possibilities by correlating the mark “T” (“true”) with them in the schema.\",\"tlp\":[4.43]},{\"label\":\"4.42\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":77,\"x_axis\":71,\"page\":6,\"ger\":\"Das Fehlen dieses Abzeichens bedeutet die Nicht-Übereinstimmung.\",\"pmc\":\"The absence of this mark means disagreement.\",\"ogd\":\"\",\"str\":\"The absence of this mark means disagreement.pt\",\"tlp\":[4.43]},{\"label\":\"4.43\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":77,\"x_axis\":75,\"page\":7,\"ger\":\"Das Zeichen welches durch die Zuordnung jener Abzeichen und der Wahrheitsmöglichkeiten entsteht ist ein Satzzeichen.\",\"pmc\":\"The sign that results from correlating that mark with truth-possibilities is a propositional sign.\",\"ogd\":\"\",\"str\":\"The sign that results from correlating that mark with truth-possibilities is a\\rsentential sign.\",\"tlp\":[4.44]},{\"label\":\"4.44\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":77,\"x_axis\":91,\"page\":7,\"ger\":\"Ist die Reihenfolge der Wahrheitsmöglichkeiten im Schema durch eine Kombinationsregel ein für allemal festgesetzt dann ist die letzte Kolonne allein schon ein Ausdruck der Wahrheitsbedingungen.\",\"pmc\":\"If the order of the truth-possibilities in a schema is fixed once and for all by a combinatory rule, then the last column by itself will be an expression of the truth-conditions.\",\"ogd\":\"\",\"str\":\"If the order of the truth-possibilities in a schema is fixed once and for all by a combinatory rule, then the last column by itself will be an expression of the truth-conditions.\",\"tlp\":[4.442]},{\"label\":\"5.4\",\"precision\":1,\"fontSize\":\"40px\",\"y_axis\":77,\"x_axis\":111,\"page\":56,\"ger\":\"Der Elementarsatz besteht aus Namen. Da wir aber nicht die Anzahl der Namen von verschiedener Bedeutung zeigen können, so können wir auch nicht die Zusammensetzung des Elementarsatzes zeigen. \",\"pmc\":\"Elementary propositions consist of names. Since, however, we are unable to show the number of names with different meanings, we are also unable to show the composition of elementary propositions.\",\"ogd\":\"\",\"str\":\"Elementary propositions consist of names. Since, however, we are unable to show the number of names with different meanings, we also cannot show the composition of elementary propositions.\",\"tlp\":[5.55]},{\"label\":\"5.401\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":77,\"x_axis\":113,\"page\":56,\"ger\":\"Russell sagte es gäbe einfache Relationen zwischen verschiedenen Anzahlen von Dingen (individuals). Aber zwischen welchen Anzahlen? Und wie soll sich das entscheiden? — Durch die Erfahrung? \",\"pmc\":\"Russell said that there were simple relations between different numbers of things (individuals). But between what numbers? And how is this supposed to be decided? - By experience?\",\"ogd\":\"\",\"str\":\"Russell said that there were simple relations between different numbers of things (individuals). But between what numbers? And how is this supposed to be decided? - By experience?\",\"tlp\":[5.553]},{\"label\":\"5.402\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":77,\"x_axis\":115,\"page\":56,\"ger\":\"Es muß sich a priori angeben lassen, ob ich z.B. in die Lage kommen kann etwas mit einer 27-stelligen Relation bezeichnen zu müssen. \",\"pmc\":\"It has to be possible to answer a priori the question whether I can get into a position in which I need a 27-termed relation in order to signify something.\",\"ogd\":\"\",\"str\":\"It has to be possible to answer a priori the question whether I can get into a position in which I need a 27-termed relation to signify something.\",\"tlp\":[5.5541]},{\"label\":\"5.403\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":77,\"x_axis\":117,\"page\":57,\"ger\":\"Dürfen wir denn aber überhaupt so fragen? Können wir eine Zeichenform aufstellen und nicht wissen ob ihr etwas entsprechen könne? \",\"pmc\":\"But is it really legitimate even to ask such a question? Can we set up a form of sign without knowing whether anything can correspond to it.\",\"ogd\":\"\",\"str\":\"But can it even be legitimate to ask such a question? How can we set up a form of a sign without knowing whether anything can correspond to it?\",\"tlp\":[5.5542]},{\"label\":\"5.404\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":77,\"x_axis\":119,\"page\":57,\"ger\":\"Hat die Frage einen Sinn: Was muß sein damit etwas der Fall — sein kann? \",\"pmc\":\"Does it make sense to ask what there must be in order that something can be the case?\",\"ogd\":\"\",\"str\":\"Does it make sense to ask what there must be such that something can be the case?\",\"tlp\":[5.5524]},{\"label\":\"5.405\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":77,\"x_axis\":121,\"page\":57,\"ger\":\"Wo immer man Zeichen nach einem System bilden kann, dort ist das System das logisch Wichtige und nicht die einzelnen Zeichen. \",\"pmc\":\"But when there is a system by which we can create signs, the system is important for logic and not the individual signs.\",\"ogd\":\"\",\"str\":\"But when we have a system for creating signs, the system is what is important for logic and not the individual signs.\",\"tlp\":[5.555]},{\"label\":\"5.326\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":77,\"x_axis\":127,\"page\":63,\"ger\":\"Es verändert ja die Wahr- oder Falschheit jedes Satzes etwas am allgemeinen Bau der Welt. Und der Spielraum welcher ihrem Bau durch die Gesamtheit der Elementarsätze gelassen wird, ist eben derjenige, welchen die ganz allgemeinen Sätze begrenzen. <br />(Denn wenn ein Elementarsatz wahr ist, so ist damit doch jedenfalls ein Elementarsatz mehr wahr.)\",\"pmc\":\"The truth or falsity of every proposition does make some alteration in the general construction of the world. And the range that the totality of elementary propositions leaves open for its construction is exactly the same as that which is delimited by entirely general propositions.<br />(For if an elementary proposition is true, that means, at any rate, one more true elementary proposition.)\",\"ogd\":\"\",\"str\":\"The truth or falsity of every proposition alters something about the general structure of the world. And the play that is left open to it structure by the totality of elementary propositions leaves open for its construction is precisely what is delimited by the entirely general propositions. \\r(For if an elementary proposition is true, then, at any rate, one more elementary proposition is true.)\",\"tlp\":[5.5262]},{\"label\":\"5.33412\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":77,\"x_axis\":135,\"page\":59,\"ger\":\"Das was das Axiom of infinity sagen soll würde sich in der Sprache dadurch ausdrücken daß es unendlich viele Namen mit verschiedener Bedeutung gäbe. \",\"pmc\":\"What the axiom of infinity is intended to say would express itself in language through the existence of infinitely many names with different meanings.\",\"ogd\":\"\",\"str\":\"What the axiom of infinity is supposed to say would be expressed in language by there being infinitely many names with different meanings.\",\"tlp\":[5.535]},{\"label\":\"4.421\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":79,\"x_axis\":71,\"page\":12,\"ger\":\"Der Ausdruck der Übereinstimmung und nicht Übereinstimmung mit den Wahrheitsmöglichkeiten der Elementarsätze drückt die Wahrheitsbedingungen des Satzes aus. \",\"pmc\":\"The expression of agreement and disagreement with the truth-possibilities of elementary propositions expresses the truth-conditions of a proposition.\",\"ogd\":\"\",\"str\":\"The expression of agreement and disagreement with the truth-possibilities of elementary propositions expresses the truth-conditions of a proposition.\",\"tlp\":[4.431]},{\"label\":\"4.4301\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":79,\"x_axis\":75,\"page\":46,\"ger\":\"Hiernach scheint es nun möglich zu sein die allgemeinste Satzform anzugeben; d.h. eine Beschreibung der Satzzeichenirgend einer Zeichensprache zu geben, so daß jeder mögliche Sinn durch ein Zeichen auf welches die Beschreibung paßt ausgedrückt werden kann, und daß jedes Zeichen worauf die Beschreibung paßt einen Sinn ausdrücken kann, wenn die Bedeutung der einfachen Zeichen entsprechend gewählt wird.\",\"pmc\":\"Accordingly it now seems possible to give the most general propositional form: that is, to give a description of the propositional signs of any sign-language whatsoever in such a way that every possible sense can be expressed by a sign satisfying the description, and every sign satisfying the description can express a sense, provided that the meanings of the simple signs are suitably chosen.\",\"ogd\":\"\",\"str\":\"Accordingly it now seems possible to give the most general propositional form: that is, to describe the sentential signs of any sign-language whatsoever so that every possible sense can be expressed by a sign that falls under the description, and every sign that falls under the description can express a sense, provided that the meanings of the simple signs are suitably chosen.\",\"tlp\":[4.5]},{\"label\":\"4.43011\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":79,\"x_axis\":77,\"page\":46,\"ger\":\"Es ist klar, daß bei der Beschreibung der allgemeinsten Satzform nur ihr Wesentliches beschrieben werden darf, — sonst wäre sie nämlich nicht die allgemeinste.\",\"pmc\":\"It is clear that only what is essential to the most general propositional form may be included in its description - for otherwise it would not be the most general form.\",\"ogd\":\"\",\"str\":\"Clearly, only what is essential to the most general propositional form may be included in its description -  otherwise, it would not be the most general form.\",\"tlp\":[4.5]},{\"label\":\"4.43012\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":79,\"x_axis\":79,\"page\":78,\"ger\":\"Daß es eine allgemeine Satzform gibt, wird dadurch bewiesen, daß es keinen Satz geben darf dessen Form man nicht hätte voraussehen (d.h. konstruieren) können. \",\"pmc\":\"The existence of a general propositional form is proved by the fact that there cannot be a proposition whose form could not have been forseen (i.e. constructed).\",\"ogd\":\"\",\"str\":\"That no proposition can be given whose form could not have been forseen (i.e. constructed) proves the existence of a general propositional form.\",\"tlp\":[4.5]},{\"label\":\"4.43013\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":79,\"x_axis\":81,\"page\":81,\"ger\":\"Angenommen uns wären alle einfachen Sätze gegeben. Dann läßt sich einfach fragen, welche Sätze kann ich aus ihnen bilden. Und das sind alle Sätze und so sind sie begrenzt. \",\"pmc\":\"Suppose that we are given all simple propositions, then we can simply ask: what propositions can I construct out of these? And there we have all propositions and that fixes their limits.\",\"ogd\":\"\",\"str\":\"Suppose we were given all simple propositions. Then we can simply ask what propositions I can construct out of them. And these are all the propositions and that is how they are limited.\",\"tlp\":[4.51]},{\"label\":\"4.43014\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":79,\"x_axis\":83,\"page\":91,\"ger\":\"Die Sätze sind alles was aus der Gesamtheit aller Elementarsätze folgt. (Natürlich auch daraus daß es die Gesamtheit aller ist.) \",\"pmc\":\"Propositions comprise all that follows from the totality of all elementary propositions (and, of course, from its being the totality of them all).\",\"ogd\":\"\",\"str\":\"Propositions are all that follows from the totality of all elementary propositions (and, of course, from its being the totality of them all.)\",\"tlp\":[4.52]},{\"label\":\"4.431\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":79,\"x_axis\":85,\"page\":7,\"ger\":\"Also ist z.B. ’ <br />' p | q |    '<br /> W | F | W<br /> W |W | W<br /> F | F   |<br /> F | W | W<br />ein Satzzeichen.\",\"pmc\":\"So for example, the following is a propositional sign. <br />' p| q |    '<br /> T | F | T<br /> T | T | T<br /> F | F |<br /> F | T | T<br />\",\"ogd\":\"\",\"str\":\"So for example, this\\r\\ris a sentential sign.\\r\",\"tlp\":[4.442]},{\"label\":\"4.4311\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":79,\"x_axis\":87,\"page\":32,\"ger\":\"Freges Zeichen 〟✓\\\" ist logisch ganz bedeutungslos es zeigt bei Frege (und Russell) nur an daß diese Autoren die so bezeichneten Sätze für wahr halten. 〟✓\\\" gehört daher ebensowenig zum Satzgefüge wie etwa die Nummer des Satzes. Ein Satz kann unmöglich von sich selbst aussagen daß er wahr ist. \",\"pmc\":\"Frege's sign '⊢' is logically quite meaningless: in the works of Frege (and Russell) it simply indicates that these authors hold the propositions marked with this sign to be true. Thus '⊢' is no more a component part of a proposition than is, for instance, the proposition's number. It is quite impossible for a proposition to state that it itself is true.\",\"ogd\":\"\",\"str\":\"Frege's sign “⊢” is logically quite meaningless: in Frege (and Russell) it only indicates that these authors hold the sentences marked in this way to be true. Thus “⊢” is no more a component part of a proposition than is, for instance, the proposition's number. A proposition cannot possibly assert of itself that is true.\",\"tlp\":[4.442]},{\"label\":\"4.441\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":79,\"x_axis\":91,\"page\":7,\"ger\":\"Schreiben wir diese Kolonne als Reihe hin so wird das Zeichen in 〟(WWFW) (p,q)\\\" oder 〟(W,W, ,W) (p,q)\\\".\",\"pmc\":\"If we now write this column as a row, the sign in 4.432 will become '(TTFT)(p, q)' or (T, T,  , T)(p, q)'.\",\"ogd\":\"\",\"str\":\"If we now write this column as a row, the sign in 4.432 will become \\r“(TTFT )(p, q)” or “(T, T,  , T)(p, q)”.\",\"tlp\":[4.442]},{\"label\":\"5.4011\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":79,\"x_axis\":113,\"page\":96,\"ger\":\"Eine ausgezeichnete Zahl gibt es nicht. \",\"pmc\":\"There is no privileged number.\",\"ogd\":\"\",\"str\":\"There is no privileged number.\",\"tlp\":[5.553]},{\"label\":\"5.4041\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":79,\"x_axis\":119,\"page\":91,\"ger\":\"Die Logik erfüllt die Welt; die Grenzen der Welt sind auch ihre Grenzen. \",\"pmc\":\"Logic pervades the world: the limits of the world are also its limits.\",\"ogd\":\"\",\"str\":\"Logic permeates the world: the limits of the world are also its limits.\",\"tlp\":[5.61]},{\"label\":\"5.4051\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":79,\"x_axis\":121,\"page\":87,\"ger\":\"Und wie wäre es auch möglich daß ich es in der Logik mit Formen zu tun hätte, die ich erfinden kann, sondern mit dem muß ich es zu tun haben, was es mir möglich macht sie zu erfinden. \",\"pmc\":\"And anyway, is it really possible that in logic I should have to deal with forms I can invent? What I have to deal with must be that which makes it possible for me to invent them.\",\"ogd\":\"\",\"str\":\"And in any case, how could logic demand that I must deal with forms that I can invent?  I must, rather, deal with that which makes it possible for me to invent forms.\",\"tlp\":[5.555]},{\"label\":\"5.335\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":79,\"x_axis\":133,\"page\":59,\"ger\":\"Die Grenzen meiner Sprache bedeuten die Grenzen meiner Welt. \",\"pmc\":\"The limits of my language mean the limits of my world.\",\"ogd\":\"\",\"str\":\"The limits of my language mean the limits of my world.\",\"tlp\":[5.6]},{\"label\":\"5.3351\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":79,\"x_axis\":135,\"page\":59,\"ger\":\"Diese Bemerkung gibt den Schlüssel zur Entscheidung, inwieweit der Solipsismus eine Wahrheit ist. \",\"pmc\":\"This remark provides the key to the problem how much truth there is in solipsism.\",\"ogd\":\"\",\"str\":\"This remark provides the key to the problem how much truth there is in solipsism.\",\"tlp\":[5.62]},{\"label\":\"5.3352\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":79,\"x_axis\":137,\"page\":60,\"ger\":\"Was der Solipsismus nämlich meint ist ganz richtig nur läßt es sich nicht sagen, sondern es zeigt sich. \",\"pmc\":\"For what the solipsist means is quite correct; only it cannot be said, but makes itself manifest.\",\"ogd\":\"\",\"str\":\"Namely: what solipsism means is quite correct, only it cannot be said, but shows itself.\",\"tlp\":[5.62]},{\"label\":\"5.3353\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":79,\"x_axis\":139,\"page\":60,\"ger\":\"Daß die Welt meine Welt ist das zeigt sich darin daß die Grenzen der Sprache (der Sprache die allein ich verstehe) die Grenzen meiner Welt bedeuten. \",\"pmc\":\"The world is my world: this is manifest in the fact that the limits of language (of that language which alone I understand) mean the limits of my world.\",\"ogd\":\"\",\"str\":\"That the world is my world shows itself in the fact that the limits of language (the only language I understand) mean the limits of my world.\",\"tlp\":[5.62]},{\"label\":\"5.3354\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":79,\"x_axis\":141,\"page\":60,\"ger\":\"Das denkende, vorstellende Subjekt gibt es nicht. \",\"pmc\":\"There is no such thing as the subject that thinks or entertains ideas.\",\"ogd\":\"\",\"str\":\"The subject that thinks, entertains ideas: there is no such thing.\",\"tlp\":[5.631]},{\"label\":\"5.3355\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":79,\"x_axis\":145,\"page\":85,\"ger\":\"Hier sieht man daß der Solipsismus streng durchgeführt mit dem reinen Realismus zusammenfällt. <br />Das Ich des Solipsismus schrumpft zum ausdehnungslosen Punkt zusammen und es bleibt die ihm koordinierte Realität.\",\"pmc\":\"Here it can be seen that solipsism, when its implications are followed out strictly, coincides with pure realism. The self of solipsism shrinks to a point without extension, and there remains the reality co-ordinate with it.\",\"ogd\":\"\",\"str\":\"Here one sees that solipsism, strictly worked out, coincides with pure realism. The I of solipsism shrinks to an extensionless point, and what remains is the reality co-ordinated with it.\",\"tlp\":[5.64]},{\"label\":\"4.422\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":81,\"x_axis\":71,\"page\":12,\"ger\":\"Der Satz ist der Ausdruck seiner Wahrheitsbedingungen. \",\"pmc\":\"A proposition is the expression of its truth conditions.\",\"ogd\":\"\",\"str\":\"A proposition is the expression of its truth conditions.\",\"tlp\":[4.431]},{\"label\":\"4.4221\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":81,\"x_axis\":73,\"page\":55,\"ger\":\"Frege hat sie daher ganz richtig als Erklärung der Zeichen seiner Begriffsschrift vorausgeschickt. Nur ist die Erklärung des Wahrheitsbegriffes bei Frege falsch: Wären 〟das Wahre\\\" und 〟das Falsche\\\" wirklich Gegenstände und die Argumente in ~p etc. dann wäre nach Freges 〟Bestimmung\\\" der Sinn von ~p keineswegs bestimmt. \",\"pmc\":\"Thus Frege was quite right to use them as a starting point when he explained the signs of his conceptual notation. But the explanation of the concept of truth that Frege gives is mistaken: if 'the true' and 'the false' were really objects, and were the arguments in ~p, etc., then Frege's method of 'determining' the sense of ~p would leave it absolutely undetermined.\",\"ogd\":\"\",\"str\":\"So Frege was quite right to start with them in explaining the signs of his conceptual notation. But Frege’s explanation of the concept of truth is wrong: if “the true” and “the false” were real objects, and were the arguments in ~p, etc., then the sense of ~p would not in the least be determined by Frege's  “determination.”\",\"tlp\":[4.431]},{\"label\":\"4.4302\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":81,\"x_axis\":75,\"page\":79,\"ger\":\"Die allgemeine Satzform ist eine Variable. \",\"pmc\":\"The general propositional form is the variable.\",\"ogd\":\"\",\"str\":\"The general propositional form is a variable.\",\"tlp\":[4.53]},{\"label\":\"4.430141\",\"precision\":6,\"fontSize\":\"18px\",\"y_axis\":81,\"x_axis\":83,\"page\":92,\"ger\":\"So könnte man in gewissem Sinne sagen daß alle Sätze Verallgemeinerungen aus den Elementarsätzen sind. \",\"pmc\":\"Thus, in a certain sense, it could be said that all propositions were generalizations from elementary propositions.\",\"ogd\":\"\",\"str\":\"So one could say, in a certain sense, that all propositions are generalizations of elementary propositions.\",\"tlp\":[4.52]},{\"label\":\"4.432\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":81,\"x_axis\":85,\"page\":7,\"ger\":\"Der Deutlichkeit halber schreiben wir dieses Zeichen nun so: <br />' p | q |    '<br /> W | F | W<br /> W |W | W<br /> F | F   | F<br /> F | W | W<br />Die nach §4.43 auf diese Weise gebauten Satzzeichen nennen wir Satzzeichen der ersten Art.\",\"pmc\":\"For the sake of perspicuousness we now write this sign in the following way:<br />' p| q |    '<br /> T | F | T<br /> T | T | T<br /> F | F | F<br /> F | T | T<br />The propositional signs which, according to §4.43, are constructed in this way, we call proposition signs of the first kind.\",\"ogd\":\"\",\"str\":\"For the sake of clarity we now write this sign as follows:\\rp\\tq\\rF\\tF\\tT\\rT\\tF\\tT\\rF\\tT\\tF\\rT\\tT\\tT\\rThe sentential signs which, according to §4.43, are constructed in this way, we call proposition signs of the first kind.\",\"tlp\":[\"None\"]},{\"label\":\"4.4321\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":81,\"x_axis\":87,\"page\":45,\"ger\":\"Die Wahrheitsbedingungen bestimmen den Spielraum der den Tatsachen durch den Satz gelassen wird. \",\"pmc\":\"The truth-conditions of a proposition determine the range that it leaves open to the facts.\",\"ogd\":\"\",\"str\":\"The truth-conditions of a proposition determine the leeway left to the facts.\",\"tlp\":[4.463]},{\"label\":\"4.4322\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":81,\"x_axis\":89,\"page\":41,\"ger\":\"Der Satz, das Bild, das Modell, sind, im negativen Sinn, wie ein fester Körper der die Bewegungsfreiheit der anderen beschränkt; im positiven Sinne, wie der von fester Substanz begrenzte Raum, worin ein Körper Platz hat. \",\"pmc\":\"A proposition, a picture, or a model is, in the negative sense, like a solid body that restricts the freedom of movement of others, and, in the positive sense, like a space bounded by solid substance in which there is room for a body.\",\"ogd\":\"\",\"str\":\"A proposition, a picture, or a model is, in the negative sense, like a solid body which restricts the freedom of movement of another; in a positive sense, like a space bounded by solid substance in which there is room for a body.\",\"tlp\":[4.463]},{\"label\":\"4.442\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":81,\"x_axis\":91,\"page\":13,\"ger\":\"WWFW sind also die Wahrheitsbedingungen dieses Satzes. (geändert)\",\"pmc\":\"So TTFT are the truth-conditions of this proposition.\",\"ogd\":\"\",\"str\":\"So TTFT are the truth-conditions of this proposition.\",\"tlp\":[\"None\"]},{\"label\":\"5.4012\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":81,\"x_axis\":113,\"page\":97,\"ger\":\"Die Angabe jeder speziellen Form wäre vollkommen willkürlich. \",\"pmc\":\"It would be completely arbitrary to give any specific form.\",\"ogd\":\"\",\"str\":\"The specification of any special form would be completely arbitrary.\",\"tlp\":[5.554]},{\"label\":\"5.4042\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":81,\"x_axis\":119,\"page\":91,\"ger\":\"Wir können also in der Logik nicht sagen: das und das gibt es in der Welt, jenes nicht. \",\"pmc\":\"So we cannot say in logic: 'The world has this in it, and this, but not that.'\",\"ogd\":\"\",\"str\":\"So  in logic we cannot say: “The world has this in it, and this, but not that.”\",\"tlp\":[5.61]},{\"label\":\"5.40421\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":81,\"x_axis\":121,\"page\":90,\"ger\":\"Was wir nicht denken können, das können wir nicht denken; wir können also auch nicht sagen, was wir nicht denken können. \",\"pmc\":\"We cannot think what we cannot think. So what we cannot think we cannot say either.\",\"ogd\":\"\",\"str\":\"We cannot think what we cannot think; so we cannot say what we cannot think.\",\"tlp\":[5.61]},{\"label\":\"5.33531\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":81,\"x_axis\":139,\"page\":83,\"ger\":\"Die Welt und das Leben sind eins. \",\"pmc\":\"The world and life are one.\",\"ogd\":\"\",\"str\":\"The world and life are one.\",\"tlp\":[5.621]},{\"label\":\"5.33541\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":81,\"x_axis\":141,\"page\":76,\"ger\":\"Wenn ich ein Buch schriebe 〟Die Welt, wie ich sie vorfand\\\", so wäre darin auch über meinen Leib zu berichten und zu sagen, welche Glieder meinem Willen unterstehen etc. dies ist nämlich eine Methode das Subjekt zu isolieren, oder vielmehr, zu zeigen daß es in einem wichtigen Sinne kein Subjekt gibt: von ihm allein nämlich, könnte in diesem Buchenicht die Rede sein. — \",\"pmc\":\"If I wrote a book called The World as I found it, I should have to include a report on my body, and should have to say which parts were subordinate to my will, etc., this being a method of isolating the subject, or rather of showing that in an important sense there is no subject; for it alone could not be mentioned in that book.\",\"ogd\":\"\",\"str\":\"If I were to write a book called The World as I Found It, I would also have to report in it about my body, and say which parts obey my will, etc. This then would be a method of isolating the subject, or rather of showing that in an important sense there is no subject; for it alone could not be mentioned in that book. –\",\"tlp\":[5.631]},{\"label\":\"5.33551\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":81,\"x_axis\":145,\"page\":85,\"ger\":\"Es gibt also wirklich einen Sinn in welchem in der Philosophie nicht-psychologisch vom Ich die Rede sein kann.<br />Das Ich tritt in die Philosophie dadurch ein daß 〟die Welt meine Welt ist\\\".\",\"pmc\":\"Thus there really is a sense in which philosophy can talk about the self in a non-psychological way.<br />What brings the self into philosophy is that 'the world is my world'.\",\"ogd\":\"\",\"str\":\"So there really is a sense in which there can be talk of the I in a non-psychological way in philosophy. What brings the I into philosophy is that “the world is my world”.\",\"tlp\":[5.641]},{\"label\":\"4.423\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":83,\"x_axis\":71,\"page\":11,\"ger\":\"Die Wahrheitsmöglichkeiten der Elementarsätze sind die Wahrheitsbedingungen der Sätze.\",\"pmc\":\"Truth-possibilities of elementary propositions are the truth-conditions of propositions.\",\"ogd\":\"\",\"str\":\"Truth-possibilities of elementary propositions are the truth-conditions of\\rpropositions.pt\",\"tlp\":[4.41]},{\"label\":\"4.4303\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":83,\"x_axis\":75,\"page\":46,\"ger\":\"Die allgemeinste Satzform ist: es verhält sich so und so. Diese Form muß in allen Sätzen auf irgend eine Weise enthalten sein.\",\"pmc\":\"The most general propositional form is: This is how things stand. This form must be contained in all propositions in some way or other.\",\"ogd\":\"\",\"str\":\"The most general propositional form is: such and such is the case. This form must be contained in all propositions in some way or other.\",\"tlp\":[4.5]},{\"label\":\"4.433\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":83,\"x_axis\":85,\"page\":15,\"ger\":\"Es ist klar daß dem Komplex der Zeichen 〟F\\\" und 〟W\\\" kein Gegenstand (oder Komplex von Gegenständen) entspricht, so wenig wie den horizontalen und vertikalen Strichen oder den Klammern. 〟Logische Gegenstände\\\" gibt es nicht. \",\"pmc\":\"It is clear that a complex of the signs 'F' and 'T' has no object (or complex of objects) corresponding to it, just as there is none corresponding to the horizontal and vertical lines or to the brackets. There are no 'logical objects'.\",\"ogd\":\"\",\"str\":\"Clearly, a complex of the signs “F” and “T” has no corresponding object (or complex of objects), just as there is none corresponding to the horizontal and vertical lines or to the brackets. There are no “logical objects”.\",\"tlp\":[4.441]},{\"label\":\"4.4331\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":83,\"x_axis\":87,\"page\":15,\"ger\":\"Analoges gilt natürlich für alle Zeichen die dasselbe ausdrücken wie die Schemata der W und F\\\".\",\"pmc\":\"Of course the same applies to all signs that express what the schemata of 'T's' and 'F's' express.\",\"ogd\":\"\",\"str\":\"Naturally, the same applies to all signs that express what the schemas of “T's” and “F 's” express.\",\"tlp\":[4.441]},{\"label\":\"4.443\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":83,\"x_axis\":91,\"page\":13,\"ger\":\"Für n Elementarsätze gibt es Ln mögliche Gruppen von Wahrheitsbedingungen. \",\"pmc\":\"For n elementary propositions there are Ln possible groups of truth-conditions.\",\"ogd\":\"\",\"str\":\"For n elementary propositions there are Ln possible groups of truth-conditions.\",\"tlp\":[4.45]},{\"label\":\"5.41\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":83,\"x_axis\":113,\"page\":57,\"ger\":\"Ob aber ein Zeichen der Art F(a,b,c…) analysierbar ist oder nicht, zeigt sich nicht am Zeichen. Sondern wenn es analysierbar ist so zeigt es sich an der bezeichnenden Beziehung. Also daran daß eine analysierende Definition des Zeichens Sinn hat. \",\"pmc\":\"However, whether a sign like F(a, b, c, …) is analyzable or not does not make itself manifest in the sign. Rather, if it is analyzable, that makes itself manifest in the signifying relation, and so in the sign's possessing a definition that anlayzes it and that has sense.\",\"ogd\":\"\",\"str\":\"However, whether a sign like F (a, b, c, …) is analyzable or not does not show itself in the sign. Rather, if it is analyzable, that shows itself in the signifying relation, and so in the sign's possessing a definition that analyzes it and that has sense.\",\"tlp\":[\"None\"]},{\"label\":\"5.42\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":83,\"x_axis\":117,\"page\":57,\"ger\":\"Wir können jene Frage offen lassen: die Sprache wird sie von selbst entscheiden. \",\"pmc\":\"We can leave that question open: language itself will decide it.\",\"ogd\":\"\",\"str\":\"We can leave that question open: language itself will decide it.\",\"tlp\":[\"None\"]},{\"label\":\"5.4043\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":83,\"x_axis\":119,\"page\":91,\"ger\":\"Das würde nämlich scheinbar voraussetzen daß wir gewisse Möglichkeiten ausschließen und dies kann nicht der Fall sein, da sonst die Logik über die Grenzen der Welt hinaus müßte, wenn sie nämlich diese Grenzen auch von der anderen Seite betrachten könnte. \",\"pmc\":\"For that would appear to presuppose that we were excluding certain possibilities, and this cannot be the case, since it would require that logic should go beyond the limits of the world; for only in that way could it view those limits from the other side as well.\",\"ogd\":\"\",\"str\":\"For that would appear to presuppose that we have excluded certain possibilities, and this cannot be the case, since this would require that logic should go beyond the limits of the world, as if it could also have a view of those limits from the other side.\",\"tlp\":[5.61]},{\"label\":\"5.33532\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":83,\"x_axis\":139,\"page\":85,\"ger\":\"Ich bin meine Welt (der Mikrokosmos). \",\"pmc\":\"I am my world, (the microcosm).\",\"ogd\":\"\",\"str\":\"I am my world (the microcosm).\",\"tlp\":[5.63]},{\"label\":\"5.33542\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":83,\"x_axis\":141,\"page\":84,\"ger\":\"Das Subjekt gehört nicht zur Welt, sondern es ist eine Grenze der Welt. \",\"pmc\":\"The subject does not belong to the world: rather, it is a limit of the world.\",\"ogd\":\"\",\"str\":\"The subject is not part of the world, but a limit of the world.\",\"tlp\":[5.632]},{\"label\":\"5.33552\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":83,\"x_axis\":145,\"page\":94,\"ger\":\"Das philosophische Ich ist nicht der Mensch, nicht der menschliche Körper oder die menschliche Seele von der die Psychologie handelt, sondern das metaphysische Subjekt, die Grenze (nicht ein Teil) der Welt. \",\"pmc\":\"The philosophical self is not the human being, not the human body, or the human soul, with which psychology deals, but rather the metaphysical subject, the limit (not a part) of the world.\",\"ogd\":\"\",\"str\":\"The philosophical I is not the human being, not the human body, nor the human soul, with which psychology deals, but rather the metaphysical subject, the limit (not a part) of the world.\",\"tlp\":[5.641]},{\"label\":\"4.444\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":85,\"x_axis\":91,\"page\":13,\"ger\":\"Die Gruppen von Wahrheitsbedingungen welche zu den Wahrheitsmöglichkeiten einer Anzahl von Elementarsätzen gehören lassen sich in einer Reihe ordnen. \",\"pmc\":\"The groups of truth-conditions that are obtainable from the truth-possibilities of a given number of elementary propositions can be arranged in a series.\",\"ogd\":\"\",\"str\":\"The groups of truth-conditions that belong to the truth-possibilities of a given number of elementary propositions can be arranged in a series.\",\"tlp\":[4.45]},{\"label\":\"5.4101\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":85,\"x_axis\":111,\"page\":81,\"ger\":\"Es ist offenbar daß wir bei der Analyse der Sätze auf Elementarsätze kommen müssen die aus Namen in unmittelbarer Verbindung bestehen. \",\"pmc\":\"It is obvious that the analysis of propositions must bring us to elementary propositions which consist of names in immediate combination.\",\"ogd\":\"\",\"str\":\"Obviously, analysing propositions must lead us to elementary propositions consisting of names in immediate connection.\",\"tlp\":[4.221]},{\"label\":\"5.41011\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":85,\"x_axis\":113,\"page\":94,\"ger\":\"Es frägt sich hier, wie kommt der Satzverband zustande. \",\"pmc\":\"This raises the question how such combination into propositions comes about.\",\"ogd\":\"\",\"str\":\"The question here is: how does the propositional connection//combination//nexus// arise?\",\"tlp\":[4.221]},{\"label\":\"5.411\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":85,\"x_axis\":115,\"page\":80,\"ger\":\"Eine Hierarchie der Formen der Elementarsätze kann es nicht geben. \",\"pmc\":\"There cannot be a hierarchy of the forms of elementary propositions.\",\"ogd\":\"\",\"str\":\"There can be no hierarchy of the forms of elementary propositions.\",\"tlp\":[5.556]},{\"label\":\"5.421\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":85,\"x_axis\":117,\"page\":97,\"ger\":\"Die Anwendung der Logik entscheidet darüber, welche Elementarsätze es gibt. \",\"pmc\":\"The application of logic decides what elementary propositions there are.\",\"ogd\":\"\",\"str\":\"The application of logic is what decides what elementary propositions there are.\",\"tlp\":[5.557]},{\"label\":\"5.4211\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":85,\"x_axis\":119,\"page\":97,\"ger\":\"Was in der Anwendung liegt, kann die Logik nicht vorausnehmen. \",\"pmc\":\"What belongs to its application, logic cannot anticipate.\",\"ogd\":\"\",\"str\":\"Logic cannot forsee what belongs to its application.\",\"tlp\":[5.557]},{\"label\":\"5.4212\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":85,\"x_axis\":121,\"page\":97,\"ger\":\"Das ist klar: die Logik darf mit ihrer Anwendung nicht kollidieren. \",\"pmc\":\"It is clear that logic must not clash with its application.\",\"ogd\":\"\",\"str\":\"Clearly, logic may not clash with its application.\",\"tlp\":[5.557]},{\"label\":\"5.4213\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":85,\"x_axis\":123,\"page\":97,\"ger\":\"Aber die Logik muß sich mit ihrer Anwendung berühren. \",\"pmc\":\"But logic has to be in contact with its application.\",\"ogd\":\"\",\"str\":\"But logic and its application must touch each other.\",\"tlp\":[5.557]},{\"label\":\"5.4214\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":85,\"x_axis\":125,\"page\":97,\"ger\":\"Also dürfen die Logik und ihre Anwendung einander nicht übergreifen. \",\"pmc\":\"Therefore logic and its application must not overlap.\",\"ogd\":\"\",\"str\":\"Therefore logic and its application may not overlap one another.\",\"tlp\":[5.557]},{\"label\":\"5.33543\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":85,\"x_axis\":141,\"page\":84,\"ger\":\"Wo in der Welt ist ein metaphysisches Subjekt zu merken?<br />Du sagst, es verhält sich hier ganz wie bei Auge und Gesichtsfeld. Aber das Auge siehst Du wirklich nicht. <br />Und nichts am Gesichtsfeld läßt darauf schließen daß es von einem Auge gesehen wird.\",\"pmc\":\"Where in the world is a metaphysical subject to be found?<br />You will say that this is exactly like the case of the eye and the visual field. But really you do not see the eye.<br />And nothing in the visual field allows you to infer that it is seen by an eye.\",\"ogd\":\"\",\"str\":\"Where in the world is a metaphysical subject to be found?\\rYou say this is just like the case of the eye and the visual field. But you do not actually see the eye. And nothing in the visual field would enable one to infer that it is seen by an eye.\",\"tlp\":[5.633]},{\"label\":\"5.335431\",\"precision\":6,\"fontSize\":\"18px\",\"y_axis\":85,\"x_axis\":143,\"page\":84,\"ger\":\"Das Gesichtsfeld hat nämlich nicht etwa eine solche Form \",\"pmc\":\"For the form of the visual field is surely not like this\",\"ogd\":\"\",\"str\":\"The form of the visual field is surely not like this:\\rEye\",\"tlp\":[5.6331]},{\"label\":\"4.445\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":87,\"x_axis\":91,\"page\":13,\"ger\":\"Unter den möglichen Gruppen von Wahrheitsbedingungen gibt es zwei extreme Fälle.\",\"pmc\":\"Among the possible groups of truth-conditions there are two extreme cases.\",\"ogd\":\"\",\"str\":\"Among the possible groups of truth-conditions there are two limiting cases.\",\"tlp\":[4.46]},{\"label\":\"5.4102\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":87,\"x_axis\":111,\"page\":81,\"ger\":\"Ein Zeichen des Elementarsatzes ist es, daß kein Elementarsatz mit ihm in Widerspruch stehen kann. \",\"pmc\":\"It is a sign of a proposition's being elementary that there can be no elementary proposition contradicting it.\",\"ogd\":\"\",\"str\":\"It is a sign of a proposition's being elementary that no elementary proposition can contradict it.\",\"tlp\":[4.211]},{\"label\":\"5.412\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":87,\"x_axis\":115,\"page\":81,\"ger\":\"Nur was wir selbst konstruieren, können wir voraussehen. \",\"pmc\":\"We can forsee only what we ourselves construct.\",\"ogd\":\"\",\"str\":\"We can foresee only what we ourselves construct.\",\"tlp\":[5.556]},{\"label\":\"5.422\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":87,\"x_axis\":117,\"page\":57,\"ger\":\"Elementarsätze bezeichnen wir mit 〟p0\\\", 〟q0\\\", 〟r0\\\", etc. oder mit f0(a), f0(a,b), etc. wobei wir es dahingestellt sein lassen ob a=b ist oder nicht.\",\"pmc\":\"For elementary propositions we use the signs 'p0', 'q0', 'r0', etc. or 'f0(a)', 'f0(a, b)', etc. where it is left open whether or not a = b.\",\"ogd\":\"\",\"str\":\"For elementary propositions we use the signs “p0”, “q0”, “r0”, etc. or “f0(a)”, “f0(a, b)”, etc. where it is left open whether or not a=b.\",\"tlp\":[\"None\"]},{\"label\":\"5.4221\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":87,\"x_axis\":119,\"page\":97,\"ger\":\"Es ist klar wir haben vom Elementarsatz einen Begriff abgesehen von seiner besonderen logischen Form. \",\"pmc\":\"Clearly we have some concept of elementary propositions quite apart from their particular logical forms.\",\"ogd\":\"\",\"str\":\"Clearly we have the concept of an elementary proposition apart from its particular logical form.\",\"tlp\":[5.555]},{\"label\":\"5.4222\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":87,\"x_axis\":121,\"page\":97,\"ger\":\"Weiß ich aus rein logischen Gründen, — und so ist es — daß es Elementarsätze geben muß, dann muß es auch jeder andere wissen, der die Sätze in ihrer unanalysierten Form sieht. \",\"pmc\":\"If I know on purely logical grounds - as indeed I do - that there must be elementary propositions, then everyone else who sees propositions in their unanalyzed form must know it too.\",\"ogd\":\"\",\"str\":\"If I know on purely logical grounds - and I do - that there must be elementary propositions, this must be known by anyone who sees propositions in their unanalysed form.\",\"tlp\":[5.5562]},{\"label\":\"5.4223\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":87,\"x_axis\":123,\"page\":97,\"ger\":\"Wenn ich die Elementarsätze nicht a priori angeben kann, dann muß es zu offenbarem Unsinn führen, sie angeben zu wollen.\",\"pmc\":\"If I cannot say a priori what elementary propositions there are, then the attempt to do so must lead to obvious nonsense.\",\"ogd\":\"\",\"str\":\"Since I cannot specify a priori what elementary propositions there are, any attempt to do so must lead to obvious nonsense.\",\"tlp\":[5.5571]},{\"label\":\"5.33544\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":87,\"x_axis\":141,\"page\":85,\"ger\":\"Das hängt damit zusammen daß kein Teil unserer Erfahrung auch a priori ist. \",\"pmc\":\"This is connected with the fact that no part of our experience is at the same time a priori.\",\"ogd\":\"\",\"str\":\"This is connected with no part of our experience being a priori.\",\"tlp\":[5.634]},{\"label\":\"4.446\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":89,\"x_axis\":91,\"page\":13,\"ger\":\"Im einen Fall ist der Satz für sämtliche Wahrheitsmöglichkeiten der Elementarsätze wahr. Wir sagen die Wahrheitsbedingungen sind tautologisch. Im zweiten Fall ist der Satz für sämtliche Wahrheitsmöglichkeiten falsch; die Wahrheitsbedingungen sind kontradiktorisch. \",\"pmc\":\"In one of these cases the proposition is true for all the truth-possibilities of the elementary propositions. We say that the truth-conditions are tautological.<br />In the second case the proposition is all false for all the truth-possibilities: the truth-conditions are contradictory.\",\"ogd\":\"\",\"str\":\"In one case the proposition is true for all the truth-possibilities of the elementary propositions. We say that the truth-conditions are tautological. \",\"tlp\":[4.46]},{\"label\":\"4.447\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":91,\"x_axis\":91,\"page\":45,\"ger\":\"Die Tautologie hat keine Wahrheitsbedingungen denn sie ist bedingungslos wahr und die Kontradiktion ist unter keiner Bedingung wahr.\",\"pmc\":\"A tautology has no truth-conditions, since it is unconditionally true: and a contradiction is true on no condition.\",\"ogd\":\"\",\"str\":\"Because a tautology is unconditionally true, it has no truth-conditions; on no condition is a contradiction true.\",\"tlp\":[4.461]},{\"label\":\"4.44601\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":89,\"x_axis\":93,\"page\":38,\"ger\":\"Im ersten Falle nennen wir den Satz eine Tautologie im zweiten Fall eine Kontradiktion.\",\"pmc\":\"In the first case we call the proposition a tautology; in the second, a contradiction.\",\"ogd\":\"\",\"str\":\"In the first case we call the proposition a tautology; in the second, a contradiction.\",\"tlp\":[4.46]},{\"label\":\"4.44602\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":89,\"x_axis\":95,\"page\":36,\"ger\":\"Analytische Sätze sind Tautologien. \",\"pmc\":\"Analytical propositions are tautologies.\",\"ogd\":\"\",\"str\":\"Analytic propositions are tautologies.\",\"tlp\":[\"None\"]},{\"label\":\"5.4103\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":89,\"x_axis\":111,\"page\":80,\"ger\":\"Auch wenn die Welt unendlich komplex wäre, so daß jede Tatsache aus unendlich vielen Sachverhalten bestünde und jeder Sachverhalt aus unendlich vielen Gegenständen zusammengesetzt wäre; auch dann müßte es Gegenstände und Sachverhalte geben.\",\"pmc\":\"Even if the world were infinitely complex, so that every fact consisted of infinitely many states of affairs and every state of affairs were composed of infinitely many objects, there would still have to be objects and states of affairs.\",\"ogd\":\"\",\"str\":\"Even if the world were infinitely complex, so that every fact consisted of infinitely many elementary facts and every elementary fact were composed of infinitely many objects, there would still have to be objects and elementary facts.\",\"tlp\":[4.2211]},{\"label\":\"5.413\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":89,\"x_axis\":115,\"page\":81,\"ger\":\"Die empirische Realität ist begrenzt durch die Gesamtheit der Gegenstände. Die Grenze zeigt sich wieder in der Gesamtheit der Elementarsätze. Die Hierarchien sind und müssen unabhängig von der Realität sein. \",\"pmc\":\"Empirical reality is limited by the totality of objects.<br />The limit also makes itself manifest in the totality of objects.<br />Hierarchies are and must be independent of reality.\",\"ogd\":\"\",\"str\":\"Empirical reality is limited by the totality of objects. \\rThe limit also shows itself in the totality of objects. \\rHierarchies are and must be independent of reality.\",\"tlp\":[5.5561]},{\"label\":\"5.33545\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":89,\"x_axis\":141,\"page\":85,\"ger\":\"Alles was wir sehen, könnte auch anders sein.<br />Alles was wir überhaupt beschreiben können, könnte auch anders sein.\",\"pmc\":\"Whatever we see could be other than it is.<br />Whatever we can describe at all could be other than it is.\",\"ogd\":\"\",\"str\":\"All we see could also be otherwise.\\rAll we can describe at all could also be otherwise.\",\"tlp\":[5.634]},{\"label\":\"4.4461\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":91,\"x_axis\":93,\"page\":31,\"ger\":\"Tautologien sind sinnlos. (Ich weiß z.B. nichts über das Wetter wenn ich weiß daß es regnet oder nicht regnet.) \",\"pmc\":\"Tautologies lack sense. (For example, I know nothing about the weather when I know that it is either raining or not raining.)\",\"ogd\":\"\",\"str\":\"Tautologies lack sense. (For example, I know nothing about the weather when I know that it is either raining or not raining.)\",\"tlp\":[4.461]},{\"label\":\"4.4462\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":91,\"x_axis\":95,\"page\":45,\"ger\":\"Der Satz zeigt was er sagt, die Tautologie und Kontradiktion, daß sie nichts sagen. \",\"pmc\":\"Propositions show what they say: tautologies and contradictions show that they say nothing.\",\"ogd\":\"\",\"str\":\"A proposition shows what it says: a tautology and a contradiction show that they say nothing.\",\"tlp\":[4.461]},{\"label\":\"5.414\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":91,\"x_axis\":115,\"page\":57,\"ger\":\"Alle Sätze unserer Umgangssprache sind tatsächlich, so wie sie sind, logisch vollkommen geordnet. — Jenes Einfachste, was wir hier angeben sollen, ist nicht ein Gleichnis der Wahrheit, sondern die volle Wahrheit selbst. (Unsere Probleme sind nicht abstrakt, sondern vielleicht die konkretesten die es gibt.) \",\"pmc\":\"In fact, all the propositions of our everyday language, just as they stand, are in perfect logical order. - That utterly simple thing, which we have to formulate here, is not an image of the truth, but the truth itself in its entirety.<br />(Our problems are not abstract, but perhaps the most concrete that there are.)\",\"ogd\":\"\",\"str\":\"All the propositions of our ordinary language are actually, just as they are, in perfect logical order. - That utterly simple thing, that we have to formulate here, is not a likeness of the truth, but the complete truth itself. (Our problems are not abstract, but on the contrary, as concrete as they can be.)\",\"tlp\":[5.5563]},{\"label\":\"5.33546\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":91,\"x_axis\":141,\"page\":92,\"ger\":\"Es gibt keine Ordnung der Dinge a priori. \",\"pmc\":\"There is no a priori order of things.\",\"ogd\":\"\",\"str\":\"There is no order of things a priori.\",\"tlp\":[5.634]},{\"label\":\"4.448\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":93,\"x_axis\":91,\"page\":45,\"ger\":\"Tautologie und Kontradiktion sind sinnlos. \",\"pmc\":\"Tautologies and contradictions lack sense.\",\"ogd\":\"\",\"str\":\"Tautologies and contradictions lack sense.\",\"tlp\":[4.46]},{\"label\":\"4.44801\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":93,\"x_axis\":93,\"page\":45,\"ger\":\"(Wie der Punkt von dem zwei Pfeile in entgegengesetzter Richtung auseinander gehen) \",\"pmc\":\"(Like a point from which two arrows go out in opposite directions to one another.)\",\"ogd\":\"\",\"str\":\"(Like a point with two arrows going out in opposite directions.)\",\"tlp\":[4.461]},{\"label\":\"4.4481\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":95,\"x_axis\":93,\"page\":38,\"ger\":\"Tautologie und Kontradiktion sind (sinnlos) nicht unsinnig. Sie gehören zum Symbolismus und zwar ähnlich wie die 0 in die Arithmetik. \",\"pmc\":\"Tautologies and contradictions are not nonsensical (but lack sense). They are part of the symbolism, just as '0' is in arithmetic.\",\"ogd\":\"\",\"str\":\"Tautologies and contradictions are not nonsense (but lack sense). They belong to the symbolism, just like “0” in arithmetic.\",\"tlp\":[4.4611]},{\"label\":\"4.4482\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":95,\"x_axis\":95,\"page\":45,\"ger\":\"Tautologie und Kontradiktion sind nicht Bilder der Wirklichkeit. Sie stellen keine mögliche Sachlage dar. Denn jene läßt jedemögliche Sachlage zu, diese keine. \",\"pmc\":\"Tautologies and contradictions are not pictures of reality. They do not represent any possible situations. For the former admit all possible situations, and the latter none.\",\"ogd\":\"\",\"str\":\"Tautologies and contradictions are not pictures of reality. They represent no possible situations. For tautologies admit all possible situations, and contradictions admit none.\",\"tlp\":[4.462]},{\"label\":\"4.4483\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":95,\"x_axis\":97,\"page\":44,\"ger\":\"In der Tautologie heben die Bedingungen der Übereinstimmung mit der Welt — die darstellenden Beziehungen — einander auf, so daß sie in keiner darstellenden Beziehung zur Wirklichkeit steht. \",\"pmc\":\"In a tautology the conditions of agreement with the world - the representational relations - cancel one another, so that it does not stand in any representational relation to reality.\",\"ogd\":\"\",\"str\":\"In a tautology the conditions of agreement with the world - the representing relations - cancel one another, so that it does not stand in any  representing relation to reality.\",\"tlp\":[4.462]},{\"label\":\"4.4484\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":95,\"x_axis\":99,\"page\":42,\"ger\":\"In der Tautologie bildet der Elementarsatz selbstverständlich noch immer ab, aber er ist mit der Wirklichkeit so lose verbunden daß diese unbeschränkte Freiheit hat. Die Kontradiktion setzt solche Schranken, daß keine Wirklichkeit in ihnen existieren kann. \",\"pmc\":\"Of course in a tautology an elementary proposition still depicts, but it is so loosely connected with reality that it leaves it unbounded freedom. The bounds set by a contradiction are such that no reality can exist within them.\",\"ogd\":\"\",\"str\":\"Of course in a tautology an elementary proposition still depicts, but it is so loosely connected with reality as to leave it unlimited freedom. The bounds set by a contradiction are such that no reality can exist within them.\",\"tlp\":[\"None\"]},{\"label\":\"4.4485\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":95,\"x_axis\":101,\"page\":42,\"ger\":\"Die Tautologie läßt der Wirklichkeit den ganzen — unendlichen — logischen Raum frei; die Kontradiktion erfüllt den ganzen logischen Raum und läßt der Wirklichkeit keinen Punkt. Keine von beiden kann daher die Wirklichkeit irgendwie bestimmen. \",\"pmc\":\"A tautology leaves open to reality the whole - the infinite whole - of logical space: a contradiction fills the whole of logical space leaving no point of it for reality. Thus neither of them can determine reality in any way.\",\"ogd\":\"\",\"str\":\"A tautology leaves the whole infinite logical space open to reality; a contradiction fills the whole of logical space, leaving no point to reality. Thus neither of them can determine reality in any way.\",\"tlp\":[4.463]},{\"label\":\"4.4486\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":95,\"x_axis\":103,\"page\":45,\"ger\":\"Die Wahrheit der Tautologie ist gewiß, des Satzes möglich, der Kontradiktion unmöglich. \",\"pmc\":\"A tautology's truth is certain, a proposition's possible, a contradiction's impossible.\",\"ogd\":\"\",\"str\":\"The truth of tautology is certain, of propositions possible, of contradiction impossible.\",\"tlp\":[4.464]},{\"label\":\"4.449\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":97,\"x_axis\":91,\"page\":45,\"ger\":\"Das logische Produkt einer Tautologie und eines Satzes sagt dasselbe wie der Satz. Also ist jenes Produkt identisch mit dem Satz. Denn man kann das Wesentliche des Zeichens nicht ändern ohne seinen Sinn zu ändern. \",\"pmc\":\"The logical product of a tautology and a proposition says the same thing as the proposition. This product, therefore, is identical with the proposition. For it is impossible to alter what is essential to a sign without altering its sense.\",\"ogd\":\"\",\"str\":\"The logical product of a tautology and a proposition says the same thing as the proposition. This product, therefore, is identical with the proposition. For the essence of a sign cannot be altered without altering its sense.\",\"tlp\":[4.465]},{\"label\":\"4.4491\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":97,\"x_axis\":93,\"page\":51,\"ger\":\"Einer bestimmten logischen Verbindung von Zeichen entspricht eine bestimmte logische Verbindung ihrer Bedeutungen; jede beliebige Verbindung entspricht nur den unverbundenen Zeichen.<br />Das heißt, Sätze die für jede Sachlage wahr sind können überhaupt keine Zeichenverbindungen sein, denn sonst könnten ihnen nur bestimmte Verbindungen von Gegenständen entsprechen.<br />(Und keiner logischen Verbindung entspricht keine Verbindung der Gegenstände.)\",\"pmc\":\"What corresponds to a determinate logical combination of signs is a determinate logical combination of their meanings. It is only to the uncombined signs that absolutely any combination corresponds.<br />In other words, propositions that are true for every situation cannot be combinations of signs at all, since, if they were, only determinate combinations of objects could correspond to them.<br />(And what is not a logical combination has no combination of objects corresponding to it.)\",\"ogd\":\"\",\"str\":\"A definite logical combination of signs corresponds to a definite logical combination of their meanings. It is only to the uncombined signs that absolutely any combination corresponds. That is, propositions that are true for every situation cannot be combinations of signs at all, for otherwise, only definite combinations of objects would correspond to them. \\r(And what isn’t a logical combination has no combination of objects corresponding to it.)\",\"tlp\":[4.466]},{\"label\":\"4.4492\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":97,\"x_axis\":95,\"page\":58,\"ger\":\"Die Tautologie ist der Grenzfall der Zeichenverbindung nämlich ihre Auflösung. \",\"pmc\":\"Tautology is the limiting case, indeed the disintegration, of the combination of signs.\",\"ogd\":\"\",\"str\":\"Tautology is a limiting case of the combination of signs, namely their disintegration.\",\"tlp\":[4.466]},{\"label\":\"4.44861\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":97,\"x_axis\":103,\"page\":42,\"ger\":\"Gewiß, möglich, unmöglich: hier haben wir das Anzeichen jener Gradation, die wir in der Wahrscheinlichkeitslehre brauchen. \",\"pmc\":\"Certain, possible, impossible: here we have the first indication of the scale that we need in the theory of probability.\",\"ogd\":\"\",\"str\":\"Certain, possible, impossible: here we have an indication of the scale needed in probability theory.\",\"tlp\":[4.464]}]};\n\n//# sourceURL=webpack:///./src/data/ptSections.json?");

/***/ }),

/***/ "./src/data/sections.json":
/*!********************************!*\
  !*** ./src/data/sections.json ***!
  \********************************/
/*! exports provided: sections, default */
/***/ (function(module) {

eval("module.exports = {\"sections\":[{\"label\":\"1\",\"precision\":0,\"fontSize\":\"90px\",\"y_axis\":1,\"x_axis\":1,\"ger\":\"Die Welt ist alles, was der Fall ist.\",\"pmc\":\"The world is all that is the case.\",\"ogd\":\"The world is everything that is the case.\",\"str\":\"\"},{\"label\":\"2\",\"precision\":0,\"fontSize\":\"90px\",\"y_axis\":1,\"x_axis\":9,\"ger\":\"Was der Fall ist, die Tatsache, ist das Bestehen von Sachverhalten.\",\"pmc\":\"What is the case—a fact—is the existence of states of affairs.\",\"ogd\":\"What is the case, the fact, is the existence of atomic facts.\",\"str\":\"\"},{\"label\":\"3\",\"precision\":0,\"fontSize\":\"90px\",\"y_axis\":1,\"x_axis\":37,\"ger\":\"Das logische Bild der Tatsachen ist der Gedanke.\",\"pmc\":\"A logical picture of facts is a thought.\",\"ogd\":\"The logical picture of the facts is the thought.\",\"str\":\"\"},{\"label\":\"4\",\"precision\":0,\"fontSize\":\"90px\",\"y_axis\":1,\"x_axis\":51,\"ger\":\"Der Gedanke ist der sinnvolle Satz.\",\"pmc\":\"A thought is a proposition with a sense.\",\"ogd\":\"The thought is the significant proposition.\",\"str\":\"\"},{\"label\":\"5\",\"precision\":0,\"fontSize\":\"90px\",\"y_axis\":1,\"x_axis\":75,\"ger\":\"Der Satz ist eine Wahrheitsfunktion der Elementarsätze. (Der Elementarsatz ist eine Wahrheitsfunktion seiner selbst.)\",\"pmc\":\"A proposition is a truth-function of elementary propositions. (An elementary proposition is a truth-function of itself.)\",\"ogd\":\"Propositions are truth-functions of elementary propositions. (An elementary proposition is a truth-function of itself.)\",\"str\":\"\"},{\"label\":\"6\",\"precision\":0,\"fontSize\":\"90px\",\"y_axis\":1,\"x_axis\":107,\"ger\":\"Die allgemeine Form der Wahrheitsfunktion ist: <span class=\\\"mathmode\\\">[<span class=\\\"overlined\\\"><var>p</var></span>, <span class=\\\"overlined\\\"><var>ξ</var></span>, <span class=\\\"nop\\\">N</span>(<span class=\\\"overlined\\\"><var>ξ</var></span>)]</span>. Dies ist die allgemeine Form des Satzes.\",\"pmc\":\"The general form of a truth-function is  <span class=\\\"mathmode\\\">[<span class=\\\"overlined\\\"><var>p</var></span>, <span class=\\\"overlined\\\"><var>ξ</var></span>, <span class=\\\"nop\\\">N</span>(<span class=\\\"overlined\\\"><var>ξ</var></span>)]</span>. This is the general form of a proposition.\",\"ogd\":\"The general form of truth-function is: <span class=\\\"mathmode\\\">[<span class=\\\"overlined\\\"><var>p</var></span>, <span class=\\\"overlined\\\"><var>ξ</var></span>, <span class=\\\"nop\\\">N</span>(<span class=\\\"overlined\\\"><var>ξ</var></span>)]</span>. This is the general form of proposition.\",\"str\":\"\"},{\"label\":\"7\",\"precision\":0,\"fontSize\":\"90px\",\"y_axis\":1,\"x_axis\":129,\"ger\":\"Wovon man nicht sprechen kann, darüber muss man schweigen.\",\"pmc\":\"What we cannot speak about we must pass over in silence.\",\"ogd\":\"Whereof one cannot speak, thereof one must be silent.\",\"str\":\"\"},{\"label\":\"1.1\",\"precision\":1,\"fontSize\":\"40px\",\"y_axis\":3,\"x_axis\":1,\"ger\":\"Die Welt ist die Gesamtheit der Tatsachen, nicht der Dinge.\",\"pmc\":\"The world is the totality of facts, not of things.\",\"ogd\":\"The world is the totality of facts, not of things.\",\"str\":\"\"},{\"label\":\"1.11\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":3,\"x_axis\":3,\"ger\":\"Die Welt ist durch die Tatsachen bestimmt und dadurch, dass es <em class=\\\"germph\\\">alle</em> Tatsachen sind.\",\"pmc\":\"The world is determined by the facts, and by their being <em>all</em> the facts.\",\"ogd\":\"The world is determined by the facts, and by these being <em>all</em> the facts.\",\"str\":\"\"},{\"label\":\"1.12\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":3,\"x_axis\":5,\"ger\":\"Denn, die Gesamtheit der Tatsachen bestimmt, was der Fall ist und auch, was alles nicht der Fall ist.\",\"pmc\":\"For the totality of facts determines what is the case, and also whatever is not the case.\",\"ogd\":\"For the totality of facts determines both what is the case, and also all that is not the case.\",\"str\":\"\"},{\"label\":\"1.13\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":3,\"x_axis\":7,\"ger\":\"Die Tatsachen im logischen Raum sind die Welt.\",\"pmc\":\"The facts in logical space are the world.\",\"ogd\":\"The facts in logical space are the world.\",\"str\":\"\"},{\"label\":\"2.01\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":3,\"x_axis\":11,\"ger\":\"Der Sachverhalt ist eine Verbindung von Gegenständen. (Sachen, Dingen.)\",\"pmc\":\"A state of affairs (a state of things) is a combination of objects (things).\",\"ogd\":\"An atomic fact is a combination of objects (entities, things).\",\"str\":\"\"},{\"label\":\"2.02\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":3,\"x_axis\":21,\"ger\":\"Der Gegenstand ist einfach.\",\"pmc\":\"Objects are simple.\",\"ogd\":\"The object is simple.\",\"str\":\"\"},{\"label\":\"2.03\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":3,\"x_axis\":29,\"ger\":\"Im Sachverhalt hängen die Gegenstände ineinander, wie die Glieder einer Kette.\",\"pmc\":\"In a state of affairs objects fit into one another like the links of a chain.\",\"ogd\":\"In the atomic fact objects hang one in another, like the links of a chain.\",\"str\":\"\"},{\"label\":\"2.04\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":3,\"x_axis\":31,\"ger\":\"Die Gesamtheit der bestehenden Sachverhalte ist die Welt.\",\"pmc\":\"The totality of existing states of affairs is the world.\",\"ogd\":\"The totality of existent atomic facts is the world.\",\"str\":\"\"},{\"label\":\"2.05\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":3,\"x_axis\":33,\"ger\":\"Die Gesamtheit der bestehenden Sachverhalte bestimmt auch, welche Sachverhalte nicht bestehen.\",\"pmc\":\"The totality of existing states of affairs also determines which states of affairs do not exist.\",\"ogd\":\"The totality of existent atomic facts also determines which atomic facts do not exist.\",\"str\":\"\"},{\"label\":\"2.06\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":3,\"x_axis\":35,\"ger\":\"Das Bestehen und Nichtbestehen von Sachverhalten ist die Wirklichkeit. (Das Bestehen von Sachverhalten nennen wir auch eine positive, das Nichtbestehen eine negative Tatsache.)\",\"pmc\":\"The existence and non-existence of states of affairs is reality. (We call the existence of states of affairs a positive fact, and their non-existence a negative fact.)\",\"ogd\":\"The existence and non-existence of atomic facts is the reality. (The existence of atomic facts we also call a positive fact, their non-existence a negative fact.)\",\"str\":\"\"},{\"label\":\"3.001\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":3,\"x_axis\":39,\"ger\":\"„Ein Sachverhalt ist denkbar“ heißt: Wir können uns ein Bild von ihm machen.\",\"pmc\":\"‘A state of affairs is thinkable’: what this means is that we can picture it to ourselves.\",\"ogd\":\"“An atomic fact is thinkable”—means: we can imagine it.\",\"str\":\"\"},{\"label\":\"4.001\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":3,\"x_axis\":53,\"ger\":\"Die Gesamtheit der Sätze ist die Sprache.\",\"pmc\":\"The totality of propositions is language.\",\"ogd\":\"The totality of propositions is the language.\",\"str\":\"\"},{\"label\":\"4.002\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":3,\"x_axis\":55,\"ger\":\"Der Mensch besitzt die Fähigkeit Sprachen zu bauen, womit sich jeder Sinn ausdrücken lässt, ohne eine Ahnung davon zu haben, wie und was jedes Wort bedeutet. – Wie man auch spricht, ohne zu wissen, wie die einzelnen Laute hervorgebracht werden. Die Umgangssprache ist ein Teil des menschlichen Organismus und nicht weniger kompliziert als dieser. Es ist menschenunmöglich, die Sprachlogik aus ihr unmittelbar zu entnehmen. Die Sprache verkleidet den Gedanken. Und zwar so, dass man nach der äußeren Form des Kleides, nicht auf die Form des bekleideten Gedankens schließen kann; weil die äußere Form des Kleides nach ganz anderen Zwecken gebildet ist als danach, die Form des Körpers erkennen zu lassen. Die stillschweigenden Abmachungen zum Verständnis der Umgangssprache sind enorm kompliziert.\",\"pmc\":\"Man possesses the ability to construct languages capable of expressing every sense, without having any idea how each word has meaning or what its meaning is—just as people speak without knowing how the individual sounds are produced. Everyday language is a part of the human organism and is no less complicated than it. It is not humanly possible to gather immediately from it what the logic of language is. Language disguises thought. So much so, that from the outward form of the clothing it is impossible to infer the form of the thought beneath it, because the outward form of the clothing is not designed to reveal the form of the body, but for entirely different purposes. The tacit conventions on which the understanding of everyday language depends are enormously complicated.\",\"ogd\":\"Man possesses the capacity of constructing languages, in which every sense can be expressed, without having an idea how and what each word means—just as one speaks without knowing how the single sounds are produced. Colloquial language is a part of the human organism and is not less complicated than it. From it it is humanly impossible to gather immediately the logic of language. Language disguises the thought; so that from the external form of the clothes one cannot infer the form of the thought they clothe, because the external form of the clothes is constructed with quite another object than to let the form of the body be recognized. The silent adjustments to understand colloquial language are enormously complicated.\",\"str\":\"\"},{\"label\":\"4.003\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":3,\"x_axis\":57,\"ger\":\"Die meisten Sätze und Fragen, welche über philosophische Dinge geschrieben worden sind, sind nicht falsch, sondern unsinnig. Wir können daher Fragen dieser Art überhaupt nicht beantworten, sondern nur ihre Unsinnigkeit feststellen. Die meisten Fragen und Sätze der Philosophen beruhen darauf, dass wir unsere Sprachlogik nicht verstehen. (Sie sind von der Art der Frage, ob das Gute mehr oder weniger identisch sei als das Schöne.) Und es ist nicht verwunderlich, dass die tiefsten Probleme eigentlich <em class=\\\"germph\\\">keine</em> Probleme sind.\",\"pmc\":\"Most of the propositions and questions to be found in philosophical works are not false but nonsensical. Consequently we cannot give any answer to questions of this kind, but can only point out that they are nonsensical. Most of the propositions and questions of philosophers arise from our failure to understand the logic of our language. (They belong to the same class as the question whether the good is more or less identical than the beautiful.) And it is not surprising that the deepest problems are in fact <em>not</em> problems at all.\",\"ogd\":\"Most propositions and questions, that have been written about philosophical matters, are not false, but senseless. We cannot, therefore, answer questions of this kind at all, but only state their senselessness. Most questions and propositions of the philosophers result from the fact that we do not understand the logic of our language. (They are of the same kind as the question whether the Good is more or less identical than the Beautiful.) And so it is not to be wondered at that the deepest problems are really <em>no</em> problems.\",\"str\":\"\"},{\"label\":\"5.01\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":3,\"x_axis\":77,\"ger\":\"Die Elementarsätze sind die Wahrheitsargumente des Satzes.\",\"pmc\":\"Elementary propositions are the truth-arguments of propositions.\",\"ogd\":\"The elementary propositions are the truth-arguments of propositions.\",\"str\":\"\"},{\"label\":\"5.02\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":3,\"x_axis\":79,\"ger\":\"Es liegt nahe, die Argumente von Funktionen mit den Indices von Namen zu verwechseln. Ich erkenne nämlich sowohl am Argument wie am Index die Bedeutung des sie enthaltenden Zeichens. In Russells „<span class=\\\"mathmode\\\"><span class=\\\"mathrel\\\">+</span><sub><var>c</var></sub></span>“ ist z. B. „<span class=\\\"mathmode\\\"><sub><var>c</var></sub></span>“ ein Index, der darauf hinweist, dass das ganze Zeichen das Additionszeichen für Kardinalzahlen ist. Aber diese Bezeichnung beruht auf willkürlicher Übereinkunft und man könnte statt „<span class=\\\"mathmode\\\"><span class=\\\"mathrel\\\">+</span><sub><var>c</var></sub></span>“ auch ein einfaches Zeichen wählen; in „<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><var>p</var></span>“ aber ist „<span class=\\\"mathmode\\\"><var>p</var></span>“ kein Index, sondern ein Argument: der Sinn von „<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><var>p</var></span>“ <em class=\\\"germph\\\">kann nicht</em> verstanden werden, ohne dass vorher der Sinn von „<span class=\\\"mathmode\\\"><var>p</var></span>“ verstanden worden wäre. (Im Namen Julius Cäsar ist „Julius“ ein Index. Der Index ist immer ein Teil einer Beschreibung des Gegenstandes, dessen Namen wir ihn anhängen. Z. B. <em class=\\\"germph\\\">der</em> Cäsar aus dem Geschlechte der Julier.) Die Verwechslung von Argument und Index liegt, wenn ich mich nicht irre, der Theorie Freges von der Bedeutung der Sätze und Funktionen zugrunde. Für Frege waren die Sätze der Logik Namen, und deren Argumente die Indices dieser Namen.\",\"pmc\":\"The arguments of functions are readily confused with the affixes of names. For both arguments and affixes enable me to recognize the meaning of the signs containing them. For example, when Russell writes ‘<span class=\\\"mathmode\\\"><span class=\\\"mathrel\\\">+</span><sub><var>c</var></sub></span>’, the ‘<span class=\\\"mathmode\\\"><sub><var>c</var></sub></span>’ is an affix which indicates that the sign as a whole is the addition-sign for cardinal numbers. But the use of this sign is the result of arbitrary convention and it would be quite possible to choose a simple sign instead of ‘<span class=\\\"mathmode\\\"><span class=\\\"mathrel\\\">+</span><sub><var>c</var></sub></span>’; in ‘<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><var>p</var></span>’, however, ‘<span class=\\\"mathmode\\\"><var>p</var></span>’ is not an affix but an argument: the sense of ‘<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><var>p</var></span>’ <em>cannot</em> be understood unless the sense of ‘<span class=\\\"mathmode\\\"><var>p</var></span>’ has been understood already. (In the name Julius Caesar ‘Julius’ is an affix. An affix is always part of a description of the object to whose name we attach it: e.g. <em>the</em> Caesar of the Julian gens.) If I am not mistaken, Frege’s theory about the meaning of propositions and functions is based on the confusion between an argument and an affix. Frege regarded the propositions of logic as names, and their arguments as the affixes of those names.\",\"ogd\":\"It is natural to confuse the arguments of functions with the indices of names. For I recognize the meaning of the sign containing it from the argument just as much as from the index. In Russell’s “<span class=\\\"mathmode\\\"><span class=\\\"mathrel\\\">+</span><sub><var>c</var></sub></span>”, for example, “<span class=\\\"mathmode\\\"><sub><var>c</var></sub></span>” is an index which indicates that the whole sign is the addition sign for cardinal numbers. But this way of symbolizing depends on arbitrary agreement, and one could choose a simple sign instead of “<span class=\\\"mathmode\\\"><span class=\\\"mathrel\\\">+</span><sub><var>c</var></sub></span>”: but in “<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><var>p</var></span>” “<span class=\\\"mathmode\\\"><var>p</var></span>” is not an index but an argument; the sense of “<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><var>p</var></span>” <em>cannot</em> be understood, unless the sense of “<span class=\\\"mathmode\\\"><var>p</var></span>” has previously been understood. (In the name Julius Cæsar, Julius is an index. The index is always part of a description of the object to whose name we attach it, <em>e.g.</em> <em>The</em> Cæsar of the Julian gens.) The confusion of argument and index is, if I am not mistaken, at the root of Frege’s theory of the meaning of propositions and functions. For Frege the propositions of logic were names and their arguments the indices of these names.\",\"str\":\"\"},{\"label\":\"6.001\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":3,\"x_axis\":109,\"ger\":\"Dies sagt nichts anderes, als dass jeder Satz ein Resultat der successiven Anwendung der Operation <span class=\\\"mathmode\\\"><span class=\\\"mathop\\\"><span class=\\\"nop\\\">N</span>’</span>(<span class=\\\"overlined\\\"><var>ξ</var></span>)</span> auf die Elementarsätze ist.\",\"pmc\":\"What this says is just that every proposition is a result of successive applications to elementary propositions of the operation <span class=\\\"mathmode\\\"><span class=\\\"nop\\\">N</span>(<span class=\\\"overlined\\\"><var>ξ</var></span>)</span>.\",\"ogd\":\"This says nothing else than that every proposition is the result of successive applications of the operation <span class=\\\"mathmode\\\"><span class=\\\"mathop\\\"><span class=\\\"nop\\\">N</span>’</span>(<span class=\\\"overlined\\\"><var>ξ</var></span>)</span> to the elementary propositions.\",\"str\":\"\"},{\"label\":\"6.002\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":3,\"x_axis\":111,\"ger\":\"Ist die allgemeine Form gegeben, wie ein Satz gebaut ist, so ist damit auch schon die allgemeine Form davon gegeben, wie aus einem Satz durch eine Operation ein anderer erzeugt werden kann.\",\"pmc\":\"If we are given the general form according to which propositions are constructed, then with it we are also given the general form according to which one proposition can be generated out of another by means of an operation.\",\"ogd\":\"If we are given the general form of the way in which a proposition is constructed, then thereby we are also given the general form of the way in which by an operation out of one proposition another can be created.\",\"str\":\"\"},{\"label\":\"1.2\",\"precision\":1,\"fontSize\":\"40px\",\"y_axis\":5,\"x_axis\":1,\"ger\":\"Die Welt zerfällt in Tatsachen.\",\"pmc\":\"The world divides into facts.\",\"ogd\":\"The world divides into facts.\",\"str\":\"\"},{\"label\":\"1.21\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":5,\"x_axis\":3,\"ger\":\"Eines kann der Fall sein oder nicht der Fall sein und alles übrige gleich bleiben.\",\"pmc\":\"Each item can be the case or not the case while everything else remains the same.\",\"ogd\":\"Any one can either be the case or not be the case, and everything else remain the same.\",\"str\":\"\"},{\"label\":\"2.011\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":5,\"x_axis\":11,\"ger\":\"Es ist dem Ding wesentlich, der Bestandteil eines Sachverhaltes sein zu können.\",\"pmc\":\"It is essential to things that they should be possible constituents of states of affairs.\",\"ogd\":\"It is essential to a thing that it can be a constituent part of an atomic fact.\",\"str\":\"\"},{\"label\":\"2.0121\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":7,\"x_axis\":13,\"ger\":\"Es erschiene gleichsam als Zufall, wenn dem Ding, das allein für sich bestehen könnte, nachträglich eine Sachlage passen würde. Wenn die Dinge in Sachverhalten vorkommen können, so muss dies schon in ihnen liegen. (Etwas Logisches kann nicht nur-möglich sein. Die Logik handelt von jeder Möglichkeit und alle Möglichkeiten sind ihre Tatsachen.) Wie wir uns räumliche Gegenstände überhaupt nicht außerhalb des Raumes, zeitliche nicht außerhalb der Zeit denken können, so können wir uns <em class=\\\"germph\\\">keinen</em> Gegenstand außerhalb der Möglichkeit seiner Verbindung mit anderen denken. Wenn ich mir den Gegenstand im Verbande des Sachverhalts denken kann, so kann ich ihn nicht außerhalb der <em class=\\\"germph\\\">Möglichkeit</em> dieses Verbandes denken.\",\"pmc\":\"It would seem to be a sort of accident, if it turned out that a situation would fit a thing that could already exist entirely on its own. If things can occur in states of affairs, this possibility must be in them from the beginning. (Nothing in the province of logic can be merely possible. Logic deals with every possibility and all possibilities are its facts.) Just as we are quite unable to imagine spatial objects outside space or temporal objects outside time, so too there is <em>no</em> object that we can imagine excluded from the possibility of combining with others. If I can imagine objects combined in states of affairs, I cannot imagine them excluded from the possibility of such combinations.\",\"ogd\":\"It would, so to speak, appear as an accident, when to a thing that could exist alone on its own account, subsequently a state of affairs could be made to fit. If things can occur in atomic facts, this possibility must already lie in them. (A logical entity cannot be merely possible. Logic treats of every possibility, and all possibilities are its facts.) Just as we cannot think of spatial objects at all apart from space, or temporal objects apart from time, so we cannot think of <em>any</em> object apart from the possibility of its connexion with other things. If I can think of an object in the context of an atomic fact, I cannot think of it apart from the <em>possibility</em> of this context.\",\"str\":\"\"},{\"label\":\"2.0122\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":7,\"x_axis\":15,\"ger\":\"Das Ding ist selbständig, insofern es in allen <em class=\\\"germph\\\">möglichen</em> Sachlagen vorkommen kann, aber diese Form der Selbständigkeit ist eine Form des Zusammenhangs mit dem Sachverhalt, eine Form der Unselbständigkeit. (Es ist unmöglich, dass Worte in zwei verschiedenen Weisen auftreten, allein und im Satz.)\",\"pmc\":\"Things are independent in so far as they can occur in all <em>possible</em> situations, but this form of independence is a form of connexion with states of affairs, a form of dependence. (It is impossible for words to appear in two different roles: by themselves, and in propositions.)\",\"ogd\":\"The thing is independent, in so far as it can occur in all <em>possible</em> circumstances, but this form of independence is a form of connexion with the atomic fact, a form of dependence. (It is impossible for words to occur in two different ways, alone and in the proposition.)\",\"str\":\"\"},{\"label\":\"2.0123\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":7,\"x_axis\":17,\"ger\":\"Wenn ich den Gegenstand kenne, so kenne ich auch sämtliche Möglichkeiten seines Vorkommens in Sachverhalten. (Jede solche Möglichkeit muss in der Natur des Gegenstandes liegen.) Es kann nicht nachträglich eine neue Möglichkeit gefunden werden.\",\"pmc\":\"If I know an object I also know all its possible occurrences in states of affairs. (Every one of these possibilities must be part of the nature of the object.) A new possibility cannot be discovered later.\",\"ogd\":\"If I know an object, then I also know all the possibilities of its occurrence in atomic facts. (Every such possibility must lie in the nature of the object.) A new possibility cannot subsequently be found.\",\"str\":\"\"},{\"label\":\"2.0124\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":7,\"x_axis\":19,\"ger\":\"Sind alle Gegenstände gegeben, so sind damit auch alle <em class=\\\"germph\\\">möglichen</em> Sachverhalte gegeben.\",\"pmc\":\"If all objects are given, then at the same time all <em>possible</em> states of affairs are also given.\",\"ogd\":\"If all objects are given, then thereby are all <em>possible</em> atomic facts also given.\",\"str\":\"\"},{\"label\":\"2.0201\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":5,\"x_axis\":23,\"ger\":\"Jede Aussage über Komplexe lässt sich in eine Aussage über deren Bestandteile und in diejenigen Sätze zerlegen, welche die Komplexe vollständig beschreiben.\",\"pmc\":\"Every statement about complexes can be resolved into a statement about their constituents and into the propositions that describe the complexes completely.\",\"ogd\":\"Every statement about complexes can be analysed into a statement about their constituent parts, and into those propositions which completely describe the complexes.\",\"str\":\"\"},{\"label\":\"2.031\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":5,\"x_axis\":29,\"ger\":\"Im Sachverhalt verhalten sich die Gegenstände in bestimmter Art und Weise zueinander.\",\"pmc\":\"In a state of affairs objects stand in a determinate relation to one another.\",\"ogd\":\"In the atomic fact the objects are combined in a definite way.\",\"str\":\"\"},{\"label\":\"2.061\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":5,\"x_axis\":35,\"ger\":\"Die Sachverhalte sind von einander unabhängig.\",\"pmc\":\"States of affairs are independent of one another.\",\"ogd\":\"Atomic facts are independent of one another.\",\"str\":\"\"},{\"label\":\"3.01\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":5,\"x_axis\":39,\"ger\":\"Die Gesamtheit der wahren Gedanken sind ein Bild der Welt.\",\"pmc\":\"The totality of true thoughts is a picture of the world.\",\"ogd\":\"The totality of true thoughts is a picture of the world.\",\"str\":\"\"},{\"label\":\"3.02\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":5,\"x_axis\":41,\"ger\":\"Der Gedanke enthält die Möglichkeit der Sachlage, die er denkt. Was denkbar ist, ist auch möglich.\",\"pmc\":\"A thought contains the possibility of the situation of which it is the thought. What is thinkable is possible too.\",\"ogd\":\"The thought contains the possibility of the state of affairs which it thinks. What is thinkable is also possible.\",\"str\":\"\"},{\"label\":\"3.03\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":5,\"x_axis\":43,\"ger\":\"Wir können nichts Unlogisches denken, weil wir sonst unlogisch denken müssten.\",\"pmc\":\"Thought can never be of anything illogical, since, if it were, we should have to think illogically.\",\"ogd\":\"We cannot think anything unlogical, for otherwise we should have to think unlogically.\",\"str\":\"\"},{\"label\":\"3.04\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":5,\"x_axis\":45,\"ger\":\"Ein a priori richtiger Gedanke wäre ein solcher, dessen Möglichkeit seine Wahrheit bedingte.\",\"pmc\":\"If a thought were correct <em>a priori</em>, it would be a thought whose possibility ensured its truth.\",\"ogd\":\"An a priori true thought would be one whose possibility guaranteed its truth.\",\"str\":\"\"},{\"label\":\"3.05\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":5,\"x_axis\":47,\"ger\":\"Nur so könnten wir a priori wissen, dass ein Gedanke wahr ist, wenn aus dem Gedanken selbst (ohne Vergleichsobjekt) seine Wahrheit zu erkennen wäre.\",\"pmc\":\"<em>A priori</em> knowledge that a thought was true would be possible only if its truth were recognizable from the thought itself (without anything to compare it with).\",\"ogd\":\"Only if we could know a priori that a thought is true if its truth was to be recognized from the thought itself (without an object of comparison).\",\"str\":\"\"},{\"label\":\"4.0031\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":5,\"x_axis\":57,\"ger\":\"Alle Philosophie ist „Sprachkritik“. (Allerdings nicht im Sinne Mauthners.) Russells Verdienst ist es, gezeigt zu haben, dass die scheinbare logische Form des Satzes nicht seine wirkliche sein muss.\",\"pmc\":\"All philosophy is a ‘critique of language’ (though not in Mauthner’s sense). It was Russell who performed the service of showing that the apparent logical form of a proposition need not be its real one.\",\"ogd\":\"All philosophy is “Critique of language” (but not at all in Mauthner’s sense). Russell’s merit is to have shown that the apparent logical form of the proposition need not be its real form.\",\"str\":\"\"},{\"label\":\"5.1\",\"precision\":1,\"fontSize\":\"40px\",\"y_axis\":5,\"x_axis\":75,\"ger\":\"Die Wahrheitsfunktionen lassen sich in Reihen ordnen. Das ist die Grundlage der Wahrscheinlichkeitslehre.\",\"pmc\":\"Truth-functions can be arranged in series. That is the foundation of the theory of probability.\",\"ogd\":\"The truth-functions can be ordered in series. That is the foundation of the theory of probability.\",\"str\":\"\"},{\"label\":\"5.101\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":5,\"x_axis\":77,\"ger\":\"Die Wahrheitsfunktionen jeder Anzahl von Elementarsätzen lassen sich in einem Schema folgender Art hinschreiben: <!-- noindent --><table class=\\\"fnlist\\\"><tr><td class=\\\"righttight\\\" >(</td><td class=\\\"centertight\\\" >W</td><td class=\\\"centertight\\\" >W</td><td class=\\\"centertight\\\" >W</td><td class=\\\"centertight\\\" >W</td><td class=\\\"lefttight\\\" >)</td><td class=\\\"leftcell\\\" ><span class=\\\"mathmode\\\">(<var>p</var>,&nbsp;<var>q</var>)</span>&nbsp;&nbsp;</td><td class=\\\"leftcell\\\" >Tautologie&nbsp;</td><td >(Wenn <span class=\\\"mathmode\\\"><var>p</var></span>, so <span class=\\\"mathmode\\\"><var>p</var></span>; und wenn <span class=\\\"mathmode\\\"><var>q</var></span>, so <span class=\\\"mathmode\\\"><var>q</var></span>.) &nbsp;&nbsp; <span class=\\\"mathmode\\\">(<var>p</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">⊃</span></span><var>p</var><span class=\\\"mathrel\\\">.</span><var>q</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">⊃</span></span><var>q</var>)</span></td> </tr><tr><td class=\\\"righttight\\\" >(</td><td class=\\\"centertight\\\" >F</td><td class=\\\"centertight\\\" >W</td><td class=\\\"centertight\\\" >W</td><td class=\\\"centertight\\\" >W</td><td class=\\\"lefttight\\\" >)</td><td class=\\\"leftcell\\\" ><span class=\\\"mathmode\\\">(<var>p</var>,&nbsp;<var>q</var>)</span>&nbsp;&nbsp;</td><td class=\\\"leftcell\\\" >in&nbsp;Worten:&nbsp;</td><td >Nicht beides <span class=\\\"mathmode\\\"><var>p</var></span> und <span class=\\\"mathmode\\\"><var>q</var></span>. &nbsp;&nbsp; <span class=\\\"mathmode\\\">(<span class=\\\"mathop\\\">~</span>(<var>p</var><span class=\\\"mathrel\\\">.</span><var>q</var>))</span></td> </tr><tr><td class=\\\"righttight\\\" >(</td><td class=\\\"centertight\\\" >W</td><td class=\\\"centertight\\\" >F</td><td class=\\\"centertight\\\" >W</td><td class=\\\"centertight\\\" >W</td><td class=\\\"lefttight\\\" >)</td><td class=\\\"leftcell\\\" ><span class=\\\"mathmode\\\">(<var>p</var>,&nbsp;<var>q</var>)</span>&nbsp;&nbsp;</td><td class=\\\"leftcell\\\" >&nbsp;”&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;”</td><td >Wenn <span class=\\\"mathmode\\\"><var>q</var></span>, so <span class=\\\"mathmode\\\"><var>p</var></span>. &nbsp;&nbsp; <span class=\\\"mathmode\\\">(<var>q</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">⊃</span></span><var>p</var>)</span></td> </tr><tr><td class=\\\"righttight\\\" >(</td><td class=\\\"centertight\\\" >W</td><td class=\\\"centertight\\\" >W</td><td class=\\\"centertight\\\" >F</td><td class=\\\"centertight\\\" >W</td><td class=\\\"lefttight\\\" >)</td><td class=\\\"leftcell\\\" ><span class=\\\"mathmode\\\">(<var>p</var>,&nbsp;<var>q</var>)</span>&nbsp;&nbsp;</td><td class=\\\"leftcell\\\" >&nbsp;”&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;”</td><td >Wenn <span class=\\\"mathmode\\\"><var>p</var></span>, so <span class=\\\"mathmode\\\"><var>q</var></span>. &nbsp;&nbsp; <span class=\\\"mathmode\\\">(<var>p</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">⊃</span></span><var>q</var>)</span></td> </tr><tr><td class=\\\"righttight\\\" >(</td><td class=\\\"centertight\\\" >W</td><td class=\\\"centertight\\\" >W</td><td class=\\\"centertight\\\" >W</td><td class=\\\"centertight\\\" >F</td><td class=\\\"lefttight\\\" >)</td><td class=\\\"leftcell\\\" ><span class=\\\"mathmode\\\">(<var>p</var>,&nbsp;<var>q</var>)</span>&nbsp;&nbsp;</td><td class=\\\"leftcell\\\" >&nbsp;”&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;”</td><td ><span class=\\\"mathmode\\\"><var>p</var></span> oder <span class=\\\"mathmode\\\"><var>q</var></span>. &nbsp;&nbsp; <span class=\\\"mathmode\\\">(<var>p</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">∨</span></span><var>q</var>)</span></td> </tr><tr><td class=\\\"righttight\\\" >(</td><td class=\\\"centertight\\\" >F</td><td class=\\\"centertight\\\" >F</td><td class=\\\"centertight\\\" >W</td><td class=\\\"centertight\\\" >W</td><td class=\\\"lefttight\\\" >)</td><td class=\\\"leftcell\\\" ><span class=\\\"mathmode\\\">(<var>p</var>,&nbsp;<var>q</var>)</span>&nbsp;&nbsp;</td><td class=\\\"leftcell\\\" >&nbsp;”&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;”</td><td >Nicht <span class=\\\"mathmode\\\"><var>q</var></span>.  &nbsp;&nbsp; <span class=\\\"mathmode\\\">(<span class=\\\"mathop\\\">~</span><var>q</var>)</span></td> </tr><tr><td class=\\\"righttight\\\" >(</td><td class=\\\"centertight\\\" >F</td><td class=\\\"centertight\\\" >W</td><td class=\\\"centertight\\\" >F</td><td class=\\\"centertight\\\" >W</td><td class=\\\"lefttight\\\" >)</td><td class=\\\"leftcell\\\" ><span class=\\\"mathmode\\\">(<var>p</var>,&nbsp;<var>q</var>)</span>&nbsp;&nbsp;</td><td class=\\\"leftcell\\\" >&nbsp;”&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;”</td><td >Nicht <span class=\\\"mathmode\\\"><var>p</var></span>.  &nbsp;&nbsp; <span class=\\\"mathmode\\\">(<span class=\\\"mathop\\\">~</span><var>p</var>)</span></td> </tr><tr><td class=\\\"righttight\\\" >(</td><td class=\\\"centertight\\\" >F</td><td class=\\\"centertight\\\" >W</td><td class=\\\"centertight\\\" >W</td><td class=\\\"centertight\\\" >F</td><td class=\\\"lefttight\\\" >)</td><td class=\\\"leftcell\\\" ><span class=\\\"mathmode\\\">(<var>p</var>,&nbsp;<var>q</var>)</span>&nbsp;&nbsp;</td><td class=\\\"leftcell\\\" >&nbsp;”&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;”</td><td ><span class=\\\"mathmode\\\"><var>p</var></span>, oder <span class=\\\"mathmode\\\"><var>q</var></span>, aber nicht beide.  &nbsp;&nbsp; <span class=\\\"mathmode\\\">(<var>p</var><span class=\\\"mathrel\\\">.</span><span class=\\\"mathop\\\">~</span><var>q</var><span class=\\\"mathrel\\\">:<span class=\\\"symbol\\\">∨</span>:</span><var>q</var><span class=\\\"mathrel\\\">.</span><span class=\\\"mathop\\\">~</span><var>p</var>)</span></td> </tr><tr><td class=\\\"righttight\\\" >(</td><td class=\\\"centertight\\\" >W</td><td class=\\\"centertight\\\" >F</td><td class=\\\"centertight\\\" >F</td><td class=\\\"centertight\\\" >W</td><td class=\\\"lefttight\\\" >)</td><td class=\\\"leftcell\\\" ><span class=\\\"mathmode\\\">(<var>p</var>,&nbsp;<var>q</var>)</span>&nbsp;&nbsp;</td><td class=\\\"leftcell\\\" >&nbsp;”&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;”</td><td >Wenn <span class=\\\"mathmode\\\"><var>p</var></span>, so <span class=\\\"mathmode\\\"><var>q</var></span>; und wenn <span class=\\\"mathmode\\\"><var>q</var></span>, so <span class=\\\"mathmode\\\"><var>p</var></span>.  &nbsp;&nbsp; <span class=\\\"mathmode\\\">(<var>p</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">≡</span></span><var>q</var>)</span></td> </tr><tr><td class=\\\"righttight\\\" >(</td><td class=\\\"centertight\\\" >W</td><td class=\\\"centertight\\\" >F</td><td class=\\\"centertight\\\" >W</td><td class=\\\"centertight\\\" >F</td><td class=\\\"lefttight\\\" >)</td><td class=\\\"leftcell\\\" ><span class=\\\"mathmode\\\">(<var>p</var>,&nbsp;<var>q</var>)</span>&nbsp;&nbsp;</td><td class=\\\"leftcell\\\" >&nbsp;”&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;”</td><td ><span class=\\\"mathmode\\\"><var>p</var></span></td> </tr><tr><td class=\\\"righttight\\\" >(</td><td class=\\\"centertight\\\" >W</td><td class=\\\"centertight\\\" >W</td><td class=\\\"centertight\\\" >F</td><td class=\\\"centertight\\\" >F</td><td class=\\\"lefttight\\\" >)</td><td class=\\\"leftcell\\\" ><span class=\\\"mathmode\\\">(<var>p</var>,&nbsp;<var>q</var>)</span>&nbsp;&nbsp;</td><td class=\\\"leftcell\\\" >&nbsp;”&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;”</td><td ><span class=\\\"mathmode\\\"><var>q</var></span></td> </tr><tr><td class=\\\"righttight\\\" >(</td><td class=\\\"centertight\\\" >F</td><td class=\\\"centertight\\\" >F</td><td class=\\\"centertight\\\" >F</td><td class=\\\"centertight\\\" >W</td><td class=\\\"lefttight\\\" >)</td><td class=\\\"leftcell\\\" ><span class=\\\"mathmode\\\">(<var>p</var>,&nbsp;<var>q</var>)</span>&nbsp;&nbsp;</td><td class=\\\"leftcell\\\" >&nbsp;”&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;”</td><td >Weder <span class=\\\"mathmode\\\"><var>p</var></span> noch <span class=\\\"mathmode\\\"><var>q</var></span>.  &nbsp;&nbsp; <span class=\\\"mathmode\\\">(<span class=\\\"mathop\\\">~</span><var>p</var><span class=\\\"mathrel\\\">.</span><span class=\\\"mathop\\\">~</span><var>q</var>)</span> oder <span class=\\\"mathmode\\\">(<var>p</var><span class=\\\"mathrel\\\">|</span><var>q</var>)</span></td></tr> <tr><td class=\\\"righttight\\\" >(</td><td class=\\\"centertight\\\" >F</td><td class=\\\"centertight\\\" >F</td><td class=\\\"centertight\\\" >W</td><td class=\\\"centertight\\\" >F</td><td class=\\\"lefttight\\\" >)</td><td class=\\\"leftcell\\\" ><span class=\\\"mathmode\\\">(<var>p</var>,&nbsp;<var>q</var>)</span>&nbsp;&nbsp;</td><td class=\\\"leftcell\\\" >&nbsp;”&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;”</td><td ><span class=\\\"mathmode\\\"><var>p</var></span> und nicht <span class=\\\"mathmode\\\"><var>q</var></span>.  &nbsp;&nbsp; <span class=\\\"mathmode\\\">(<var>p</var><span class=\\\"mathrel\\\">.</span><span class=\\\"mathop\\\">~</span><var>q</var>)</span></td> </tr><tr><td class=\\\"righttight\\\" >(</td><td class=\\\"centertight\\\" >F</td><td class=\\\"centertight\\\" >W</td><td class=\\\"centertight\\\" >F</td><td class=\\\"centertight\\\" >F</td><td class=\\\"lefttight\\\" >)</td><td class=\\\"leftcell\\\" ><span class=\\\"mathmode\\\">(<var>p</var>,&nbsp;<var>q</var>)</span>&nbsp;&nbsp;</td><td class=\\\"leftcell\\\" >&nbsp;”&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;”</td><td ><span class=\\\"mathmode\\\"><var>q</var></span> und nicht <span class=\\\"mathmode\\\"><var>p</var></span>.  &nbsp;&nbsp; <span class=\\\"mathmode\\\">(<var>q</var><span class=\\\"mathrel\\\">.</span><span class=\\\"mathop\\\">~</span><var>p</var>)</span></td> </tr><tr><td class=\\\"righttight\\\" >(</td><td class=\\\"centertight\\\" >W</td><td class=\\\"centertight\\\" >F</td><td class=\\\"centertight\\\" >F</td><td class=\\\"centertight\\\" >F</td><td class=\\\"lefttight\\\" >)</td><td class=\\\"leftcell\\\" ><span class=\\\"mathmode\\\">(<var>p</var>,&nbsp;<var>q</var>)</span>&nbsp;&nbsp;</td><td class=\\\"leftcell\\\" >&nbsp;”&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;”</td><td ><span class=\\\"mathmode\\\"><var>q</var></span> und <span class=\\\"mathmode\\\"><var>p</var></span>.  &nbsp;&nbsp; <span class=\\\"mathmode\\\">(<var>q</var><span class=\\\"mathrel\\\">.</span><var>p</var>)</span></td> </tr><tr><td class=\\\"righttight\\\" >(</td><td class=\\\"centertight\\\" >F</td><td class=\\\"centertight\\\" >F</td><td class=\\\"centertight\\\" >F</td><td class=\\\"centertight\\\" >F</td><td class=\\\"lefttight\\\" >)</td><td class=\\\"leftcell\\\" ><span class=\\\"mathmode\\\">(<var>p</var>,&nbsp;<var>q</var>)</span>&nbsp;&nbsp;</td><td class=\\\"leftcell\\\"  colspan=\\\"2\\\">Kontradiktion (<span class=\\\"mathmode\\\"><var>p</var></span> und nicht <span class=\\\"mathmode\\\"><var>p</var></span>; und <span class=\\\"mathmode\\\"><var>q</var></span> und nicht <span class=\\\"mathmode\\\"><var>q</var></span>.)  &nbsp;&nbsp; <span class=\\\"mathmode\\\">(<var>p</var><span class=\\\"mathrel\\\">.</span><span class=\\\"mathop\\\">~</span><var>p</var><span class=\\\"mathrel\\\">.</span><var>q</var><span class=\\\"mathrel\\\">.</span><span class=\\\"mathop\\\">~</span><var>q</var>)</span></td></tr></table> Diejenigen Wahrheitsmöglichkeiten seiner Wahrheitsargumente, welche den Satz bewahrheiten, will ich seine <em class=\\\"germph\\\">Wahrheitsgründe</em> nennen.\",\"pmc\":\"The truth-functions of a given number of elementary propositions can always be set out in a schema of the following kind: <!-- noindent --><table class=\\\"fnlist\\\"> <tr><td class=\\\"righttight\\\" >(</td><td class=\\\"centertight\\\" >T</td><td class=\\\"centertight\\\" >T</td><td class=\\\"centertight\\\" >T</td><td class=\\\"centertight\\\" >T</td><td class=\\\"lefttight\\\" >)</td><td class=\\\"leftcell\\\" ><span class=\\\"mathmode\\\">(<var>p</var>,&nbsp;<var>q</var>)</span>&nbsp;&nbsp;</td><td class=\\\"leftcell\\\" >Tautology&nbsp;</td><td >(If <span class=\\\"mathmode\\\"><var>p</var></span> then <span class=\\\"mathmode\\\"><var>p</var></span>; and if <span class=\\\"mathmode\\\"><var>q</var></span> then <span class=\\\"mathmode\\\"><var>q</var></span>.) &nbsp;&nbsp; <span class=\\\"mathmode\\\">(<var>p</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">⊃</span></span><var>p</var><span class=\\\"mathrel\\\">.</span><var>q</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">⊃</span></span><var>q</var>)</span></td> </tr> <tr><td class=\\\"righttight\\\" >(</td><td class=\\\"centertight\\\" >F</td><td class=\\\"centertight\\\" >T</td><td class=\\\"centertight\\\" >T</td><td class=\\\"centertight\\\" >T</td><td class=\\\"lefttight\\\" >)</td><td class=\\\"leftcell\\\" ><span class=\\\"mathmode\\\">(<var>p</var>,&nbsp;<var>q</var>)</span>&nbsp;&nbsp;</td><td class=\\\"leftcell\\\" >In&nbsp;words:&nbsp;</td><td >Not both <span class=\\\"mathmode\\\"><var>p</var></span> and <span class=\\\"mathmode\\\"><var>q</var></span>. &nbsp;&nbsp; <span class=\\\"mathmode\\\">(<span class=\\\"mathop\\\">~</span>(<var>p</var><span class=\\\"mathrel\\\">.</span><var>q</var>))</span></td> </tr> <tr><td class=\\\"righttight\\\" >(</td><td class=\\\"centertight\\\" >T</td><td class=\\\"centertight\\\" >F</td><td class=\\\"centertight\\\" >T</td><td class=\\\"centertight\\\" >T</td><td class=\\\"lefttight\\\" >)</td><td class=\\\"leftcell\\\" ><span class=\\\"mathmode\\\">(<var>p</var>,&nbsp;<var>q</var>)</span>&nbsp;&nbsp;</td><td class=\\\"leftcell\\\" >&nbsp;”&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;”&nbsp;&nbsp;&nbsp;:</td><td >If <span class=\\\"mathmode\\\"><var>q</var></span> then <span class=\\\"mathmode\\\"><var>p</var></span>. &nbsp;&nbsp; <span class=\\\"mathmode\\\">(<var>q</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">⊃</span></span><var>p</var>)</span></td> </tr> <tr><td class=\\\"righttight\\\" >(</td><td class=\\\"centertight\\\" >T</td><td class=\\\"centertight\\\" >T</td><td class=\\\"centertight\\\" >F</td><td class=\\\"centertight\\\" >T</td><td class=\\\"lefttight\\\" >)</td><td class=\\\"leftcell\\\" ><span class=\\\"mathmode\\\">(<var>p</var>,&nbsp;<var>q</var>)</span>&nbsp;&nbsp;</td><td class=\\\"leftcell\\\" >&nbsp;”&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;”&nbsp;&nbsp;&nbsp;:</td><td >If <span class=\\\"mathmode\\\"><var>p</var></span> then <span class=\\\"mathmode\\\"><var>q</var></span>. &nbsp;&nbsp; <span class=\\\"mathmode\\\">(<var>p</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">⊃</span></span><var>q</var>)</span></td> </tr> <tr><td class=\\\"righttight\\\" >(</td><td class=\\\"centertight\\\" >T</td><td class=\\\"centertight\\\" >T</td><td class=\\\"centertight\\\" >T</td><td class=\\\"centertight\\\" >F</td><td class=\\\"lefttight\\\" >)</td><td class=\\\"leftcell\\\" ><span class=\\\"mathmode\\\">(<var>p</var>,&nbsp;<var>q</var>)</span>&nbsp;&nbsp;</td><td class=\\\"leftcell\\\" >&nbsp;”&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;”&nbsp;&nbsp;&nbsp;:</td><td ><span class=\\\"mathmode\\\"><var>p</var></span> or <span class=\\\"mathmode\\\"><var>q</var></span>. &nbsp;&nbsp; <span class=\\\"mathmode\\\">(<var>p</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">∨</span></span><var>q</var>)</span></td> </tr> <tr><td class=\\\"righttight\\\" >(</td><td class=\\\"centertight\\\" >F</td><td class=\\\"centertight\\\" >F</td><td class=\\\"centertight\\\" >T</td><td class=\\\"centertight\\\" >T</td><td class=\\\"lefttight\\\" >)</td><td class=\\\"leftcell\\\" ><span class=\\\"mathmode\\\">(<var>p</var>,&nbsp;<var>q</var>)</span>&nbsp;&nbsp;</td><td class=\\\"leftcell\\\" >&nbsp;”&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;”&nbsp;&nbsp;&nbsp;:</td><td >Not <span class=\\\"mathmode\\\"><var>q</var></span>.  &nbsp;&nbsp; <span class=\\\"mathmode\\\">(<span class=\\\"mathop\\\">~</span><var>q</var>)</span></td> </tr> <tr><td class=\\\"righttight\\\" >(</td><td class=\\\"centertight\\\" >F</td><td class=\\\"centertight\\\" >T</td><td class=\\\"centertight\\\" >F</td><td class=\\\"centertight\\\" >T</td><td class=\\\"lefttight\\\" >)</td><td class=\\\"leftcell\\\" ><span class=\\\"mathmode\\\">(<var>p</var>,&nbsp;<var>q</var>)</span>&nbsp;&nbsp;</td><td class=\\\"leftcell\\\" >&nbsp;”&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;”&nbsp;&nbsp;&nbsp;:</td><td >Not <span class=\\\"mathmode\\\"><var>p</var></span>.  &nbsp;&nbsp; <span class=\\\"mathmode\\\">(<span class=\\\"mathop\\\">~</span><var>p</var>)</span></td> </tr> <tr><td class=\\\"righttight\\\" >(</td><td class=\\\"centertight\\\" >F</td><td class=\\\"centertight\\\" >T</td><td class=\\\"centertight\\\" >T</td><td class=\\\"centertight\\\" >F</td><td class=\\\"lefttight\\\" >)</td><td class=\\\"leftcell\\\" ><span class=\\\"mathmode\\\">(<var>p</var>,&nbsp;<var>q</var>)</span>&nbsp;&nbsp;</td><td class=\\\"leftcell\\\" >&nbsp;”&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;”&nbsp;&nbsp;&nbsp;:</td><td ><span class=\\\"mathmode\\\"><var>p</var></span> or <span class=\\\"mathmode\\\"><var>q</var></span>, but not both.  &nbsp;&nbsp; <span class=\\\"mathmode\\\">(<var>p</var><span class=\\\"mathrel\\\">.</span><span class=\\\"mathop\\\">~</span><var>q</var><span class=\\\"mathrel\\\">:<span class=\\\"symbol\\\">∨</span>:</span><var>q</var><span class=\\\"mathrel\\\">.</span><span class=\\\"mathop\\\">~</span><var>p</var>)</span></td> </tr> <tr><td class=\\\"righttight\\\" >(</td><td class=\\\"centertight\\\" >T</td><td class=\\\"centertight\\\" >F</td><td class=\\\"centertight\\\" >F</td><td class=\\\"centertight\\\" >T</td><td class=\\\"lefttight\\\" >)</td><td class=\\\"leftcell\\\" ><span class=\\\"mathmode\\\">(<var>p</var>,&nbsp;<var>q</var>)</span>&nbsp;&nbsp;</td><td class=\\\"leftcell\\\" >&nbsp;”&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;”&nbsp;&nbsp;&nbsp;:</td><td >If <span class=\\\"mathmode\\\"><var>p</var></span> then <span class=\\\"mathmode\\\"><var>q</var></span>, and if <span class=\\\"mathmode\\\"><var>q</var></span> then <span class=\\\"mathmode\\\"><var>p</var></span>.  &nbsp;&nbsp; <span class=\\\"mathmode\\\">(<var>p</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">≡</span></span><var>q</var>)</span></td> </tr> <tr><td class=\\\"righttight\\\" >(</td><td class=\\\"centertight\\\" >T</td><td class=\\\"centertight\\\" >F</td><td class=\\\"centertight\\\" >T</td><td class=\\\"centertight\\\" >F</td><td class=\\\"lefttight\\\" >)</td><td class=\\\"leftcell\\\" ><span class=\\\"mathmode\\\">(<var>p</var>,&nbsp;<var>q</var>)</span>&nbsp;&nbsp;</td><td class=\\\"leftcell\\\" >&nbsp;”&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;”&nbsp;&nbsp;&nbsp;:</td><td ><span class=\\\"mathmode\\\"><var>p</var></span></td> </tr> <tr><td class=\\\"righttight\\\" >(</td><td class=\\\"centertight\\\" >T</td><td class=\\\"centertight\\\" >T</td><td class=\\\"centertight\\\" >F</td><td class=\\\"centertight\\\" >F</td><td class=\\\"lefttight\\\" >)</td><td class=\\\"leftcell\\\" ><span class=\\\"mathmode\\\">(<var>p</var>,&nbsp;<var>q</var>)</span>&nbsp;&nbsp;</td><td class=\\\"leftcell\\\" >&nbsp;”&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;”&nbsp;&nbsp;&nbsp;:</td><td ><span class=\\\"mathmode\\\"><var>q</var></span></td> </tr> <tr><td class=\\\"righttight\\\" >(</td><td class=\\\"centertight\\\" >F</td><td class=\\\"centertight\\\" >F</td><td class=\\\"centertight\\\" >F</td><td class=\\\"centertight\\\" >T</td><td class=\\\"lefttight\\\" >)</td><td class=\\\"leftcell\\\" ><span class=\\\"mathmode\\\">(<var>p</var>,&nbsp;<var>q</var>)</span>&nbsp;&nbsp;</td><td class=\\\"leftcell\\\" >&nbsp;”&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;”&nbsp;&nbsp;&nbsp;:</td><td >Neither <span class=\\\"mathmode\\\"><var>p</var></span> nor <span class=\\\"mathmode\\\"><var>q</var></span>.  &nbsp;&nbsp; <span class=\\\"mathmode\\\">(<span class=\\\"mathop\\\">~</span><var>p</var><span class=\\\"mathrel\\\">.</span><span class=\\\"mathop\\\">~</span><var>q</var></span> or <span class=\\\"mathmode\\\"><var>p</var><span class=\\\"mathrel\\\">|</span><var>q</var>)</span></td></tr> <tr><td class=\\\"righttight\\\" >(</td><td class=\\\"centertight\\\" >F</td><td class=\\\"centertight\\\" >F</td><td class=\\\"centertight\\\" >T</td><td class=\\\"centertight\\\" >F</td><td class=\\\"lefttight\\\" >)</td><td class=\\\"leftcell\\\" ><span class=\\\"mathmode\\\">(<var>p</var>,&nbsp;<var>q</var>)</span>&nbsp;&nbsp;</td><td class=\\\"leftcell\\\" >&nbsp;”&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;”&nbsp;&nbsp;&nbsp;:</td><td ><span class=\\\"mathmode\\\"><var>p</var></span> and not <span class=\\\"mathmode\\\"><var>q</var></span>.  &nbsp;&nbsp; <span class=\\\"mathmode\\\">(<var>p</var><span class=\\\"mathrel\\\">.</span><span class=\\\"mathop\\\">~</span><var>q</var>)</span></td> </tr> <tr><td class=\\\"righttight\\\" >(</td><td class=\\\"centertight\\\" >F</td><td class=\\\"centertight\\\" >T</td><td class=\\\"centertight\\\" >F</td><td class=\\\"centertight\\\" >F</td><td class=\\\"lefttight\\\" >)</td><td class=\\\"leftcell\\\" ><span class=\\\"mathmode\\\">(<var>p</var>,&nbsp;<var>q</var>)</span>&nbsp;&nbsp;</td><td class=\\\"leftcell\\\" >&nbsp;”&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;”&nbsp;&nbsp;&nbsp;:</td><td ><span class=\\\"mathmode\\\"><var>q</var></span> and not <span class=\\\"mathmode\\\"><var>p</var></span>.  &nbsp;&nbsp; <span class=\\\"mathmode\\\">(<var>q</var><span class=\\\"mathrel\\\">.</span><span class=\\\"mathop\\\">~</span><var>p</var>)</span></td> </tr> <tr><td class=\\\"righttight\\\" >(</td><td class=\\\"centertight\\\" >T</td><td class=\\\"centertight\\\" >F</td><td class=\\\"centertight\\\" >F</td><td class=\\\"centertight\\\" >F</td><td class=\\\"lefttight\\\" >)</td><td class=\\\"leftcell\\\" ><span class=\\\"mathmode\\\">(<var>p</var>,&nbsp;<var>q</var>)</span>&nbsp;&nbsp;</td><td class=\\\"leftcell\\\" >&nbsp;”&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;”&nbsp;&nbsp;&nbsp;:</td><td ><span class=\\\"mathmode\\\"><var>q</var></span> and <span class=\\\"mathmode\\\"><var>p</var></span>.  &nbsp;&nbsp; <span class=\\\"mathmode\\\">(<var>q</var><span class=\\\"mathrel\\\">.</span><var>p</var>)</span></td> </tr> <tr><td class=\\\"righttight\\\" >(</td><td class=\\\"centertight\\\" >F</td><td class=\\\"centertight\\\" >F</td><td class=\\\"centertight\\\" >F</td><td class=\\\"centertight\\\" >F</td><td class=\\\"lefttight\\\" >)</td><td class=\\\"leftcell\\\" ><span class=\\\"mathmode\\\">(<var>p</var>,&nbsp;<var>q</var>)</span>&nbsp;&nbsp;</td><td class=\\\"leftcell\\\"  colspan=\\\"2\\\">Contradiction (<span class=\\\"mathmode\\\"><var>p</var></span> and not <span class=\\\"mathmode\\\"><var>p</var></span>, and <span class=\\\"mathmode\\\"><var>q</var></span> and not <span class=\\\"mathmode\\\"><var>q</var></span>.)  &nbsp;&nbsp; <span class=\\\"mathmode\\\">(<var>p</var><span class=\\\"mathrel\\\">.</span><span class=\\\"mathop\\\">~</span><var>p</var><span class=\\\"mathrel\\\">.</span><var>q</var><span class=\\\"mathrel\\\">.</span><span class=\\\"mathop\\\">~</span><var>q</var>)</span></td></tr></table> I will give the name <em>truth-grounds</em> of a proposition to those truth-possibilities of its truth-arguments that make it true.\",\"ogd\":\"The truth-functions of every number of elementary propositions can be written in a schema of the following kind: <!-- noindent --><table class=\\\"fnlist\\\"> <tr><td class=\\\"righttight\\\" >(</td><td class=\\\"centertight\\\" >T</td><td class=\\\"centertight\\\" >T</td><td class=\\\"centertight\\\" >T</td><td class=\\\"centertight\\\" >T</td><td class=\\\"lefttight\\\" >)</td><td class=\\\"leftcell\\\" ><span class=\\\"mathmode\\\">(<var>p</var>,&nbsp;<var>q</var>)</span>&nbsp;&nbsp;</td><td class=\\\"leftcell\\\" >Tautology&nbsp;</td><td >(if <span class=\\\"mathmode\\\"><var>p</var></span> then <span class=\\\"mathmode\\\"><var>p</var></span>; and if <span class=\\\"mathmode\\\"><var>q</var></span> then <span class=\\\"mathmode\\\"><var>q</var></span>) &nbsp;&nbsp; <span class=\\\"mathmode\\\">[<var>p</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">⊃</span></span><var>p</var><span class=\\\"mathrel\\\">.</span><var>q</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">⊃</span></span><var>q</var>]</span></td> </tr> <tr><td class=\\\"righttight\\\" >(</td><td class=\\\"centertight\\\" >F</td><td class=\\\"centertight\\\" >T</td><td class=\\\"centertight\\\" >T</td><td class=\\\"centertight\\\" >T</td><td class=\\\"lefttight\\\" >)</td><td class=\\\"leftcell\\\" ><span class=\\\"mathmode\\\">(<var>p</var>,&nbsp;<var>q</var>)</span>&nbsp;&nbsp;</td><td class=\\\"leftcell\\\" >in&nbsp;words:&nbsp;</td><td >Not both <span class=\\\"mathmode\\\"><var>p</var></span> and <span class=\\\"mathmode\\\"><var>q</var></span>. &nbsp;&nbsp; <span class=\\\"mathmode\\\">[<span class=\\\"mathop\\\">~</span>(<var>p</var><span class=\\\"mathrel\\\">.</span><var>q</var>)]</span></td> </tr> <tr><td class=\\\"righttight\\\" >(</td><td class=\\\"centertight\\\" >T</td><td class=\\\"centertight\\\" >F</td><td class=\\\"centertight\\\" >T</td><td class=\\\"centertight\\\" >T</td><td class=\\\"lefttight\\\" >)</td><td class=\\\"leftcell\\\" ><span class=\\\"mathmode\\\">(<var>p</var>,&nbsp;<var>q</var>)</span>&nbsp;&nbsp;</td><td class=\\\"leftcell\\\" >&nbsp;”&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;”</td><td >If <span class=\\\"mathmode\\\"><var>q</var></span> then <span class=\\\"mathmode\\\"><var>p</var></span>. &nbsp;&nbsp; <span class=\\\"mathmode\\\">[<var>q</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">⊃</span></span><var>p</var>]</span></td> </tr> <tr><td class=\\\"righttight\\\" >(</td><td class=\\\"centertight\\\" >T</td><td class=\\\"centertight\\\" >T</td><td class=\\\"centertight\\\" >F</td><td class=\\\"centertight\\\" >T</td><td class=\\\"lefttight\\\" >)</td><td class=\\\"leftcell\\\" ><span class=\\\"mathmode\\\">(<var>p</var>,&nbsp;<var>q</var>)</span>&nbsp;&nbsp;</td><td class=\\\"leftcell\\\" >&nbsp;”&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;”</td><td >If <span class=\\\"mathmode\\\"><var>p</var></span> then <span class=\\\"mathmode\\\"><var>q</var></span>. &nbsp;&nbsp; <span class=\\\"mathmode\\\">[<var>p</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">⊃</span></span><var>q</var>]</span></td> </tr> <tr><td class=\\\"righttight\\\" >(</td><td class=\\\"centertight\\\" >T</td><td class=\\\"centertight\\\" >T</td><td class=\\\"centertight\\\" >T</td><td class=\\\"centertight\\\" >F</td><td class=\\\"lefttight\\\" >)</td><td class=\\\"leftcell\\\" ><span class=\\\"mathmode\\\">(<var>p</var>,&nbsp;<var>q</var>)</span>&nbsp;&nbsp;</td><td class=\\\"leftcell\\\" >&nbsp;”&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;”</td><td ><span class=\\\"mathmode\\\"><var>p</var></span> or <span class=\\\"mathmode\\\"><var>q</var></span>. &nbsp;&nbsp; <span class=\\\"mathmode\\\">[<var>p</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">∨</span></span><var>q</var>]</span></td> </tr> <tr><td class=\\\"righttight\\\" >(</td><td class=\\\"centertight\\\" >F</td><td class=\\\"centertight\\\" >F</td><td class=\\\"centertight\\\" >T</td><td class=\\\"centertight\\\" >T</td><td class=\\\"lefttight\\\" >)</td><td class=\\\"leftcell\\\" ><span class=\\\"mathmode\\\">(<var>p</var>,&nbsp;<var>q</var>)</span>&nbsp;&nbsp;</td><td class=\\\"leftcell\\\" >&nbsp;”&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;”</td><td >Not <span class=\\\"mathmode\\\"><var>q</var></span>.  &nbsp;&nbsp; <span class=\\\"mathmode\\\">[<span class=\\\"mathop\\\">~</span><var>q</var>]</span></td> </tr> <tr><td class=\\\"righttight\\\" >(</td><td class=\\\"centertight\\\" >F</td><td class=\\\"centertight\\\" >T</td><td class=\\\"centertight\\\" >F</td><td class=\\\"centertight\\\" >T</td><td class=\\\"lefttight\\\" >)</td><td class=\\\"leftcell\\\" ><span class=\\\"mathmode\\\">(<var>p</var>,&nbsp;<var>q</var>)</span>&nbsp;&nbsp;</td><td class=\\\"leftcell\\\" >&nbsp;”&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;”</td><td >Not <span class=\\\"mathmode\\\"><var>p</var></span>.  &nbsp;&nbsp; <span class=\\\"mathmode\\\">[<span class=\\\"mathop\\\">~</span><var>p</var>]</span></td> </tr> <tr><td class=\\\"righttight\\\" >(</td><td class=\\\"centertight\\\" >F</td><td class=\\\"centertight\\\" >T</td><td class=\\\"centertight\\\" >T</td><td class=\\\"centertight\\\" >F</td><td class=\\\"lefttight\\\" >)</td><td class=\\\"leftcell\\\" ><span class=\\\"mathmode\\\">(<var>p</var>,&nbsp;<var>q</var>)</span>&nbsp;&nbsp;</td><td class=\\\"leftcell\\\" >&nbsp;”&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;”</td><td ><span class=\\\"mathmode\\\"><var>p</var></span> or <span class=\\\"mathmode\\\"><var>q</var></span>, but not both.  &nbsp;&nbsp; <span class=\\\"mathmode\\\">[<var>p</var><span class=\\\"mathrel\\\">.</span><span class=\\\"mathop\\\">~</span><var>q</var><span class=\\\"mathrel\\\">:<span class=\\\"symbol\\\">∨</span>:</span><var>q</var><span class=\\\"mathrel\\\">.</span><span class=\\\"mathop\\\">~</span><var>p</var>]</span></td> </tr> <tr><td class=\\\"righttight\\\" >(</td><td class=\\\"centertight\\\" >T</td><td class=\\\"centertight\\\" >F</td><td class=\\\"centertight\\\" >F</td><td class=\\\"centertight\\\" >T</td><td class=\\\"lefttight\\\" >)</td><td class=\\\"leftcell\\\" ><span class=\\\"mathmode\\\">(<var>p</var>,&nbsp;<var>q</var>)</span>&nbsp;&nbsp;</td><td class=\\\"leftcell\\\" >&nbsp;”&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;”</td><td >If <span class=\\\"mathmode\\\"><var>p</var></span>, then <span class=\\\"mathmode\\\"><var>q</var></span>; and if <span class=\\\"mathmode\\\"><var>q</var></span>, then <span class=\\\"mathmode\\\"><var>p</var></span>.  &nbsp;&nbsp; <span class=\\\"mathmode\\\">[<var>p</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">≡</span></span><var>q</var>]</span></td> </tr> <tr><td class=\\\"righttight\\\" >(</td><td class=\\\"centertight\\\" >T</td><td class=\\\"centertight\\\" >F</td><td class=\\\"centertight\\\" >T</td><td class=\\\"centertight\\\" >F</td><td class=\\\"lefttight\\\" >)</td><td class=\\\"leftcell\\\" ><span class=\\\"mathmode\\\">(<var>p</var>,&nbsp;<var>q</var>)</span>&nbsp;&nbsp;</td><td class=\\\"leftcell\\\" >&nbsp;”&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;”</td><td ><span class=\\\"mathmode\\\"><var>p</var></span></td> </tr> <tr><td class=\\\"righttight\\\" >(</td><td class=\\\"centertight\\\" >T</td><td class=\\\"centertight\\\" >T</td><td class=\\\"centertight\\\" >F</td><td class=\\\"centertight\\\" >F</td><td class=\\\"lefttight\\\" >)</td><td class=\\\"leftcell\\\" ><span class=\\\"mathmode\\\">(<var>p</var>,&nbsp;<var>q</var>)</span>&nbsp;&nbsp;</td><td class=\\\"leftcell\\\" >&nbsp;”&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;”</td><td ><span class=\\\"mathmode\\\"><var>q</var></span></td> </tr> <tr><td class=\\\"righttight\\\" >(</td><td class=\\\"centertight\\\" >F</td><td class=\\\"centertight\\\" >F</td><td class=\\\"centertight\\\" >F</td><td class=\\\"centertight\\\" >T</td><td class=\\\"lefttight\\\" >)</td><td class=\\\"leftcell\\\" ><span class=\\\"mathmode\\\">(<var>p</var>,&nbsp;<var>q</var>)</span>&nbsp;&nbsp;</td><td class=\\\"leftcell\\\" >&nbsp;”&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;”</td><td >Neither <span class=\\\"mathmode\\\"><var>p</var></span> nor <span class=\\\"mathmode\\\"><var>q</var></span>.  &nbsp;&nbsp; <span class=\\\"mathmode\\\">[<span class=\\\"mathop\\\">~</span><var>p</var><span class=\\\"mathrel\\\">.</span><span class=\\\"mathop\\\">~</span><var>q</var></span> or <span class=\\\"mathmode\\\"><var>p</var><span class=\\\"mathrel\\\">|</span><var>q</var>]</span></td></tr> <tr><td class=\\\"righttight\\\" >(</td><td class=\\\"centertight\\\" >F</td><td class=\\\"centertight\\\" >F</td><td class=\\\"centertight\\\" >T</td><td class=\\\"centertight\\\" >F</td><td class=\\\"lefttight\\\" >)</td><td class=\\\"leftcell\\\" ><span class=\\\"mathmode\\\">(<var>p</var>,&nbsp;<var>q</var>)</span>&nbsp;&nbsp;</td><td class=\\\"leftcell\\\" >&nbsp;”&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;”</td><td ><span class=\\\"mathmode\\\"><var>p</var></span> and not <span class=\\\"mathmode\\\"><var>q</var></span>.  &nbsp;&nbsp; <span class=\\\"mathmode\\\">[<var>p</var><span class=\\\"mathrel\\\">.</span><span class=\\\"mathop\\\">~</span><var>q</var>]</span></td> </tr> <tr><td class=\\\"righttight\\\" >(</td><td class=\\\"centertight\\\" >F</td><td class=\\\"centertight\\\" >T</td><td class=\\\"centertight\\\" >F</td><td class=\\\"centertight\\\" >F</td><td class=\\\"lefttight\\\" >)</td><td class=\\\"leftcell\\\" ><span class=\\\"mathmode\\\">(<var>p</var>,&nbsp;<var>q</var>)</span>&nbsp;&nbsp;</td><td class=\\\"leftcell\\\" >&nbsp;”&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;”</td><td ><span class=\\\"mathmode\\\"><var>q</var></span> and not <span class=\\\"mathmode\\\"><var>p</var></span>.  &nbsp;&nbsp; <span class=\\\"mathmode\\\">[<var>q</var><span class=\\\"mathrel\\\">.</span><span class=\\\"mathop\\\">~</span><var>p</var>]</span></td> </tr> <tr><td class=\\\"righttight\\\" >(</td><td class=\\\"centertight\\\" >T</td><td class=\\\"centertight\\\" >F</td><td class=\\\"centertight\\\" >F</td><td class=\\\"centertight\\\" >F</td><td class=\\\"lefttight\\\" >)</td><td class=\\\"leftcell\\\" ><span class=\\\"mathmode\\\">(<var>p</var>,&nbsp;<var>q</var>)</span>&nbsp;&nbsp;</td><td class=\\\"leftcell\\\" >&nbsp;”&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;”</td><td ><span class=\\\"mathmode\\\"><var>p</var></span> and <span class=\\\"mathmode\\\"><var>q</var></span>.  &nbsp;&nbsp; <span class=\\\"mathmode\\\">[<var>p</var><span class=\\\"mathrel\\\">.</span><var>q</var>]</span></td> </tr> <tr><td class=\\\"righttight\\\" >(</td><td class=\\\"centertight\\\" >F</td><td class=\\\"centertight\\\" >F</td><td class=\\\"centertight\\\" >F</td><td class=\\\"centertight\\\" >F</td><td class=\\\"lefttight\\\" >)</td><td class=\\\"leftcell\\\" ><span class=\\\"mathmode\\\">(<var>p</var>,&nbsp;<var>q</var>)</span>&nbsp;&nbsp;</td><td class=\\\"leftcell\\\"  colspan=\\\"2\\\">Contradiction (<span class=\\\"mathmode\\\"><var>p</var></span> and not <span class=\\\"mathmode\\\"><var>p</var></span>; and <span class=\\\"mathmode\\\"><var>q</var></span> and not <span class=\\\"mathmode\\\"><var>q</var></span>.)  &nbsp;&nbsp; <span class=\\\"mathmode\\\">[<var>p</var><span class=\\\"mathrel\\\">.</span><span class=\\\"mathop\\\">~</span><var>p</var><span class=\\\"mathrel\\\">.</span><var>q</var><span class=\\\"mathrel\\\">.</span><span class=\\\"mathop\\\">~</span><var>q</var>]</span></td></tr></table> Those truth-possibilities of its truth-arguments, which verify the proposition, I shall call its <em>truth-grounds</em>.\",\"str\":\"\"},{\"label\":\"6.01\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":5,\"x_axis\":109,\"ger\":\"Die allgemeine Form der Operation <span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">Ω’</span>(<span class=\\\"overlined\\\"><var>η</var></span>)</span> ist also: <span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">[<span class=\\\"overlined\\\"><var>ξ</var></span>, <span class=\\\"nop\\\">N</span>(<span class=\\\"overlined\\\"><var>ξ</var></span>)]’</span> (<span class=\\\"overlined\\\"><var>η</var></span>) (<span class=\\\"mathrel\\\">=</span>[<span class=\\\"overlined\\\"><var>η</var></span>, <span class=\\\"overlined\\\"><var>ξ</var></span>, <span class=\\\"nop\\\">N</span>(<span class=\\\"overlined\\\"><var>ξ</var></span>)])</span>. Das ist die allgemeinste Form des Überganges von einem Satz zum anderen.\",\"pmc\":\"Therefore the general form of an operation <span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">Ω’</span>(<span class=\\\"overlined\\\"><var>η</var></span>)</span> is <span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">[<span class=\\\"overlined\\\"><var>ξ</var></span>, <span class=\\\"nop\\\">N</span>(<span class=\\\"overlined\\\"><var>ξ</var></span>)]’</span> (<span class=\\\"overlined\\\"><var>η</var></span>) (<span class=\\\"mathrel\\\">=</span>[<span class=\\\"overlined\\\"><var>η</var></span>, <span class=\\\"overlined\\\"><var>ξ</var></span>, <span class=\\\"nop\\\">N</span>(<span class=\\\"overlined\\\"><var>ξ</var></span>)])</span>. This is the most general form of transition from one proposition to another.\",\"ogd\":\"The general form of the operation <span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">Ω’</span>(<span class=\\\"overlined\\\"><var>η</var></span>)</span> is therefore: <span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">[<span class=\\\"overlined\\\"><var>ξ</var></span>, <span class=\\\"nop\\\">N</span>(<span class=\\\"overlined\\\"><var>ξ</var></span>)]’</span> (<span class=\\\"overlined\\\"><var>η</var></span>) (<span class=\\\"mathrel\\\">=</span>[<span class=\\\"overlined\\\"><var>η</var></span>, <span class=\\\"overlined\\\"><var>ξ</var></span>, <span class=\\\"nop\\\">N</span>(<span class=\\\"overlined\\\"><var>ξ</var></span>)])</span>. This is the most general form of transition from one proposition to another.\",\"str\":\"\"},{\"label\":\"6.02\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":5,\"x_axis\":111,\"ger\":\"Und <em class=\\\"germph\\\">so</em> kommen wir zu den Zahlen: Ich definiere <div class=\\\"centered\\\"><table class=\\\"alignedmath\\\"><tr><td class=\\\"righttight\\\"><span class=\\\"mathmode\\\"><var>x</var><span class=\\\"mathrel\\\">=</span></span></td><td class=\\\"lefttight\\\"><span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">Ω<sup>0</sup>’</span><var>x</var></span>&nbsp;&nbsp;Def. und</td></tr><tr><td class=\\\"righttight\\\"><span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">Ω’</span><span class=\\\"mathop\\\">Ω<sup><var>ν</var></sup>’</span><var>x</var><span class=\\\"mathrel\\\">=</span></span></td><td class=\\\"lefttight\\\"><span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">Ω<sup><var>ν</var>+1</sup>’</span><var>x</var></span>&nbsp;&nbsp;Def.</td></tr></table></div> Nach diesen Zeichenregeln schreiben wir also die Reihe <div class=\\\"centered\\\"><span class=\\\"mathmode\\\"><var>x</var>, <span class=\\\"mathop\\\">Ω’</span><var>x</var>, <span class=\\\"mathop\\\">Ω’</span><span class=\\\"mathop\\\">Ω’</span><var>x</var>, <span class=\\\"mathop\\\">Ω’</span><span class=\\\"mathop\\\">Ω’</span><span class=\\\"mathop\\\">Ω’</span><var>x</var>,<span class=\\\"mathrel\\\">…</span></span></div><span class=\\\"mathmode\\\"></span> so: <div class=\\\"centered\\\"><span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">Ω<sup>0</sup>’</span><var>x</var>, <span class=\\\"mathop\\\">Ω<sup>0<span class=\\\"mathrel\\\">+</span>1</sup>’</span><var>x</var>, <span class=\\\"mathop\\\">Ω<sup>0<span class=\\\"mathrel\\\">+</span>1<span class=\\\"mathrel\\\">+</span>1</sup>’</span><var>x</var>, <span class=\\\"mathop\\\">Ω<sup>0<span class=\\\"mathrel\\\">+</span>1<span class=\\\"mathrel\\\">+</span>1<span class=\\\"mathrel\\\">+</span>1</sup>’</span><var>x</var>,<span class=\\\"mathrel\\\">…</span></span></div><span class=\\\"mathmode\\\"></span> Also schreibe ich statt „<span class=\\\"mathmode\\\">[<var>x</var>, <var>ξ</var>, <span class=\\\"mathop\\\">Ω’</span><var>ξ</var>]</span>“: <div class=\\\"centered\\\"><span class=\\\"mathmode\\\">„[<span class=\\\"mathop\\\">Ω<sup>0</sup>’</span><var>x</var>, <span class=\\\"mathop\\\">Ω<sup><var>ν</var></sup>’</span><var>x</var>, <span class=\\\"mathop\\\">Ω<sup><var>ν</var><span class=\\\"mathrel\\\">+</span>1</sup>’</span><var>x</var>]“.</span></div><span class=\\\"mathmode\\\"></span> Und definiere: <div class=\\\"centered\\\"><table class=\\\"alignedmath\\\"><tr><td class=\\\"lefttight\\\"><span class=\\\"mathmode\\\">0<span class=\\\"mathrel\\\">+</span>1<span class=\\\"mathrel\\\">=</span>1</span>&nbsp;&nbsp;Def.</td></tr><tr><td class=\\\"lefttight\\\"><span class=\\\"mathmode\\\">0<span class=\\\"mathrel\\\">+</span>1<span class=\\\"mathrel\\\">+</span>1<span class=\\\"mathrel\\\">=</span>2</span>&nbsp;&nbsp;Def.</td></tr><tr><td class=\\\"lefttight\\\"><span class=\\\"mathmode\\\">0<span class=\\\"mathrel\\\">+</span>1<span class=\\\"mathrel\\\">+</span>1<span class=\\\"mathrel\\\">+</span>1<span class=\\\"mathrel\\\">=</span>3</span>&nbsp;&nbsp;Def.</td></tr><tr><td class=\\\"lefttight\\\">(u. s. f.)</td></tr></table></div>\",\"pmc\":\"And <em>this</em> is how we arrive at numbers. I give the following definitions <div class=\\\"centered\\\"><table class=\\\"alignedmath\\\"><tr><td class=\\\"righttight\\\"><span class=\\\"mathmode\\\"><var>x</var><span class=\\\"mathrel\\\">=</span></span></td><td class=\\\"lefttight\\\"><span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">Ω<sup>0</sup>’</span><var>x</var></span>&nbsp;&nbsp;Def.,</td></tr><tr><td class=\\\"righttight\\\"><span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">Ω’</span><span class=\\\"mathop\\\">Ω<sup><var>ν</var></sup>’</span><var>x</var><span class=\\\"mathrel\\\">=</span></span></td><td class=\\\"lefttight\\\"><span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">Ω<sup><var>ν</var>+1</sup>’</span><var>x</var></span>&nbsp;&nbsp;Def.</td></tr></table></div> So, in accordance with these rules, which deal with signs, we write the series <div class=\\\"centered\\\"><span class=\\\"mathmode\\\"><var>x</var>, <span class=\\\"mathop\\\">Ω’</span><var>x</var>, <span class=\\\"mathop\\\">Ω’</span><span class=\\\"mathop\\\">Ω’</span><var>x</var>, <span class=\\\"mathop\\\">Ω’</span><span class=\\\"mathop\\\">Ω’</span><span class=\\\"mathop\\\">Ω’</span><var>x</var>,<span class=\\\"mathrel\\\">…</span></span></div><span class=\\\"mathmode\\\"></span> in the following way <div class=\\\"centered\\\"><span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">Ω<sup>0</sup>’</span><var>x</var>, <span class=\\\"mathop\\\">Ω<sup>0<span class=\\\"mathrel\\\">+</span>1</sup>’</span><var>x</var>, <span class=\\\"mathop\\\">Ω<sup>0<span class=\\\"mathrel\\\">+</span>1<span class=\\\"mathrel\\\">+</span>1</sup>’</span><var>x</var>, <span class=\\\"mathop\\\">Ω<sup>0<span class=\\\"mathrel\\\">+</span>1<span class=\\\"mathrel\\\">+</span>1<span class=\\\"mathrel\\\">+</span>1</sup>’</span><var>x</var>,<span class=\\\"mathrel\\\">…</span></span></div><span class=\\\"mathmode\\\"></span> Therefore, instead of ‘<span class=\\\"mathmode\\\">[<var>x</var>, <var>ξ</var>, <span class=\\\"mathop\\\">Ω’</span><var>ξ</var>]</span>’, <div class=\\\"centered\\\"><span class=\\\"mathmode\\\"><span class=\\\"mathrm\\\">I write</span>  &nbsp; ‘[<span class=\\\"mathop\\\">Ω<sup>0</sup>’</span><var>x</var>, <span class=\\\"mathop\\\">Ω<sup><var>ν</var></sup>’</span><var>x</var>, <span class=\\\"mathop\\\">Ω<sup><var>ν</var><span class=\\\"mathrel\\\">+</span>1</sup>’</span><var>x</var>]’.</span></div><span class=\\\"mathmode\\\"></span> And I give the following definitions <div class=\\\"centered\\\"><table class=\\\"alignedmath\\\"><tr><td class=\\\"righttight\\\"><span class=\\\"mathmode\\\">0<span class=\\\"mathrel\\\">+</span>1<span class=\\\"mathrel\\\">=</span></span></td><td class=\\\"lefttight\\\"><span class=\\\"mathmode\\\">1</span>&nbsp;&nbsp;Def.,</td></tr><tr><td class=\\\"righttight\\\"><span class=\\\"mathmode\\\">0<span class=\\\"mathrel\\\">+</span>1<span class=\\\"mathrel\\\">+</span>1<span class=\\\"mathrel\\\">=</span></span></td><td class=\\\"lefttight\\\"><span class=\\\"mathmode\\\">2</span>&nbsp;&nbsp;Def.,</td></tr><tr><td class=\\\"righttight\\\"><span class=\\\"mathmode\\\">0<span class=\\\"mathrel\\\">+</span>1<span class=\\\"mathrel\\\">+</span>1<span class=\\\"mathrel\\\">+</span>1<span class=\\\"mathrel\\\">=</span></span></td><td class=\\\"lefttight\\\"><span class=\\\"mathmode\\\">3</span>&nbsp;&nbsp;Def.,</td></tr><tr><td class=\\\"centertight\\\" colspan=\\\"2\\\">(and so on).</td></tr></table></div>\",\"ogd\":\"And thus we come to numbers: I define <div class=\\\"centered\\\"><table class=\\\"alignedmath\\\"><tr><td class=\\\"righttight\\\"><span class=\\\"mathmode\\\"><var>x</var><span class=\\\"mathrel\\\">=</span></span></td><td class=\\\"lefttight\\\"><span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">Ω<sup>0</sup>’</span><var>x</var></span>&nbsp;&nbsp;Def. and</td></tr><tr><td class=\\\"righttight\\\"><span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">Ω’</span><span class=\\\"mathop\\\">Ω<sup><var>ν</var></sup>’</span><var>x</var><span class=\\\"mathrel\\\">=</span></span></td><td class=\\\"lefttight\\\"><span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">Ω<sup><var>ν</var>+1</sup>’</span><var>x</var></span>&nbsp;&nbsp;Def.</td></tr></table></div> According, then, to these symbolic rules we write the series <div class=\\\"centered\\\"><span class=\\\"mathmode\\\"><var>x</var>, <span class=\\\"mathop\\\">Ω’</span><var>x</var>, <span class=\\\"mathop\\\">Ω’</span><span class=\\\"mathop\\\">Ω’</span><var>x</var>, <span class=\\\"mathop\\\">Ω’</span><span class=\\\"mathop\\\">Ω’</span><span class=\\\"mathop\\\">Ω’</span><var>x</var>,<span class=\\\"mathrel\\\">…</span></span></div><span class=\\\"mathmode\\\"></span> as: <div class=\\\"centered\\\"><span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">Ω<sup>0</sup>’</span><var>x</var>, <span class=\\\"mathop\\\">Ω<sup>0<span class=\\\"mathrel\\\">+</span>1</sup>’</span><var>x</var>, <span class=\\\"mathop\\\">Ω<sup>0<span class=\\\"mathrel\\\">+</span>1<span class=\\\"mathrel\\\">+</span>1</sup>’</span><var>x</var>, <span class=\\\"mathop\\\">Ω<sup>0<span class=\\\"mathrel\\\">+</span>1<span class=\\\"mathrel\\\">+</span>1<span class=\\\"mathrel\\\">+</span>1</sup>’</span><var>x</var>,<span class=\\\"mathrel\\\">…</span></span></div><span class=\\\"mathmode\\\"></span> Therefore I write in place of “<span class=\\\"mathmode\\\">[<var>x</var>, <var>ξ</var>,</span> <span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">Ω’</span><var>ξ</var>]</span>”, <div class=\\\"centered\\\"><span class=\\\"mathmode\\\">“[<span class=\\\"mathop\\\">Ω<sup>0</sup>’</span><var>x</var>, <span class=\\\"mathop\\\">Ω<sup><var>ν</var></sup>’</span><var>x</var>, <span class=\\\"mathop\\\">Ω<sup><var>ν</var><span class=\\\"mathrel\\\">+</span>1</sup>’</span><var>x</var>]”.</span></div><span class=\\\"mathmode\\\"></span> And I define: <div class=\\\"centered\\\"><table class=\\\"alignedmath\\\"><tr><td class=\\\"lefttight\\\"><span class=\\\"mathmode\\\">0<span class=\\\"mathrel\\\">+</span>1<span class=\\\"mathrel\\\">=</span>1</span>&nbsp;&nbsp;Def.</td></tr><tr><td class=\\\"lefttight\\\"><span class=\\\"mathmode\\\">0<span class=\\\"mathrel\\\">+</span>1<span class=\\\"mathrel\\\">+</span>1<span class=\\\"mathrel\\\">=</span>2</span>&nbsp;&nbsp;Def.</td></tr><tr><td class=\\\"lefttight\\\"><span class=\\\"mathmode\\\">0<span class=\\\"mathrel\\\">+</span>1<span class=\\\"mathrel\\\">+</span>1<span class=\\\"mathrel\\\">+</span>1<span class=\\\"mathrel\\\">=</span>3</span>&nbsp;&nbsp;Def.</td></tr><tr><td class=\\\"lefttight\\\">and so on.</td></tr></table></div>\",\"str\":\"\"},{\"label\":\"6.03\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":5,\"x_axis\":113,\"ger\":\"Die allgemeine Form der ganzen Zahl ist: <span class=\\\"mathmode\\\">[0, <var>ξ</var>, <var>ξ</var><span class=\\\"mathrel\\\">+</span>1]</span>.\",\"pmc\":\"The general form of an integer is <span class=\\\"mathmode\\\">[0, <var>ξ</var>, <var>ξ</var><span class=\\\"mathrel\\\">+</span>1]</span>.\",\"ogd\":\"The general form of the cardinal number is: <span class=\\\"mathmode\\\">[0, <var>ξ</var>, <var>ξ</var><span class=\\\"mathrel\\\">+</span>1]</span>.\",\"str\":\"\"},{\"label\":\"2.012\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":7,\"x_axis\":11,\"ger\":\"In der Logik ist nichts zufällig: Wenn das Ding im Sachverhalt vorkommen <em class=\\\"germph\\\">kann</em>, so muss die Möglichkeit des Sachverhaltes im Ding bereits präjudiziert sein.\",\"pmc\":\"In logic nothing is accidental: if a thing <em>can</em> occur in a state of affairs, the possibility of the state of affairs must be written into the thing itself.\",\"ogd\":\"In logic nothing is accidental: if a thing <em>can</em> occur in an atomic fact the possibility of that atomic fact must already be prejudged in the thing.\",\"str\":\"\"},{\"label\":\"2.01231\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":9,\"x_axis\":17,\"ger\":\"Um einen Gegenstand zu kennen, muss ich zwar nicht seine externen – aber ich muss alle seine internen Eigenschaften kennen.\",\"pmc\":\"If I am to know an object, though I need not know its external properties, I must know all its internal properties.\",\"ogd\":\"In order to know an object, I must know not its external but all its internal qualities.\",\"str\":\"\"},{\"label\":\"2.021\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":7,\"x_axis\":21,\"ger\":\"Die Gegenstände bilden die Substanz der Welt. Darum können sie nicht zusammengesetzt sein.\",\"pmc\":\"Objects make up the substance of the world. That is why they cannot be composite.\",\"ogd\":\"Objects form the substance of the world. Therefore they cannot be compound.\",\"str\":\"\"},{\"label\":\"2.0211\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":7,\"x_axis\":23,\"ger\":\"Hätte die Welt keine Substanz, so würde, ob ein Satz Sinn hat, davon abhängen, ob ein anderer Satz wahr ist.\",\"pmc\":\"If the world had no substance, then whether a proposition had sense would depend on whether another proposition was true.\",\"ogd\":\"If the world had no substance, then whether a proposition had sense would depend on whether another proposition was true.\",\"str\":\"\"},{\"label\":\"2.0212\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":7,\"x_axis\":25,\"ger\":\"Es wäre dann unmöglich, ein Bild der Welt (wahr oder falsch) zu entwerfen.\",\"pmc\":\"In that case we could not sketch any picture of the world (true or false).\",\"ogd\":\"It would then be impossible to form a picture of the world (true or false).\",\"str\":\"\"},{\"label\":\"2.032\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":7,\"x_axis\":29,\"ger\":\"Die Art und Weise, wie die Gegenstände im Sachverhalt zusammenhängen, ist die Struktur des Sachverhaltes.\",\"pmc\":\"The determinate way in which objects are connected in a state of affairs is the structure of the state of affairs.\",\"ogd\":\"The way in which objects hang together in the atomic fact is the structure of the atomic fact.\",\"str\":\"\"},{\"label\":\"2.062\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":7,\"x_axis\":35,\"ger\":\"Aus dem Bestehen oder Nichtbestehen eines Sachverhaltes kann nicht auf das Bestehen oder Nichtbestehen eines anderen geschlossen werden.\",\"pmc\":\"From the existence or non-existence of one state of affairs it is impossible to infer the existence or non-existence of another.\",\"ogd\":\"From the existence or non-existence of an atomic fact we cannot infer the existence or non-existence of another.\",\"str\":\"\"},{\"label\":\"3.031\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":7,\"x_axis\":43,\"ger\":\"Man sagte einmal, dass Gott alles schaffen könne, nur nichts, was den logischen Gesetzen zuwider wäre. – Wir können nämlich von einer „unlogischen“ Welt nicht <em class=\\\"germph\\\">sagen</em>, wie sie aussähe.\",\"pmc\":\"It used to be said that God could create anything except what would be contrary to the laws of logic. The truth is that we could not <em>say</em> what an ‘illogical’ world would look like.\",\"ogd\":\"It used to be said that God could create everything, except what was contrary to the laws of logic. The truth is, we could not <em>say</em> of an “unlogical” world how it would look.\",\"str\":\"\"},{\"label\":\"4.01\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":7,\"x_axis\":53,\"ger\":\"Der Satz ist ein Bild der Wirklichkeit. Der Satz ist ein Modell der Wirklichkeit, so wie wir sie uns denken.\",\"pmc\":\"A proposition is a picture of reality. A proposition is a model of reality as we imagine it.\",\"ogd\":\"The proposition is a picture of reality. The proposition is a model of the reality as we think it is.\",\"str\":\"\"},{\"label\":\"4.02\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":7,\"x_axis\":57,\"ger\":\"Dies sehen wir daraus, dass wir den Sinn des Satzzeichens verstehen, ohne dass er uns erklärt wurde.\",\"pmc\":\"We can see this from the fact that we understand the sense of a propositional sign without its having been explained to us.\",\"ogd\":\"This we see from the fact that we understand the sense of the propositional sign, without having had it explained to us.\",\"str\":\"\"},{\"label\":\"4.03\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":7,\"x_axis\":59,\"ger\":\"Ein Satz muss mit alten Ausdrücken einen neuen Sinn mitteilen. Der Satz teilt uns eine Sachlage mit, also muss er <em class=\\\"germph\\\">wesentlich</em> mit der Sachlage zusammenhängen. Und der Zusammenhang ist eben, dass er ihr logisches Bild ist. Der Satz sagt nur insoweit etwas aus, als er ein Bild ist.\",\"pmc\":\"A proposition must use old expressions to communicate a new sense. A proposition communicates a situation to us, and so it must be <em>essentially</em> connected with the situation. And the connexion is precisely that it is its logical picture. A proposition states something only in so far as it is a picture.\",\"ogd\":\"A proposition must communicate a new sense with old words. The proposition communicates to us a state of affairs, therefore it must be <em>essentially</em> connected with the state of affairs. And the connexion is, in fact, that it is its logical picture. The proposition only asserts something, in so far as it is a picture.\",\"str\":\"\"},{\"label\":\"4.04\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":7,\"x_axis\":65,\"ger\":\"Am Satz muss gerade soviel zu unterscheiden sein, als an der Sachlage, die er darstellt. Die beiden müssen die gleiche logische (mathematische) Mannigfaltigkeit besitzen. (Vergleiche Hertz’s „Mechanik“, über dynamische Modelle.)\",\"pmc\":\"In a proposition there must be exactly as many distinguishable parts as in the situation that it represents. The two must possess the same logical (mathematical) multiplicity. (Compare Hertz’s <em>Mechanics</em> on dynamical models.)\",\"ogd\":\"In the proposition there must be exactly as many things distinguishable as there are in the state of affairs, which it represents. They must both possess the same logical (mathematical) multiplicity (cf. Hertz’s Mechanics, on Dynamic Models).\",\"str\":\"\"},{\"label\":\"4.05\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":7,\"x_axis\":69,\"ger\":\"Die Wirklichkeit wird mit dem Satz verglichen.\",\"pmc\":\"Reality is compared with propositions.\",\"ogd\":\"Reality is compared with the proposition.\",\"str\":\"\"},{\"label\":\"4.06\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":7,\"x_axis\":71,\"ger\":\"Nur dadurch kann der Satz wahr oder falsch sein, indem er ein Bild der Wirklichkeit ist.\",\"pmc\":\"A proposition can be true or false only in virtue of being a picture of reality.\",\"ogd\":\"Propositions can be true or false only by being pictures of the reality.\",\"str\":\"\"},{\"label\":\"5.11\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":7,\"x_axis\":77,\"ger\":\"Sind die Wahrheitsgründe, die einer Anzahl von Sätzen gemeinsam sind, sämtlich auch Wahrheitsgründe eines bestimmten Satzes, so sagen wir, die Wahrheit dieses Satzes folge aus der Wahrheit jener Sätze.\",\"pmc\":\"If all the truth-grounds that are common to a number of propositions are at the same time truth-grounds of a certain proposition, then we say that the truth of that proposition follows from the truth of the others.\",\"ogd\":\"If the truth-grounds which are common to a number of propositions are all also truth-grounds of some one proposition, we say that the truth of this proposition follows from the truth of those propositions.\",\"str\":\"\"},{\"label\":\"5.12\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":7,\"x_axis\":79,\"ger\":\"Insbesondere folgt die Wahrheit eines Satzes „<span class=\\\"mathmode\\\"><var>p</var></span>“ aus der Wahrheit eines anderen „<span class=\\\"mathmode\\\"><var>q</var></span>“, wenn alle Wahrheitsgründe des zweiten Wahrheitsgründe des ersten sind.\",\"pmc\":\"In particular, the truth of a proposition ‘<span class=\\\"mathmode\\\"><var>p</var></span>’ follows from the truth of another proposition ‘<span class=\\\"mathmode\\\"><var>q</var></span>’ if all the truth-grounds of the latter are truth-grounds of the former.\",\"ogd\":\"In particular the truth of a proposition <span class=\\\"mathmode\\\"><var>p</var></span> follows from that of a proposition <span class=\\\"mathmode\\\"><var>q</var></span>, if all the truth-grounds of the second are truth-grounds of the first.\",\"str\":\"\"},{\"label\":\"5.13\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":7,\"x_axis\":83,\"ger\":\"Dass die Wahrheit eines Satzes aus der Wahrheit anderer Sätze folgt, ersehen wir aus der Struktur der Sätze.\",\"pmc\":\"When the truth of one proposition follows from the truth of others, we can see this from the structure of the propositions.\",\"ogd\":\"That the truth of one proposition follows from the truth of other propositions, we perceive from the structure of the propositions.\",\"str\":\"\"},{\"label\":\"5.14\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":7,\"x_axis\":85,\"ger\":\"Folgt ein Satz aus einem anderen, so sagt dieser mehr als jener, jener weniger als dieser.\",\"pmc\":\"If one proposition follows from another, then the latter says more than the former, and the former less than the latter.\",\"ogd\":\"If a proposition follows from another, then the latter says more than the former, the former less than the latter.\",\"str\":\"\"},{\"label\":\"5.15\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":7,\"x_axis\":91,\"ger\":\"Ist <span class=\\\"mathmode\\\"><span class=\\\"mathrm\\\">W</span><sub><var>r</var></sub></span> die Anzahl der Wahrheitsgründe des Satzes „<span class=\\\"mathmode\\\"><var>r</var></span>“, <span class=\\\"mathmode\\\"><span class=\\\"mathrm\\\">W</span><sub><var>rs</var></sub></span> die Anzahl derjenigen Wahrheitsgründe des Satzes „<span class=\\\"mathmode\\\"><var>s</var></span>“, die zugleich Wahrheitsgründe von „<span class=\\\"mathmode\\\"><var>r</var></span>“ sind, dann nennen wir das Verhältnis: <span class=\\\"mathmode\\\"><span class=\\\"mathrm\\\">W</span><sub><var>rs</var></sub> : <span class=\\\"mathrm\\\">W</span><sub><var>r</var></sub></span> das Maß der <em class=\\\"germph\\\">Wahrscheinlichkeit</em>, welche der Satz „<span class=\\\"mathmode\\\"><var>r</var></span>“ dem Satz „<span class=\\\"mathmode\\\"><var>s</var></span>“ gibt.\",\"pmc\":\"If <span class=\\\"mathmode\\\"><span class=\\\"mathrm\\\">T</span><sub><var>r</var></sub></span> is the number of the truth-grounds of a proposition ‘<span class=\\\"mathmode\\\"><var>r</var></span>’, and if <span class=\\\"mathmode\\\"><span class=\\\"mathrm\\\">T</span><sub><var>rs</var></sub></span> is the number of the truth-grounds of a proposition ‘<span class=\\\"mathmode\\\"><var>s</var></span>’ that are at the same time truth-grounds of ‘<span class=\\\"mathmode\\\"><var>r</var></span>’, then we call the ratio <span class=\\\"mathmode\\\"><span class=\\\"mathrm\\\">T</span><sub><var>rs</var></sub> : <span class=\\\"mathrm\\\">T</span><sub><var>r</var></sub></span> the degree of probability that the proposition ‘<span class=\\\"mathmode\\\"><var>r</var></span>’ gives to the proposition ‘<span class=\\\"mathmode\\\"><var>s</var></span>’.\",\"ogd\":\"If <span class=\\\"mathmode\\\"><span class=\\\"mathrm\\\">T</span><sub><var>r</var></sub></span> is the number of the truth-grounds of the proposition “<span class=\\\"mathmode\\\"><var>r</var></span>”, <span class=\\\"mathmode\\\"><span class=\\\"mathrm\\\">T</span><sub><var>rs</var></sub></span> the number of those truth-grounds of the proposition “<span class=\\\"mathmode\\\"><var>s</var></span>” which are at the same time truth-grounds of “<span class=\\\"mathmode\\\"><var>r</var></span>”, then we call the ratio <span class=\\\"mathmode\\\"><span class=\\\"mathrm\\\">T</span><sub><var>rs</var></sub> : <span class=\\\"mathrm\\\">T</span><sub><var>r</var></sub></span> the measure of the <em>probability</em> which the proposition “<span class=\\\"mathmode\\\"><var>r</var></span>” gives to the proposition “<span class=\\\"mathmode\\\"><var>s</var></span>”.\",\"str\":\"\"},{\"label\":\"6.031\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":7,\"x_axis\":113,\"ger\":\"Die Theorie der Klassen ist in der Mathematik ganz überflüssig. Dies hängt damit zusammen, dass die Allgemeinheit, welche wir in der Mathematik brauchen, nicht die <em class=\\\"germph\\\">zufällige</em> ist.\",\"pmc\":\"The theory of classes is completely superfluous in mathematics. This is connected with the fact that the generality required in mathematics is not <em>accidental</em> generality.\",\"ogd\":\"The theory of classes is altogether superfluous in mathematics. This is connected with the fact that the generality which we need in mathematics is not the <em>accidental</em> one.\",\"str\":\"\"},{\"label\":\"2.013\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":9,\"x_axis\":11,\"ger\":\"Jedes Ding ist, gleichsam, in einem Raume möglicher Sachverhalte. Diesen Raum kann ich mir leer denken, nicht aber das Ding ohne den Raum.\",\"pmc\":\"Each thing is, as it were, in a space of possible states of affairs. This space I can imagine empty, but I cannot imagine the thing without the space.\",\"ogd\":\"Every thing is, as it were, in a space of possible atomic facts. I can think of this space as empty, but not of the thing without the space.\",\"str\":\"\"},{\"label\":\"2.0131\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":9,\"x_axis\":13,\"ger\":\"Der räumliche Gegenstand muss im unendlichen Raume liegen. (Der Raumpunkt ist eine Argumentstelle.) Der Fleck im Gesichtsfeld muss zwar nicht rot sein, aber eine Farbe muss er haben: er hat sozusagen den Farbenraum um sich. Der Ton muss <em class=\\\"germph\\\">eine</em> Höhe haben, der Gegenstand des Tastsinnes <em class=\\\"germph\\\">eine</em> Härte, usw.\",\"pmc\":\"A spatial object must be situated in infinite space. (A spatial point is an argument-place.) A speck in the visual field, thought it need not be red, must have some colour: it is, so to speak, surrounded by colour-space. Notes must have <em>some</em> pitch, objects of the sense of touch <em>some</em> degree of hardness, and so on.\",\"ogd\":\"A spatial object must lie in infinite space. (A point in space is an argument place.) A speck in a visual field need not be red, but it must have a colour; it has, so to speak, a colour space round it. A tone must have <em>a</em> pitch, the object of the sense of touch <em>a</em> hardness, etc.\",\"str\":\"\"},{\"label\":\"2.022\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":9,\"x_axis\":21,\"ger\":\"Es ist offenbar, dass auch eine von der wirklichen noch so verschieden gedachte Welt Etwas – eine Form – mit der wirklichen gemein haben muss.\",\"pmc\":\"It is obvious that an imagined world, however different it may be from the real one, must have <em>something</em>—a form—in common with it.\",\"ogd\":\"It is clear that however different from the real one an imagined world may be, it must have something—a form—in common with the real world.\",\"str\":\"\"},{\"label\":\"2.033\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":9,\"x_axis\":29,\"ger\":\"Die Form ist die Möglichkeit der Struktur.\",\"pmc\":\"Form is the possibility of structure.\",\"ogd\":\"The form is the possibility of the structure.\",\"str\":\"\"},{\"label\":\"2.063\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":9,\"x_axis\":35,\"ger\":\"Die gesamte Wirklichkeit ist die Welt.\",\"pmc\":\"The sum-total of reality is the world.\",\"ogd\":\"The total reality is the world.\",\"str\":\"\"},{\"label\":\"3.032\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":9,\"x_axis\":43,\"ger\":\"Etwas „der Logik widersprechendes“ in der Sprache darstellen, kann man ebensowenig, wie in der Geometrie eine den Gesetzen des Raumes widersprechende Figur durch ihre Koordinaten darstellen; oder die Koordinaten eines Punktes angeben, welcher nicht existiert.\",\"pmc\":\"It is as impossible to represent in language anything that ‘contradicts logic’ as it is in geometry to represent by its co-ordinates a figure that contradicts the laws of space, or to give the co-ordinates of a point that does not exist.\",\"ogd\":\"To present in language anything which “contradicts logic” is as impossible as in geometry to present by its co-ordinates a figure which contradicts the laws of space; or to give the co-ordinates of a point which does not exist.\",\"str\":\"\"},{\"label\":\"3.0321\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":9,\"x_axis\":45,\"ger\":\"Wohl können wir einen Sachverhalt räumlich darstellen, welcher den Gesetzen der Physik, aber keinen, der den Gesetzen der Geometrie zuwiderliefe.\",\"pmc\":\"Though a state of affairs that would contravene the laws of physics can be represented by us spatially, one that would contravene the laws of geometry cannot.\",\"ogd\":\"We could present spatially an atomic fact which contradicted the laws of physics, but not one which contradicted the laws of geometry.\",\"str\":\"\"},{\"label\":\"4.011\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":9,\"x_axis\":53,\"ger\":\"Auf den ersten Blick scheint der Satz – wie er etwa auf dem Papier gedruckt steht – kein Bild der Wirklichkeit zu sein, von der er handelt. Aber auch die Notenschrift scheint auf den ersten Blick kein Bild der Musik zu sein, und unsere Lautzeichen-(Buchstaben-)Schrift kein Bild unserer Lautsprache. Und doch erweisen sich diese Zeichensprachen auch im gewöhnlichen Sinne als Bilder dessen, was sie darstellen.\",\"pmc\":\"At first sight a proposition—one set out on the printed page, for example—does not seem to be a picture of the reality with which it is concerned. But neither do written notes seem at first sight to be a picture of a piece of music, nor our phonetic notation (the alphabet) to be a picture of our speech. And yet these sign-languages prove to be pictures, even in the ordinary sense, of what they represent.\",\"ogd\":\"At the first glance the proposition—say as it stands printed on paper—does not seem to be a picture of the reality of which it treats. But nor does the musical score appear at first sight to be a picture of a musical piece; nor does our phonetic spelling (letters) seem to be a picture of our spoken language. And yet these symbolisms prove to be pictures—even in the ordinary sense of the word—of what they represent.\",\"str\":\"\"},{\"label\":\"4.021\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":9,\"x_axis\":57,\"ger\":\"Der Satz ist ein Bild der Wirklichkeit: Denn ich kenne die von ihm dargestellte Sachlage, wenn ich den Satz verstehe. Und den Satz verstehe ich, ohne dass mir sein Sinn erklärt wurde.\",\"pmc\":\"A proposition is a picture of reality: for if I understand a proposition, I know the situation that it represents. And I understand the proposition without having had its sense explained to me.\",\"ogd\":\"The proposition is a picture of reality, for I know the state of affairs presented by it, if I understand the proposition. And I understand the proposition, without its sense having been explained to me.\",\"str\":\"\"},{\"label\":\"4.031\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":9,\"x_axis\":59,\"ger\":\"Im Satz wird gleichsam eine Sachlage probeweise zusammengestellt. Man kann geradezu sagen: statt, dieser Satz hat diesen und diesen Sinn; dieser Satz stellt diese und diese Sachlage dar.\",\"pmc\":\"In a proposition a situation is, as it were, constructed by way of experiment. Instead of, ‘This proposition has such and such a sense’, we can simply say, ‘This proposition represents such and such a situation’.\",\"ogd\":\"In the proposition a state of affairs is, as it were, put together for the sake of experiment. One can say, instead of, This proposition has such and such a sense, This proposition represents such and such a state of affairs.\",\"str\":\"\"},{\"label\":\"4.0311\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":9,\"x_axis\":61,\"ger\":\"Ein Name steht für ein Ding, ein anderer für ein anderes Ding und untereinander sind sie verbunden, so stellt das Ganze – wie ein lebendes Bild – den Sachverhalt vor.\",\"pmc\":\"One name stands for one thing, another for another thing, and they are combined with one another. In this way the whole group—like a <em>tableau vivant</em>—presents a state of affairs.\",\"ogd\":\"One name stands for one thing, and another for another thing, and they are connected together. And so the whole, like a living picture, presents the atomic fact.\",\"str\":\"\"},{\"label\":\"4.0312\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":9,\"x_axis\":63,\"ger\":\"Die Möglichkeit des Satzes beruht auf dem Prinzip der Vertretung von Gegenständen durch Zeichen. Mein Grundgedanke ist, dass die „logischen Konstanten“ nicht vertreten. Dass sich die <em class=\\\"germph\\\">Logik</em> der Tatsachen nicht vertreten lässt.\",\"pmc\":\"The possibility of propositions is based on the principle that objects have signs as their representatives. My fundamental idea is that the ‘logical constants’ are not representatives; that there can be no representatives of the <em>logic</em> of facts.\",\"ogd\":\"The possibility of propositions is based upon the principle of the representation of objects by signs. My fundamental thought is that the “logical constants” do not represent. That the <em>logic</em> of the facts cannot be represented.\",\"str\":\"\"},{\"label\":\"4.041\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":9,\"x_axis\":65,\"ger\":\"Diese mathematische Mannigfaltigkeit kann man natürlich nicht selbst wieder abbilden. Aus ihr kann man beim Abbilden nicht heraus.\",\"pmc\":\"This mathematical multiplicity, of course, cannot itself be the subject of depiction. One cannot get away from it when depicting.\",\"ogd\":\"This mathematical multiplicity naturally cannot in its turn be represented. One cannot get outside it in the representation.\",\"str\":\"\"},{\"label\":\"4.0411\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":9,\"x_axis\":67,\"ger\":\"Wollten wir z. B. das, was wir durch „<span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<var>x</var>).</span><var>fx</var></span>“ ausdrücken, durch Vorsetzen eines Indexes vor „<span class=\\\"mathmode\\\"><var>fx</var></span>“ ausdrücken – etwa so: „<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\"><span class=\\\"mathrm\\\">Alg.</span></span><var>fx</var></span>“ – es würde nicht genügen – wir wüssten nicht, was verallgemeinert wurde. Wollten wir es durch einen Index „<span class=\\\"mathmode\\\"><sub><var>a</var></sub></span>“ anzeigen – etwa so: „<span class=\\\"mathmode\\\"><var>f</var>(<var>x</var><sub><var>a</var></sub>)</span>“ – es würde auch nicht genügen – wir wüssten nicht den Bereich der Allgemeinheitsbezeichnung. Wollten wir es durch Einführung einer Marke in die Argumentstellen versuchen – etwa so: „<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">(<var>A</var>, <var>A</var>).</span> <var>F</var>(<var>A</var>, <var>A</var>)</span>“ – es würde nicht genügen – wir könnten die Identität der Variablen nicht feststellen. U.s.w. Alle diese Bezeichnungsweisen genügen nicht, weil sie nicht die notwendige mathematische Mannigfaltigkeit haben.\",\"pmc\":\"If, for example, we wanted to express what we now write as ‘<span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<var>x</var>).</span><var>fx</var></span>’ by putting an affix in front of ‘<span class=\\\"mathmode\\\"><var>fx</var></span>’—for instance by writing ‘<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\"><span class=\\\"mathrm\\\">Gen.</span></span> <var>fx</var></span>’—it would not be adequate: we should not know what was being generalized. If we wanted to signalize it with an affix ‘<span class=\\\"mathmode\\\"><var>g</var></span>’—for instance by writing ‘<span class=\\\"mathmode\\\"><var>f</var>(<var>x</var><sub><var>g</var></sub>)</span>’—that would not be adequate either: we should not know the scope of the generality-sign. If we were to try to do it by introducing a mark into the argument-places—for instance by writing ‘<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">(<var>G</var>, <var>G</var>).</span> <var>F</var>(<var>G</var>, <var>G</var>)</span>’—it would not be adequate: we should not be able to establish the identity of the variables. And so on. All these modes of signifying are inadequate because they lack the necessary mathematical multiplicity.\",\"ogd\":\"If we tried, for example, to express what is expressed by “<span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<var>x</var>).</span><var>fx</var></span>” by putting an index before <span class=\\\"mathmode\\\"><var>fx</var></span>, like: “<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\"><span class=\\\"mathrm\\\">Gen.</span></span> <var>fx</var></span>”, it would not do, we should not know what was generalized. If we tried to show it by an index <span class=\\\"mathmode\\\"><var>g</var></span>, like: “<span class=\\\"mathmode\\\"><var>f</var>(<var>x</var><sub><var>g</var></sub>)</span>” it would not do—we should not know the scope of the generalization. If we were to try it by introducing a mark in the argument places, like “<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">(<var>G</var>, <var>G</var>).</span> <var>F</var>(<var>G</var>, <var>G</var>)</span>”, it would not do—we could not determine the identity of the variables, etc. All these ways of symbolizing are inadequate because they have not the necessary mathematical multiplicity.\",\"str\":\"\"},{\"label\":\"4.0412\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":9,\"x_axis\":69,\"ger\":\"Aus demselben Grunde genügt die idealistische Erklärung des Sehens der räumlichen Beziehungen durch die „Raumbrille“ nicht, weil sie nicht die Mannigfaltigkeit dieser Beziehungen erklären kann.\",\"pmc\":\"For the same reason the idealist’s appeal to ‘spatial spectacles’ is inadequate to explain the seeing of spatial relations, because it cannot explain the multiplicity of these relations.\",\"ogd\":\"For the same reason the idealist explanation of the seeing of spatial relations through “spatial spectacles” does not do, because it cannot explain the multiplicity of these relations.\",\"str\":\"\"},{\"label\":\"4.061\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":9,\"x_axis\":71,\"ger\":\"Beachtet man nicht, dass der Satz einen von den Tatsachen unabhängigen Sinn hat, so kann man leicht glauben, dass wahr und falsch gleichberechtigte Beziehungen von Zeichen und Bezeichnetem sind. Man könnte dann z. B. sagen, dass „<span class=\\\"mathmode\\\"><var>p</var></span>“ auf die wahre Art bezeichnet, was „<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><var>p</var></span>“ auf die falsche Art, etc.\",\"pmc\":\"It must not be overlooked that a proposition has a sense that is independent of the facts: otherwise one can easily suppose that true and false are relations of equal status between signs and what they signify. In that case one could say, for example, that ‘<span class=\\\"mathmode\\\"><var>p</var></span>’ signified in the true way what ‘<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><var>p</var></span>’ signified in the false way, etc.\",\"ogd\":\"If one does not observe that propositions have a sense independent of the facts, one can easily believe that true and false are two relations between signs and things signified with equal rights. One could, then, for example, say that “<span class=\\\"mathmode\\\"><var>p</var></span>” signifies in the true way what “<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><var>p</var></span>” signifies in the false way, etc.\",\"str\":\"\"},{\"label\":\"5.121\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":9,\"x_axis\":79,\"ger\":\"Die Wahrheitsgründe des einen sind in denen des anderen enthalten; <span class=\\\"mathmode\\\"><var>p</var></span> folgt aus <span class=\\\"mathmode\\\"><var>q</var></span>.\",\"pmc\":\"The truth-grounds of the one are contained in those of the other: <span class=\\\"mathmode\\\"><var>p</var></span> follows from <span class=\\\"mathmode\\\"><var>q</var></span>.\",\"ogd\":\"The truth-grounds of <span class=\\\"mathmode\\\"><var>q</var></span> are contained in those of <span class=\\\"mathmode\\\"><var>p</var></span>; <span class=\\\"mathmode\\\"><var>p</var></span> follows from <span class=\\\"mathmode\\\"><var>q</var></span>.\",\"str\":\"\"},{\"label\":\"5.131\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":9,\"x_axis\":83,\"ger\":\"Folgt die Wahrheit eines Satzes aus der Wahrheit anderer, so drückt sich dies durch Beziehungen aus, in welchen die Formen jener Sätze zu einander stehen; und zwar brauchen wir sie nicht erst in jene Beziehungen zu setzen, indem wir sie in einem Satz miteinander verbinden, sondern diese Beziehungen sind intern und bestehen, sobald, und dadurch dass, jene Sätze bestehen.\",\"pmc\":\"If the truth of one proposition follows from the truth of others, this finds expression in relations in which the forms of the propositions stand to one another: nor is it necessary for us to set up these relations between them, by combining them with one another in a single proposition; on the contrary, the relations are internal, and their existence is an immediate result of the existence of the propositions.\",\"ogd\":\"If the truth of one proposition follows from the truth of others, this expresses itself in relations in which the forms of these propositions stand to one another, and we do not need to put them in these relations first by connecting them with one another in a proposition; for these relations are internal, and exist as soon as, and by the very fact that, the propositions exist.\",\"str\":\"\"},{\"label\":\"5.141\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":9,\"x_axis\":85,\"ger\":\"Folgt <span class=\\\"mathmode\\\"><var>p</var></span> aus <span class=\\\"mathmode\\\"><var>q</var></span> und <span class=\\\"mathmode\\\"><var>q</var></span> aus <span class=\\\"mathmode\\\"><var>p</var></span>, so sind sie ein und derselbe Satz.\",\"pmc\":\"If <span class=\\\"mathmode\\\"><var>p</var></span> follows from <span class=\\\"mathmode\\\"><var>q</var></span> and <span class=\\\"mathmode\\\"><var>q</var></span> from <span class=\\\"mathmode\\\"><var>p</var></span>, then they are one and the same proposition.\",\"ogd\":\"If <span class=\\\"mathmode\\\"><var>p</var></span> follows from <span class=\\\"mathmode\\\"><var>q</var></span> and <span class=\\\"mathmode\\\"><var>q</var></span> from <span class=\\\"mathmode\\\"><var>p</var></span> then they are one and the same proposition.\",\"str\":\"\"},{\"label\":\"5.151\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":9,\"x_axis\":91,\"ger\":\"Sei in einem Schema wie dem obigen in No. 5.101 <span class=\\\"mathmode\\\"><span class=\\\"mathrm\\\">W</span><sub><var>r</var></sub></span> die Anzahl der „W“ im Satze <span class=\\\"mathmode\\\"><var>r</var></span>; <span class=\\\"mathmode\\\"><span class=\\\"mathrm\\\">W</span><sub><var>rs</var></sub></span> die Anzahl derjenigen „W“ im Satze <span class=\\\"mathmode\\\"><var>s</var></span>, die in gleichen Kolonnen mit „W“ des Satzes <span class=\\\"mathmode\\\"><var>r</var></span> stehen. Der Satz <span class=\\\"mathmode\\\"><var>r</var></span> gibt dann dem Satze <span class=\\\"mathmode\\\"><var>s</var></span> die Wahrscheinlichkeit: <span class=\\\"mathmode\\\"><span class=\\\"mathrm\\\">W</span><sub><var>rs</var></sub> : <span class=\\\"mathrm\\\">W</span><sub><var>r</var></sub></span>.\",\"pmc\":\"In a schema like the one above in 5.101, let <span class=\\\"mathmode\\\"><span class=\\\"mathrm\\\">T</span><sub><var>r</var></sub></span> be the number of ‘T’s’ in the proposition <span class=\\\"mathmode\\\"><var>r</var></span>, and let <span class=\\\"mathmode\\\"><span class=\\\"mathrm\\\">T</span><sub><var>rs</var></sub></span>, be the number of ‘T’s’ in the proposition <span class=\\\"mathmode\\\"><var>s</var></span> that stand in columns in which the proposition <span class=\\\"mathmode\\\"><var>r</var></span> has ‘T’s’. Then the proposition <span class=\\\"mathmode\\\"><var>r</var></span> gives to the proposition <span class=\\\"mathmode\\\"><var>s</var></span> the probability <span class=\\\"mathmode\\\"><span class=\\\"mathrm\\\">T</span><sub><var>rs</var></sub> : <span class=\\\"mathrm\\\">T</span><sub><var>r</var></sub></span>.\",\"ogd\":\"Suppose in a schema like that above in No. 5.101 <span class=\\\"mathmode\\\"><span class=\\\"mathrm\\\">T</span><sub><var>r</var></sub></span> is the number of the “T” ’s in the proposition <span class=\\\"mathmode\\\"><var>r</var></span>, <span class=\\\"mathmode\\\"><span class=\\\"mathrm\\\">T</span><sub><var>rs</var></sub></span> the number of those “T” ’s in the proposition <span class=\\\"mathmode\\\"><var>s</var></span>, which stand in the same columns as “T” ’s of the proposition <span class=\\\"mathmode\\\"><var>r</var></span>; then the proposition <span class=\\\"mathmode\\\"><var>r</var></span> gives to the proposition <span class=\\\"mathmode\\\"><var>s</var></span> the probability <span class=\\\"mathmode\\\"><span class=\\\"mathrm\\\">T</span><sub><var>rs</var></sub> : <span class=\\\"mathrm\\\">T</span><sub><var>r</var></sub></span>.\",\"str\":\"\"},{\"label\":\"5.1511\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":9,\"x_axis\":93,\"ger\":\"Es gibt keinen besonderen Gegenstand, der den Wahrscheinlichkeitssätzen eigen wäre.\",\"pmc\":\"There is no special object peculiar to probability propositions.\",\"ogd\":\"There is no special object peculiar to probability propositions.\",\"str\":\"\"},{\"label\":\"6.022\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":9,\"x_axis\":111,\"ger\":\"Der Zahlbegriff ist nichts anderes als das Gemeinsame aller Zahlen, die allgemeine Form der Zahl. Der Zahlbegriff ist die variable Zahl. Und der Begriff der Zahlengleichheit ist die allgemeine Form aller speziellen Zahlengleichheiten.\",\"pmc\":\"The concept of number is simply what is common to all numbers, the general form of a number. The concept of number is the variable number. And the concept of numerical equality is the general form of all particular cases of numerical equality.\",\"ogd\":\"The concept number is nothing else than that which is common to all numbers, the general form of a number. The concept number is the variable number. And the concept of equality of numbers is the general form of all special equalities of numbers.\",\"str\":\"\"},{\"label\":\"2.014\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":11,\"x_axis\":11,\"ger\":\"Die Gegenstände enthalten die Möglichkeit aller Sachlagen.\",\"pmc\":\"Objects contain the possibility of all situations.\",\"ogd\":\"Objects contain the possibility of all states of affairs.\",\"str\":\"\"},{\"label\":\"2.0141\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":11,\"x_axis\":13,\"ger\":\"Die Möglichkeit seines Vorkommens in Sachverhalten, ist die Form des Gegenstandes.\",\"pmc\":\"The possibility of its occurring in states of affairs is the form of an object.\",\"ogd\":\"The possibility of its occurrence in atomic facts is the form of the object.\",\"str\":\"\"},{\"label\":\"2.023\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":11,\"x_axis\":21,\"ger\":\"Diese feste Form besteht eben aus den Gegenständen.\",\"pmc\":\"Objects are just what constitute this unalterable form.\",\"ogd\":\"This fixed form consists of the objects.\",\"str\":\"\"},{\"label\":\"2.0231\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":11,\"x_axis\":23,\"ger\":\"Die Substanz der Welt <em class=\\\"germph\\\">kann</em> nur eine Form und keine materiellen Eigenschaften bestimmen. Denn diese werden erst durch die Sätze dargestellt – erst durch die Konfiguration der Gegenstände gebildet.\",\"pmc\":\"The substance of the world <em>can</em> only determine a form, and not any material properties. For it is only by means of propositions that material properties are represented—only by the configuration of objects that they are produced.\",\"ogd\":\"The substance of the world <em>can</em> only determine a form and not any material properties. For these are first presented by the propositions—first formed by the configuration of the objects.\",\"str\":\"\"},{\"label\":\"2.0232\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":11,\"x_axis\":25,\"ger\":\"Beiläufig gesprochen: Die Gegenstände sind farblos.\",\"pmc\":\"In a manner of speaking, objects are colourless.\",\"ogd\":\"Roughly speaking: objects are colourless.\",\"str\":\"\"},{\"label\":\"2.0233\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":11,\"x_axis\":27,\"ger\":\"Zwei Gegenstände von der gleichen logischen Form sind – abgesehen von ihren externen Eigenschaften – von einander nur dadurch unterschieden, dass sie verschieden sind.\",\"pmc\":\"If two objects have the same logical form, the only distinction between them, apart from their external properties, is that they are different.\",\"ogd\":\"Two objects of the same logical form are—apart from their external properties—only differentiated from one another in that they are different.\",\"str\":\"\"},{\"label\":\"2.034\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":11,\"x_axis\":29,\"ger\":\"Die Struktur der Tatsache besteht aus den Strukturen der Sachverhalte.\",\"pmc\":\"The structure of a fact consists of the structures of states of affairs.\",\"ogd\":\"The structure of the fact consists of the structures of the atomic facts.\",\"str\":\"\"},{\"label\":\"3.1\",\"precision\":1,\"fontSize\":\"40px\",\"y_axis\":11,\"x_axis\":37,\"ger\":\"Im Satz drückt sich der Gedanke sinnlich wahrnehmbar aus.\",\"pmc\":\"In a proposition a thought finds an expression that can be perceived by the senses.\",\"ogd\":\"In the proposition the thought is expressed perceptibly through the senses.\",\"str\":\"\"},{\"label\":\"3.11\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":11,\"x_axis\":39,\"ger\":\"Wir benützen das sinnlich wahrnehmbare Zeichen (Laut- oder Schriftzeichen etc.) des Satzes als Projektion der möglichen Sachlage. Die Projektionsmethode ist das Denken des Satz-Sinnes.\",\"pmc\":\"We use the perceptible sign of a proposition (spoken or written, etc.) as a projection of a possible situation. The method of projection is to think of the sense of the proposition.\",\"ogd\":\"We use the sensibly perceptible sign (sound or written sign, etc.) of the proposition as a projection of the possible state of affairs. The method of projection is the thinking of the sense of the proposition.\",\"str\":\"\"},{\"label\":\"3.12\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":11,\"x_axis\":41,\"ger\":\"Das Zeichen, durch welches wir den Gedanken ausdrücken, nenne ich das Satzzeichen. Und der Satz ist das Satzzeichen in seiner projektiven Beziehung zur Welt.\",\"pmc\":\"I call the sign with which we express a thought a propositional sign.—And a proposition is a propositional sign in its projective relation to the world.\",\"ogd\":\"The sign through which we express the thought I call the propositional sign. And the proposition is the propositional sign in its projective relation to the world.\",\"str\":\"\"},{\"label\":\"3.13\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":11,\"x_axis\":43,\"ger\":\"Zum Satz gehört alles, was zur Projektion gehört; aber nicht das Projizierte. Also die Möglichkeit des Projizierten, aber nicht dieses selbst. Im Satz ist also sein Sinn noch nicht enthalten, wohl aber die Möglichkeit, ihn auszudrücken. („Der Inhalt des Satzes“ heißt der Inhalt des sinnvollen Satzes.) Im Satz ist die Form seines Sinnes enthalten, aber nicht dessen Inhalt.\",\"pmc\":\"A proposition includes all that the projection includes, but not what is projected. Therefore, though what is projected is not itself included, its possibility is. A proposition, therefore, does not actually contain its sense, but does contain the possibility of expressing it. (‘The content of a proposition’ means the content of a proposition that has sense.) A proposition contains the form, but not the content, of its sense.\",\"ogd\":\"To the proposition belongs everything which belongs to the projection; but not what is projected. Therefore the possibility of what is projected but not this itself. In the proposition, therefore, its sense is not yet contained, but the possibility of expressing it. (“The content of the proposition” means the content of the significant proposition.) In the proposition the form of its sense is contained, but not its content.\",\"str\":\"\"},{\"label\":\"3.14\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":11,\"x_axis\":45,\"ger\":\"Das Satzzeichen besteht darin, dass sich seine Elemente, die Wörter, in ihm auf bestimmte Art und Weise zu einander verhalten. Das Satzzeichen ist eine Tatsache.\",\"pmc\":\"What constitutes a propositional sign is that in it its elements (the words) stand in a determinate relation to one another. A propositional sign is a fact.\",\"ogd\":\"The propositional sign consists in the fact that its elements, the words, are combined in it in a definite way. The propositional sign is a fact.\",\"str\":\"\"},{\"label\":\"4.012\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":11,\"x_axis\":53,\"ger\":\"Offenbar ist, dass wir einen Satz von der Form „<span class=\\\"mathmode\\\"><var>aRb</var></span>“ als Bild empfinden. Hier ist das Zeichen offenbar ein Gleichnis des Bezeichneten.\",\"pmc\":\"It is obvious that a proposition of the form ‘<span class=\\\"mathmode\\\"><var>aRb</var></span>’ strikes us as a picture. In this case the sign is obviously a likeness of what is signified.\",\"ogd\":\"It is obvious that we perceive a proposition of the form <span class=\\\"mathmode\\\"><var>aRb</var></span> as a picture. Here the sign is obviously a likeness of the signified.\",\"str\":\"\"},{\"label\":\"4.022\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":11,\"x_axis\":57,\"ger\":\"Der Satz <em class=\\\"germph\\\">zeigt</em> seinen Sinn. Der Satz <em class=\\\"germph\\\">zeigt</em>, wie es sich verhält, <em class=\\\"germph\\\">wenn</em> er wahr ist. Und er <em class=\\\"germph\\\">sagt</em>, <em class=\\\"germph\\\">dass</em> es sich so verhält.\",\"pmc\":\"A proposition <em>shows</em> its sense. A proposition <em>shows</em> how things stand <em>if</em> it is true. And it <em>says that</em> they do so stand.\",\"ogd\":\"The proposition <em>shows</em> its sense. The proposition <em>shows</em> how things stand, <em>if</em> it is true. And it <em>says</em>, that they do so stand.\",\"str\":\"\"},{\"label\":\"4.032\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":11,\"x_axis\":59,\"ger\":\"Nur insoweit ist der Satz ein Bild der Sachlage, als er logisch gegliedert ist. (Auch der Satz: „ambulo“, ist zusammengesetzt, denn sein Stamm ergibt mit einer anderen Endung, und seine Endung mit einem anderen Stamm, einen anderen Sinn.)\",\"pmc\":\"It is only in so far as a proposition is logically articulated that it is a picture of a situation. (Even the proposition, <em>Ambulo</em>, is composite: for its stem with a different ending yields a different sense, and so does its ending with a different stem.)\",\"ogd\":\"The proposition is a picture of its state of affairs, only in so far as it is logically articulated. (Even the proposition “ambulo” is composite, for its stem gives a different sense with another termination, or its termination with another stem.)\",\"str\":\"\"},{\"label\":\"4.062\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":11,\"x_axis\":71,\"ger\":\"Kann man sich nicht mit falschen Sätzen, wie bisher mit wahren, verständigen? Solange man nur weiß, dass sie falsch gemeint sind. Nein! Denn, wahr ist ein Satz, wenn es sich so verhält, wie wir es durch ihn sagen; und wenn wir mit „<span class=\\\"mathmode\\\"><var>p</var></span>“ <span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><var>p</var></span> meinen, und es sich so verhält wie wir es meinen, so ist „<span class=\\\"mathmode\\\"><var>p</var></span>“ in der neuen Auffassung wahr und nicht falsch.\",\"pmc\":\"Can we not make ourselves understood with false propositions just as we have done up till now with true ones?—So long as it is known that they are meant to be false.—No! For a proposition is true if we use it to say that things stand in a certain way, and they do; and if by ‘<span class=\\\"mathmode\\\"><var>p</var></span>’ we mean <span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><var>p</var></span> and things stand as we mean that they do, then, construed in the new way, ‘<span class=\\\"mathmode\\\"><var>p</var></span>’ is true and not false.\",\"ogd\":\"Can we not make ourselves understood by means of false propositions as hitherto with true ones, so long as we know that they are meant to be false? No! For a proposition is true, if what we assert by means of it is the case; and if by “<span class=\\\"mathmode\\\"><var>p</var></span>” we mean <span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><var>p</var></span>, and what we mean is the case, then “<span class=\\\"mathmode\\\"><var>p</var></span>” in the new conception is true and not false.\",\"str\":\"\"},{\"label\":\"4.0621\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":11,\"x_axis\":73,\"ger\":\"Dass aber die Zeichen „<span class=\\\"mathmode\\\"><var>p</var></span>“ und „<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><var>p</var></span>“ das gleiche sagen <em class=\\\"germph\\\">können</em>, ist wichtig. Denn es zeigt, dass dem Zeichen „~“ in der Wirklichkeit nichts entspricht. Dass in einem Satz die Verneinung vorkommt, ist noch kein Merkmal seines Sinnes (<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><span class=\\\"mathop\\\">~</span><var>p</var><span class=\\\"mathrel\\\">=</span><var>p</var></span>). Die Sätze „<span class=\\\"mathmode\\\"><var>p</var></span>“ und „<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><var>p</var></span>“ haben entgegengesetzten Sinn, aber es entspricht ihnen eine und dieselbe Wirklichkeit.\",\"pmc\":\"But it is important that the signs ‘<span class=\\\"mathmode\\\"><var>p</var></span>’ and ‘<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><var>p</var></span>’ can say the same thing. For it shows that nothing in reality corresponds to the sign ‘~’. The occurrence of negation in a proposition is not enough to characterize its sense (<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><span class=\\\"mathop\\\">~</span><var>p</var><span class=\\\"mathrel\\\">=</span><var>p</var></span>). The propositions ‘<span class=\\\"mathmode\\\"><var>p</var></span>’ and ‘<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><var>p</var></span>’ have opposite sense, but there corresponds to them one and the same reality.\",\"ogd\":\"That, however, the signs “<span class=\\\"mathmode\\\"><var>p</var></span>” and “<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><var>p</var></span>” <em>can</em> say the same thing is important, for it shows that the sign “~” corresponds to nothing in reality. That negation occurs in a proposition, is no characteristic of its sense (<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><span class=\\\"mathop\\\">~</span><var>p</var><span class=\\\"mathrel\\\">=</span><var>p</var></span>). The propositions “<span class=\\\"mathmode\\\"><var>p</var></span>” and “<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><var>p</var></span>” have opposite senses, but to them corresponds one and the same reality.\",\"str\":\"\"},{\"label\":\"5.122\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":11,\"x_axis\":79,\"ger\":\"Folgt <span class=\\\"mathmode\\\"><var>p</var></span> aus <span class=\\\"mathmode\\\"><var>q</var></span>, so ist der Sinn von „<span class=\\\"mathmode\\\"><var>p</var></span>“ im Sinne von „<span class=\\\"mathmode\\\"><var>q</var></span>“ enthalten.\",\"pmc\":\"If <span class=\\\"mathmode\\\"><var>p</var></span> follows from <span class=\\\"mathmode\\\"><var>q</var></span>, the sense of ‘<span class=\\\"mathmode\\\"><var>p</var></span>’ is contained in the sense of ‘<span class=\\\"mathmode\\\"><var>q</var></span>’.\",\"ogd\":\"If <span class=\\\"mathmode\\\"><var>p</var></span> follows from <span class=\\\"mathmode\\\"><var>q</var></span>, the sense of “<span class=\\\"mathmode\\\"><var>p</var></span>” is contained in that of “<span class=\\\"mathmode\\\"><var>q</var></span>”.\",\"str\":\"\"},{\"label\":\"5.132\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":11,\"x_axis\":83,\"ger\":\"Folgt <span class=\\\"mathmode\\\"><var>p</var></span> aus <span class=\\\"mathmode\\\"><var>q</var></span>, so kann ich von <span class=\\\"mathmode\\\"><var>q</var></span> auf <span class=\\\"mathmode\\\"><var>p</var></span> schließen; <span class=\\\"mathmode\\\"><var>p</var></span> aus <span class=\\\"mathmode\\\"><var>q</var></span> folgern. Die Art des Schlusses ist allein aus den beiden Sätzen zu entnehmen. Nur sie selbst können den Schluss rechtfertigen. „Schlussgesetze“, welche – wie bei Frege und Russell – die Schlüsse rechtfertigen sollen, sind sinnlos, und wären überflüssig.\",\"pmc\":\"If <span class=\\\"mathmode\\\"><var>p</var></span> follows from <span class=\\\"mathmode\\\"><var>q</var></span>, I can make an inference from <span class=\\\"mathmode\\\"><var>q</var></span> to <span class=\\\"mathmode\\\"><var>p</var></span>, deduce <span class=\\\"mathmode\\\"><var>p</var></span> from <span class=\\\"mathmode\\\"><var>q</var></span>. The nature of the inference can be gathered only from the two propositions. They themselves are the only possible justification of the inference. ‘Laws of inference’, which are supposed to justify inferences, as in the works of Frege and Russell, have no sense, and would be superfluous.\",\"ogd\":\"If <span class=\\\"mathmode\\\"><var>p</var></span> follows from <span class=\\\"mathmode\\\"><var>q</var></span>, I can conclude from <span class=\\\"mathmode\\\"><var>q</var></span> to <span class=\\\"mathmode\\\"><var>p</var></span>; infer <span class=\\\"mathmode\\\"><var>p</var></span> from <span class=\\\"mathmode\\\"><var>q</var></span>. The method of inference is to be understood from the two propositions alone. Only they themselves can justify the inference. Laws of inference, which—as in Frege and Russell—are to justify the conclusions, are senseless and would be superfluous.\",\"str\":\"\"},{\"label\":\"5.142\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":11,\"x_axis\":85,\"ger\":\"Die Tautologie folgt aus allen Sätzen: sie sagt nichts.\",\"pmc\":\"A tautology follows from all propositions: it says nothing.\",\"ogd\":\"A tautology follows from all propositions: it says nothing.\",\"str\":\"\"},{\"label\":\"5.152\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":11,\"x_axis\":91,\"ger\":\"Sätze, welche keine Wahrheitsargumente mit einander gemein haben, nennen wir von einander unabhängig. Zwei Elementarsätze geben einander die Wahrscheinlichkeit <span class=\\\"mathmode\\\">½</span>. Folgt <span class=\\\"mathmode\\\"><var>p</var></span> aus <span class=\\\"mathmode\\\"><var>q</var></span>, so gibt der Satz „<span class=\\\"mathmode\\\"><var>q</var></span>“ dem Satz „<span class=\\\"mathmode\\\"><var>p</var></span>“ die Wahrscheinlichkeit 1. Die Gewissheit des logischen Schlusses ist ein Grenzfall der Wahrscheinlichkeit. (Anwendung auf Tautologie und Kontradiktion.)\",\"pmc\":\"When propositions have no truth-arguments in common with one another, we call them independent of one another. Two elementary propositions give one another the probability <span class=\\\"mathmode\\\">½</span>. If <span class=\\\"mathmode\\\"><var>p</var></span> follows from <span class=\\\"mathmode\\\"><var>q</var></span>, then the proposition ‘<span class=\\\"mathmode\\\"><var>q</var></span>’ gives to the proposition ‘<span class=\\\"mathmode\\\"><var>p</var></span>’ the probability 1. The certainty of logical inference is a limiting case of probability. (Application of this to tautology and contradiction.)\",\"ogd\":\"Propositions which have no truth-arguments in common with one another we call independent. Independent propositions (<em>e.g.</em> any two elementary propositions) give to one another the probability <span class=\\\"mathmode\\\">½</span>. If <span class=\\\"mathmode\\\"><var>p</var></span> follows from <span class=\\\"mathmode\\\"><var>q</var></span>, the proposition <span class=\\\"mathmode\\\"><var>q</var></span> gives to the proposition <span class=\\\"mathmode\\\"><var>p</var></span> the probability 1. The certainty of logical conclusion is a limiting case of probability. (Application to tautology and contradiction.)\",\"str\":\"\"},{\"label\":\"6.1\",\"precision\":1,\"fontSize\":\"40px\",\"y_axis\":11,\"x_axis\":107,\"ger\":\"Die Sätze der Logik sind Tautologien.\",\"pmc\":\"The propositions of logic are tautologies.\",\"ogd\":\"The propositions of logic are tautologies.\",\"str\":\"\"},{\"label\":\"6.11\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":11,\"x_axis\":109,\"ger\":\"Die Sätze der Logik sagen also nichts. (Sie sind die analytischen Sätze.)\",\"pmc\":\"Therefore the propositions of logic say nothing. (They are the analytic propositions.)\",\"ogd\":\"The propositions of logic therefore say nothing. (They are the analytical propositions.)\",\"str\":\"\"},{\"label\":\"6.12\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":11,\"x_axis\":111,\"ger\":\"Dass die Sätze der Logik Tautologien sind, das <em class=\\\"germph\\\">zeigt</em> die formalen – logischen – Eigenschaften der Sprache, der Welt. Dass ihre Bestandteile <em class=\\\"germph\\\">so</em> verknüpft eine Tautologie ergeben, das charakterisiert die Logik ihrer Bestandteile. Damit Sätze, auf bestimmte Art und Weise verknüpft, eine Tautologie ergeben, dazu müssen sie bestimmte Eigenschaften der Struktur haben. Dass sie <em class=\\\"germph\\\">so</em> verbunden eine Tautologie ergeben, zeigt also, dass sie diese Eigenschaften der Struktur besitzen.\",\"pmc\":\"The fact that the propositions of logic are tautologies <em>shows</em> the formal—logical—properties of language and the world. The fact that a tautology is yielded by <em>this particular way</em> of connecting its constituents characterizes the logic of its constituents. If propositions are to yield a tautology when they are connected in a certain way, they must have certain structural properties. So their yielding a tautology when combined <em>in this way</em> shows that they possess these structural properties.\",\"ogd\":\"The fact that the propositions of logic are tautologies <em>shows</em> the formal—logical—properties of language, of the world. That its constituent parts connected together <em>in this way</em> give a tautology characterizes the logic of its constituent parts. In order that propositions connected together in a definite way may give a tautology they must have definite properties of structure. That they give a tautology when <em>so</em> connected shows therefore that they possess these properties of structure.\",\"str\":\"\"},{\"label\":\"6.13\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":11,\"x_axis\":115,\"ger\":\"Die Logik ist keine Lehre, sondern ein Spiegelbild der Welt. Die Logik ist transzendental.\",\"pmc\":\"Logic is not a body of doctrine, but a mirror-image of the world. Logic is transcendental.\",\"ogd\":\"Logic is not a theory but a reflexion of the world. Logic is transcendental.\",\"str\":\"\"},{\"label\":\"2.024\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":13,\"x_axis\":21,\"ger\":\"Die Substanz ist das, was unabhängig von dem was der Fall ist, besteht.\",\"pmc\":\"The substance is what subsists independently of what is the case.\",\"ogd\":\"Substance is what exists independently of what is the case.\",\"str\":\"\"},{\"label\":\"2.02331\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":13,\"x_axis\":27,\"ger\":\"Entweder ein Ding hat Eigenschaften, die kein anderes hat, dann kann man es ohneweiteres durch eine Beschreibung aus den anderen herausheben, und darauf hinweisen; oder aber, es gibt mehrere Dinge, die ihre sämtlichen Eigenschaften gemeinsam haben, dann ist es überhaupt unmöglich auf eines von ihnen zu zeigen. Denn, ist das Ding durch nichts hervorgehoben, so kann ich es nicht hervorheben, denn sonst ist es eben hervorgehoben.\",\"pmc\":\"Either a thing has properties that nothing else has, in which case we can immediately use a description to distinguish it from the others and refer to it; or, on the other hand, there are several things that have the whole set of their properties in common, in which case it is quite impossible to indicate one of them. For if there is nothing to distinguish a thing, I cannot distinguish it, since otherwise it would be distinguished after all.\",\"ogd\":\"Either a thing has properties which no other has, and then one can distinguish it straight away from  the others by a description and refer to it; or, on the other hand, there are several things which have the totality of their properties in common, and then it is quite impossible to point to any one of them. For if a thing is not distinguished by anything, I cannot distinguish it—for otherwise it would be distinguished.\",\"str\":\"\"},{\"label\":\"3.141\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":13,\"x_axis\":45,\"ger\":\"Der Satz ist kein Wörtergemisch. – (Wie das musikalische Thema kein Gemisch von Tönen.) Der Satz ist artikuliert.\",\"pmc\":\"A proposition is not a blend of words.—(Just as a theme in music is not a blend of notes.) A proposition is articulate.\",\"ogd\":\"The proposition is not a mixture of words (just as the musical theme is not a mixture of tones). The proposition is articulate.\",\"str\":\"\"},{\"label\":\"4.013\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":13,\"x_axis\":53,\"ger\":\"Und wenn wir in das Wesentliche dieser Bildhaftigkeit eindringen, so sehen wir, dass dieselbe durch <em class=\\\"germph\\\">scheinbare Unregelmäßigkeiten</em> (wie die Verwendung von <span class=\\\"mathmode\\\"><span class=\\\"symbol\\\">♯</span></span> und <span class=\\\"mathmode\\\"><span class=\\\"symbol\\\">♭</span></span> in der Notenschrift) <em class=\\\"germph\\\">nicht</em> gestört wird. Denn auch diese Unregelmäßigkeiten bilden das ab, was sie ausdrücken sollen; nur auf eine andere Art und Weise.\",\"pmc\":\"And if we penetrate to the essence of this pictorial character, we see that it is <em>not</em> impaired by <em>apparent irregularities</em> (such as the use of <span class=\\\"mathmode\\\"><span class=\\\"symbol\\\">♯</span></span> and <span class=\\\"mathmode\\\"><span class=\\\"symbol\\\">♭</span></span> in musical notation). For even these irregularities depict what they are intended to express; only they do it in a different way.\",\"ogd\":\"And if we penetrate to the essence of this pictorial nature we see that this is not disturbed by <em>apparent irregularities</em> (like the use of <span class=\\\"mathmode\\\"><span class=\\\"symbol\\\">♯</span></span> and <span class=\\\"mathmode\\\"><span class=\\\"symbol\\\">♭</span></span>  in the score). For these irregularities also picture what they are to express; only in another way.\",\"str\":\"\"},{\"label\":\"4.023\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":13,\"x_axis\":57,\"ger\":\"Die Wirklichkeit muss durch den Satz auf ja oder nein fixiert sein. Dazu muss sie durch ihn vollständig beschrieben werden. Der Satz ist die Beschreibung eines Sachverhaltes. Wie die Beschreibung einen Gegenstand nach seinen externen Eigenschaften, so beschreibt der Satz die Wirklichkeit nach ihren internen Eigenschaften. Der Satz konstruiert eine Welt mit Hilfe eines logischen Gerüstes und darum kann man am Satz auch sehen, wie sich alles Logische verhält, <em class=\\\"germph\\\">wenn</em> er wahr ist. Man kann aus einem falschen Satz <em class=\\\"germph\\\">Schlüsse ziehen</em>.\",\"pmc\":\"A proposition must restrict reality to two alternatives: yes or no. In order to do that, it must describe reality completely. A proposition is a description of a state of affairs. Just as a description of an object describes it by giving its external properties, so a proposition describes reality by its internal properties. A proposition constructs a world with the help of a logical scaffolding, so that one can actually see from the proposition how everything stands logically <em>if</em> it is true. One can <em>draw inferences</em> from a false proposition.\",\"ogd\":\"The proposition determines reality to this extent, that one only needs to say “Yes” or “No” to it to make it agree with reality. Reality must therefore be completely described by the proposition. A proposition is the description of a fact. As the description of an object describes it by its external properties so propositions describe reality by its internal properties. The proposition constructs a world with the help of a logical scaffolding, and therefore one can actually see in the proposition all the logical features possessed by reality <em>if</em> it is true. One can <em>draw conclusions</em> from a false proposition.\",\"str\":\"\"},{\"label\":\"4.063\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":13,\"x_axis\":71,\"ger\":\"Ein Bild zur Erklärung des Wahrheitsbegriffes: Schwarzer Fleck auf weißem Papier; die Form des Fleckes kann man beschreiben, indem man für jeden Punkt der Fläche angibt, ob er weiß oder schwarz ist. Der Tatsache, dass ein Punkt schwarz ist, entspricht eine positive – der, dass ein Punkt weiß (nicht schwarz) ist, eine negative Tatsache. Bezeichne ich einen Punkt der Fläche (einen Fregeschen Wahrheitswert), so entspricht dies der Annahme, die zur Beurteilung aufgestellt wird, etc. etc. Um aber sagen zu können, ein Punkt sei schwarz oder weiß, muss ich vorerst wissen, wann man einen Punkt schwarz und wann man ihn weiß nennt; um sagen zu können: „<span class=\\\"mathmode\\\"><var>p</var></span>“ ist wahr (oder falsch), muss ich bestimmt haben, unter welchen Umständen ich „<span class=\\\"mathmode\\\"><var>p</var></span>“ wahr nenne, und damit bestimme ich den Sinn des Satzes. Der Punkt, an dem das Gleichnis hinkt ist nun der: Wir können auf einen Punkt des Papiers zeigen, auch ohne zu wissen, was weiß und schwarz ist; einem Satz ohne Sinn aber entspricht gar nichts, denn er bezeichnet kein Ding (Wahrheitswert) dessen Eigenschaften etwa „falsch“ oder „wahr“ hießen; das Verbum eines Satzes ist nicht „ist wahr“ oder „ist falsch“ – wie Frege glaubte –, sondern das, was „wahr ist“, muss das Verbum schon enthalten.\",\"pmc\":\"An analogy to illustrate the concept of truth: imagine a black spot on white paper: you can describe the shape of the spot by saying, for each point on the sheet, whether it is black or white. To the fact that a point is black there corresponds a positive fact, and to the fact that a point is white (not black), a negative fact. If I designate a point on the sheet (a truth-value according to Frege), then this corresponds to the supposition that is put forward for judgement, etc. etc. But in order to be able to say that a point is black or white, I must first know when a point is called black, and when white: in order to be able to say, ‘“<span class=\\\"mathmode\\\"><var>p</var></span>” is true (or false)’, I must have determined in what circumstances I call ‘<span class=\\\"mathmode\\\"><var>p</var></span>’ true, and in so doing I determine the sense of the proposition. Now the point where the simile breaks down is this: we can indicate a point on the paper even if we do not know what black and white are, but if a proposition has no sense, nothing corresponds to it, since it does not designate a thing (a truth-value) which might have properties called ‘false’ or ‘true’. The verb of a proposition is not ‘is true’ or ‘is false’, as Frege thought: rather, that which ‘is true’ must already contain the verb.\",\"ogd\":\"An illustration to explain the concept of truth. A black spot on white paper; the form of the spot can be described by saying of each point of the plane whether it is white or black. To the fact that a point is black corresponds a positive fact; to the fact that a point is white (not black), a negative fact. If I indicate a point of the plane (a truth-value in Frege’s terminology), this corresponds to the assumption proposed for judgment, etc. etc. But to be able to say that a point is black or white, I must first know under what conditions a point is called white or black; in order to be able to say “<span class=\\\"mathmode\\\"><var>p</var></span>” is true (or false) I must have determined under what conditions I call “<span class=\\\"mathmode\\\"><var>p</var></span>” true, and thereby I determine the sense of the proposition. The point at which the simile breaks down is this: we can indicate a point on the paper, without knowing what white and black are; but to a proposition without a sense corresponds nothing at all, for it signifies no thing (truth-value) whose properties are called “false” or “true”; the verb of the proposition is not “is true” or “is false”—as Frege thought—but that which “is true” must already contain the verb.\",\"str\":\"\"},{\"label\":\"5.123\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":13,\"x_axis\":79,\"ger\":\"Wenn ein Gott eine Welt erschafft, worin gewisse Sätze wahr sind, so schafft er damit auch schon eine Welt, in welcher alle ihre Folgesätze stimmen. Und ähnlich könnte er keine Welt schaffen, worin der Satz „<span class=\\\"mathmode\\\"><var>p</var></span>“ wahr ist, ohne seine sämtlichen Gegenstände zu schaffen.\",\"pmc\":\"If a god creates a world in which certain propositions are true, then by that very act he also creates a world in which all the propositions that follow from them come true. And similarly he could not create a world in which the proposition ‘<span class=\\\"mathmode\\\"><var>p</var></span>’ was true without creating all its objects.\",\"ogd\":\"If a god creates a world in which certain propositions are true, he creates thereby also a world in which all propositions consequent on them are true. And similarly he could not create a world in which the proposition “<span class=\\\"mathmode\\\"><var>p</var></span>” is true without creating all its objects.\",\"str\":\"\"},{\"label\":\"5.133\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":13,\"x_axis\":83,\"ger\":\"Alles Folgern geschieht a priori.\",\"pmc\":\"All deductions are made <em>a priori</em>.\",\"ogd\":\"All inference takes place a priori.\",\"str\":\"\"},{\"label\":\"5.143\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":13,\"x_axis\":85,\"ger\":\"Die Kontradiktion ist das Gemeinsame der Sätze, was <em class=\\\"germph\\\">kein</em> Satz mit einem anderen gemein hat. Die Tautologie ist das Gemeinsame aller Sätze, welche nichts miteinander gemein haben. Die Kontradiktion verschwindet sozusagen außerhalb, die Tautologie innerhalb aller Sätze. Die Kontradiktion ist die äußere Grenze der Sätze, die Tautologie ihr substanzloser Mittelpunkt.\",\"pmc\":\"Contradiction is that common factor of propositions which <em>no</em> proposition has in common with another. Tautology is the common factor of all propositions that have nothing in common with one another. Contradiction, one might say, vanishes outside all propositions: tautology vanishes inside them. Contradiction is the outer limit of propositions: tautology is the unsubstantial point at their centre.\",\"ogd\":\"Contradiction is something shared by propositions, which <em>no</em> proposition has in common with another. Tautology is that which is shared by all propositions, which have nothing in common with one another. Contradiction vanishes so to speak outside, tautology inside all propositions. Contradiction is the external limit of the propositions, tautology their substanceless centre.\",\"str\":\"\"},{\"label\":\"5.153\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":13,\"x_axis\":91,\"ger\":\"Ein Satz ist an sich weder wahrscheinlich noch unwahrscheinlich. Ein Ereignis trifft ein, oder es trifft nicht ein, ein Mittelding gibt es nicht.\",\"pmc\":\"In itself, a proposition is neither probable nor improbable. Either an event occurs or it does not: there is no middle way.\",\"ogd\":\"A proposition is in itself neither probable nor improbable. An event occurs or does not occur, there is no middle course.\",\"str\":\"\"},{\"label\":\"6.111\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":13,\"x_axis\":109,\"ger\":\"Theorien, die einen Satz der Logik gehaltvoll erscheinen lassen, sind immer falsch. Man könnte z. B. glauben, dass die Worte „wahr“ und „falsch“ zwei Eigenschaften unter anderen Eigenschaften bezeichnen, und da erschiene es als eine merkwürdige Tatsache, dass jeder Satz eine dieser Eigenschaften besitzt. Das scheint nun nichts weniger als selbstverständlich zu sein, ebensowenig selbstverständlich, wie etwa der Satz: „Alle Rosen sind entweder gelb oder rot“ klänge, auch wenn er wahr wäre. Ja, jener Satz bekommt nun ganz den Charakter eines naturwissenschaftlichen Satzes, und dies ist das sichere Anzeichen dafür, dass er falsch aufgefasst wurde.\",\"pmc\":\"All theories that make a proposition of logic appear to have content are false. One might think, for example, that the words ‘true’ and ‘false’ signified two properties among other properties, and then it would seem to be a remarkable fact that every proposition possessed one of these properties. On this theory it seems to be anything but obvious, just as, for instance, the proposition, ‘All roses are either yellow or red’, would not sound obvious even if it were true. Indeed, the logical proposition acquires all the characteristics of a proposition of natural science and this is the sure sign that it has been construed wrongly.\",\"ogd\":\"Theories which make a proposition of logic appear substantial are always false. One could <em>e.g.</em> believe that the words “true” and “false” signify two properties among other properties, and then it would appear as a remarkable fact that every proposition possesses one of these properties. This now by no means appears self-evident, no more so than the proposition “All roses are either yellow or red” would seem even if it were true. Indeed our proposition now gets quite the character of a proposition of natural science and this is a certain symptom of its being falsely understood.\",\"str\":\"\"},{\"label\":\"6.1201\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":13,\"x_axis\":111,\"ger\":\"Dass z. B. die Sätze „<span class=\\\"mathmode\\\"><var>p</var></span>“ und „<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><var>p</var></span>“ in der Verbindung „<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span>(<var>p</var><span class=\\\"mathrel\\\">.</span><span class=\\\"mathop\\\">~</span><var>p</var>)</span>“ eine Tautologie ergeben, zeigt, dass sie einander widersprechen. Dass die Sätze „<span class=\\\"mathmode\\\"><var>p</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">⊃</span></span><var>q</var></span>“, „<span class=\\\"mathmode\\\"><var>p</var></span>“ und „<span class=\\\"mathmode\\\"><var>q</var></span>“ in der Form „<span class=\\\"mathmode\\\">(<var>p</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">⊃</span></span><var>q</var>)<span class=\\\"mathrel\\\">.</span>(<var>p</var>)<span class=\\\"mathrel\\\">:<span class=\\\"symbol\\\">⊃</span>:</span>(<var>q</var>)</span>“ miteinander verbunden eine Tautologie ergeben, zeigt, dass <span class=\\\"mathmode\\\"><var>q</var></span> aus <span class=\\\"mathmode\\\"><var>p</var></span> und <span class=\\\"mathmode\\\"><var>p</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">⊃</span></span><var>q</var></span> folgt. Dass „<span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<var>x</var>).</span><var>fx</var><span class=\\\"mathrel\\\">:<span class=\\\"symbol\\\">⊃</span>:</span><var>fa</var></span>“ eine Tautologie ist, dass <span class=\\\"mathmode\\\"><var>fa</var></span> aus <span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<var>x</var>).</span><var>fx</var></span> folgt. etc. etc.\",\"pmc\":\"For example, the fact that the propositions ‘<span class=\\\"mathmode\\\"><var>p</var></span>’ and ‘<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><var>p</var></span>’ in the combination ‘<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span>(<var>p</var><span class=\\\"mathrel\\\">.</span><span class=\\\"mathop\\\">~</span><var>p</var>)</span>’ yield a tautology shows that they contradict one another. The fact that the propositions ‘<span class=\\\"mathmode\\\"><var>p</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">⊃</span></span><var>q</var></span>’, ‘<span class=\\\"mathmode\\\"><var>p</var></span>’, and ‘<span class=\\\"mathmode\\\"><var>q</var></span>’, combined with one another in the form ‘<span class=\\\"mathmode\\\">(<var>p</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">⊃</span></span><var>q</var>)<span class=\\\"mathrel\\\">.</span>(<var>p</var>)<span class=\\\"mathrel\\\">:<span class=\\\"symbol\\\">⊃</span>:</span>(<var>q</var>)</span>’, yield a tautology shows that <span class=\\\"mathmode\\\"><var>q</var></span> follows from <span class=\\\"mathmode\\\"><var>p</var></span> and <span class=\\\"mathmode\\\"><var>p</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">⊃</span></span><var>q</var></span>. The fact that ‘<span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<var>x</var>).</span><var>fx</var><span class=\\\"mathrel\\\">:<span class=\\\"symbol\\\">⊃</span>:</span><var>fa</var></span>’ is a tautology shows that <span class=\\\"mathmode\\\"><var>fa</var></span> follows from <span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<var>x</var>).</span><var>fx</var></span>. Etc. etc.\",\"ogd\":\"That <em>e.g.</em> the propositions “<span class=\\\"mathmode\\\"><var>p</var></span>” and “<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><var>p</var></span>” in the connexion “<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span>(<var>p</var><span class=\\\"mathrel\\\">.</span><span class=\\\"mathop\\\">~</span><var>p</var>)</span>” give a tautology shows that they contradict one another. That the propositions “<span class=\\\"mathmode\\\"><var>p</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">⊃</span></span><var>q</var></span>”, “<span class=\\\"mathmode\\\"><var>p</var></span>” and “<span class=\\\"mathmode\\\"><var>q</var></span>” connected together in the form “<span class=\\\"mathmode\\\">(<var>p</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">⊃</span></span><var>q</var>)<span class=\\\"mathrel\\\">.</span>(<var>p</var>)<span class=\\\"mathrel\\\">:<span class=\\\"symbol\\\">⊃</span>:</span>(<var>q</var>)</span>” give a tautology shows that <span class=\\\"mathmode\\\"><var>q</var></span> follows from <span class=\\\"mathmode\\\"><var>p</var></span> and <span class=\\\"mathmode\\\"><var>p</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">⊃</span></span><var>q</var></span>. That “<span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<var>x</var>).</span><var>fx</var><span class=\\\"mathrel\\\">:<span class=\\\"symbol\\\">⊃</span>:</span><var>fa</var></span>” is a tautology shows that <span class=\\\"mathmode\\\"><var>fa</var></span> follows from <span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<var>x</var>).</span><var>fx</var></span>, etc. etc.\",\"str\":\"\"},{\"label\":\"6.121\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":13,\"x_axis\":113,\"ger\":\"Die Sätze der Logik demonstrieren die logischen Eigenschaften der Sätze, indem sie sie zu nichtssagenden Sätzen verbinden. Diese Methode könnte man auch eine Nullmethode nennen. Im logischen Satz werden Sätze miteinander ins Gleichgewicht gebracht und der Zustand des Gleichgewichts zeigt dann an, wie diese Sätze logisch beschaffen sein müssen.\",\"pmc\":\"The propositions of logic demonstrate the logical properties of propositions by combining them so as to form propositions that say nothing. This method could also be called a zero-method. In a logical proposition, propositions are brought into equilibrium with one another, and the state of equilibrium then indicates what the logical constitution of these propositions must be.\",\"ogd\":\"The propositions of logic demonstrate the logical properties of propositions, by combining them into propositions which say nothing. This method could be called a zero-method. In a logical proposition propositions are brought into equilibrium with one another, and the state of equilibrium then shows how these propositions must be logically constructed.\",\"str\":\"\"},{\"label\":\"2.025\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":15,\"x_axis\":21,\"ger\":\"Sie ist Form und Inhalt.\",\"pmc\":\"It is form and content.\",\"ogd\":\"It is form and content.\",\"str\":\"\"},{\"label\":\"2.0251\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":15,\"x_axis\":23,\"ger\":\"Raum, Zeit und Farbe (Färbigkeit) sind Formen der Gegenstände.\",\"pmc\":\"Space, time, colour (being coloured) are forms of objects.\",\"ogd\":\"Space, time and colour (colouredness) are forms of objects.\",\"str\":\"\"},{\"label\":\"3.142\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":15,\"x_axis\":45,\"ger\":\"Nur Tatsachen können einen Sinn ausdrücken, eine Klasse von Namen kann es nicht.\",\"pmc\":\"Only facts can express a sense, a set of names cannot.\",\"ogd\":\"Only facts can express a sense, a class of names cannot.\",\"str\":\"\"},{\"label\":\"4.014\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":15,\"x_axis\":53,\"ger\":\"Die Grammophonplatte, der musikalische Gedanke, die Notenschrift, die Schallwellen, stehen alle in jener abbildenden internen Beziehung zu einander, die zwischen Sprache und Welt besteht. Ihnen allen ist der logische Bau gemeinsam. (Wie im Märchen die zwei Jünglinge, ihre zwei Pferde und ihre Lilien. Sie sind alle in gewissem Sinne Eins.)\",\"pmc\":\"A gramophone record, the musical idea, the written notes, and the sound-waves, all stand to one another in the same internal relation of depicting that holds between language and the world. They are all constructed according to a common logical pattern. (Like the two youths in the fairy-tale, their two horses, and their lilies. They are all in a certain sense one.)\",\"ogd\":\"The gramophone record, the musical thought, the score, the waves of sound, all stand to one another in that pictorial internal relation, which holds between language and the world. To all of them the logical structure is common. (Like the two youths, their two horses and their lilies in the story. They are all in a certain sense one.)\",\"str\":\"\"},{\"label\":\"4.0141\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":15,\"x_axis\":55,\"ger\":\"Dass es eine allgemeine Regel gibt, durch die der Musiker aus der Partitur die Symphonie entnehmen kann, durch welche man aus der Linie auf der Grammophonplatte die Symphonie und nach der ersten Regel wieder die Partitur ableiten kann, darin besteht eben die innere Ähnlichkeit dieser scheinbar so ganz verschiedenen Gebilde. Und jene Regel ist das Gesetz der Projektion, welches die Symphonie in die Notensprache projiziert. Sie ist die Regel der Übersetzung der Notensprache in die Sprache der Grammophonplatte.\",\"pmc\":\"There is a general rule by means of which the musician can obtain the symphony from the score, and which makes it possible to derive the symphony from the groove on the gramophone record, and, using the first rule, to derive the score again. That is what constitutes the inner similarity between these things which seem to be constructed in such entirely different ways. And that rule is the law of projection which projects the symphony into the language of musical notation. It is the rule for translating this language into the language of gramophone records.\",\"ogd\":\"In the fact that there is a general rule by which the musician is able to read the symphony out of the score, and that there is a rule by which one could reconstruct the symphony from the line on a gramophone record and from this again—by means of the first rule—construct the score, herein lies the internal similarity between these things which at first sight seem to be entirely different. And the rule is the law of projection which projects the symphony into the language of the musical score. It is the rule of translation of this language into the language of the gramophone record.\",\"str\":\"\"},{\"label\":\"4.024\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":15,\"x_axis\":57,\"ger\":\"Einen Satz verstehen, heißt, wissen was der Fall ist, wenn er wahr ist. (Man kann ihn also verstehen, ohne zu wissen, ob er wahr ist.) Man versteht ihn, wenn man seine Bestandteile versteht.\",\"pmc\":\"To understand a proposition means to know what is the case if it is true. (One can understand it, therefore, without knowing whether it is true.) It is understood by anyone who understands its constituents.\",\"ogd\":\"To understand a proposition means to know what is the case, if it is true. (One can therefore understand it without knowing whether it is true or not.) One understands it if one understands it constituent parts.\",\"str\":\"\"},{\"label\":\"4.064\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":15,\"x_axis\":71,\"ger\":\"Jeder Satz muss <em class=\\\"germph\\\">schon</em> einen Sinn haben; die Bejahung kann ihn ihm nicht geben, denn sie bejaht ja gerade den Sinn. Und dasselbe gilt von der Verneinung, etc.\",\"pmc\":\"Every proposition must <em>already</em> have a sense: it cannot be given a sense by affirmation. Indeed its sense is just what is affirmed. And the same applies to negation, etc.\",\"ogd\":\"Every proposition must <em>already</em> have a sense; assertion cannot give it a sense, for what it asserts is the sense itself. And the same holds of denial, etc.\",\"str\":\"\"},{\"label\":\"4.0641\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":15,\"x_axis\":73,\"ger\":\"Man könnte sagen: Die Verneinung bezieht sich schon auf den logischen Ort, den der verneinte Satz bestimmt. Der verneinende Satz bestimmt einen <em class=\\\"germph\\\">anderen</em> logischen Ort als der verneinte. Der verneinende Satz bestimmt einen logischen Ort mit Hilfe des logischen Ortes des verneinten Satzes, indem er jenen als außerhalb diesem liegend beschreibt. Dass man den verneinten Satz wieder verneinen kann, zeigt schon, dass das, was verneint wird, schon ein Satz und nicht erst die Vorbereitung zu einem Satze ist.\",\"pmc\":\"One could say that negation must be related to the logical place determined by the negated proposition. The negating proposition determines a logical place <em>different</em> from that of the negated proposition. The negating proposition determines a logical place with the help of the logical place of the negated proposition. For it describes it as lying outside the latter’s logical place. The negated proposition can be negated again, and this in itself shows that what is negated is already a proposition, and not merely something that is preliminary to a proposition.\",\"ogd\":\"One could say, the denial is already related to the logical place determined by the proposition that is denied. The denying proposition determines a logical place <em>other</em> than does the proposition denied. The denying proposition determines a logical place, with the help of the logical place of the proposition denied, by saying that it lies outside the latter place. That one can deny again the denied proposition, shows that what is denied is already a proposition and not merely the preliminary to a proposition.\",\"str\":\"\"},{\"label\":\"5.124\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":15,\"x_axis\":79,\"ger\":\"Der Satz bejaht jeden Satz, der aus ihm folgt.\",\"pmc\":\"A proposition affirms every proposition that follows from it.\",\"ogd\":\"A proposition asserts every proposition which follows from it.\",\"str\":\"\"},{\"label\":\"5.1241\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":15,\"x_axis\":81,\"ger\":\"„<span class=\\\"mathmode\\\"><var>p</var><span class=\\\"mathrel\\\">.</span><var>q</var></span>“ ist einer der Sätze, welche „<span class=\\\"mathmode\\\"><var>p</var></span>“ bejahen, und zugleich einer der Sätze, welche „<span class=\\\"mathmode\\\"><var>q</var></span>“ bejahen. Zwei Sätze sind einander entgegengesetzt, wenn es keinen sinnvollen Satz gibt, der sie beide bejaht. Jeder Satz der einem anderen widerspricht, verneint ihn.\",\"pmc\":\"‘<span class=\\\"mathmode\\\"><var>p</var><span class=\\\"mathrel\\\">.</span><var>q</var></span>’ is one of the propositions that affirm ‘<span class=\\\"mathmode\\\"><var>p</var></span>’ and at the same time one of the propositions that affirm ‘<span class=\\\"mathmode\\\"><var>q</var></span>’. Two propositions are opposed to one another if there is no proposition with a sense, that affirms them both. Every proposition that contradicts another negates it.\",\"ogd\":\"“<span class=\\\"mathmode\\\"><var>p</var><span class=\\\"mathrel\\\">.</span><var>q</var></span>” is one of the propositions which assert “<span class=\\\"mathmode\\\"><var>p</var></span>” and at the same time one of the propositions which assert “<span class=\\\"mathmode\\\"><var>q</var></span>”. Two propositions are opposed to one another if there is no significant proposition which asserts them both. Every proposition which contradicts another, denies it.\",\"str\":\"\"},{\"label\":\"5.134\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":15,\"x_axis\":83,\"ger\":\"Aus einem Elementarsatz lässt sich kein anderer folgern.\",\"pmc\":\"One elementary proposition cannot be deduced from another.\",\"ogd\":\"From an elementary proposition no other can be inferred.\",\"str\":\"\"},{\"label\":\"5.154\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":15,\"x_axis\":91,\"ger\":\"In einer Urne seien gleichviel weiße und schwarze Kugeln (und keine anderen). Ich ziehe eine Kugel nach der anderen und lege sie wieder in die Urne zurück. Dann kann ich durch den Versuch feststellen, dass sich die Zahlen der gezogenen schwarzen und weißen Kugeln bei fortgesetztem Ziehen einander nähern. <em class=\\\"germph\\\">Das</em> ist also kein mathematisches Faktum. Wenn ich nun sage: Es ist gleich wahrscheinlich, dass ich eine weiße Kugel wie eine schwarze ziehen werde, so heißt das: Alle mir bekannten Umstände (die hypothetisch angenommenen Naturgesetze mitinbegriffen) geben dem Eintreffen des einen Ereignisses nicht <em class=\\\"germph\\\">mehr</em> Wahrscheinlichkeit als dem Eintreffen des anderen. Das heißt, sie geben – wie aus den obigen Erklärungen leicht zu entnehmen ist – jedem die Wahrscheinlichkeit <span class=\\\"mathmode\\\">½</span>. Was ich durch den Versuch bestätige ist, dass das Eintreffen der beiden Ereignisse von den Umständen, die ich nicht näher kenne, unabhängig ist.\",\"pmc\":\"Suppose that an urn contains black and white balls in equal numbers (and none of any other kind). I draw one ball after another, putting them back into the urn. By this experiment I can establish that the number of black balls drawn and the number of white balls drawn approximate to one another as the draw continues. So <em>this</em> is not a mathematical truth. Now, if I say, ‘The probability of my drawing a white ball is equal to the probability of my drawing a black one’, this means that all the circumstances that I know of (including the laws of nature assumed as hypotheses) give no <em>more</em> probability to the occurrence of the one event than to that of the other. That is to say, they give each the probability <span class=\\\"mathmode\\\">½</span>, as can easily be gathered from the above definitions. What I confirm by the experiment is that the occurrence of the two events is independent of the circumstances of which I have no more detailed knowledge.\",\"ogd\":\"In an urn there are equal numbers of white and black balls (and no others). I draw one ball after another and put them back in the urn. Then I can determine by the experiment that the numbers of the black and white balls which are drawn approximate as the drawing continues. So <em>this</em> is not a mathematical fact. If then, I say, It is equally probable that I should draw a white and a black ball, this means, All the circumstances known to me (including the natural laws hypothetically assumed) give to the occurrence of the one event no more probability than to the occurrence of the other. That is they give—as can easily be understood from the above explanations—to each the probability <span class=\\\"mathmode\\\">½</span>. What I can verify by the experiment is that the occurrence of the two events is independent of the circumstances with which I have no closer acquaintance.\",\"str\":\"\"},{\"label\":\"6.112\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":15,\"x_axis\":109,\"ger\":\"Die richtige Erklärung der logischen Sätze muss ihnen eine einzigartige Stellung unter allen Sätzen geben.\",\"pmc\":\"The correct explanation of the propositions of logic must assign to them a unique status among all propositions.\",\"ogd\":\"The correct explanation of logical propositions must give them a peculiar position among all propositions.\",\"str\":\"\"},{\"label\":\"6.1202\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":15,\"x_axis\":111,\"ger\":\"Es ist klar, dass man zu demselben Zweck statt der Tautologien auch die Kontradiktionen verwenden könnte.\",\"pmc\":\"It is clear that one could achieve the same purpose by using contradictions instead of tautologies.\",\"ogd\":\"It is clear that we could have used for this purpose contradictions instead of tautologies.\",\"str\":\"\"},{\"label\":\"6.122\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":15,\"x_axis\":113,\"ger\":\"Daraus ergibt sich, dass wir auch ohne die logischen Sätze auskommen können, da wir ja in einer entsprechenden Notation die formalen Eigenschaften der Sätze durch das bloße Ansehen dieser Sätze erkennen können.\",\"pmc\":\"It follows from this that we can actually do without logical propositions; for in a suitable notation we can in fact recognize the formal properties of propositions by mere inspection of the propositions themselves.\",\"ogd\":\"Whence it follows that we can get on without logical propositions, for we can recognize in an adequate notation the formal properties of the propositions by mere inspection.\",\"str\":\"\"},{\"label\":\"6.1221\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":15,\"x_axis\":115,\"ger\":\"Ergeben z. B. zwei Sätze „<span class=\\\"mathmode\\\"><var>p</var></span>“ und „<span class=\\\"mathmode\\\"><var>q</var></span>“ in der Verbindung „<span class=\\\"mathmode\\\"><var>p</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">⊃</span></span><var>q</var></span>“ eine Tautologie, so ist klar, dass <span class=\\\"mathmode\\\"><var>q</var></span> aus <span class=\\\"mathmode\\\"><var>p</var></span> folgt. Dass z. B. „<span class=\\\"mathmode\\\"><var>q</var></span>“ aus „<span class=\\\"mathmode\\\"><var>p</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">⊃</span></span><var>q</var><span class=\\\"mathrel\\\">.</span><var>p</var></span>“ folgt, ersehen wir aus diesen beiden Sätzen selbst, aber wir können es auch <em class=\\\"germph\\\">so</em> zeigen, indem wir sie zu „<span class=\\\"mathmode\\\"><var>p</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">⊃</span></span><var>q</var><span class=\\\"mathrel\\\">.</span><var>p</var><span class=\\\"mathrel\\\">:<span class=\\\"symbol\\\">⊃</span>:</span><var>q</var></span>“ verbinden und nun zeigen, dass dies eine Tautologie ist.\",\"pmc\":\"If, for example, two propositions ‘<span class=\\\"mathmode\\\"><var>p</var></span>’ and ‘<span class=\\\"mathmode\\\"><var>q</var></span>’ in the combination ‘<span class=\\\"mathmode\\\"><var>p</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">⊃</span></span><var>q</var></span>’ yield a tautology, then it is clear that <span class=\\\"mathmode\\\"><var>q</var></span> follows from <span class=\\\"mathmode\\\"><var>p</var></span>. For example, we see from the two propositions themselves that ‘<span class=\\\"mathmode\\\"><var>q</var></span>’ follows from ‘<span class=\\\"mathmode\\\"><var>p</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">⊃</span></span><var>q</var><span class=\\\"mathrel\\\">.</span><var>p</var></span>’, but it is also possible to show it in <em>this</em> way: we combine them to form ‘<span class=\\\"mathmode\\\"><var>p</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">⊃</span></span><var>q</var><span class=\\\"mathrel\\\">.</span><var>p</var><span class=\\\"mathrel\\\">:<span class=\\\"symbol\\\">⊃</span>:</span><var>q</var></span>’, and then show that this is a tautology.\",\"ogd\":\"If for example two propositions “<span class=\\\"mathmode\\\"><var>p</var></span>” and “<span class=\\\"mathmode\\\"><var>q</var></span>” give a tautology in the connexion “<span class=\\\"mathmode\\\"><var>p</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">⊃</span></span><var>q</var></span>”, then it is clear that <span class=\\\"mathmode\\\"><var>q</var></span> follows from <span class=\\\"mathmode\\\"><var>p</var></span>. <em>E.g.</em> that “<span class=\\\"mathmode\\\"><var>q</var></span>” follows from “<span class=\\\"mathmode\\\"><var>p</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">⊃</span></span><var>q</var><span class=\\\"mathrel\\\">.</span><var>p</var></span>” we see from these two propositions themselves, but we can also show it by combining them to “<span class=\\\"mathmode\\\"><var>p</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">⊃</span></span><var>q</var><span class=\\\"mathrel\\\">.</span><var>p</var><span class=\\\"mathrel\\\">:<span class=\\\"symbol\\\">⊃</span>:</span><var>q</var></span>” and then showing that this is a tautology.\",\"str\":\"\"},{\"label\":\"6.1222\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":15,\"x_axis\":117,\"ger\":\"Dies wirft ein Licht auf die Frage, warum die logischen Sätze nicht durch die Erfahrung bestätigt werden können, ebensowenig wie sie durch die Erfahrung widerlegt werden können. Nicht nur muss ein Satz der Logik durch keine mögliche Erfahrung widerlegt werden können, sondern er darf auch nicht durch eine solche bestätigt werden können.\",\"pmc\":\"This throws some light on the question why logical propositions cannot be confirmed by experience any more than they can be refuted by it. Not only must a proposition of logic be irrefutable by any possible experience, but it must also be unconfirmable by any possible experience.\",\"ogd\":\"This throws light on the question why logical propositions can no more be empirically confirmed than they can be empirically refuted. Not only must a proposition of logic be incapable of being contradicted by any possible experience, but it must also be incapable of being confirmed by any such.\",\"str\":\"\"},{\"label\":\"6.1223\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":15,\"x_axis\":119,\"ger\":\"Nun wird klar, warum man oft fühlte, als wären die „logischen Wahrheiten“ von uns zu „<em class=\\\"germph\\\">fordern</em>“: Wir können sie nämlich insofern fordern, als wir eine genügende Notation fordern können.\",\"pmc\":\"Now it becomes clear why people have often felt as if it were for us to ‘<em>postulate</em>’ the ‘truths of logic’. The reason is that we can postulate them in so far as we can postulate an adequate notation.\",\"ogd\":\"It now becomes clear why we often feel as though “logical truths” must be “<em>postulated</em>” by us. We can in fact postulate them in so far as we can postulate an adequate notation.\",\"str\":\"\"},{\"label\":\"6.1224\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":15,\"x_axis\":121,\"ger\":\"Es wird jetzt auch klar, warum die Logik die Lehre von den Formen und vom Schließen genannt wurde.\",\"pmc\":\"It also becomes clear now why logic was called the theory of forms and of inference.\",\"ogd\":\"It also becomes clear why logic has been called the theory of forms and of inference.\",\"str\":\"\"},{\"label\":\"2.026\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":17,\"x_axis\":21,\"ger\":\"Nur wenn es Gegenstände gibt, kann es eine feste Form der Welt geben.\",\"pmc\":\"There must be objects, if the world is to have unalterable form.\",\"ogd\":\"Only if there are objects can there be a fixed form of the world.\",\"str\":\"\"},{\"label\":\"3.143\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":17,\"x_axis\":45,\"ger\":\"Dass das Satzzeichen eine Tatsache ist, wird durch die gewöhnliche Ausdrucksform der Schrift oder des Druckes verschleiert. Denn im gedruckten Satz z. B. sieht das Satzzeichen nicht wesentlich verschieden aus vom Wort. (So war es möglich, dass Frege den Satz einen zusammengesetzten Namen nannte.)\",\"pmc\":\"Although a propositional sign is a fact, this is obscured by the usual form of expression in writing or print. For in a printed proposition, for example, no essential difference is apparent between a propositional sign and a word. (That is what made it possible for Frege to call a proposition a composite name.)\",\"ogd\":\"That the propositional sign is a fact is concealed by the ordinary form of expression, written or printed. For in the printed proposition, for example, the sign of a proposition does not appear essentially different from a word. (Thus it was possible for Frege to call the proposition a compounded name.)\",\"str\":\"\"},{\"label\":\"3.1431\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":17,\"x_axis\":47,\"ger\":\"Sehr klar wird das Wesen des Satzzeichens, wenn wir es uns, statt aus Schriftzeichen, aus räumlichen Gegenständen (etwa Tischen, Stühlen, Büchern) zusammengesetzt denken. Die gegenseitige räumliche Lage dieser Dinge drückt dann den Sinn des Satzes aus.\",\"pmc\":\"The essence of a propositional sign is very clearly seen if we imagine one composed of spatial objects (such as tables, chairs, and books) instead of written signs. Then the spatial arrangement of these things will express the sense of the proposition.\",\"ogd\":\"The essential nature of the propositional sign becomes very clear when we imagine it made up of spatial objects (such as tables, chairs, books) instead of written signs. The mutual spatial position of these things then expresses the sense of the proposition.\",\"str\":\"\"},{\"label\":\"3.1432\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":17,\"x_axis\":49,\"ger\":\"Nicht: „Das komplexe Zeichen ‚<span class=\\\"mathmode\\\"><var>aRb</var></span>‘ sagt, dass <span class=\\\"mathmode\\\"><var>a</var></span> in der Beziehung <span class=\\\"mathmode\\\"><var>R</var></span> zu <span class=\\\"mathmode\\\"><var>b</var></span> steht“, sondern: <em class=\\\"germph\\\">Dass</em> „<span class=\\\"mathmode\\\"><var>a</var></span>“ in einer gewissen Beziehung zu „<span class=\\\"mathmode\\\"><var>b</var></span>“ steht, sagt, <em class=\\\"germph\\\">dass</em> <span class=\\\"mathmode\\\"><var>aRb</var></span>.\",\"pmc\":\"Instead of, ‘The complex sign “<span class=\\\"mathmode\\\"><var>aRb</var></span>” says that <span class=\\\"mathmode\\\"><var>a</var></span> stands to <span class=\\\"mathmode\\\"><var>b</var></span> in\\nthe relation <span class=\\\"mathmode\\\"><var>R</var></span>’, we ought to put, ‘<em>That</em> “<span class=\\\"mathmode\\\"><var>a</var></span>” stands to “<span class=\\\"mathmode\\\"><var>b</var></span>” in a certain\\nrelation says <em>that</em> <span class=\\\"mathmode\\\"><var>aRb</var></span>.’\",\"ogd\":\"We must not say, “The complex sign ‘<span class=\\\"mathmode\\\"><var>aRb</var></span>’ says ‘<span class=\\\"mathmode\\\"><var>a</var></span> stands in relation <span class=\\\"mathmode\\\"><var>R</var></span> to <span class=\\\"mathmode\\\"><var>b</var></span>’”; but we must say, “<em>That</em> ‘<span class=\\\"mathmode\\\"><var>a</var></span>’ stands in a certain relation to ‘<span class=\\\"mathmode\\\"><var>b</var></span>’ says <em>that</em> <span class=\\\"mathmode\\\"><var>aRb</var></span>”.\",\"str\":\"\"},{\"label\":\"4.015\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":17,\"x_axis\":53,\"ger\":\"Die Möglichkeit aller Gleichnisse, der ganzen Bildhaftigkeit unserer Ausdrucksweise, ruht in der Logik der Abbildung.\",\"pmc\":\"The possibility of all imagery, of all our pictorial modes of expression, is contained in the logic of depiction.\",\"ogd\":\"The possibility of all similes, of all the images of our language, rests on the logic of representation.\",\"str\":\"\"},{\"label\":\"4.025\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":17,\"x_axis\":57,\"ger\":\"Die Übersetzung einer Sprache in eine andere geht nicht so vor sich, dass man jeden <em class=\\\"germph\\\">Satz</em> der einen in einen <em class=\\\"germph\\\">Satz</em> der anderen übersetzt, sondern nur die Satzbestandteile werden übersetzt. (Und das Wörterbuch übersetzt nicht nur Substantiva, sondern auch Zeit-, Eigenschafts- und Bindewörter etc.; und es behandelt sie alle gleich.)\",\"pmc\":\"When translating one language into another, we do not proceed by translating each <em>proposition</em> of the one into a <em>proposition</em> of the other, but merely by translating the constituents of propositions. (And the dictionary translates not only substantives, but also verbs, adjectives, and conjunctions, etc.; and it treats them all in the same way.)\",\"ogd\":\"The translation of one language into another is not a process of translating each proposition of the one into a proposition of the other, but only the constituent parts of propositions are translated. (And the dictionary does not only translate substantives but also adverbs and conjunctions, etc., and it treats them all alike.)\",\"str\":\"\"},{\"label\":\"5.135\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":17,\"x_axis\":83,\"ger\":\"Auf keine Weise kann aus dem Bestehen irgend einer Sachlage auf das Bestehen einer von ihr gänzlich verschiedenen Sachlage geschlossen werden.\",\"pmc\":\"There is no possible way of making an inference from the existence of one situation to the existence of another, entirely different situation.\",\"ogd\":\"In no way can an inference be made from the existence of one state of affairs to the existence of another entirely different from it.\",\"str\":\"\"},{\"label\":\"5.155\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":17,\"x_axis\":91,\"ger\":\"Die Einheit des Wahrscheinlichkeitssatzes ist: Die Umstände – die ich sonst nicht weiter kenne – geben dem Eintreffen eines bestimmten Ereignisses den und den Grad der Wahrscheinlichkeit.\",\"pmc\":\"The minimal unit for a probability proposition is this: The circumstances—of which I have no further knowledge—give such and such a degree of probability to the occurrence of a particular event.\",\"ogd\":\"The unit of the probability proposition is: The circumstances—with which I am not further acquainted—give to the occurrence of a definite event such and such a degree of probability.\",\"str\":\"\"},{\"label\":\"6.113\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":17,\"x_axis\":109,\"ger\":\"Es ist das besondere Merkmal der logischen Sätze, dass man am Symbol allein erkennen kann, dass sie wahr sind, und diese Tatsache schließt die ganze Philosophie der Logik in sich. Und so ist es auch eine der wichtigsten Tatsachen, dass sich die Wahrheit oder Falschheit der nichtlogischen Sätze <em class=\\\"germph\\\">nicht</em> am Satz allein erkennen lässt.\",\"pmc\":\"It is the peculiar mark of logical propositions that one can recognize that they are true from the symbol alone, and this fact contains in itself the whole philosophy of logic. And so too it is a very important fact that the truth or falsity of non-logical propositions <em>cannot</em> be recognized from the propositions alone.\",\"ogd\":\"It is the characteristic mark of logical propositions that one can perceive in the symbol alone that they are true; and this fact contains in itself the whole philosophy of logic. And so also it is one of the most important facts that the truth or falsehood of non-logical propositions can <em>not</em> be recognized from the propositions alone.\",\"str\":\"\"},{\"label\":\"6.1203\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":17,\"x_axis\":111,\"ger\":\"Um eine Tautologie als solche zu erkennen, kann man sich, in den Fällen, in welchen in der Tautologie keine Allgemeinheitsbezeichnung vorkommt, folgender anschaulichen Methode bedienen: Ich schreibe statt „<span class=\\\"mathmode\\\"><var>p</var></span>“, „<span class=\\\"mathmode\\\"><var>q</var></span>“, „<span class=\\\"mathmode\\\"><var>r</var></span>“ etc. „<span class=\\\"mathmode\\\"><span class=\\\"mathrm\\\">W</span> <var>p</var> <span class=\\\"mathrm\\\">F</span></span>“, „<span class=\\\"mathmode\\\"><span class=\\\"mathrm\\\">W</span> <var>q</var> <span class=\\\"mathrm\\\">F</span></span>“, „<span class=\\\"mathmode\\\"><span class=\\\"mathrm\\\">W</span> <var>r</var> <span class=\\\"mathrm\\\">F</span></span>“ etc. Die Wahrheitskombinationen drücke ich durch Klammern aus, z. B.: <!-- noindent --><div class=\\\"centered\\\"><object data=\\\"../images/abfigureonegerman.svg\\\" type=\\\"image/svg+xml\\\" width=\\\"158\\\" height=\\\"69\\\" style=\\\"width: 158pt; height: 69pt;\\\"><img src=\\\"images/abfigureonegerman.png\\\" alt=\\\"[TF figure]\\\" /></object></div> <!-- noindent --> und die Zuordnung der Wahr- oder Falschheit des ganzen Satzes und der Wahrheitskombinationen der Wahrheitsargumente durch Striche auf folgende Weise: <!-- noindent --><div class=\\\"centered\\\"><object data=\\\"../images/abfiguretwogerman.svg\\\" type=\\\"image/svg+xml\\\" width=\\\"158\\\" height=\\\"124\\\" style=\\\"width: 158pt; height: 124pt;\\\"><img src=\\\"images/abfiguretwogerman.png\\\" alt=\\\"[TF figure]\\\" /></object></div> <!-- noindent --> Dies Zeichen würde also z. B. den Satz <span class=\\\"mathmode\\\"><var>p</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">⊃</span></span><var>q</var></span> darstellen. Nun will ich z. B. den Satz <span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span>(<var>p</var><span class=\\\"mathrel\\\">.</span><span class=\\\"mathop\\\">~</span><var>p</var>)</span> (Gesetz des Widerspruchs) daraufhin untersuchen, ob er eine Tautologie ist. Die Form „<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><var>ξ</var></span>“ wird in unserer Notation <!-- noindent --><div class=\\\"centered\\\"><object data=\\\"../images/abfigurethreegerman.svg\\\" type=\\\"image/svg+xml\\\" width=\\\"49\\\" height=\\\"75\\\" style=\\\"width: 49pt; height: 75pt;\\\"><img src=\\\"images/abfigurethreegerman.png\\\" alt=\\\"[TF figure]\\\" /></object></div> <!-- noindent --> geschrieben; die Form „<span class=\\\"mathmode\\\"><var>ξ</var><span class=\\\"mathrel\\\">.</span><var>η</var></span>“ so: <!-- noindent --><div class=\\\"centered\\\"><object data=\\\"../images/abfigurefourgerman.svg\\\" type=\\\"image/svg+xml\\\" width=\\\"158\\\" height=\\\"116\\\" style=\\\"width: 158pt; height: 116pt;\\\"><img src=\\\"images/abfigurefourgerman.png\\\" alt=\\\"[TF figure]\\\" /></object></div> <!-- noindent -->Daher lautet der Satz <span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span>(<var>p</var><span class=\\\"mathrel\\\">.</span><span class=\\\"mathop\\\">~</span><var>q</var>)</span> so: <!-- noindent --><div class=\\\"centered\\\"><object data=\\\"../images/abfigurefivegerman.svg\\\" type=\\\"image/svg+xml\\\" width=\\\"133\\\" height=\\\"168\\\" style=\\\"width: 133pt; height: 168pt;\\\"><img src=\\\"images/abfigurefivegerman.png\\\" alt=\\\"[TF figure]\\\" /></object></div> <!-- noindent --> Setzen wir statt „<span class=\\\"mathmode\\\"><var>q</var></span>“ „<span class=\\\"mathmode\\\"><var>p</var></span>“ ein und untersuchen die Verbindung der äußersten W und F mit den innersten, so ergibt sich, dass die Wahrheit des ganzen Satzes <em class=\\\"germph\\\">allen</em> Wahrheitskombinationen seines Argumentes, seine Falschheit keiner der Wahrheitskombinationen zugeordnet ist.\",\"pmc\":\"In order to recognize an expression as a tautology, in cases where no generality-sign occurs in it, one can employ the following intuitive method: instead of ‘<span class=\\\"mathmode\\\"><var>p</var></span>’, ‘<span class=\\\"mathmode\\\"><var>q</var></span>’, ‘<span class=\\\"mathmode\\\"><var>r</var></span>’, etc. I write ‘<span class=\\\"mathmode\\\"><span class=\\\"mathrm\\\">T</span> <var>p</var> <span class=\\\"mathrm\\\">F</span></span>’, ‘<span class=\\\"mathmode\\\"><span class=\\\"mathrm\\\">T</span> <var>q</var> <span class=\\\"mathrm\\\">F</span></span>’, ‘<span class=\\\"mathmode\\\"><span class=\\\"mathrm\\\">T</span> <var>r</var> <span class=\\\"mathrm\\\">F</span></span>’, etc. Truth-combinations I express by means of brackets, e.g. <!-- noindent --><div class=\\\"centered\\\"><object data=\\\"../images/abfigureoneenglishpmc.svg\\\" type=\\\"image/svg+xml\\\" width=\\\"157\\\" height=\\\"69\\\" style=\\\"width: 157pt; height: 69pt;\\\"><img src=\\\"images/abfigureoneenglishpmc.png\\\" alt=\\\"[TF figure]\\\" /></object></div> <!-- noindent --> and I use lines to express the correlation of the truth or falsity of the whole proposition with the truth-combinations of its truth-arguments, in the following way <!-- noindent --><div class=\\\"centered\\\"><object data=\\\"../images/abfiguretwoenglishpmc.svg\\\" type=\\\"image/svg+xml\\\" width=\\\"157\\\" height=\\\"124\\\" style=\\\"width: 157pt; height: 124pt;\\\"><img src=\\\"images/abfiguretwoenglishpmc.png\\\" alt=\\\"[TF figure]\\\" /></object></div> <!-- noindent --> So this sign, for instance, would represent the proposition <span class=\\\"mathmode\\\"><var>p</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">⊃</span></span><var>q</var></span>. Now, by way of example, I wish to examine the proposition <span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span>(<var>p</var><span class=\\\"mathrel\\\">.</span><span class=\\\"mathop\\\">~</span><var>p</var>)</span> (the law of contradiction) in order to determine whether it is a tautology. In our notation the form ‘<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><var>ξ</var></span>’ is written as <!-- noindent --><div class=\\\"centered\\\"><object data=\\\"../images/abfigurethreeenglishpmc.svg\\\" type=\\\"image/svg+xml\\\" width=\\\"46\\\" height=\\\"75\\\" style=\\\"width: 46pt; height: 75pt;\\\"><img src=\\\"images/abfigurethreeenglishpmc.png\\\" alt=\\\"[TF figure]\\\" /></object></div> <!-- noindent --> and the form ‘<span class=\\\"mathmode\\\"><var>ξ</var><span class=\\\"mathrel\\\">.</span><var>η</var></span>’ as <!-- noindent --><div class=\\\"centered\\\"><object data=\\\"../images/abfigurefourenglishpmc.svg\\\" type=\\\"image/svg+xml\\\" width=\\\"157\\\" height=\\\"116\\\" style=\\\"width: 157pt; height: 116pt;\\\"><img src=\\\"images/abfigurefourenglishpmc.png\\\" alt=\\\"[TF figure]\\\" /></object></div> <!-- noindent --> Hence the proposition <span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span>(<var>p</var><span class=\\\"mathrel\\\">.</span><span class=\\\"mathop\\\">~</span><var>q</var>)</span> reads as follows <!-- noindent --><div class=\\\"centered\\\"><object data=\\\"../images/abfigurefiveenglishpmc.svg\\\" type=\\\"image/svg+xml\\\" width=\\\"129\\\" height=\\\"168\\\" style=\\\"width: 129pt; height: 168pt;\\\"><img src=\\\"images/abfigurefiveenglishpmc.png\\\" alt=\\\"[TF figure]\\\" /></object></div> <!-- noindent --> If we here substitute ‘<span class=\\\"mathmode\\\"><var>p</var></span>’ for ‘<span class=\\\"mathmode\\\"><var>q</var></span>’ and examine how the outermost T and F are connected with the innermost ones, the result will be that the truth of the whole proposition is correlated with <em>all</em> the truth-combinations of its argument, and its falsity with none of the truth-combinations.\",\"ogd\":\"In order to recognize a tautology as such, we can, in cases in which no sign of generality occurs in the tautology, make use of the following intuitive method: I write instead of “<span class=\\\"mathmode\\\"><var>p</var></span>”, “<span class=\\\"mathmode\\\"><var>q</var></span>”, “<span class=\\\"mathmode\\\"><var>r</var></span>”, etc., “<span class=\\\"mathmode\\\"><span class=\\\"mathrm\\\">T</span> <var>p</var> <span class=\\\"mathrm\\\">F</span></span>”, “<span class=\\\"mathmode\\\"><span class=\\\"mathrm\\\">T</span> <var>q</var> <span class=\\\"mathrm\\\">F</span></span>”, “<span class=\\\"mathmode\\\"><span class=\\\"mathrm\\\">T</span> <var>r</var> <span class=\\\"mathrm\\\">F</span></span>”, etc. The truth-combinations I express by brackets, <em>e.g.</em>: <!-- noindent --><div class=\\\"centered\\\"><object data=\\\"../images/abfigureoneenglish.svg\\\" type=\\\"image/svg+xml\\\" width=\\\"156\\\" height=\\\"69\\\" style=\\\"width: 156pt; height: 69pt;\\\"><img src=\\\"images/abfigureoneenglish.png\\\" alt=\\\"[TF figure]\\\" /></object></div> <!-- noindent --> and the co-ordination of the truth or falsity of the whole proposition with the truth-combinations of the truth-arguments by lines in the following way: <!-- noindent --><div class=\\\"centered\\\"><object data=\\\"../images/abfiguretwoenglish.svg\\\" type=\\\"image/svg+xml\\\" width=\\\"156\\\" height=\\\"124\\\" style=\\\"width: 156pt; height: 124pt;\\\"><img src=\\\"images/abfiguretwoenglish.png\\\" alt=\\\"[TF figure]\\\" /></object></div> <!-- noindent --> This sign, for example, would therefore present the proposition <span class=\\\"mathmode\\\"><var>p</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">⊃</span></span><var>q</var></span>. Now I will proceed to inquire whether such a proposition as <span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span>(<var>p</var><span class=\\\"mathrel\\\">.</span><span class=\\\"mathop\\\">~</span><var>p</var>)</span> (The Law of Contradiction) is a tautology. The form “<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><var>ξ</var></span>” is written in our notation <!-- noindent --><div class=\\\"centered\\\"><object data=\\\"../images/abfigurethreeenglish.svg\\\" type=\\\"image/svg+xml\\\" width=\\\"47\\\" height=\\\"75\\\" style=\\\"width: 47pt; height: 75pt;\\\"><img src=\\\"images/abfigurethreeenglish.png\\\" alt=\\\"[TF figure]\\\" /></object></div> <!-- noindent --> the form “<span class=\\\"mathmode\\\"><var>ξ</var><span class=\\\"mathrel\\\">.</span><var>η</var></span>” thus:— <!-- noindent --><div class=\\\"centered\\\"><object data=\\\"../images/abfigurefourenglish.svg\\\" type=\\\"image/svg+xml\\\" width=\\\"156\\\" height=\\\"116\\\" style=\\\"width: 156pt; height: 116pt;\\\"><img src=\\\"images/abfigurefourenglish.png\\\" alt=\\\"[TF figure]\\\" /></object></div> <!-- noindent -->Hence the proposition <span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span>(<var>p</var><span class=\\\"mathrel\\\">.</span><span class=\\\"mathop\\\">~</span><var>q</var>)</span> runs thus:— <!-- noindent --><div class=\\\"centered\\\"><object data=\\\"../images/abfigurefiveenglish.svg\\\" type=\\\"image/svg+xml\\\" width=\\\"129\\\" height=\\\"168\\\" style=\\\"width: 129pt; height: 168pt;\\\"><img src=\\\"images/abfigurefiveenglish.png\\\" alt=\\\"[TF figure]\\\" /></object></div> <!-- noindent --> If here we put “<span class=\\\"mathmode\\\"><var>p</var></span>” instead of “<span class=\\\"mathmode\\\"><var>q</var></span>” and examine the combination of the outermost T and F with the innermost, it is seen that the truth of the whole proposition is co-ordinated with <em>all</em> the truth-combinations of its argument, its falsity with none of the truth-combinations.\",\"str\":\"\"},{\"label\":\"6.123\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":17,\"x_axis\":113,\"ger\":\"Es ist klar: Die logischen Gesetze dürfen nicht selbst wieder logischen Gesetzen unterstehen. (Es gibt nicht, wie Russell meinte, für jede „Type“ ein eigenes Gesetz des Widerspruches, sondern Eines genügt, da es auf sich selbst nicht angewendet wird.)\",\"pmc\":\"Clearly the laws of logic cannot in their turn be subject to laws of logic. (There is not, as Russell thought, a special law of contradiction for each ‘type’; one law is enough, since it is not applied to itself.)\",\"ogd\":\"It is clear that the laws of logic cannot themselves obey further logical laws. (There is not, as Russell supposed, for every “type” a special law of contradiction; but one is sufficient, since it is not applied to itself.)\",\"str\":\"\"},{\"label\":\"6.1231\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":17,\"x_axis\":115,\"ger\":\"Das Anzeichen des logischen Satzes ist <em class=\\\"germph\\\">nicht</em> die Allgemeingültigkeit. Allgemein sein heißt ja nur: zufälligerweise für alle Dinge gelten. Ein unverallgemeinerter Satz kann ja ebensowohl tautologisch sein als ein verallgemeinerter.\",\"pmc\":\"The mark of a logical proposition is <em>not</em> general validity. To be general means no more than to be accidentally valid for all things. An ungeneralized proposition can be tautological just as well as a generalized one.\",\"ogd\":\"The mark of logical propositions is not their general validity. To be general is only to be accidentally valid for all things. An ungeneralized proposition can be tautologous just as well as a generalized one.\",\"str\":\"\"},{\"label\":\"6.1232\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":17,\"x_axis\":117,\"ger\":\"Die logische Allgemeingültigkeit könnte man wesentlich nennen, im Gegensatz zu jener zufälligen, etwa des Satzes: „Alle Menschen sind sterblich“. Sätze wie Russells „Axiom of Reducibility“ sind nicht logische Sätze, und dies erklärt unser Gefühl: Dass sie, wenn wahr, so doch nur durch einen günstigen Zufall wahr sein könnten.\",\"pmc\":\"The general validity of logic might be called essential, in contrast with the accidental general validity of such propositions as ‘All men are mortal’. Propositions like Russell’s ‘axiom of reducibility’ are not logical propositions, and this explains our feeling that, even if they were true, their truth could only be the result of a fortunate accident.\",\"ogd\":\"Logical general validity, we could call essential as opposed to accidental general validity, <em>e.g.</em> of the proposition “all men are mortal”. Propositions like Russell’s “axiom of reducibility” are not logical propositions, and this explains our feeling that, if true, they can only be true by a happy chance.\",\"str\":\"\"},{\"label\":\"6.1233\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":17,\"x_axis\":119,\"ger\":\"Es lässt sich eine Welt denken, in der das Axiom of Reducibility nicht gilt. Es ist aber klar, dass die Logik nichts mit der Frage zu schaffen hat, ob unsere Welt wirklich so ist oder nicht.\",\"pmc\":\"It is possible to imagine a world in which the axiom of reducibility is not valid. It is clear, however, that logic has nothing to do with the question whether our world really is like that or not.\",\"ogd\":\"We can imagine a world in which the axiom of reducibility is not valid. But it is clear that logic has nothing to do with the question whether our world is really of this kind or not.\",\"str\":\"\"},{\"label\":\"2.027\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":19,\"x_axis\":21,\"ger\":\"Das Feste, das Bestehende und der Gegenstand sind Eins.\",\"pmc\":\"Objects, the unalterable, and the subsistent are one and the same.\",\"ogd\":\"The fixed, the existent and the object are one.\",\"str\":\"\"},{\"label\":\"2.0271\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":19,\"x_axis\":23,\"ger\":\"Der Gegenstand ist das Feste, Bestehende; die Konfiguration ist das Wechselnde, Unbeständige.\",\"pmc\":\"Objects are what is unalterable and subsistent; their configuration is what is changing and unstable.\",\"ogd\":\"The object is the fixed, the existent; the configuration is the changing, the variable.\",\"str\":\"\"},{\"label\":\"2.0272\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":19,\"x_axis\":25,\"ger\":\"Die Konfiguration der Gegenstände bildet den Sachverhalt.\",\"pmc\":\"The configuration of objects produces states of affairs.\",\"ogd\":\"The configuration of the objects forms the atomic fact.\",\"str\":\"\"},{\"label\":\"3.144\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":19,\"x_axis\":45,\"ger\":\"Sachlagen kann man beschreiben, nicht <em class=\\\"germph\\\">benennen</em>. (Namen gleichen Punkten, Sätze Pfeilen, sie haben Sinn.)\",\"pmc\":\"Situations can be described but not <em>given names</em>. (Names are like points; propositions like arrows—they have sense.)\",\"ogd\":\"States of affairs can be described but not <em>named</em>. (Names resemble points; propositions resemble arrows, they have sense.)\",\"str\":\"\"},{\"label\":\"4.016\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":19,\"x_axis\":53,\"ger\":\"Um das Wesen des Satzes zu verstehen, denken wir an die Hieroglyphenschrift, welche die Tatsachen die sie beschreibt abbildet. Und aus ihr wurde die Buchstabenschrift, ohne das Wesentliche der Abbildung zu verlieren.\",\"pmc\":\"In order to understand the essential nature of a proposition, we should consider hieroglyphic script, which depicts the facts that it describes. And alphabetic script developed out of it without losing what was essential to depiction.\",\"ogd\":\"In order to understand the essence of the proposition, consider hieroglyphic writing, which pictures the facts it describes. And from it came the alphabet without the essence of the representation being lost.\",\"str\":\"\"},{\"label\":\"4.026\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":19,\"x_axis\":57,\"ger\":\"Die Bedeutung der einfachen Zeichen (der Wörter) müssen uns erklärt werden, dass wir sie verstehen. Mit den Sätzen aber verständigen wir uns.\",\"pmc\":\"The meanings of simple signs (words) must be explained to us if we are to understand them. With propositions, however, we make ourselves understood.\",\"ogd\":\"The meanings of the simple signs (the words) must be explained to us, if we are to understand them. By means of propositions we explain ourselves.\",\"str\":\"\"},{\"label\":\"5.136\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":19,\"x_axis\":83,\"ger\":\"Einen Kausalnexus, der einen solchen Schluss rechtfertigte, gibt es nicht.\",\"pmc\":\"There is no causal nexus to justify such an inference.\",\"ogd\":\"There is no causal nexus which justifies such an inference.\",\"str\":\"\"},{\"label\":\"5.1361\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":19,\"x_axis\":85,\"ger\":\"Die Ereignisse der Zukunft <em class=\\\"germph\\\">können</em> wir nicht aus den gegenwärtigen erschließen. Der Glaube an den Kausalnexus ist der <em class=\\\"germph\\\">Aberglaube</em>.\",\"pmc\":\"We <em>cannot</em> infer the events of the future from those of the present. Superstition is nothing but belief in the causal nexus.\",\"ogd\":\"The events of the future <em>cannot</em> be inferred from those of the present. Superstition is the belief in the causal nexus.\",\"str\":\"\"},{\"label\":\"5.1362\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":19,\"x_axis\":87,\"ger\":\"Die Willensfreiheit besteht darin, dass zukünftige Handlungen jetzt nicht gewusst werden können. Nur dann könnten wir sie wissen, wenn die Kausalität eine <em class=\\\"germph\\\">innere</em> Notwendigkeit wäre, wie die des logischen Schlusses. – Der Zusammenhang von Wissen und Gewusstem ist der der logischen Notwendigkeit. („A weiß, dass <span class=\\\"mathmode\\\"><var>p</var></span> der Fall ist“ ist sinnlos, wenn <span class=\\\"mathmode\\\"><var>p</var></span> eine Tautologie ist.)\",\"pmc\":\"The freedom of the will consists in the impossibility of knowing actions that still lie in the future. We could know them only if causality were an <em>inner</em> necessity like that of logical inference.—The connexion between knowledge and what is known is that of logical necessity. (‘A knows that <span class=\\\"mathmode\\\"><var>p</var></span> is the case’, has no sense if <span class=\\\"mathmode\\\"><var>p</var></span> is a tautology.)\",\"ogd\":\"The freedom of the will consists in the fact that future actions cannot be known now. We could only know them if causality were an <em>inner</em> necessity, like that of logical deduction.—The connexion of knowledge and what is known is that of logical necessity. (“A knows that <span class=\\\"mathmode\\\"><var>p</var></span> is the case” is senseless if <span class=\\\"mathmode\\\"><var>p</var></span> is a tautology.)\",\"str\":\"\"},{\"label\":\"5.1363\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":19,\"x_axis\":89,\"ger\":\"Wenn daraus, dass ein Satz uns einleuchtet, nicht <em class=\\\"germph\\\">folgt</em>, dass er wahr ist, so ist das Einleuchten auch keine Rechtfertigung für unseren Glauben an seine Wahrheit.\",\"pmc\":\"If the truth of a proposition does not <em>follow</em> from the fact that it is self-evident to us, then its self-evidence in no way justifies our belief in its truth.\",\"ogd\":\"If from the fact that a proposition is obvious to us it does not <em>follow</em> that it is true, then obviousness is no justification for our belief in its truth.\",\"str\":\"\"},{\"label\":\"5.156\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":19,\"x_axis\":91,\"ger\":\"So ist die Wahrscheinlichkeit eine Verallgemeinerung. Sie involviert eine allgemeine Beschreibung einer Satzform. Nur in Ermanglung der Gewissheit gebrauchen wir die Wahrscheinlichkeit. – Wenn wir zwar eine Tatsache nicht vollkommen kennen, wohl aber <em class=\\\"germph\\\">etwas</em> über ihre Form wissen. (Ein Satz kann zwar ein unvollständiges Bild einer gewissen Sachlage sein, aber er ist immer <em class=\\\"germph\\\">ein</em> vollständiges Bild.) Der Wahrscheinlichkeitssatz ist gleichsam ein Auszug aus anderen Sätzen.\",\"pmc\":\"It is in this way that probability is a generalization. It involves a general description of a propositional form. We use probability only in default of certainty—if our knowledge of a fact is not indeed complete, but we do know <em>something</em> about its form. (A proposition may well be an incomplete picture of a certain situation, but it is always a complete picture of <em>something</em>.) A probability proposition is a sort of excerpt from other propositions.\",\"ogd\":\"Probability is a generalization. It involves a general description of a propositional form. Only in default of certainty do we need probability. If we are not completely acquainted with a fact, but know <em>something</em> about its form. (A proposition can, indeed, be an incomplete picture of a certain state of affairs, but it is always <em>a</em> complete picture.) The probability proposition is, as it were, an extract from other propositions.\",\"str\":\"\"},{\"label\":\"6.124\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":19,\"x_axis\":113,\"ger\":\"Die logischen Sätze beschreiben das Gerüst der Welt, oder vielmehr, sie stellen es dar. Sie „handeln“ von nichts. Sie setzen voraus, dass Namen Bedeutung, und Elementarsätze Sinn haben: Und dies ist ihre Verbindung mit der Welt. Es ist klar, dass es etwas über die Welt anzeigen muss, dass gewisse Verbindungen von Symbolen – welche wesentlich einen bestimmten Charakter haben – Tautologien sind. Hierin liegt das Entscheidende. Wir sagten, manches an den Symbolen, die wir gebrauchen, wäre willkürlich, manches nicht. In der Logik drückt nur dieses aus: Das heißt aber, in der Logik drücken nicht <em class=\\\"germph\\\">wir</em> mit Hilfe der Zeichen aus, was wir wollen, sondern in der Logik sagt die Natur der naturnotwendigen Zeichen selbst aus: Wenn wir die logische Syntax irgendeiner Zeichensprache kennen, dann sind bereits alle Sätze der Logik gegeben.\",\"pmc\":\"The propositions of logic describe the scaffolding of the world, or rather they represent it. They have no ‘subject-matter’. They presuppose that names have meaning and elementary propositions sense; and that is their connexion with the world. It is clear that something about the world must be indicated by the fact that certain combinations of symbols—whose essence involves the possession of a determinate character—are tautologies. This contains the decisive point. We have said that some things are arbitrary in the symbols that we use and that some things are not. In logic it is only the latter that express: but that means that logic is not a field in which <em>we</em> express what we wish with the help of signs, but rather one in which the nature of the natural and inevitable signs speaks for itself. If we know the logical syntax of any sign-language, then we have already been given all the propositions of logic.\",\"ogd\":\"The logical propositions describe the scaffolding of the world, or rather they present it. They “treat” of nothing. They presuppose that names have meaning, and that elementary propositions have sense. And this is their connexion with the world. It is clear that it must show something about the world that certain combinations of symbols—which essentially have a definite character—are tautologies. Herein lies the decisive point. We said that in the symbols which we use something is arbitrary, something not. In logic only this expresses: but this means that in logic it is not <em>we</em> who express, by means of signs, what we want, but in logic the nature of the essentially necessary signs itself asserts. That is to say, if we know the logical syntax of any sign language, then all the propositions of logic are already given.\",\"str\":\"\"},{\"label\":\"2.1\",\"precision\":1,\"fontSize\":\"40px\",\"y_axis\":21,\"x_axis\":9,\"ger\":\"Wir machen uns Bilder der Tatsachen.\",\"pmc\":\"We picture facts to ourselves.\",\"ogd\":\"We make to ourselves pictures of facts.\",\"str\":\"\"},{\"label\":\"2.11\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":21,\"x_axis\":11,\"ger\":\"Das Bild stellt die Sachlage im logischen Raume, das Bestehen und Nichtbestehen von Sachverhalten vor.\",\"pmc\":\"A picture presents a situation in logical space, the existence and non-existence of states of affairs.\",\"ogd\":\"The picture presents the facts in logical space, the existence and non-existence of atomic facts.\",\"str\":\"\"},{\"label\":\"2.12\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":21,\"x_axis\":13,\"ger\":\"Das Bild ist ein Modell der Wirklichkeit.\",\"pmc\":\"A picture is a model of reality.\",\"ogd\":\"The picture is a model of reality.\",\"str\":\"\"},{\"label\":\"2.13\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":21,\"x_axis\":15,\"ger\":\"Den Gegenständen entsprechen im Bilde die Elemente des Bildes.\",\"pmc\":\"In a picture objects have the elements of the picture corresponding to them.\",\"ogd\":\"To the objects correspond in the picture the elements of the picture.\",\"str\":\"\"},{\"label\":\"2.14\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":21,\"x_axis\":17,\"ger\":\"Das Bild besteht darin, dass sich seine Elemente in bestimmter Art und Weise zu einander verhalten.\",\"pmc\":\"What constitutes a picture is that its elements are related to one another in a determinate way.\",\"ogd\":\"The picture consists in the fact that its elements are combined with one another in a definite way.\",\"str\":\"\"},{\"label\":\"2.15\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":21,\"x_axis\":19,\"ger\":\"Dass sich die Elemente des Bildes in bestimmter Art und Weise zu einander verhalten, stellt vor, dass sich die Sachen so zu einander verhalten. Dieser Zusammenhang der Elemente des Bildes heiße seine Struktur und ihre Möglichkeit seine Form der Abbildung.\",\"pmc\":\"The fact that the elements of a picture are related to one another in a determinate way represents that things are related to one another in the same way. Let us call this connexion of its elements the structure of the picture, and let us call the possibility of this structure the pictorial form of the picture.\",\"ogd\":\"That the elements of the picture are combined with one another in a definite way, represents that the things are so combined with one another. This connexion of the elements of the picture is called its structure, and the possibility of this structure is called the form of representation of the picture.\",\"str\":\"\"},{\"label\":\"2.16\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":21,\"x_axis\":21,\"ger\":\"Die Tatsache muss, um Bild zu sein, etwas mit dem Abgebildeten gemeinsam haben.\",\"pmc\":\"If a fact is to be a picture, it must have something in common with what it depicts.\",\"ogd\":\"In order to be a picture a fact must have something in common with what it pictures.\",\"str\":\"\"},{\"label\":\"2.17\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":21,\"x_axis\":23,\"ger\":\"Was das Bild mit der Wirklichkeit gemein haben muss, um sie auf seine Art und Weise – richtig oder falsch – abbilden zu können, ist seine Form der Abbildung.\",\"pmc\":\"What a picture must have in common with reality, in order to be able to depict it—correctly or incorrectly—in the way that it does, is its pictorial form.\",\"ogd\":\"What the picture must have in common with reality in order to be able to represent it after its manner—rightly or falsely—is its form of representation.\",\"str\":\"\"},{\"label\":\"2.18\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":21,\"x_axis\":25,\"ger\":\"Was jedes Bild, welcher Form immer, mit der Wirklichkeit gemein haben muss, um sie überhaupt – richtig oder falsch – abbilden zu können, ist die logische Form, das ist, die Form der Wirklichkeit.\",\"pmc\":\"What any picture, of whatever form, must have in common with reality, in order to be able to depict it—correctly or incorrectly—in any way at all, is logical form, i.e. the form of reality.\",\"ogd\":\"What every picture, of whatever form, must have in common with reality in order to be able to represent it at all—rightly or falsely—is the logical form, that is, the form of reality.\",\"str\":\"\"},{\"label\":\"2.19\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":21,\"x_axis\":27,\"ger\":\"Das logische Bild kann die Welt abbilden.\",\"pmc\":\"Logical pictures can depict the world.\",\"ogd\":\"The logical picture can depict the world.\",\"str\":\"\"},{\"label\":\"3.2\",\"precision\":1,\"fontSize\":\"40px\",\"y_axis\":21,\"x_axis\":37,\"ger\":\"Im Satze kann der Gedanke so ausgedrückt sein, dass den Gegenständen des Gedankens Elemente des Satzzeichens entsprechen.\",\"pmc\":\"In a proposition a thought can be expressed in such a way that elements of the propositional sign correspond to the objects of the thought.\",\"ogd\":\"In propositions thoughts can be so expressed that to the objects of the thoughts correspond the elements of the propositional sign.\",\"str\":\"\"},{\"label\":\"3.21\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":21,\"x_axis\":39,\"ger\":\"Der Konfiguration der einfachen Zeichen im Satzzeichen entspricht die Konfiguration der Gegenstände in der Sachlage.\",\"pmc\":\"The configuration of objects in a situation corresponds to the configuration of simple signs in the propositional sign.\",\"ogd\":\"To the configuration of the simple signs in the propositional sign corresponds the configuration of the objects in the state of affairs.\",\"str\":\"\"},{\"label\":\"3.22\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":21,\"x_axis\":41,\"ger\":\"Der Name vertritt im Satz den Gegenstand.\",\"pmc\":\"In a proposition a name is the representative of an object.\",\"ogd\":\"In the proposition the name represents the object.\",\"str\":\"\"},{\"label\":\"3.23\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":21,\"x_axis\":43,\"ger\":\"Die Forderung der Möglichkeit der einfachen Zeichen ist die Forderung der Bestimmtheit des Sinnes.\",\"pmc\":\"The requirement that simple signs be possible is the requirement that sense be determinate.\",\"ogd\":\"The postulate of the possibility of the simple signs is the postulate of the determinateness of the sense.\",\"str\":\"\"},{\"label\":\"3.24\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":21,\"x_axis\":45,\"ger\":\"Der Satz, welcher vom Komplex handelt, steht in interner Beziehung zum Satze, der von dessen Bestandteil handelt. Der Komplex kann nur durch seine Beschreibung gegeben sein, und diese wird stimmen oder nicht stimmen. Der Satz, in welchem von einem Komplex die Rede ist, wird, wenn dieser nicht existiert, nicht unsinnig, sondern einfach falsch sein. Dass ein Satzelement einen Komplex bezeichnet, kann man aus einer Unbestimmtheit in den Sätzen sehen, worin es vorkommt. Wir <em class=\\\"germph\\\">wissen</em>, durch diesen Satz ist noch nicht alles bestimmt. (Die Allgemeinheitsbezeichnung <em class=\\\"germph\\\">enthält</em> ja ein Urbild.) Die Zusammenfassung des Symbols eines Komplexes in ein einfaches Symbol kann durch eine Definition ausgedrückt werden.\",\"pmc\":\"A proposition about a complex stands in an internal relation to a proposition about a constituent of the complex. A complex can be given\\nonly by its description, which will be right or wrong. A proposition\\nthat mentions a complex will not be nonsensical, if the complex does\\nnot exist, but simply false. When a propositional element signifies a complex, this can be seen from an indeterminateness in the propositions in which it occurs. In such cases we <em>know</em> that the proposition leaves something undetermined. (In fact the notation for generality <em>contains</em> a prototype.) The contraction of a symbol for a complex into a simple symbol can be expressed in a definition.\",\"ogd\":\"A proposition about a complex stands in internal relation to the proposition about its constituent part. A\\ncomplex can only be given by its description, and this will either be\\nright or wrong. The proposition in which there is mention of a complex,\\nif this does not exist, becomes not nonsense but simply false. That a propositional element signifies a complex can be seen from an indeterminateness in the propositions in which it occurs. We <em>know</em> that everything is not yet determined by this proposition. (The notation for generality <em>contains</em> a prototype.) The combination of the symbols of a complex in a simple symbol can be expressed by a definition.\",\"str\":\"\"},{\"label\":\"3.25\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":21,\"x_axis\":47,\"ger\":\"Es gibt eine und nur eine vollständige Analyse des Satzes.\",\"pmc\":\"A proposition has one and only one complete analysis.\",\"ogd\":\"There is one and only one complete analysis of the proposition.\",\"str\":\"\"},{\"label\":\"3.26\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":21,\"x_axis\":49,\"ger\":\"Der Name ist durch keine Definition weiter zu zergliedern: er ist ein Urzeichen.\",\"pmc\":\"A name cannot be dissected any further by means of a definition: it is a primitive sign.\",\"ogd\":\"The name cannot be analysed further by any definition. It is a primitive sign.\",\"str\":\"\"},{\"label\":\"3.201\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":19,\"x_axis\":39,\"ger\":\"Diese Elemente nenne ich „einfache Zeichen“ und den Satz „vollständig analysiert“.\",\"pmc\":\"I call such elements ‘simple signs’, and such a proposition ‘complete analysed’.\",\"ogd\":\"These elements I call “simple signs” and the proposition “completely analysed”.\",\"str\":\"\"},{\"label\":\"3.202\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":19,\"x_axis\":41,\"ger\":\"Die im Satze angewandten einfachen Zeichen heißen Namen.\",\"pmc\":\"The simple signs employed in propositions are called names.\",\"ogd\":\"The simple signs employed in propositions are called names.\",\"str\":\"\"},{\"label\":\"3.203\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":19,\"x_axis\":43,\"ger\":\"Der Name bedeutet den Gegenstand. Der Gegenstand ist seine Bedeutung. („<span class=\\\"mathmode\\\"><var>A</var></span>“ ist dasselbe Zeichen wie „<span class=\\\"mathmode\\\"><var>A</var></span>“.)\",\"pmc\":\"A name means an object. The object is its meaning. (‘<span class=\\\"mathmode\\\"><var>A</var></span>’ is the same sign as ‘<span class=\\\"mathmode\\\"><var>A</var></span>’.)\",\"ogd\":\"The name means the object. The object is its meaning. (“<span class=\\\"mathmode\\\"><var>A</var></span>” is the same sign as “<span class=\\\"mathmode\\\"><var>A</var></span>”.)\",\"str\":\"\"},{\"label\":\"4.027\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":21,\"x_axis\":57,\"ger\":\"Es liegt im Wesen des Satzes, dass er uns einen <em class=\\\"germph\\\">neuen</em> Sinn mitteilen kann.\",\"pmc\":\"It belongs to the essence of a proposition that it should be able to communicate a <em>new</em> sense to us.\",\"ogd\":\"It is essential to propositions, that they can communicate a <em>new</em> sense to us.\",\"str\":\"\"},{\"label\":\"5.2\",\"precision\":1,\"fontSize\":\"40px\",\"y_axis\":21,\"x_axis\":75,\"ger\":\"Die Strukturen der Sätze stehen in internen Beziehungen zu einander.\",\"pmc\":\"The structures of propositions stand in internal relations to one another.\",\"ogd\":\"The structures of propositions stand to one another in internal relations.\",\"str\":\"\"},{\"label\":\"5.21\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":21,\"x_axis\":77,\"ger\":\"Wir können diese internen Beziehungen dadurch in unserer Ausdrucksweise hervorheben, dass wir einen Satz als Resultat einer Operation darstellen, die ihn aus anderen Sätzen (den Basen der Operation) hervorbringt.\",\"pmc\":\"In order to give prominence to these internal relations we can adopt the following mode of expression: we can represent a proposition as the result of an operation that produces it out of other propositions (which are the bases of the operation).\",\"ogd\":\"We can bring out these internal relations in our manner of expression, by presenting a proposition as the result of an operation which produces it from other propositions (the bases of the operation).\",\"str\":\"\"},{\"label\":\"5.22\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":21,\"x_axis\":79,\"ger\":\"Die Operation ist der Ausdruck einer Beziehung zwischen den Strukturen ihres Resultats und ihrer Basen.\",\"pmc\":\"An operation is the expression of a relation between the structures of its result and of its bases.\",\"ogd\":\"The operation is the expression of a relation between the structures of its result and its bases.\",\"str\":\"\"},{\"label\":\"5.23\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":21,\"x_axis\":81,\"ger\":\"Die Operation ist das, was mit dem einen Satz geschehen muss, um aus ihm den anderen zu machen.\",\"pmc\":\"The operation is what has to be done to the one proposition in order to make the other out of it.\",\"ogd\":\"The operation is that which must happen to a proposition in order to make another out of it.\",\"str\":\"\"},{\"label\":\"5.24\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":21,\"x_axis\":83,\"ger\":\"Die Operation zeigt sich in einer Variablen; sie zeigt, wie man von einer Form von Sätzen zu einer anderen gelangen kann. Sie bringt den Unterschied der Formen zum Ausdruck. (Und das Gemeinsame zwischen den Basen und dem Resultat der Operation sind eben die Basen.)\",\"pmc\":\"An operation manifests itself in a variable; it shows how we can get from one form of proposition to another. It gives expression to the difference between the forms. (And what the bases of an operation and its result have in common is just the bases themselves.)\",\"ogd\":\"An operation shows itself in a variable; it shows how we can proceed from one form of proposition to another. It gives expression to the difference between the forms. (And that which is common the the bases, and the result of an operation, is the bases themselves.)\",\"str\":\"\"},{\"label\":\"5.25\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":21,\"x_axis\":85,\"ger\":\"Das Vorkommen der Operation charakterisiert den Sinn des Satzes nicht. Die Operation sagt ja nichts aus, nur ihr Resultat, und dies hängt von den Basen der Operation ab. (Operation und Funktion dürfen nicht miteinander verwechselt werden.)\",\"pmc\":\"The occurrence of an operation does not characterize the sense of a proposition. Indeed, no statement is made by an operation, but only by its result, and this depends on the bases of the operation. (Operations and functions must not be confused with each other.)\",\"ogd\":\"The occurrence of an operation does not characterize the sense of a proposition. For an operation does not assert anything; only its result does, and this depends on the bases of the operation. (Operation and function must not be confused with one another.)\",\"str\":\"\"},{\"label\":\"6.125\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":21,\"x_axis\":113,\"ger\":\"Es ist möglich, und zwar auch nach der alten Auffassung der Logik, von vornherein eine Beschreibung aller „wahren“ logischen Sätze zu geben.\",\"pmc\":\"It is possible—indeed possible even according to the old conception of logic—to give in advance a description of all ‘true’ logical propositions.\",\"ogd\":\"It is possible, also with the old conception of logic, to give at the outset a description of all “true” logical propositions.\",\"str\":\"\"},{\"label\":\"6.1251\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":21,\"x_axis\":115,\"ger\":\"Darum kann es in der Logik auch <em class=\\\"germph\\\">nie</em> Überraschungen geben.\",\"pmc\":\"Hence there can <em>never</em> be surprises in logic.\",\"ogd\":\"Hence there can <em>never</em> be surprises in logic.\",\"str\":\"\"},{\"label\":\"2.131\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":23,\"x_axis\":15,\"ger\":\"Die Elemente des Bildes vertreten im Bild die Gegenstände.\",\"pmc\":\"In a picture the elements of the picture are the representatives of objects.\",\"ogd\":\"The elements of the picture stand, in the picture, for the objects.\",\"str\":\"\"},{\"label\":\"2.141\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":23,\"x_axis\":17,\"ger\":\"Das Bild ist eine Tatsache.\",\"pmc\":\"A picture is a fact.\",\"ogd\":\"The picture is a fact.\",\"str\":\"\"},{\"label\":\"2.161\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":23,\"x_axis\":21,\"ger\":\"In Bild und Abgebildetem muss etwas identisch sein, damit das eine überhaupt ein Bild des anderen sein kann.\",\"pmc\":\"There must be something identical in a picture and what it depicts, to enable the one to be a picture of the other at all.\",\"ogd\":\"In the picture and the pictured there must be something identical in order that the one can be a picture of the other at all.\",\"str\":\"\"},{\"label\":\"2.171\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":23,\"x_axis\":23,\"ger\":\"Das Bild kann jede Wirklichkeit abbilden, deren Form es hat. Das räumliche Bild alles Räumliche, das farbige alles Farbige, etc.\",\"pmc\":\"A picture can depict any reality whose form it has. A spatial picture can depict anything spatial, a coloured one anything coloured, etc.\",\"ogd\":\"The picture can represent every reality whose form it has. The spatial picture, everything spatial, the coloured, everything coloured, etc.\",\"str\":\"\"},{\"label\":\"2.181\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":23,\"x_axis\":25,\"ger\":\"Ist die Form der Abbildung die logische Form, so heißt das Bild das logische Bild.\",\"pmc\":\"A picture whose pictorial form is logical form is called a logical picture.\",\"ogd\":\"If the form of representation is the logical form, then the picture is called a logical picture.\",\"str\":\"\"},{\"label\":\"3.221\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":23,\"x_axis\":41,\"ger\":\"Die Gegenstände kann ich nur <em class=\\\"germph\\\">nennen</em>. Zeichen vertreten sie. Ich kann nur <em class=\\\"germph\\\">von</em> ihnen sprechen, <em class=\\\"germph\\\">sie aussprechen</em> kann ich nicht. Ein Satz kann nur sagen, <em class=\\\"germph\\\">wie</em> ein Ding ist, nicht <em class=\\\"germph\\\">was</em> es ist.\",\"pmc\":\"Objects can only be <em>named</em>. Signs are their representatives. I can only speak <em>about</em> them: I cannot <em>put them into words</em>. Propositions can only say <em>how</em> things are, not <em>what</em> they are.\",\"ogd\":\"Objects I can only <em>name</em>. Signs represent them. I can only speak <em>of</em> them. I cannot <em>assert them</em>. A proposition can only say <em>how</em> a thing is, not <em>what</em> it is.\",\"str\":\"\"},{\"label\":\"3.251\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":23,\"x_axis\":47,\"ger\":\"Der Satz drückt auf bestimmte, klar angebbare Weise aus, was er ausdrückt: Der Satz ist artikuliert.\",\"pmc\":\"What a proposition expresses it expresses in a determinate manner, which can be set out clearly: a proposition is articulate.\",\"ogd\":\"The proposition expresses what it expresses in a definite and clearly specifiable way: the proposition is articulate.\",\"str\":\"\"},{\"label\":\"3.261\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":23,\"x_axis\":49,\"ger\":\"Jedes definierte Zeichen bezeichnet <em class=\\\"germph\\\">über</em> jene Zeichen, durch welche es definiert wurde; und die Definitionen weisen den Weg. Zwei Zeichen, ein Urzeichen, und ein durch Urzeichen definiertes, können nicht auf dieselbe Art und Weise bezeichnen. Namen <em class=\\\"germph\\\">kann</em> man nicht durch Definitionen auseinanderlegen. (Kein Zeichen, welches allein, selbständig eine Bedeutung hat.)\",\"pmc\":\"Every sign that has a definition signifies <em>via</em> the signs that serve to define it; and the definitions point the way. Two signs cannot signify in the same manner if one is primitive and the other is defined by means of primitive signs. Names <em>cannot</em> be anatomized by means of definitions. (Nor can any sign that has a meaning independently and on its own.)\",\"ogd\":\"Every defined sign signifies <em>via</em> those signs by which it is defined, and the definitions show the way. Two signs, one a primitive sign, and one defined by primitive signs, cannot signify in the same way. Names <em>cannot</em> be taken to pieces by definition (nor any sign which alone and independently has a meaning).\",\"str\":\"\"},{\"label\":\"4.1\",\"precision\":1,\"fontSize\":\"40px\",\"y_axis\":23,\"x_axis\":51,\"ger\":\"Der Satz stellt das Bestehen und Nichtbestehen der Sachverhalte dar.\",\"pmc\":\"Propositions represent the existence and non-existence of states of affairs.\",\"ogd\":\"A proposition presents the existence and non-existence of atomic facts.\",\"str\":\"\"},{\"label\":\"4.11\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":23,\"x_axis\":53,\"ger\":\"Die Gesamtheit der wahren Sätze ist die gesamte Naturwissenschaft (oder die Gesamtheit der Naturwissenschaften).\",\"pmc\":\"The totality of true propositions is the whole of natural science (or the whole corpus of the natural sciences).\",\"ogd\":\"The totality of true propositions is the total natural science (or the totality of the natural sciences).\",\"str\":\"\"},{\"label\":\"4.12\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":23,\"x_axis\":59,\"ger\":\"Der Satz kann die gesamte Wirklichkeit darstellen, aber er kann nicht das darstellen, was er mit der Wirklichkeit gemein haben muss, um sie darstellen zu können – die logische Form. Um die logische Form darstellen zu können, müssten wir uns mit dem Satze außerhalb der Logik aufstellen können, das heißt außerhalb der Welt.\",\"pmc\":\"Propositions can represent the whole of reality, but they cannot represent what they must have in common with reality in order to be able to represent it—logical form. In order to be able to represent logical form, we should have to be able to station ourselves with propositions somewhere outside logic, that is to say outside the world.\",\"ogd\":\"Propositions can represent the whole reality, but they cannot represent what they must have in common with reality in order to be able to represent it—the logical form. To be able to represent the logical form, we should have to be able to put ourselves with the propositions outside logic, that is outside the world.\",\"str\":\"\"},{\"label\":\"5.231\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":23,\"x_axis\":81,\"ger\":\"Und das wird natürlich von ihren formalen Eigenschaften, von der internen Ähnlichkeit ihrer Formen abhängen.\",\"pmc\":\"And that will, of course, depend on their formal properties, on the internal similarity of their forms.\",\"ogd\":\"And that will naturally depend on their formal properties, on the internal similarity of their forms.\",\"str\":\"\"},{\"label\":\"5.241\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":23,\"x_axis\":83,\"ger\":\"Die Operation kennzeichnet keine Form, sondern nur den Unterschied der Formen.\",\"pmc\":\"An operation is not the mark of a form, but only of a difference between forms.\",\"ogd\":\"The operation does not characterize a form but only the difference between forms.\",\"str\":\"\"},{\"label\":\"5.251\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":23,\"x_axis\":85,\"ger\":\"Eine Funktion kann nicht ihr eigenes Argument sein, wohl aber kann das Resultat einer Operation ihre eigene Basis werden.\",\"pmc\":\"A function cannot be its own argument, whereas an operation can take one of its own results as its base.\",\"ogd\":\"A function cannot be its own argument, but the result of an operation can be its own basis.\",\"str\":\"\"},{\"label\":\"6.126\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":23,\"x_axis\":113,\"ger\":\"Ob ein Satz der Logik angehört, kann man berechnen, indem man die logischen Eigenschaften des <em class=\\\"germph\\\">Symbols</em> berechnet. Und dies tun wir, wenn wir einen logischen Satz „beweisen“. Denn, ohne uns um einen Sinn und eine Bedeutung zu kümmern, bilden wir den logischen Satz aus anderen nach bloßen <em class=\\\"germph\\\">Zeichenregeln</em>. Der Beweis der logischen Sätze besteht darin, dass wir sie aus anderen logischen Sätzen durch successive Anwendung gewisser Operationen entstehen lassen, die aus den ersten immer wieder Tautologien erzeugen. (Und zwar <em class=\\\"germph\\\">folgen</em> aus einer Tautologie nur Tautologien.) Natürlich ist diese Art zu zeigen, dass ihre Sätze Tautologien sind, der Logik durchaus unwesentlich. Schon darum, weil die Sätze, von welchen der Beweis ausgeht, ja ohne Beweis zeigen müssen, dass sie Tautologien sind.\",\"pmc\":\"One can calculate whether a proposition belongs to logic, by calculating the logical properties of the <em>symbol</em>. And this is what we do when we ‘prove’ a logical proposition. For, without bothering about sense or meaning, we construct the logical proposition out of others using only <em>rules that deal with signs</em>. The proof of logical propositions consists in the following process: we produce them out of other logical propositions by successively applying certain operations that always generate further tautologies out of the initial ones. (And in fact only tautologies <em>follow</em> from a tautology.) Of course this way of showing that the propositions of logic are tautologies is not at all essential to logic, if only because the propositions from which the proof starts must show without any proof that they are tautologies.\",\"ogd\":\"Whether a proposition belongs to logic can be calculated by calculating the logical properties of the <em>symbol</em>. And this we do when we prove a logical proposition. For without troubling ourselves about a sense and a meaning, we form the logical propositions out of others by mere <em>symbolic rules</em>. We prove a logical proposition by creating it out of other logical propositions by applying in succession certain operations, which again generate tautologies out of the first. (And from a tautology only tautologies <em>follow</em>.) Naturally this way of showing that its propositions are tautologies is quite unessential to logic. Because the propositions, from which the proof starts, must show without proof that they are tautologies.\",\"str\":\"\"},{\"label\":\"6.1261\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":23,\"x_axis\":115,\"ger\":\"In der Logik sind Prozess und Resultat äquivalent. (Darum keine Überraschung.)\",\"pmc\":\"In logic process and result are equivalent. (Hence the absence of surprise.)\",\"ogd\":\"In logic process and result are equivalent. (Therefore no surprises.)\",\"str\":\"\"},{\"label\":\"6.1262\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":23,\"x_axis\":117,\"ger\":\"Der Beweis in der Logik ist nur ein mechanisches Hilfsmittel zum leichteren Erkennen der Tautologie, wo sie kompliziert ist.\",\"pmc\":\"Proof in logic is merely a mechanical expedient to facilitate the recognition of tautologies in complicated cases.\",\"ogd\":\"Proof in logic is only a mechanical expedient to facilitate the recognition of tautology, where it is complicated.\",\"str\":\"\"},{\"label\":\"6.1263\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":23,\"x_axis\":119,\"ger\":\"Es wäre ja auch zu merkwürdig, wenn man einen sinnvollen Satz <em class=\\\"germph\\\">logisch</em> aus anderen beweisen könnte, und einen logischen Satz <em class=\\\"germph\\\">auch</em>. Es ist von vornherein klar, dass der logische Beweis eines sinnvollen Satzes und der Beweis <em class=\\\"germph\\\">in</em> der Logik zwei ganz verschiedene Dinge sein müssen.\",\"pmc\":\"Indeed, it would be altogether too remarkable if a proposition that had sense could be proved <em>logically</em> from others, and <em>so too</em> could a logical proposition. It is clear from the start that a logical proof of a proposition that has sense and a proof <em>in</em> logic must be two entirely different things.\",\"ogd\":\"It would be too remarkable, if one could prove a significant proposition <em>logically</em> from another, and a logical proposition <em>also</em>. It is clear from the beginning that the logical proof of a significant proposition and the proof <em>in</em> logic must be two quite different things.\",\"str\":\"\"},{\"label\":\"6.1264\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":23,\"x_axis\":121,\"ger\":\"Der sinnvolle Satz sagt etwas aus, und sein Beweis zeigt, dass es so ist; in der Logik ist jeder Satz die Form eines Beweises. Jeder Satz der Logik ist ein in Zeichen dargestellter modus ponens. (Und den modus ponens kann man nicht durch einen Satz ausdrücken.)\",\"pmc\":\"A proposition that has sense states something, which is shown by its proof to be so. In logic every proposition is the form of a proof. Every proposition of logic is a <em>modus ponens</em> represented in signs. (And one cannot express the <em>modus ponens</em> by means of a proposition.)\",\"ogd\":\"The significant proposition asserts something, and its proof shows that it is so; in logic every proposition is the form of a proof. Every proposition of logic is a modus ponens presented in signs. (And the modus ponens can not be expressed by a proposition.)\",\"str\":\"\"},{\"label\":\"6.1265\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":23,\"x_axis\":123,\"ger\":\"Immer kann man die Logik so auffassen, dass jeder Satz sein eigener Beweis ist.\",\"pmc\":\"It is always possible to construe logic in such a way that every proposition is its own proof.\",\"ogd\":\"Logic can always be conceived to be such that every proposition is its own proof.\",\"str\":\"\"},{\"label\":\"2.172\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":25,\"x_axis\":23,\"ger\":\"Seine Form der Abbildung aber, kann das Bild nicht abbilden; es weist sie auf.\",\"pmc\":\"A picture cannot, however, depict its pictorial form: it displays it.\",\"ogd\":\"The picture, however, cannot represent its form of representation; it shows it forth.\",\"str\":\"\"},{\"label\":\"2.182\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":25,\"x_axis\":25,\"ger\":\"Jedes Bild ist <em class=\\\"germph\\\">auch</em> ein logisches. (Dagegen ist z. B. nicht jedes Bild ein räumliches.)\",\"pmc\":\"Every picture is <em>at the same time</em> a logical one. (On the other hand, not every picture is, for example, a spatial one.)\",\"ogd\":\"Every picture is <em>also</em> a logical picture. (On the other hand, for example, not every picture is spatial.)\",\"str\":\"\"},{\"label\":\"3.262\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":25,\"x_axis\":49,\"ger\":\"Was in den Zeichen nicht zum Ausdruck kommt, das zeigt ihre Anwendung. Was die Zeichen verschlucken, das spricht ihre Anwendung aus.\",\"pmc\":\"What signs fail to express, their application shows. What signs slur over, their application says clearly.\",\"ogd\":\"What does not get expressed in the sign is shown by its application. What the signs conceal, their application declares.\",\"str\":\"\"},{\"label\":\"4.111\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":25,\"x_axis\":53,\"ger\":\"Die Philosophie ist keine der Naturwissenschaften. (Das Wort „Philosophie“ muss etwas bedeuten, was über oder unter, aber nicht neben den Naturwissenschaften steht.)\",\"pmc\":\"Philosophy is not one of the natural sciences. (The word ‘philosophy’ must mean something whose place is above or below the natural sciences, not beside them.)\",\"ogd\":\"Philosophy is not one of the natural sciences. (The word “philosophy” must mean something which stands above or below, but not beside the natural sciences.)\",\"str\":\"\"},{\"label\":\"4.121\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":25,\"x_axis\":59,\"ger\":\"Der Satz kann die logische Form nicht darstellen, sie spiegelt sich in ihm. Was sich in der Sprache spiegelt, kann sie nicht darstellen. Was <em class=\\\"germph\\\">sich</em> in der Sprache ausdrückt, können <em class=\\\"germph\\\">wir</em> nicht durch sie ausdrücken. Der Satz <em class=\\\"germph\\\">zeigt</em> die logische Form der Wirklichkeit. Er weist sie auf.\",\"pmc\":\"Propositions cannot represent logical form: it is mirrored in them. What finds its reflection in language, language cannot represent. What expresses <em>itself</em> in language, <em>we</em> cannot express by means of language. Propositions <em>show</em> the logical form of reality. They display it.\",\"ogd\":\"Propositions cannot represent the logical form: this mirrors itself in the propositions. That which mirrors itself in language, language cannot represent. That which expresses <em>itself</em> in language, <em>we</em> cannot express by language. The propositions <em>show</em> the logical form of reality. They exhibit it.\",\"str\":\"\"},{\"label\":\"4.1211\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":25,\"x_axis\":61,\"ger\":\"So zeigt ein Satz „<span class=\\\"mathmode\\\"><var>fa</var></span>“, dass in seinem Sinn der Gegenstand <span class=\\\"mathmode\\\"><var>a</var></span> vorkommt, zwei Sätze „<span class=\\\"mathmode\\\"><var>fa</var></span>“ und „<span class=\\\"mathmode\\\"><var>ga</var></span>“, dass in ihnen beiden von demselben Gegenstand die Rede ist. Wenn zwei Sätze einander widersprechen, so zeigt dies ihre Struktur; ebenso, wenn einer aus dem anderen folgt. U.s.w.\",\"pmc\":\"Thus one proposition ‘<span class=\\\"mathmode\\\"><var>fa</var></span>’ shows that the object <span class=\\\"mathmode\\\"><var>a</var></span> occurs in its sense, two propositions ‘<span class=\\\"mathmode\\\"><var>fa</var></span>’ and ‘<span class=\\\"mathmode\\\"><var>ga</var></span>’ show that the same object is mentioned in both of them. If two propositions contradict one another, then their structure shows it; the same is true if one of them follows from the other. And so on.\",\"ogd\":\"Thus a proposition “<span class=\\\"mathmode\\\"><var>fa</var></span>” shows that in its sense the object <span class=\\\"mathmode\\\"><var>a</var></span> occurs, two propositions “<span class=\\\"mathmode\\\"><var>fa</var></span>” and “<span class=\\\"mathmode\\\"><var>ga</var></span>” that they are both about the same object. If two propositions contradict one another, this is shown by their structure; similarly if one follows from another, etc.\",\"str\":\"\"},{\"label\":\"4.1212\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":25,\"x_axis\":63,\"ger\":\"Was gezeigt werden <em class=\\\"germph\\\">kann</em>, <em class=\\\"germph\\\">kann</em> nicht gesagt werden.\",\"pmc\":\"What <em>can</em> be shown, <em>cannot</em> be said.\",\"ogd\":\"What <em>can</em> be shown <em>cannot</em> be said.\",\"str\":\"\"},{\"label\":\"4.1213\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":25,\"x_axis\":65,\"ger\":\"Jetzt verstehen wir auch unser Gefühl: dass wir im Besitze einer richtigen logischen Auffassung seien, wenn nur einmal alles in unserer Zeichensprache stimmt.\",\"pmc\":\"Now, too, we understand our feeling that once we have a sign-language in which everything is all right, we already have a correct logical point of view.\",\"ogd\":\"Now we understand our feeling that we are in possession of the right logical conception, if only all is right in our symbolism.\",\"str\":\"\"},{\"label\":\"5.232\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":25,\"x_axis\":81,\"ger\":\"Die interne Relation, die eine Reihe ordnet, ist äquivalent mit der Operation, durch welche ein Glied aus dem anderen entsteht.\",\"pmc\":\"The internal relation by which a series is ordered is equivalent to the operation that produces one term from another.\",\"ogd\":\"The internal relation which orders a series is equivalent to the operation by which one term arises from another.\",\"str\":\"\"},{\"label\":\"5.242\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":25,\"x_axis\":83,\"ger\":\"Dieselbe Operation, die „<span class=\\\"mathmode\\\"><var>q</var></span>“ aus „<span class=\\\"mathmode\\\"><var>p</var></span>“ macht, macht aus „<span class=\\\"mathmode\\\"><var>q</var></span>“ „<span class=\\\"mathmode\\\"><var>r</var></span>“ u. s. f. Dies kann nur darin ausgedrückt sein, dass „<span class=\\\"mathmode\\\"><var>p</var></span>“, „<span class=\\\"mathmode\\\"><var>q</var></span>“, „<span class=\\\"mathmode\\\"><var>r</var></span>“, etc. Variable sind, die gewisse formale Relationen allgemein zum Ausdruck bringen.\",\"pmc\":\"The operation that produces ‘<span class=\\\"mathmode\\\"><var>q</var></span>’ from ‘<span class=\\\"mathmode\\\"><var>p</var></span>’ also produces ‘<span class=\\\"mathmode\\\"><var>r</var></span>’ from ‘<span class=\\\"mathmode\\\"><var>q</var></span>’, and so on. There is only one way of expressing this: ‘<span class=\\\"mathmode\\\"><var>p</var></span>’, ‘<span class=\\\"mathmode\\\"><var>q</var></span>’, ‘<span class=\\\"mathmode\\\"><var>r</var></span>’, etc. have to be variables that give expression in a general way to certain formal relations.\",\"ogd\":\"The same operation which makes “<span class=\\\"mathmode\\\"><var>q</var></span>” from “<span class=\\\"mathmode\\\"><var>p</var></span>”, makes “<span class=\\\"mathmode\\\"><var>r</var></span>” from “<span class=\\\"mathmode\\\"><var>q</var></span>”, and so on. This can only be expressed by the fact that “<span class=\\\"mathmode\\\"><var>p</var></span>”, “<span class=\\\"mathmode\\\"><var>q</var></span>”, “<span class=\\\"mathmode\\\"><var>r</var></span>”, etc., are variables which give general expression to certain formal relations.\",\"str\":\"\"},{\"label\":\"5.252\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":25,\"x_axis\":85,\"ger\":\"Nur so ist das Fortschreiten von Glied zu Glied in einer Formenreihe (von Type zu Type in den Hierarchien Russells und Whiteheads) möglich. (Russell und Whitehead haben die Möglichkeit dieses Fortschreitens nicht zugegeben, aber immer wieder von ihr Gebrauch gemacht.)\",\"pmc\":\"It is only in this way that the step from one term of a series of forms to another is possible (from one type to another in the hierarchies of Russell and Whitehead). (Russell and Whitehead did not admit the possibility of such steps, but repeatedly availed themselves of it.)\",\"ogd\":\"Only in this way is the progress from term to term in a formal series possible (from type to type in the hierarchy of Russell and Whitehead). (Russell and Whitehead have not admitted the possibility of this progress but have made use of it all the same.)\",\"str\":\"\"},{\"label\":\"5.2521\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":25,\"x_axis\":87,\"ger\":\"Die fortgesetzte Anwendung einer Operation auf ihr eigenes Resultat nenne ich ihre successive Anwendung („<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\"><span class=\\\"mathrm\\\">O</span>’</span><span class=\\\"mathop\\\"><span class=\\\"mathrm\\\">O</span>’</span><span class=\\\"mathop\\\"><span class=\\\"mathrm\\\">O</span>’</span><var>a</var></span>“ ist das Resultat der dreimaligen successiven Anwendung von „<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\"><span class=\\\"mathrm\\\">O</span>’</span><var>ξ</var></span>“ auf „<span class=\\\"mathmode\\\"><var>a</var></span>“). In einem ähnlichen Sinne rede ich von der successiven Anwendung <em class=\\\"germph\\\">mehrerer</em> Operationen auf eine Anzahl von Sätzen.\",\"pmc\":\"If an operation is applied repeatedly to its own results, I speak of successive applications of it. (‘<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\"><span class=\\\"mathrm\\\">O</span>’</span><span class=\\\"mathop\\\"><span class=\\\"mathrm\\\">O</span>’</span><span class=\\\"mathop\\\"><span class=\\\"mathrm\\\">O</span>’</span><var>a</var></span>’ is the result of three successive applications of the operation ‘<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\"><span class=\\\"mathrm\\\">O</span>’</span><var>ξ</var></span>’ to ‘<span class=\\\"mathmode\\\"><var>a</var></span>’.) In a similar sense I speak of successive applications of <em>more than one</em> operation to a number of propositions.\",\"ogd\":\"The repeated application of an operation to its own result I call its successive application (“<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\"><span class=\\\"mathrm\\\">O</span>’</span><span class=\\\"mathop\\\"><span class=\\\"mathrm\\\">O</span>’</span><span class=\\\"mathop\\\"><span class=\\\"mathrm\\\">O</span>’</span><var>a</var></span>” is the result of the threefold successive application of “<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\"><span class=\\\"mathrm\\\">O</span>’</span><var>ξ</var></span>” to “<span class=\\\"mathmode\\\"><var>a</var></span>”). In a similar sense I speak of the successive application of <em>several</em> operations to a number of propositions.\",\"str\":\"\"},{\"label\":\"5.2522\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":25,\"x_axis\":89,\"ger\":\"Das allgemeine Glied einer Formenreihe <span class=\\\"mathmode\\\"><var>a</var>, <span class=\\\"mathop\\\"><span class=\\\"mathrm\\\">O</span>’</span><var>a</var>, <span class=\\\"mathop\\\"><span class=\\\"mathrm\\\">O</span>’</span><span class=\\\"mathop\\\"><span class=\\\"mathrm\\\">O</span>’</span><var>a</var>,<span class=\\\"mathrel\\\">…</span></span> schreibe ich daher so: „<span class=\\\"mathmode\\\">[<var>a</var>, <var>x</var>, <span class=\\\"mathop\\\"><span class=\\\"mathrm\\\">O</span>’</span><var>x</var>]</span>“. Dieser Klammerausdruck ist eine Variable. Das erste Glied des Klammerausdruckes ist der Anfang der Formenreihe, das zweite die Form eines beliebigen Gliedes <span class=\\\"mathmode\\\"><var>x</var></span> der Reihe und das dritte die Form desjenigen Gliedes der Reihe, welches auf <span class=\\\"mathmode\\\"><var>x</var></span> unmittelbar folgt.\",\"pmc\":\"Accordingly I use the sign ‘<span class=\\\"mathmode\\\">[<var>a</var>, <var>x</var>, <span class=\\\"mathop\\\"><span class=\\\"mathrm\\\">O</span>’</span><var>x</var>]</span>’ for the general term of the series of forms <span class=\\\"mathmode\\\"><var>a</var>, <span class=\\\"mathop\\\"><span class=\\\"mathrm\\\">O</span>’</span><var>a</var>, <span class=\\\"mathop\\\"><span class=\\\"mathrm\\\">O</span>’</span><span class=\\\"mathop\\\"><span class=\\\"mathrm\\\">O</span>’</span><var>a</var>,<span class=\\\"mathrel\\\">…</span></span>. This bracketed expression is a variable: the first term of the bracketed expression is the beginning of the series of forms, the second is the form of a term <span class=\\\"mathmode\\\"><var>x</var></span> arbitrarily selected from the series, and the third is the form of the term that immediately follows <span class=\\\"mathmode\\\"><var>x</var></span> in the series.\",\"ogd\":\"The general term of the formal series <span class=\\\"mathmode\\\"><var>a</var>, <span class=\\\"mathop\\\"><span class=\\\"mathrm\\\">O</span>’</span><var>a</var>, <span class=\\\"mathop\\\"><span class=\\\"mathrm\\\">O</span>’</span><span class=\\\"mathop\\\"><span class=\\\"mathrm\\\">O</span>’</span><var>a</var>,<span class=\\\"mathrel\\\">…</span></span>. I write thus: “<span class=\\\"mathmode\\\">[<var>a</var>, <var>x</var>, <span class=\\\"mathop\\\"><span class=\\\"mathrm\\\">O</span>’</span><var>x</var>]</span>”. This expression in brackets is a variable. The first term of the expression is the beginning of the formal series, the second the form of an arbitrary term <span class=\\\"mathmode\\\"><var>x</var></span> of the series, and the third the form of that term of the series which immediately follows <span class=\\\"mathmode\\\"><var>x</var></span>.\",\"str\":\"\"},{\"label\":\"5.2523\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":25,\"x_axis\":91,\"ger\":\"Der Begriff der successiven Anwendung der Operation ist äquivalent mit dem Begriff „und so weiter“.\",\"pmc\":\"The concept of successive applications of an operation is equivalent to the concept ‘and so on’.\",\"ogd\":\"The concept of the successive application of an operation is equivalent to the concept “and so on”.\",\"str\":\"\"},{\"label\":\"6.127\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":25,\"x_axis\":113,\"ger\":\"Alle Sätze der Logik sind gleichberechtigt, es gibt unter ihnen nicht wesentlich Grundgesetze und abgeleitete Sätze. Jede Tautologie zeigt selbst, dass sie eine Tautologie ist.\",\"pmc\":\"All the propositions of logic are of equal status: it is not the case that some of them are essentially derived propositions. Every tautology itself shows that it is a tautology.\",\"ogd\":\"All propositions of logic are of equal rank; there are not some which are essentially primitive and others deduced from there. Every tautology itself shows that it is a tautology.\",\"str\":\"\"},{\"label\":\"6.1271\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":25,\"x_axis\":115,\"ger\":\"Es ist klar, dass die Anzahl der „logischen Grundgesetze“ willkürlich ist, denn man könnte die Logik ja aus Einem Grundgesetz ableiten, indem man einfach z. B. aus Freges Grundgesetzen das logische Produkt bildet. (Frege würde vielleicht sagen, dass dieses Grundgesetz nun nicht mehr unmittelbar einleuchte. Aber es ist merkwürdig, dass ein so exakter Denker wie Frege sich auf den Grad des Einleuchtens als Kriterium des logischen Satzes berufen hat.)\",\"pmc\":\"It is clear that the number of the ‘primitive propositions of logic’ is arbitrary, since one could derive logic from a single primitive proposition, e.g. by simply constructing the logical product of Frege’s primitive propositions. (Frege would perhaps say that we should then no longer have an immediately self-evident primitive proposition. But it is remarkable that a thinker as rigorous as Frege appealed to the degree of self-evidence as the criterion of a logical proposition.)\",\"ogd\":\"It is clear that the number of “primitive propositions of logic” is arbitrary, for we could deduce logic from one primitive proposition by simply forming, for example, the logical produce of Frege’s primitive propositions. (Frege would perhaps say that this would no longer be immediately self-evident. But it is remarkable that so exact a thinker as Frege should have appealed to the degree of self-evidence as the criterion of a logical proposition.)\",\"str\":\"\"},{\"label\":\"2.173\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":27,\"x_axis\":23,\"ger\":\"Das Bild stellt sein Objekt von außerhalb dar (sein Standpunkt ist seine Form der Darstellung), darum stellt das Bild sein Objekt richtig oder falsch dar.\",\"pmc\":\"A picture represents its subject from a position outside it. (Its standpoint is its representational form.) That is why a picture represents its subject correctly or incorrectly.\",\"ogd\":\"The picture represents its object from without (its standpoint is its form of representation), therefore the picture represents its object rightly or falsely.\",\"str\":\"\"},{\"label\":\"3.263\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":27,\"x_axis\":49,\"ger\":\"Die Bedeutungen von Urzeichen können durch Erläuterungen erklärt werden. Erläuterungen sind Sätze, welche die Urzeichen enthalten. Sie können also nur verstanden werden, wenn die Bedeutungen dieser Zeichen bereits bekannt sind.\",\"pmc\":\"The meanings of primitive signs can be explained by means of elucidations. Elucidations are propositions that contain the primitive signs. So they can only be understood if the meanings of those signs are already known.\",\"ogd\":\"The meanings of primitive signs can be explained by elucidations. Elucidations are propositions which contain the primitive signs. They can, therefore, only be understood when the meanings of these signs are already known.\",\"str\":\"\"},{\"label\":\"4.112\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":27,\"x_axis\":53,\"ger\":\"Der Zweck der Philosophie ist die logische Klärung der Gedanken. Die Philosophie ist keine Lehre, sondern eine Tätigkeit. Ein philosophisches Werk besteht wesentlich aus Erläuterungen. Das Resultat der Philosophie sind nicht „philosophische Sätze“, sondern das Klarwerden von Sätzen. Die Philosophie soll die Gedanken, die sonst, gleichsam, trübe und verschwommen sind, klar machen und scharf abgrenzen.\",\"pmc\":\"Philosophy aims at the logical clarification of thoughts. Philosophy is not a body of doctrine but an activity. A philosophical work consists essentially of elucidations. Philosophy does not result in ‘philosophical propositions’, but rather in the clarification of propositions. Without philosophy thoughts are, as it were, cloudy and indistinct: its task is to make them clear and to give them sharp boundaries.\",\"ogd\":\"The object of philosophy is the logical clarification of thoughts. Philosophy is not a theory but an activity. A philosophical work consists essentially of elucidations. The result of philosophy is not a number of “philosophical propositions”, but to make propositions clear. Philosophy should make clear and delimit sharply the thoughts which otherwise are, as it were, opaque and blurred.\",\"str\":\"\"},{\"label\":\"4.1121\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":27,\"x_axis\":55,\"ger\":\"Die Psychologie ist der Philosophie nicht verwandter als irgend eine andere Naturwissenschaft. Erkenntnistheorie ist die Philosophie der Psychologie. Entspricht nicht mein Studium der Zeichensprache dem Studium der Denkprozesse, welches die Philosophen für die Philosophie der Logik für so wesentlich hielten? Nur verwickelten sie sich meistens in unwesentliche psychologische Untersuchungen und eine analoge Gefahr gibt es auch bei meiner Methode.\",\"pmc\":\"Psychology is no more closely related to philosophy than any other natural science. Theory of knowledge is the philosophy of psychology. Does not my study of sign-language correspond to the study of thought-processes, which philosophers used to consider so essential to the philosophy of logic? Only in most cases they got entangled in unessential psychological investigations, and with my method too there is an analogous risk.\",\"ogd\":\"Psychology is no nearer related to philosophy, than is any other natural science. The theory of knowledge is the philosophy of psychology. Does not my study of sign-language correspond to the study of thought processes which philosophers held to be so essential to the philosophy of logic? Only they got entangled for the most part in unessential psychological investigations, and there is an analogous danger for my method.\",\"str\":\"\"},{\"label\":\"4.1122\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":27,\"x_axis\":57,\"ger\":\"Die Darwinsche Theorie hat mit der Philosophie nicht mehr zu schaffen als irgendeine andere Hypothese der Naturwissenschaft.\",\"pmc\":\"Darwin’s theory has no more to do with philosophy than any other hypothesis in natural science.\",\"ogd\":\"The Darwinian theory has no more to do with philosophy than has any other hypothesis of natural science.\",\"str\":\"\"},{\"label\":\"4.122\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":27,\"x_axis\":59,\"ger\":\"Wir können in gewissem Sinne von formalen Eigenschaften der Gegenstände und Sachverhalte bezw. von Eigenschaften der Struktur der Tatsachen reden, und in demselben Sinne von formalen Relationen und Relationen von Strukturen. (Statt Eigenschaft der Struktur sage ich auch „interne Eigenschaft“; statt Relation der Strukturen „interne Relation“. Ich führe diese Ausdrücke ein, um den Grund der bei den Philosophen sehr verbreiteten Verwechslung zwischen den internen Relationen und den eigentlichen (externen) Relationen zu zeigen.) Das Bestehen solcher interner Eigenschaften und Relationen kann aber nicht durch Sätze behauptet werden, sondern es zeigt sich in den Sätzen, welche jene Sachverhalte darstellen und von jenen Gegenständen handeln.\",\"pmc\":\"In a certain sense we can talk about formal properties of objects and states of affairs, or, in the case of facts, about structural properties: and in the same sense about formal relations and structural relations. (Instead of ‘structural property’ I also say ‘internal property’; instead of ‘structural relation’, ‘internal relation’. I introduce these expressions in order to indicate the source of the confusion between internal relations and relations proper (external relations), which is very widespread among philosophers.) It is impossible, however, to assert by means of propositions that such internal properties and relations obtain: rather, this makes itself manifest in the propositions that represent the relevant states of affairs and are concerned with the relevant objects.\",\"ogd\":\"We can speak in a certain sense of formal properties of objects and atomic facts, or of properties of the structure of facts, and in the same sense of formal relations and relations of structures. (Instead of property of the structure I also say “internal property”; instead of relation of structures “internal relation”. I introduce these expressions in order to show the reason for the confusion, very widespread among philosophers, between internal relations and proper (external) relations.) The holding of such internal properties and relations cannot, however, be asserted by propositions, but it shows itself in the propositions, which present the facts and treat of the objects in question.\",\"str\":\"\"},{\"label\":\"4.1221\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":27,\"x_axis\":61,\"ger\":\"Eine interne Eigenschaft einer Tatsache können wir auch einen Zug dieser Tatsache nennen. (In dem Sinn, in welchem wir etwa von Gesichtszügen sprechen.)\",\"pmc\":\"An internal property of a fact can also be called a feature of that fact (in the sense in which we speak of facial features, for example).\",\"ogd\":\"An internal property of a fact we also call a feature of this fact. (In the sense in which we speak of facial features.)\",\"str\":\"\"},{\"label\":\"5.233\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":27,\"x_axis\":81,\"ger\":\"Die Operation kann erst dort auftreten, wo ein Satz auf logisch bedeutungsvolle Weise aus einem anderen entsteht. Also dort, wo die logische Konstruktion des Satzes anfängt.\",\"pmc\":\"Operations cannot make their appearance before the point at which one proposition is generated out of another in a logically meaningful way; i.e. the point at which the logical construction of propositions begins.\",\"ogd\":\"The first place in which an operation can occur is where a proposition arises from another in a logically significant way; <em>i.e.</em> where the logical construction of the proposition begins.\",\"str\":\"\"},{\"label\":\"5.253\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":27,\"x_axis\":85,\"ger\":\"Eine Operation kann die Wirkung einer anderen rückgängig machen. Operationen können einander aufheben.\",\"pmc\":\"One operation can counteract the effect of another. Operations can cancel one another.\",\"ogd\":\"One operation can reverse the effect of another. Operations can cancel one another.\",\"str\":\"\"},{\"label\":\"6.2\",\"precision\":1,\"fontSize\":\"40px\",\"y_axis\":27,\"x_axis\":107,\"ger\":\"Die Mathematik ist eine logische Methode. Die Sätze der Mathematik sind Gleichungen, also Scheinsätze.\",\"pmc\":\"Mathematics is a logical method. The propositions of mathematics are equations, and therefore pseudo-propositions.\",\"ogd\":\"Mathematics is a logical method. The propositions of mathematics are equations, and therefore pseudo-propositions.\",\"str\":\"\"},{\"label\":\"6.21\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":27,\"x_axis\":109,\"ger\":\"Der Satz der Mathematik drückt keinen Gedanken aus.\",\"pmc\":\"A proposition of mathematics does not express a thought.\",\"ogd\":\"Mathematical propositions express no thoughts.\",\"str\":\"\"},{\"label\":\"6.22\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":27,\"x_axis\":111,\"ger\":\"Die Logik der Welt, die die Sätze der Logik in den Tautologien zeigen, zeigt die Mathematik in den Gleichungen.\",\"pmc\":\"The logic of the world, which is shown in tautologies by the propositions of logic, is shown in equations by mathematics.\",\"ogd\":\"The logic of the world which the propositions of logic show in tautologies, mathematics shows in equations.\",\"str\":\"\"},{\"label\":\"6.23\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":27,\"x_axis\":113,\"ger\":\"Wenn zwei Ausdrücke durch das Gleichheitszeichen verbunden werden, so heißt das, sie sind durch einander ersetzbar. Ob dies aber der Fall ist, muss sich an den beiden Ausdrücken selbst zeigen. Es charakterisiert die logische Form zweier Ausdrücke, dass sie durch einander ersetzbar sind.\",\"pmc\":\"If two expressions are combined by means of the sign of equality, that means that they can be substituted for one another. But it must be manifest in the two expressions themselves whether this is the case or not. When two expressions can be substituted for one another, that characterizes their logical form.\",\"ogd\":\"If two expressions are connected by the sign of equality, this means that they can be substituted for one another. But whether this is the case must show itself in the two expressions themselves. It characterizes the logical form of two expressions, that they can be substituted for one another.\",\"str\":\"\"},{\"label\":\"6.24\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":27,\"x_axis\":117,\"ger\":\"Die Methode der Mathematik, zu ihren Gleichungen zu kommen, ist die Substitutionsmethode. Denn die Gleichungen drücken die Ersetzbarkeit zweier Ausdrücke aus und wir schreiten von einer Anzahl von Gleichungen zu neuen Gleichungen vor, indem wir, den Gleichungen entsprechend, Ausdrücke durch andere ersetzen.\",\"pmc\":\"The method by which mathematics arrives at its equations is the method of substitution. For equations express the substitutability of two expressions and, starting from a number of equations, we advance to new equations by substituting different expressions in accordance with the equations.\",\"ogd\":\"The method by which mathematics arrives at its equations is the method of substitution. For equations express the substitutability of two expressions, and we proceed from a number of equations to new equations, replacing expressions by others in accordance with the equations.\",\"str\":\"\"},{\"label\":\"2.174\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":29,\"x_axis\":23,\"ger\":\"Das Bild kann sich aber nicht außerhalb seiner Form der Darstellung stellen.\",\"pmc\":\"A picture cannot, however, place itself outside its representational form.\",\"ogd\":\"But the picture cannot place itself outside of its form of representation.\",\"str\":\"\"},{\"label\":\"3.3\",\"precision\":1,\"fontSize\":\"40px\",\"y_axis\":29,\"x_axis\":37,\"ger\":\"Nur der Satz hat Sinn; nur im Zusammenhang des Satzes hat ein Name Bedeutung.\",\"pmc\":\"Only propositions have sense; only in the nexus of a proposition does a name have meaning.\",\"ogd\":\"Only the proposition has sense; only in the context of a proposition has a name meaning.\",\"str\":\"\"},{\"label\":\"3.31\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":29,\"x_axis\":39,\"ger\":\"Jeden Teil des Satzes, der seinen Sinn charakterisiert, nenne ich einen Ausdruck (ein Symbol). (Der Satz selbst ist ein Ausdruck.) Ausdruck ist alles, für den Sinn des Satzes wesentliche, was Sätze miteinander gemein haben können. Der Ausdruck kennzeichnet eine Form und einen Inhalt.\",\"pmc\":\"I call any part of a proposition that characterizes its sense an expression (or a symbol). (A proposition is itself an expression.) Everything essential to their sense that propositions can have in common with one another is an expression. An expression is the mark of a form and a content.\",\"ogd\":\"Every part of a proposition which characterizes its sense I call an expression (a symbol). (The proposition itself is an expression.) Expressions are everything—essential for the sense of the proposition—that propositions can have in common with one another. An expression characterizes a form and a content.\",\"str\":\"\"},{\"label\":\"3.32\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":29,\"x_axis\":41,\"ger\":\"Das Zeichen ist das sinnlich Wahrnehmbare am Symbol.\",\"pmc\":\"A sign is what can be perceived of a symbol.\",\"ogd\":\"The sign is the part of the symbol perceptible by the senses.\",\"str\":\"\"},{\"label\":\"3.33\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":29,\"x_axis\":43,\"ger\":\"In der logischen Syntax darf nie die Bedeutung eines Zeichens eine Rolle spielen; sie muss sich aufstellen lassen, ohne dass dabei von der <em class=\\\"germph\\\">Bedeutung</em> eines Zeichens die Rede wäre, sie darf <em class=\\\"germph\\\">nur</em> die Beschreibung der Ausdrücke voraussetzen.\",\"pmc\":\"In logical syntax the meaning of a sign should never play a role. It must be possible to establish logical syntax without mentioning the <em>meaning</em> of a sign: <em>only</em> the description of expressions may be presupposed.\",\"ogd\":\"In logical syntax the meaning of a sign ought never to play a rôle; it must admit of being established without mention being thereby made of the <em>meaning</em> of a sign; it ought to presuppose <em>only</em> the description of the expressions.\",\"str\":\"\"},{\"label\":\"3.34\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":29,\"x_axis\":45,\"ger\":\"Der Satz besitzt wesentliche und zufällige Züge. Zufällig sind die Züge, die von der besonderen Art der Hervorbringung des Satzzeichens herrühren. Wesentlich diejenigen, welche allein den Satz befähigen, seinen Sinn auszudrücken.\",\"pmc\":\"A proposition possesses essential and accidental features. Accidental features are those that result from the particular way in which the propositional sign is produced. Essential features are those without which the proposition could not express its sense.\",\"ogd\":\"A proposition possesses essential and accidental features. Accidental are the features which are due to a particular way of producing the propositional sign. Essential are those which alone enable the proposition to express its sense.\",\"str\":\"\"},{\"label\":\"4.113\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":29,\"x_axis\":53,\"ger\":\"Die Philosophie begrenzt das bestreitbare Gebiet der Naturwissenschaft.\",\"pmc\":\"Philosophy sets limits to the much disputed sphere of natural science.\",\"ogd\":\"Philosophy limits the disputable sphere of natural science.\",\"str\":\"\"},{\"label\":\"4.123\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":29,\"x_axis\":59,\"ger\":\"Eine Eigenschaft ist intern, wenn es undenkbar ist, dass ihr Gegenstand sie nicht besitzt. (Diese blaue Farbe und jene stehen in der internen Relation von heller und dunkler eo ipso. Es ist undenkbar, dass <em class=\\\"germph\\\">diese</em> beiden Gegenstände nicht in dieser Relation stünden.) (Hier entspricht dem schwankenden Gebrauch der Worte „Eigenschaft“ und „Relation“ der schwankende Gebrauch des Wortes „Gegenstand“.)\",\"pmc\":\"A property is internal if it is unthinkable that its object should not possess it. (This shade of blue and that one stand, <em>eo ipso</em>, in the internal relation of lighter to darker. It is unthinkable that <em>these</em> two objects should not stand in this relation.) (Here the shifting use of the word ‘object’ corresponds to the shifting use of the words ‘property’ and ‘relation’.)\",\"ogd\":\"A property is internal if it is unthinkable that its object does not possess it. (This bright blue colour and that stand in the internal relation of bright and darker eo ipso. It is unthinkable that <em>these</em> two objects should not stand in this relation.) (Here to the shifting use of the words “property” and “relation” there corresponds the shifting use of the word “object”.)\",\"str\":\"\"},{\"label\":\"5.234\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":29,\"x_axis\":81,\"ger\":\"Die Wahrheitsfunktionen der Elementarsätze sind Resultate von Operationen, die die Elementarsätze als Basen haben. (Ich nenne diese Operationen Wahrheitsoperationen.)\",\"pmc\":\"Truth-functions of elementary propositions are results of operations with elementary propositions as bases. (These operations I call truth-operations.)\",\"ogd\":\"The truth-functions of elementary proposition, are results of operations which have the elementary propositions as bases. (I call these operations, truth-operations.)\",\"str\":\"\"},{\"label\":\"5.2341\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":29,\"x_axis\":83,\"ger\":\"Der Sinn einer Wahrheitsfunktion von <span class=\\\"mathmode\\\"><var>p</var></span> ist eine Funktion des Sinnes von <span class=\\\"mathmode\\\"><var>p</var></span>. Verneinung, logische Addition, logische Multiplikation, etc., etc. sind Operationen. (Die Verneinung verkehrt den Sinn des Satzes.)\",\"pmc\":\"The sense of a truth-function of <span class=\\\"mathmode\\\"><var>p</var></span> is a function of the sense of <span class=\\\"mathmode\\\"><var>p</var></span>. Negation, logical addition, logical multiplication, etc. etc. are operations. (Negation reverses the sense of a proposition.)\",\"ogd\":\"The sense of a truth-function of <span class=\\\"mathmode\\\"><var>p</var></span> is a function of the sense of <span class=\\\"mathmode\\\"><var>p</var></span>. Denial, logical addition, logical multiplication, etc., etc., are operations. (Denial reverses the sense of a proposition.)\",\"str\":\"\"},{\"label\":\"5.254\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":29,\"x_axis\":85,\"ger\":\"Die Operation kann verschwinden (z. B. die Verneinung in „<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><span class=\\\"mathop\\\">~</span><var>p</var></span>“: <span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><span class=\\\"mathop\\\">~</span><var>p</var><span class=\\\"mathrel\\\">=</span><var>p</var></span>).\",\"pmc\":\"An operation can vanish (e.g. negation in ‘<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><span class=\\\"mathop\\\">~</span><var>p</var></span>’: <span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><span class=\\\"mathop\\\">~</span><var>p</var><span class=\\\"mathrel\\\">=</span><var>p</var></span>).\",\"ogd\":\"Operations can vanish (<em>e.g.</em> denial in “<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><span class=\\\"mathop\\\">~</span><var>p</var></span>”. <span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><span class=\\\"mathop\\\">~</span><var>p</var><span class=\\\"mathrel\\\">=</span><var>p</var></span>).\",\"str\":\"\"},{\"label\":\"6.211\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":29,\"x_axis\":109,\"ger\":\"Im Leben ist es ja nie der mathematische Satz, den wir brauchen, sondern wir benützen den mathematischen Satz <em class=\\\"germph\\\">nur</em>, um aus Sätzen, welche nicht der Mathematik angehören, auf andere zu schließen, welche gleichfalls nicht der Mathematik angehören. (In der Philosophie führt die Frage: „Wozu gebrauchen wir eigentlich jenes Wort, jenen Satz“ immer wieder zu wertvollen Einsichten.)\",\"pmc\":\"Indeed in real life a mathematical proposition is never what we want. Rather, we make use of mathematical propositions <em>only</em> in inferences from propositions that do not belong to mathematics to others that likewise do not belong to mathematics. (In philosophy the question, ‘What do we actually use this word or this proposition for?’ repeatedly leads to valuable insights.)\",\"ogd\":\"In life it is never a mathematical proposition which we need, but we use mathematical propositions <em>only</em> in order to infer from propositions which do not belong to mathematics to others which equally do not belong to mathematics. (In philosophy the question “Why do we really use that word, that proposition?” constantly leads to valuable results.)\",\"str\":\"\"},{\"label\":\"6.231\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":29,\"x_axis\":113,\"ger\":\"Es ist eine Eigenschaft der Bejahung, dass man sie als doppelte Verneinung auffassen kann. Es ist eine Eigenschaft von „<span class=\\\"mathmode\\\">1<span class=\\\"mathrel\\\">+</span>1<span class=\\\"mathrel\\\">+</span>1<span class=\\\"mathrel\\\">+</span>1</span>“, dass man es als „<span class=\\\"mathmode\\\">(1<span class=\\\"mathrel\\\">+</span>1)<span class=\\\"mathrel\\\">+</span>(1<span class=\\\"mathrel\\\">+</span>1)</span>“ auffassen kann.\",\"pmc\":\"It is a property of affirmation that it can be construed as double negation. It is a property of ‘<span class=\\\"mathmode\\\">1<span class=\\\"mathrel\\\">+</span>1<span class=\\\"mathrel\\\">+</span>1<span class=\\\"mathrel\\\">+</span>1</span>’ that it can be construed as ‘<span class=\\\"mathmode\\\">(1<span class=\\\"mathrel\\\">+</span>1)<span class=\\\"mathrel\\\">+</span>(1<span class=\\\"mathrel\\\">+</span>1)</span>’.\",\"ogd\":\"It is a property of affirmation that it can be conceived as double denial. It is a property of “<span class=\\\"mathmode\\\">1<span class=\\\"mathrel\\\">+</span>1<span class=\\\"mathrel\\\">+</span>1<span class=\\\"mathrel\\\">+</span>1</span>” that it can be conceived as “<span class=\\\"mathmode\\\">(1<span class=\\\"mathrel\\\">+</span>1)<span class=\\\"mathrel\\\">+</span>(1<span class=\\\"mathrel\\\">+</span>1)</span>”.\",\"str\":\"\"},{\"label\":\"6.241\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":29,\"x_axis\":117,\"ger\":\"So lautet der Beweis des Satzes <span class=\\\"mathmode\\\">2 × 2<span class=\\\"mathrel\\\">=</span>4</span>: <div class=\\\"centered\\\"><span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">(Ω<sup><var>ν</var></sup>)<sup><var>μ</var></sup>’</span><var>x</var><span class=\\\"mathrel\\\">=</span><span class=\\\"mathop\\\">Ω<sup><var>ν</var>× <var>μ</var></sup>’</span><var>x</var></span> Def.<br />\\n<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">Ω<sup>2 × 2</sup>’</span><var>x</var><span class=\\\"mathrel\\\">=</span><span class=\\\"mathop\\\">(Ω<sup>2</sup>)<sup>2</sup>’</span><var>x</var><span class=\\\"mathrel\\\">=</span><span class=\\\"mathop\\\">(Ω<sup>2</sup>)<sup>1<span class=\\\"mathrel\\\">+</span>1</sup>’</span><var>x</var><span class=\\\"mathrel\\\">=</span><span class=\\\"mathop\\\">Ω<sup>2</sup>’</span><span class=\\\"mathop\\\">Ω<sup>2</sup>’</span><var>x</var></span><br />\\n<span class=\\\"mathmode\\\"><span class=\\\"mathrel\\\">=</span><span class=\\\"mathop\\\">Ω<sup>1<span class=\\\"mathrel\\\">+</span>1</sup>’</span><span class=\\\"mathop\\\">Ω<sup>1<span class=\\\"mathrel\\\">+</span>1</sup>’</span><var>x</var><span class=\\\"mathrel\\\">=</span><span class=\\\"mathop\\\">(Ω’Ω)’</span><span class=\\\"mathop\\\">(Ω’Ω)’</span> <var>x</var></span><br />\\n<span class=\\\"mathmode\\\"><span class=\\\"mathrel\\\">=</span><span class=\\\"mathop\\\">Ω’</span><span class=\\\"mathop\\\">Ω’</span><span class=\\\"mathop\\\">Ω’</span><span class=\\\"mathop\\\">Ω’</span><var>x</var><span class=\\\"mathrel\\\">=</span><span class=\\\"mathop\\\">Ω<sup>1<span class=\\\"mathrel\\\">+</span>1<span class=\\\"mathrel\\\">+</span>1<span class=\\\"mathrel\\\">+</span>1</sup>’</span><var>x</var><span class=\\\"mathrel\\\">=</span><span class=\\\"mathop\\\">Ω<sup>4</sup>’</span><var>x</var></span>.<br />\\n</div>\",\"pmc\":\"Thus the proof of the proposition <span class=\\\"mathmode\\\">2 × 2<span class=\\\"mathrel\\\">=</span>4</span> runs as follows: <div class=\\\"centered\\\"><span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">(Ω<sup><var>ν</var></sup>)<sup><var>μ</var></sup>’</span><var>x</var><span class=\\\"mathrel\\\">=</span><span class=\\\"mathop\\\">Ω<sup><var>ν</var>× <var>μ</var></sup>’</span><var>x</var></span> Def.<br />\\n<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">Ω<sup>2 × 2</sup>’</span><var>x</var><span class=\\\"mathrel\\\">=</span><span class=\\\"mathop\\\">(Ω<sup>2</sup>)<sup>2</sup>’</span><var>x</var><span class=\\\"mathrel\\\">=</span><span class=\\\"mathop\\\">(Ω<sup>2</sup>)<sup>1<span class=\\\"mathrel\\\">+</span>1</sup>’</span><var>x</var><span class=\\\"mathrel\\\">=</span><span class=\\\"mathop\\\">Ω<sup>2</sup>’</span><span class=\\\"mathop\\\">Ω<sup>2</sup>’</span><var>x</var></span><br />\\n<span class=\\\"mathmode\\\"><span class=\\\"mathrel\\\">=</span><span class=\\\"mathop\\\">Ω<sup>1<span class=\\\"mathrel\\\">+</span>1</sup>’</span><span class=\\\"mathop\\\">Ω<sup>1<span class=\\\"mathrel\\\">+</span>1</sup>’</span><var>x</var><span class=\\\"mathrel\\\">=</span><span class=\\\"mathop\\\">(Ω’Ω)’</span><span class=\\\"mathop\\\">(Ω’Ω)’</span> <var>x</var></span><br />\\n<span class=\\\"mathmode\\\"><span class=\\\"mathrel\\\">=</span><span class=\\\"mathop\\\">Ω’</span><span class=\\\"mathop\\\">Ω’</span><span class=\\\"mathop\\\">Ω’</span><span class=\\\"mathop\\\">Ω’</span><var>x</var><span class=\\\"mathrel\\\">=</span><span class=\\\"mathop\\\">Ω<sup>1<span class=\\\"mathrel\\\">+</span>1<span class=\\\"mathrel\\\">+</span>1<span class=\\\"mathrel\\\">+</span>1</sup>’</span><var>x</var><span class=\\\"mathrel\\\">=</span><span class=\\\"mathop\\\">Ω<sup>4</sup>’</span><var>x</var></span>.<br />\\n</div>\",\"ogd\":\"Thus the proof of the proposition <span class=\\\"mathmode\\\">2 × 2<span class=\\\"mathrel\\\">=</span>4</span> runs: <div class=\\\"centered\\\"><span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">(Ω<sup><var>ν</var></sup>)<sup><var>μ</var></sup>’</span><var>x</var><span class=\\\"mathrel\\\">=</span><span class=\\\"mathop\\\">Ω<sup><var>ν</var>× <var>μ</var></sup>’</span><var>x</var></span> Def.<br />\\n<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">Ω<sup>2 × 2</sup>’</span><var>x</var><span class=\\\"mathrel\\\">=</span><span class=\\\"mathop\\\">(Ω<sup>2</sup>)<sup>2</sup>’</span><var>x</var><span class=\\\"mathrel\\\">=</span><span class=\\\"mathop\\\">(Ω<sup>2</sup>)<sup>1<span class=\\\"mathrel\\\">+</span>1</sup>’</span><var>x</var><span class=\\\"mathrel\\\">=</span><span class=\\\"mathop\\\">Ω<sup>2</sup>’</span><span class=\\\"mathop\\\">Ω<sup>2</sup>’</span><var>x</var></span><br />\\n<span class=\\\"mathmode\\\"><span class=\\\"mathrel\\\">=</span><span class=\\\"mathop\\\">Ω<sup>1<span class=\\\"mathrel\\\">+</span>1</sup>’</span><span class=\\\"mathop\\\">Ω<sup>1<span class=\\\"mathrel\\\">+</span>1</sup>’</span><var>x</var><span class=\\\"mathrel\\\">=</span><span class=\\\"mathop\\\">(Ω’Ω)’</span><span class=\\\"mathop\\\">(Ω’Ω)’</span> <var>x</var></span><br />\\n<span class=\\\"mathmode\\\"><span class=\\\"mathrel\\\">=</span><span class=\\\"mathop\\\">Ω’</span><span class=\\\"mathop\\\">Ω’</span><span class=\\\"mathop\\\">Ω’</span><span class=\\\"mathop\\\">Ω’</span><var>x</var><span class=\\\"mathrel\\\">=</span><span class=\\\"mathop\\\">Ω<sup>1<span class=\\\"mathrel\\\">+</span>1<span class=\\\"mathrel\\\">+</span>1<span class=\\\"mathrel\\\">+</span>1</sup>’</span><var>x</var><span class=\\\"mathrel\\\">=</span><span class=\\\"mathop\\\">Ω<sup>4</sup>’</span><var>x</var></span>.<br />\\n</div>\",\"str\":\"\"},{\"label\":\"2.151\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":31,\"x_axis\":19,\"ger\":\"Die Form der Abbildung ist die Möglichkeit, dass sich die Dinge so zu einander verhalten, wie die Elemente des Bildes.\",\"pmc\":\"Pictorial form is the possibility that things are related to one another in the same way as the elements of the picture.\",\"ogd\":\"The form of representation is the possibility that the things are combined with one another as are the elements of the picture.\",\"str\":\"\"},{\"label\":\"2.1511\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":31,\"x_axis\":21,\"ger\":\"Das Bild ist <em class=\\\"germph\\\">so</em> mit der Wirklichkeit verknüpft – es reicht bis zu ihr.\",\"pmc\":\"<em>That</em> is how a picture is attached to reality; it reaches right out to it.\",\"ogd\":\"<em>Thus</em> the picture is linked with reality; it reaches up to it.\",\"str\":\"\"},{\"label\":\"2.1512\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":31,\"x_axis\":23,\"ger\":\"Es ist wie ein Maßstab an die Wirklichkeit angelegt.\",\"pmc\":\"It is laid against reality like a measure.\",\"ogd\":\"It is like a scale applied to reality.\",\"str\":\"\"},{\"label\":\"2.1513\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":31,\"x_axis\":25,\"ger\":\"Nach dieser Auffassung gehört also zum Bilde auch noch die abbildende Beziehung, die es zum Bild macht.\",\"pmc\":\"So a picture, conceived in this way, also includes the pictorial relationship, which makes it into a picture.\",\"ogd\":\"According to this view the representing relation which makes it a picture, also belongs to the picture.\",\"str\":\"\"},{\"label\":\"2.1514\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":31,\"x_axis\":27,\"ger\":\"Die abbildende Beziehung besteht aus den Zuordnungen der Elemente des Bildes und der Sachen.\",\"pmc\":\"The pictorial relationship consists of the correlations of the picture’s elements with things.\",\"ogd\":\"The representing relation consists of the co-ordinations of the elements of the picture and the things.\",\"str\":\"\"},{\"label\":\"2.1515\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":31,\"x_axis\":29,\"ger\":\"Diese Zuordnungen sind gleichsam die Fühler der Bildelemente, mit denen das Bild die Wirklichkeit berührt.\",\"pmc\":\"These correlations are, as it were, the feelers of the picture’s elements, with which the picture touches reality.\",\"ogd\":\"These co-ordinations are as it were the feelers of its elements with which the picture touches reality.\",\"str\":\"\"},{\"label\":\"3.311\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":31,\"x_axis\":39,\"ger\":\"Der Ausdruck setzt die Formen aller Sätze voraus, in welchen er vorkommen kann. Er ist das gemeinsame charakteristische Merkmal einer Klasse von Sätzen.\",\"pmc\":\"An expression presupposes the forms of all the propositions in which it can occur. It is the common characteristic mark of a class of propositions.\",\"ogd\":\"An expression presupposes the forms of all propositions in which it can occur. It is the common characteristic mark of a class of propositions.\",\"str\":\"\"},{\"label\":\"3.321\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":31,\"x_axis\":41,\"ger\":\"Zwei verschiedene Symbole können also das Zeichen (Schriftzeichen oder Lautzeichen etc.) miteinander gemein haben – sie bezeichnen dann auf verschiedene Art und Weise.\",\"pmc\":\"So one and the same sign (written or spoken, etc.) can be common to two different symbols—in which case they will signify in different ways.\",\"ogd\":\"Two different symbols can therefore have the sign (the written sign or the sound sign) in common—they then signify in different ways.\",\"str\":\"\"},{\"label\":\"3.331\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":31,\"x_axis\":43,\"ger\":\"Von dieser Bemerkung sehen wir in Russells „Theory of types“ hinüber: Der Irrtum Russells zeigt sich darin, dass er bei der Aufstellung der Zeichenregeln von der Bedeutung der Zeichen reden musste.\",\"pmc\":\"From this observation we turn to Russell’s ‘theory of types’. It can be seen that Russell must be wrong, because he had to mention the meaning of signs when establishing the rules for them.\",\"ogd\":\"From this observation we get a further view—into Russell’s <em>Theory of Types</em>. Russell’s error is shown by the fact that in drawing up his symbolic rules he has to speak about the things his signs mean.\",\"str\":\"\"},{\"label\":\"3.341\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":31,\"x_axis\":45,\"ger\":\"Das Wesentliche am Satz ist also das, was allen Sätzen, welche den gleichen Sinn ausdrücken können, gemeinsam ist. Und ebenso ist allgemein das Wesentliche am Symbol das, was alle Symbole, die denselben Zweck erfüllen können, gemeinsam haben.\",\"pmc\":\"So what is essential in a proposition is what all propositions that can express the same sense have in common. And similarly, in general, what is essential in a symbol is what all symbols that can serve the same purpose have in common.\",\"ogd\":\"The essential in a proposition is therefore that which is common to all propositions which can express the same sense. And in the same way in general the essential in a symbol is that which all symbols which can fulfill the same purpose have in common.\",\"str\":\"\"},{\"label\":\"3.3411\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":31,\"x_axis\":47,\"ger\":\"Man könnte also sagen: Der eigentliche Name ist das, was alle Symbole, die den Gegenstand bezeichnen, gemeinsam haben. Es würde sich so successive ergeben, dass keinerlei Zusammensetzung für den Namen wesentlich ist.\",\"pmc\":\"So one could say that the real name of an object was what all symbols that signified it had in common. Thus, one by one, all kinds of composition would prove to be unessential to a name.\",\"ogd\":\"One could therefore say the real name is that which all symbols, which signify an object, have in common. It would then follow, step by step, that no sort of composition was essential for a name.\",\"str\":\"\"},{\"label\":\"4.114\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":31,\"x_axis\":53,\"ger\":\"Sie soll das Denkbare abgrenzen und damit das Undenkbare. Sie soll das Undenkbare von innen durch das Denkbare begrenzen.\",\"pmc\":\"It must set limits to what can be thought; and, in doing so, to what cannot be thought. It must set limits to what cannot be thought by working outwards through what can be thought.\",\"ogd\":\"It should limit the thinkable and thereby the unthinkable. It should limit the unthinkable from within through the thinkable.\",\"str\":\"\"},{\"label\":\"4.124\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":31,\"x_axis\":59,\"ger\":\"Das Bestehen einer internen Eigenschaft einer möglichen Sachlage wird nicht durch einen Satz ausgedrückt, sondern es drückt sich in dem sie darstellenden Satz durch eine interne Eigenschaft dieses Satzes aus. Es wäre ebenso unsinnig, dem Satze eine formale Eigenschaft zuzusprechen, als sie ihm abzusprechen.\",\"pmc\":\"The existence of an internal property of a possible situation is not expressed by means of a proposition: rather, it expresses itself in the proposition representing the situation, by means of an internal property of that proposition. It would be just as nonsensical to assert that a proposition had a formal property as to deny it.\",\"ogd\":\"The existence of an internal property of a possible state of affairs is not expressed by a proposition, but it expresses itself in the proposition which presents that state of affairs, by an internal property of this proposition. It would be as senseless to ascribe a formal property to a proposition as to deny it the formal property.\",\"str\":\"\"},{\"label\":\"4.1241\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":31,\"x_axis\":61,\"ger\":\"Formen kann man nicht dadurch voneinander unterscheiden, dass man sagt, die eine habe diese, die andere aber jene Eigenschaft; denn dies setzt voraus, dass es einen Sinn habe, beide Eigenschaften von beiden Formen auszusagen.\",\"pmc\":\"It is impossible to distinguish forms from one another by saying that one has this property and another that property: for this presupposes that it makes sense to ascribe either property to either form.\",\"ogd\":\"One cannot distinguish forms from one another by saying that one has this property, the other that: for this assumes that there is a sense in asserting either property of either form.\",\"str\":\"\"},{\"label\":\"5.3\",\"precision\":1,\"fontSize\":\"40px\",\"y_axis\":31,\"x_axis\":75,\"ger\":\"Alle Sätze sind Resultate von Wahrheitsoperationen mit den Elementarsätzen. Die Wahrheitsoperation ist die Art und Weise, wie aus den Elementarsätzen die Wahrheitsfunktion entsteht. Nach dem Wesen der Wahrheitsoperation wird auf die gleiche Weise, wie aus den Elementarsätzen ihre Wahrheitsfunktion, aus Wahrheitsfunktionen eine neue. Jede Wahrheitsoperation erzeugt aus Wahrheitsfunktionen von Elementarsätzen wieder eine Wahrheitsfunktion von Elementarsätzen, einen Satz. Das Resultat jeder Wahrheitsoperation mit den Resultaten von Wahrheitsoperationen mit Elementarsätzen ist wieder das Resultat <em class=\\\"germph\\\">Einer</em> Wahrheitsoperation mit Elementarsätzen. Jeder Satz ist das Resultat von Wahrheitsoperationen mit Elementarsätzen.\",\"pmc\":\"All propositions are results of truth-operations on elementary propositions. A truth-operation is the way in which a truth-function is produced out of elementary propositions. It is of the essence of truth-operations that, just as elementary propositions yield a truth-function of themselves, so too in the same way truth-functions yield a further truth-function. When a truth-operation is applied to truth-functions of elementary propositions, it always generates another truth-function of elementary propositions, another proposition. When a truth-operation is applied to the results of truth-operations on elementary propositions, there is always a <em>single</em> operation on elementary propositions that has the same result. Every proposition is the result of truth-operations on elementary propositions.\",\"ogd\":\"All propositions are results of truth-operations on the elementary propositions. The truth-operation is the way in which a truth-function arises from elementary propositions. According to the nature of truth-operations, in the same way as out of elementary propositions arise their truth-functions, from truth-functions arises a new one. Every truth-operation creates from truth-functions of elementary propositions, another truth-function of elementary propositions <em>i.e.</em> a proposition. The result of every truth-operation on the results of truth-operations on elementary propositions is also the result of <em>one</em> truth-operation on elementary propositions. Every proposition is the result of truth-operations on elementary propositions.\",\"str\":\"\"},{\"label\":\"5.31\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":31,\"x_axis\":77,\"ger\":\"Die Schemata No. 4.31 haben auch dann eine Bedeutung, wenn „<span class=\\\"mathmode\\\"><var>p</var></span>“, „<span class=\\\"mathmode\\\"><var>q</var></span>“, „<span class=\\\"mathmode\\\"><var>r</var></span>“, etc. nicht Elementarsätze sind. Und es ist leicht zu sehen, dass das Satzzeichen in No. 4.442, auch wenn „<span class=\\\"mathmode\\\"><var>p</var></span>“ und „<span class=\\\"mathmode\\\"><var>q</var></span>“ Wahrheitsfunktionen von Elementarsätzen sind, Eine Wahrheitsfunktion von Elementarsätzen ausdrückt.\",\"pmc\":\"The schemata in 4.31 have a meaning even when ‘<span class=\\\"mathmode\\\"><var>p</var></span>’, ‘<span class=\\\"mathmode\\\"><var>q</var></span>’, ‘<span class=\\\"mathmode\\\"><var>r</var></span>’, etc. are not elementary propositions. And it is easy to see that the propositional sign in 4.442 expresses a single truth-function of elementary propositions even when ‘<span class=\\\"mathmode\\\"><var>p</var></span>’ and ‘<span class=\\\"mathmode\\\"><var>q</var></span>’ are truth-functions of elementary propositions.\",\"ogd\":\"The Schemata No. 4.31 are also significant, if “<span class=\\\"mathmode\\\"><var>p</var></span>”, “<span class=\\\"mathmode\\\"><var>q</var></span>”, “<span class=\\\"mathmode\\\"><var>r</var></span>”, etc. are not elementary propositions. And it is easy to see that the propositional sign in No. 4.442 expresses one truth-function of elementary propositions even when “<span class=\\\"mathmode\\\"><var>p</var></span>” and “<span class=\\\"mathmode\\\"><var>q</var></span>” are truth-functions of elementary propositions.\",\"str\":\"\"},{\"label\":\"5.32\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":31,\"x_axis\":79,\"ger\":\"Alle Wahrheitsfunktionen sind Resultate der successiven Anwendung einer endlichen Anzahl von Wahrheitsoperationen auf die Elementarsätze.\",\"pmc\":\"All truth-functions are results of successive applications to elementary propositions of a finite number of truth-operations.\",\"ogd\":\"All truth-functions are results of the successive application of a finite number of truth-operations to elementary propositions.\",\"str\":\"\"},{\"label\":\"6.232\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":31,\"x_axis\":113,\"ger\":\"Frege sagt, die beiden Ausdrücke haben dieselbe Bedeutung, aber verschiedenen Sinn. Das Wesentliche an der Gleichung ist aber, dass sie nicht notwendig ist, um zu zeigen, dass die beiden Ausdrücke, die das Gleichheitszeichen verbindet, dieselbe Bedeutung haben, da sich dies aus den beiden Ausdrücken selbst ersehen lässt.\",\"pmc\":\"Frege says that the two expressions have the same meaning but different senses. But the essential point about an equation is that it is not necessary in order to show that the two expressions connected by the sign of equality have the same meaning, since this can be seen from the two expressions themselves.\",\"ogd\":\"Frege says that these expressions have the same meaning but different senses. But what is essential about equation is that it is not necessary in order to show that both expressions, which are connected by the sign of equality, have the same meaning: for this can be perceived from the two expressions themselves.\",\"str\":\"\"},{\"label\":\"6.2321\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":31,\"x_axis\":115,\"ger\":\"Und, dass die Sätze der Mathematik bewiesen werden können, heißt ja nichts anderes, als dass ihre Richtigkeit einzusehen ist, ohne dass das, was sie ausdrücken, selbst mit den Tatsachen auf seine Richtigkeit hin verglichen werden muss.\",\"pmc\":\"And the possibility of proving the propositions of mathematics means simply that their correctness can be perceived without its being necessary that what they express should itself be compared with the facts in order to determine its correctness.\",\"ogd\":\"And, that the propositions of mathematics can be proved means nothing else than that their correctness can be seen without our having to compare what they express with the facts as regards correctness.\",\"str\":\"\"},{\"label\":\"6.2322\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":31,\"x_axis\":117,\"ger\":\"Die Identität der Bedeutung zweier Ausdrücke lässt sich nicht <em class=\\\"germph\\\">behaupten</em>. Denn, um etwas von ihrer Bedeutung behaupten zu können, muss ich ihre Bedeutung kennen: und indem ich ihre Bedeutung kenne, weiß ich, ob sie dasselbe oder verschiedenes bedeuten.\",\"pmc\":\"It is impossible to <em>assert</em> the identity of meaning of two expressions. For in order to be able to assert anything about their meaning, I must know their meaning, and I cannot know their meaning without knowing whether what they mean is the same or different.\",\"ogd\":\"The identity of the meaning of two expressions cannot be <em>asserted</em>. For in order to be able to assert anything about their meaning, I must know their meaning, and if I know their meaning, I know whether they mean the same or something different.\",\"str\":\"\"},{\"label\":\"6.2323\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":31,\"x_axis\":119,\"ger\":\"Die Gleichung kennzeichnet nur den Standpunkt, von welchem ich die beiden Ausdrücke betrachte, nämlich vom Standpunkte ihrer Bedeutungsgleichheit.\",\"pmc\":\"An equation merely marks the point of view from which I consider the two expressions: it marks their equivalence in meaning.\",\"ogd\":\"The equation characterizes only the standpoint from which I consider the two expressions, that is to say the standpoint of their equality of meaning.\",\"str\":\"\"},{\"label\":\"2.15121\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":33,\"x_axis\":23,\"ger\":\"Nur die äußersten Punkte der Teilstriche <em class=\\\"germph\\\">berühren</em> den zu messenden Gegenstand.\",\"pmc\":\"Only the end-points of the graduating lines actually <em>touch</em> the object that is to be measured.\",\"ogd\":\"Only the outermost points of the dividing lines <em>touch</em> the object to be measured.\",\"str\":\"\"},{\"label\":\"3.312\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":33,\"x_axis\":39,\"ger\":\"Er wird also dargestellt durch die allgemeine Form der Sätze, die er charakterisiert. Und zwar wird in dieser Form der Ausdruck <em class=\\\"germph\\\">konstant</em> und alles übrige <em class=\\\"germph\\\">variabel</em> sein.\",\"pmc\":\"It is therefore presented by means of the general form of the propositions that it characterizes. In fact, in this form the expression will be <em>constant</em> and everything else <em>variable</em>.\",\"ogd\":\"It is therefore represented by the general form of the propositions which it characterizes. And in this form the expression is <em>constant</em> and everything else <em>variable</em>.\",\"str\":\"\"},{\"label\":\"3.322\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":33,\"x_axis\":41,\"ger\":\"Es kann nie das gemeinsame Merkmal zweier Gegenstände anzeigen, dass wir sie mit demselben Zeichen, aber durch zwei verschiedene <em class=\\\"germph\\\">Bezeichnungsweisen</em> bezeichnen. Denn das Zeichen ist ja willkürlich. Man könnte also auch zwei verschiedene Zeichen wählen, und wo bliebe dann das Gemeinsame in der Bezeichnung?\",\"pmc\":\"Our use of the same sign to signify two different objects can never indicate a common characteristic of the two, if we use it with two different <em>modes of signification</em>. For the sign, of course, is arbitrary. So we could choose two different signs instead, and then what would be left in common on the signifying side?\",\"ogd\":\"It can never indicate the common characteristic of two objects that we symbolize them with the same signs but by different <em>methods of symbolizing</em>. For the sign is arbitrary. We could therefore equally well choose two different signs and where then would be what was common in the symbolization?\",\"str\":\"\"},{\"label\":\"3.332\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":33,\"x_axis\":43,\"ger\":\"Kein Satz kann etwas über sich selbst aussagen, weil das Satzzeichen nicht in sich selbst enthalten sein kann (das ist die ganze „Theory of types“).\",\"pmc\":\"No proposition can make a statement about itself, because a propositional sign cannot be contained in itself (that is the whole of the ‘theory of types’).\",\"ogd\":\"No proposition can say anything about itself, because the propositional sign cannot be contained in itself (that is the “whole theory of types”).\",\"str\":\"\"},{\"label\":\"3.342\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":33,\"x_axis\":45,\"ger\":\"An unseren Notationen ist zwar etwas willkürlich, aber <em class=\\\"germph\\\">das</em> ist nicht willkürlich: Dass, <em class=\\\"germph\\\">wenn</em> wir etwas willkürlich bestimmt haben, dann etwas anderes der Fall sein muss. (Dies hängt von dem <em class=\\\"germph\\\">Wesen</em> der Notation ab.)\",\"pmc\":\"Although there is something arbitrary in our notations, <em>this much</em> is not arbitrary—that <em>when</em> we have determined one thing arbitrarily, something else is necessarily the case. (This derives from the <em>essence</em> of notation.)\",\"ogd\":\"In our notations there is indeed something arbitrary, but <em>this</em> is not arbitrary, namely that <em>if</em> we have determined anything arbitrarily, then something else <em>must</em> be the case. (This results from the <em>essence</em> of the notation.)\",\"str\":\"\"},{\"label\":\"3.3421\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":33,\"x_axis\":47,\"ger\":\"Eine besondere Bezeichnungsweise mag unwichtig sein, aber wichtig ist es immer, dass diese eine <em class=\\\"germph\\\">mögliche</em> Bezeichnungsweise ist. Und so verhält es sich in der Philosophie überhaupt: Das Einzelne erweist sich immer wieder als unwichtig, aber die Möglichkeit jedes Einzelnen gibt uns einen Aufschluss über das Wesen der Welt.\",\"pmc\":\"A particular mode of signifying may be unimportant but it is always important that it is a <em>possible</em> mode of signifying. And that is generally so in philosophy: again and again the individual case turns out to be unimportant, but the possibility of each individual case discloses something about the essence of the world.\",\"ogd\":\"A particular method of symbolizing may be unimportant, but it is always important that this is a <em>possible</em> method of symbolizing. And this happens as a rule in philosophy: The single thing proves over and over again to be unimportant, but the possibility of every single thing reveals something about the nature of the world.\",\"str\":\"\"},{\"label\":\"4.115\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":33,\"x_axis\":53,\"ger\":\"Sie wird das Unsagbare bedeuten, indem sie das Sagbare klar darstellt.\",\"pmc\":\"It will signify what cannot be said, by presenting clearly what can be said.\",\"ogd\":\"It will mean the unspeakable by clearly displaying the speakable.\",\"str\":\"\"},{\"label\":\"4.125\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":33,\"x_axis\":59,\"ger\":\"Das Bestehen einer internen Relation zwischen möglichen Sachlagen drückt sich sprachlich durch eine interne Relation zwischen den sie darstellenden Sätzen aus.\",\"pmc\":\"The existence of an internal relation between possible situations expresses itself in language by means of an internal relation between the propositions representing them.\",\"ogd\":\"The existence of an internal relation between possible states of affairs expresses itself in language by an internal relation between the propositions presenting them.\",\"str\":\"\"},{\"label\":\"4.1251\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":33,\"x_axis\":61,\"ger\":\"Hier erledigt sich nun die Streitfrage, „ob alle Relationen intern oder extern seien“.\",\"pmc\":\"Here we have the answer to the vexed question ‘whether all relations are internal or external’.\",\"ogd\":\"Now this settles the disputed question “whether all relations are internal or external”.\",\"str\":\"\"},{\"label\":\"4.1252\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":33,\"x_axis\":63,\"ger\":\"Reihen, welche durch <em class=\\\"germph\\\">interne</em> Relationen geordnet sind, nenne ich Formenreihen. Die Zahlenreihe ist nicht nach einer externen, sondern nach einer internen Relation geordnet. Ebenso die Reihe der Sätze „<span class=\\\"mathmode\\\"><var>aRb</var></span>“, „<span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<span class=\\\"symbol\\\">∃</span><var>x</var>):</span><var>aRx</var><span class=\\\"mathrel\\\">.</span><var>xRb</var></span>“, „<span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<span class=\\\"symbol\\\">∃</span><var>x</var>,<var>y</var>):</span><var>aRx</var><span class=\\\"mathrel\\\">.</span><var>xRy</var><span class=\\\"mathrel\\\">.</span><var>yRb</var></span>“, u. s. f. (Steht <span class=\\\"mathmode\\\"><var>b</var></span> in einer dieser Beziehungen zu <span class=\\\"mathmode\\\"><var>a</var></span>, so nenne ich <span class=\\\"mathmode\\\"><var>b</var></span> einen Nachfolder von <span class=\\\"mathmode\\\"><var>a</var></span>.)\",\"pmc\":\"I call a series that is ordered by an internal relation a series of forms. The order of the number-series is not governed by an external relation but by an internal relation. The same is true of the series of propositions ‘<span class=\\\"mathmode\\\"><var>aRb</var></span>’, ‘<span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<span class=\\\"symbol\\\">∃</span><var>x</var>):</span><var>aRx</var><span class=\\\"mathrel\\\">.</span><var>xRb</var></span>’, ‘<span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<span class=\\\"symbol\\\">∃</span><var>x</var>,<var>y</var>):</span><var>aRx</var><span class=\\\"mathrel\\\">.</span><var>xRy</var><span class=\\\"mathrel\\\">.</span><var>yRb</var></span>’, and so forth. (If <span class=\\\"mathmode\\\"><var>b</var></span> stands in one of these relations to <span class=\\\"mathmode\\\"><var>a</var></span>, I call <span class=\\\"mathmode\\\"><var>b</var></span> a successor of <span class=\\\"mathmode\\\"><var>a</var></span>.)\",\"ogd\":\"Series which are ordered by <em>internal</em> relations I call formal series. The series of numbers is ordered not by an external, but by an internal relation. Similarly the series of propositions “<span class=\\\"mathmode\\\"><var>aRb</var></span>”, “<span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<span class=\\\"symbol\\\">∃</span><var>x</var>):</span><var>aRx</var><span class=\\\"mathrel\\\">.</span><var>xRb</var></span>”, “<span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<span class=\\\"symbol\\\">∃</span><var>x</var>,<var>y</var>):</span><var>aRx</var><span class=\\\"mathrel\\\">.</span><var>xRy</var><span class=\\\"mathrel\\\">.</span><var>yRb</var></span>”, etc. (If <span class=\\\"mathmode\\\"><var>b</var></span> stands in one of these relations to <span class=\\\"mathmode\\\"><var>a</var></span>, I call <span class=\\\"mathmode\\\"><var>b</var></span> a successor of <span class=\\\"mathmode\\\"><var>a</var></span>.)\",\"str\":\"\"},{\"label\":\"5.4\",\"precision\":1,\"fontSize\":\"40px\",\"y_axis\":33,\"x_axis\":75,\"ger\":\"Hier zeigt es sich, dass es „logische Gegenstände“, „logische Konstante“ (im Sinne Freges und Russells) nicht gibt.\",\"pmc\":\"At this point it becomes manifest that there are no ‘logical objects’ or ‘logical constants’ (in Frege’s and Russell’s sense).\",\"ogd\":\"Here it becomes clear that there are no such things as “logical objects” or “logical constants” (in the sense of Frege and Russell).\",\"str\":\"\"},{\"label\":\"5.41\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":33,\"x_axis\":77,\"ger\":\"Denn: Alle Resultate von Wahrheitsoperationen mit Wahrheitsfunktionen sind identisch, welche eine und dieselbe Wahrheitsfunktion von Elementarsätzen sind.\",\"pmc\":\"The reason is that the results of truth-operations on truth-functions are always identical whenever they are one and the same truth-function of elementary propositions.\",\"ogd\":\"For all those results of truth-operations on truth-functions are identical, which are one and the same truth-function of elementary propositions.\",\"str\":\"\"},{\"label\":\"5.42\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":33,\"x_axis\":79,\"ger\":\"Dass ∨, ⊃, etc. nicht Beziehungen im Sinne von rechts und links etc. sind, leuchtet ein. Die Möglichkeit des kreuzweisen Definierens der logischen „Urzeichen“ Freges und Russells zeigt schon, dass diese keine Urzeichen sind, und schon erst recht, dass sie keine Relationen bezeichnen. Und es ist offenbar, dass das „⊃“, welches wir durch „~“ und „∨“ definieren, identisch ist mit dem, durch welches wir „∨“ mit „~“ definieren, und dass dieses „∨“ mit dem ersten identisch ist. U. s. w.\",\"pmc\":\"It is self-evident that ∨, ⊃, etc. are not relations in the sense in which right and left etc. are relations. The interdefinability of Frege’s and Russell’s ‘primitive signs’ of logic is enough to show that they are not primitive signs, still less signs for relations. And it is obvious that the ‘⊃’ defined by means of ‘~’ and ‘∨’ is identical with the one that figures with ‘~’ in the definition of ‘∨’; and that the second ‘∨’ is identical with the first one; and so on.\",\"ogd\":\"That ∨, ⊃, etc., are not relations in the sense of right and left, etc., is obvious. The possibility of crosswise definition of the logical “primitive signs” of Frege and Russell shows by itself that these are not primitive signs and that they signify no relations. And it is obvious that the “⊃” which we define by means of “~” and “∨” is identical with that by which we define “∨” with the help of “~”, and that this “∨” is the same as the first, and so on.\",\"str\":\"\"},{\"label\":\"5.43\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":33,\"x_axis\":81,\"ger\":\"Dass aus einer Tatsache <span class=\\\"mathmode\\\"><var>p</var></span> unendlich viele <em class=\\\"germph\\\">andere</em> folgen sollten, nämlich <span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><span class=\\\"mathop\\\">~</span><var>p</var></span>, <span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><span class=\\\"mathop\\\">~</span><span class=\\\"mathop\\\">~</span><span class=\\\"mathop\\\">~</span><var>p</var></span>, etc., ist doch von vornherein kaum zu glauben. Und nicht weniger merkwürdig ist, dass die unendliche Anzahl der Sätze der Logik (der Mathematik) aus einem halben Dutzend „Grundgesetzen“ folgen. Alle Sätze der Logik sagen aber dasselbe. Nämlich nichts.\",\"pmc\":\"Even at first sight it seems scarcely credible that there should follow from one fact <span class=\\\"mathmode\\\"><var>p</var></span> infinitely many <em>others</em>, namely <span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><span class=\\\"mathop\\\">~</span><var>p</var></span>, <span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><span class=\\\"mathop\\\">~</span><span class=\\\"mathop\\\">~</span><span class=\\\"mathop\\\">~</span><var>p</var></span>, etc. And it is no less remarkable that the infinite number of propositions of logic (mathematics) follow from half a dozen ‘primitive propositions’. But in fact all the propositions of logic say the same thing, to wit nothing.\",\"ogd\":\"That from a fact <span class=\\\"mathmode\\\"><var>p</var></span> an infinite number of <em>others</em> should follow, namely, <span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><span class=\\\"mathop\\\">~</span><var>p</var></span>, <span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><span class=\\\"mathop\\\">~</span><span class=\\\"mathop\\\">~</span><span class=\\\"mathop\\\">~</span><var>p</var></span>, etc., is indeed hardly to be believed, and it is no less wonderful that the infinite number of propositions of logic (of mathematics) should follow from half a dozen “primitive propositions”. But the propositions of logic say the same thing. That is, nothing.\",\"str\":\"\"},{\"label\":\"5.44\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":33,\"x_axis\":83,\"ger\":\"Die Wahrheitsfunktionen sind keine materiellen Funktionen. Wenn man z. B. eine Bejahung durch doppelte Verneinung erzeugen kann, ist dann die Verneinung – in irgend einem Sinn – in der Bejahung enthalten? Verneint „<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><span class=\\\"mathop\\\">~</span><var>p</var></span>“ <span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><var>p</var></span>, oder bejaht es <span class=\\\"mathmode\\\"><var>p</var></span>; oder beides? Der Satz „<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><span class=\\\"mathop\\\">~</span><var>p</var></span>“ handelt nicht von der Verneinung wie von einem Gegenstand; wohl aber ist die Möglichkeit der Verneinung in der Bejahung bereits präjudiziert. Und gäbe es einen Gegenstand, der „~“ hieße, so müsste „<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><span class=\\\"mathop\\\">~</span><var>p</var></span>“ etwas anderes sagen als „<span class=\\\"mathmode\\\"><var>p</var></span>“. Denn der eine Satz würde dann eben von ~ handeln, der andere nicht.\",\"pmc\":\"Truth-functions are not material functions. For example, an affirmation can be produced by double negation: in such a case does it follow that in some sense negation is contained in affirmation? Does ‘<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><span class=\\\"mathop\\\">~</span><var>p</var></span>’ negate <span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><var>p</var></span>, or does it affirm <span class=\\\"mathmode\\\"><var>p</var></span>—or both? The proposition ‘<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><span class=\\\"mathop\\\">~</span><var>p</var></span>’ is not about negation, as if negation were an object: on the other hand, the possibility of negation is already written into affirmation. And if there were an object called ‘~’, it would follow that ‘<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><span class=\\\"mathop\\\">~</span><var>p</var></span>’ said something different from what ‘<span class=\\\"mathmode\\\"><var>p</var></span>’ said, just because the one proposition would then be about ~ and the other would not.\",\"ogd\":\"Truth-functions are not material functions. If <em>e.g.</em> an affirmation can be produced by repeated denial, is the denial—in any sense—contained in the affirmation? Does “<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><span class=\\\"mathop\\\">~</span><var>p</var></span>” deny <span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><var>p</var></span>, or does it affirm <span class=\\\"mathmode\\\"><var>p</var></span>; or both? The proposition “<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><span class=\\\"mathop\\\">~</span><var>p</var></span>” does not treat of denial as an object, but the possibility of denial is already prejudged in affirmation. And if there was an object called “~”, then “<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><span class=\\\"mathop\\\">~</span><var>p</var></span>” would have to say something other than “<span class=\\\"mathmode\\\"><var>p</var></span>”. For the one proposition would then treat of ~, the other would not.\",\"str\":\"\"},{\"label\":\"5.45\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":33,\"x_axis\":85,\"ger\":\"Gibt es logische Urzeichen, so muss eine richtige Logik ihre Stellung zueinander klar machen und ihr Dasein rechtfertigen. Der Bau der Logik <em class=\\\"germph\\\">aus</em> ihren Urzeichen muss klar werden.\",\"pmc\":\"If there are primitive logical signs, then any logic that fails to show clearly how they are placed relatively to one another and to justify their existence will be incorrect. The construction of logic <em>out of</em> its primitive signs must be made clear.\",\"ogd\":\"If there are logical primitive signs a correct logic must make clear their position relative to one another and justify their existence. The construction of logic <em>out of</em> its primitive signs must become clear.\",\"str\":\"\"},{\"label\":\"5.46\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":33,\"x_axis\":87,\"ger\":\"Wenn man die logischen Zeichen richtig einführte, so hätte man damit auch schon den Sinn aller ihrer Kombinationen eingeführt; also nicht nur „<span class=\\\"mathmode\\\"><var>p</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">∨</span></span><var>q</var></span>“ sondern auch schon „<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span>(<var>p</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">∨</span></span><span class=\\\"mathop\\\">~</span><var>q</var>)</span>“ etc. etc. Man hätte damit auch schon die Wirkung aller nur möglichen Kombinationen von Klammern eingeführt. Und damit wäre es klar geworden, dass die eigentlichen allgemeinen Urzeichen nicht die „<span class=\\\"mathmode\\\"><var>p</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">∨</span></span><var>q</var> </span>“, „<span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<span class=\\\"symbol\\\">∃</span><var>x</var>).</span><var>fx</var></span>“, etc. sind, sondern die allgemeinste Form ihrer Kombinationen.\",\"pmc\":\"If we introduced logical signs properly, then we should also have introduced at the same time the sense of all combinations of them; i.e. not only ‘<span class=\\\"mathmode\\\"><var>p</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">∨</span></span><var>q</var></span>’ but ‘<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span>(<var>p</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">∨</span></span><span class=\\\"mathop\\\">~</span><var>q</var>)</span>’ as well, etc. etc. We should also have introduced at the same time the effect of all possible combinations of brackets. And thus it would have been made clear that the real general primitive signs are not ‘<span class=\\\"mathmode\\\"><var>p</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">∨</span></span><var>q</var></span>’, ‘<span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<span class=\\\"symbol\\\">∃</span><var>x</var>).</span><var>fx</var></span>’, etc. but the most general form of their combinations.\",\"ogd\":\"When we have rightly introduced the logical signs, the sense of all their combinations has been already introduced with them: therefore not only “<span class=\\\"mathmode\\\"><var>p</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">∨</span></span><var>q</var></span>” but also “<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span>(<var>p</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">∨</span></span><span class=\\\"mathop\\\">~</span><var>q</var>)</span>”, etc. etc. We should then already have introduced the effect of all possible combinations of brackets; and it would then have become clear that the proper general primitive signs are not “<span class=\\\"mathmode\\\"><var>p</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">∨</span></span><var>q</var></span>”, “<span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<span class=\\\"symbol\\\">∃</span><var>x</var>).</span><var>fx</var></span>”, etc., but the most general form of their combinations.\",\"str\":\"\"},{\"label\":\"5.47\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":33,\"x_axis\":91,\"ger\":\"Es ist klar, dass alles, was sich überhaupt <em class=\\\"germph\\\">von vornherein</em> über die Form aller Sätze sagen lässt, sich <em class=\\\"germph\\\">auf einmal</em> sagen lassen muss. Sind ja schon im Elementarsatze alle logischen Operationen enthalten. Denn „<span class=\\\"mathmode\\\"><var>fa</var></span>“ sagt dasselbe wie <div class=\\\"centered\\\"><span class=\\\"mathmode\\\">„<span class=\\\"quant\\\">(<span class=\\\"symbol\\\">∃</span><var>x</var>).</span><var>fx</var><span class=\\\"mathrel\\\">.</span><var>x</var><span class=\\\"mathrel\\\">=</span><var>a</var>“.</span></div><span class=\\\"mathmode\\\"></span> Wo Zusammengesetztheit ist, da ist Argument und Funktion, und wo diese sind, sind bereits alle logischen Konstanten. Man könnte sagen: Die Eine logische Konstante ist das, was <em class=\\\"germph\\\">alle</em> Sätze, ihrer Natur nach, mit einander gemein haben. Das aber ist die allgemeine Satzform.\",\"pmc\":\"It is clear that whatever we can say <em>in advance</em> about the form of all propositions, we must be able to say <em>all at once</em>. An elementary proposition really contains all logical operations in itself. For ‘<span class=\\\"mathmode\\\"><var>fa</var></span>’ says the same thing as <div class=\\\"centered\\\"><span class=\\\"mathmode\\\">‘<span class=\\\"quant\\\">(<span class=\\\"symbol\\\">∃</span><var>x</var>).</span><var>fx</var><span class=\\\"mathrel\\\">.</span><var>x</var><span class=\\\"mathrel\\\">=</span><var>a</var>’.</span></div><span class=\\\"mathmode\\\"></span> Wherever there is compositeness, argument and function are present, and where these are present, we already have all the logical constants. One could say that the sole logical constant was what <em>all</em> propositions, by their very nature, had in common with one another. But that is the general propositional form.\",\"ogd\":\"It is clear that everything which can be said <em>beforehand</em> about the form of <em>all</em> propositions at all can be said <em>on one occasion</em>. For all logical operations are already contained in the elementary proposition. For “<span class=\\\"mathmode\\\"><var>fa</var></span>” says the same as <div class=\\\"centered\\\"><span class=\\\"mathmode\\\">“<span class=\\\"quant\\\">(<span class=\\\"symbol\\\">∃</span><var>x</var>).</span><var>fx</var><span class=\\\"mathrel\\\">.</span><var>x</var><span class=\\\"mathrel\\\">=</span><var>a</var>”.</span></div><span class=\\\"mathmode\\\"></span> Where there is composition, there is argument and function, and where these are, all logical constants already are. One could say: the one logical constant is that which <em>all</em> propositions, according to their nature, have in common with one another. That however is the general form of proposition.\",\"str\":\"\"},{\"label\":\"6.233\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":33,\"x_axis\":113,\"ger\":\"Die Frage, ob man zur Lösung der mathematischen Probleme die Anschauung brauche, muss dahin beantwortet werden, dass eben die Sprache hier die nötige Anschauung liefert.\",\"pmc\":\"The question whether intuition is needed for the solution of mathematical problems must be given the answer that in this case language itself provides the necessary intuition.\",\"ogd\":\"To the question whether we need intuition for the solution of mathematical problems it must be answered that language itself here supplies the necessary intuition.\",\"str\":\"\"},{\"label\":\"6.2331\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":33,\"x_axis\":115,\"ger\":\"Der Vorgang des <em class=\\\"germph\\\">Rechnens</em> vermittelt eben diese Anschauung. Die Rechnung ist kein Experiment.\",\"pmc\":\"The process of <em>calculating</em> serves to bring about that intuition. Calculation is not an experiment.\",\"ogd\":\"The process of calculation brings about just this intuition. Calculation is not an experiment.\",\"str\":\"\"},{\"label\":\"2.2\",\"precision\":1,\"fontSize\":\"40px\",\"y_axis\":35,\"x_axis\":9,\"ger\":\"Das Bild hat mit dem Abgebildeten die logische Form der Abbildung gemein.\",\"pmc\":\"A picture has logico-pictorial form in common with what it depicts.\",\"ogd\":\"The picture has the logical form of representation in common with what it pictures.\",\"str\":\"\"},{\"label\":\"2.201\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":35,\"x_axis\":11,\"ger\":\"Das Bild bildet die Wirklichkeit ab, indem es eine Möglichkeit des Bestehens und Nichtbestehens von Sachverhalten darstellt.\",\"pmc\":\"A picture depicts reality by representing a possibility of existence and non-existence of states of affairs.\",\"ogd\":\"The picture depicts reality by representing a possibility of the existence and non-existence of atomic facts.\",\"str\":\"\"},{\"label\":\"2.202\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":35,\"x_axis\":13,\"ger\":\"Das Bild stellt eine mögliche Sachlage im logischen Raume dar.\",\"pmc\":\"A picture represents a possible situation in logical space.\",\"ogd\":\"The picture represents a possible state of affairs in logical space.\",\"str\":\"\"},{\"label\":\"2.203\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":35,\"x_axis\":15,\"ger\":\"Das Bild enthält die Möglichkeit der Sachlage, die es darstellt.\",\"pmc\":\"A picture contains the possibility of the situation that it represents.\",\"ogd\":\"The picture contains the possibility of the state of affairs which it represents.\",\"str\":\"\"},{\"label\":\"3.313\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":35,\"x_axis\":39,\"ger\":\"Der Ausdruck wird also durch eine Variable dargestellt, deren Werte die Sätze sind, die den Ausdruck enthalten. (Im Grenzfall wird die Variable zur Konstanten, der Ausdruck zum Satz.) Ich nenne eine solche Variable „Satzvariable“.\",\"pmc\":\"Thus an expression is presented by means of a variable whose values are the propositions that contain the expression. (In the limiting case the variable becomes a constant, the expression becomes a proposition.) I call such a variable a ‘propositional variable’.\",\"ogd\":\"An expression is thus presented by a variable, whose values are the propositions which contain the expression. (In the limiting case the variable becomes constant, the expression a proposition.) I call such a variable a “propositional variable”.\",\"str\":\"\"},{\"label\":\"3.323\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":35,\"x_axis\":41,\"ger\":\"In der Umgangssprache kommt es ungemein häufig vor, dass dasselbe Wort auf verschiedene Art und Weise bezeichnet – also verschiedenen Symbolen angehört –, oder, dass zwei Wörter, die auf verschiedene Art und Weise bezeichnen, äußerlich in der gleichen Weise im Satz angewandt werden. So erscheint das Wort „ist“ als Kopula, als Gleichheitszeichen und als Ausdruck der Existenz; „existieren“ als intransitives Zeitwort wie „gehen“; „identisch“ als Eigenschaftswort; wir reden von <em class=\\\"germph\\\">Etwas</em>, aber auch davon, dass <em class=\\\"germph\\\">etwas</em> geschieht. (Im Satze „Grün ist grün“ – wo das erste Wort ein Personenname, das letzte ein Eigenschaftswort ist – haben diese Worte nicht einfach verschiedene Bedeutung, sondern es sind <em class=\\\"germph\\\">verschiedene Symbole</em>.)\",\"pmc\":\"In everyday language it very frequently happens that the same word has different modes of signification—and so belongs to different symbols—or that two words that have different modes of signification are employed in propositions in what is superficially the same way. Thus the word ‘is’ figures as the copula, as a sign for identity, and as an expression for existence; ‘exist’ figures as an intransitive verb like ‘go’, and ‘identical’ as an adjective; we speak of <em>something</em>, but also of <em>something’s</em> happening. (In the proposition, ‘Green is green’—where the first word is the proper name of a person and the last an adjective—these words do not merely have different meanings: they are <em>different symbols</em>.)\",\"ogd\":\"In the language of everyday life it very often happens that the same word signifies in two different ways—and therefore belongs to two different symbols—or that two words, which signify in different ways, are apparently applied in the same way in the proposition. Thus the word “is” appears as the copula, as the sign of equality, and as the expression of existence; “to exist” as an intransitive verb like “to go”; “identical” as an adjective; we speak of <em>something</em> but also of the fact of <em>something</em> happening. (In the proposition “Green is green”—where the first word is a proper name as the last an adjective—these words have not merely different meanings but they are <em>different symbols</em>.)\",\"str\":\"\"},{\"label\":\"3.333\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":35,\"x_axis\":43,\"ger\":\"Eine Funktion kann darum nicht ihr eigenes Argument sein, weil das Funktionszeichen bereits das Urbild seines Arguments enthält und es sich nicht selbst enthalten kann. Nehmen wir nämlich an, die Funktion <span class=\\\"mathmode\\\"><var>F</var>(<var>fx</var>)</span> könnte ihr eigenes Argument sein; dann gäbe es also einen Satz: „<span class=\\\"mathmode\\\"><var>F</var>(<var>F</var>(<var>fx</var>))</span>“ und in diesem müssen die äußere Funktion <span class=\\\"mathmode\\\"><var>F</var></span> und die innere Funtion <span class=\\\"mathmode\\\"><var>F</var></span> verschiedene Bedeutungen haben, denn die innere hat die Form <span class=\\\"mathmode\\\"><var>φ</var>(<var>fx</var>)</span>, die äußere die Form <span class=\\\"mathmode\\\"><var>ψ</var>(<var>φ</var>(<var>fx</var>))</span>. Gemeinsam ist den beiden Funktionen nur der Buchstabe „<span class=\\\"mathmode\\\"><var>F</var></span>“, der aber allein nichts bezeichnet. Dies wird sofort klar, wenn wir statt „<span class=\\\"mathmode\\\"><var>F</var>(<var>Fu</var>)</span>“ schreiben „<span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<span class=\\\"symbol\\\">∃</span><var>φ</var>):</span><var>F</var>(<var>φu</var>)<span class=\\\"mathrel\\\">.</span><var>φu</var><span class=\\\"mathrel\\\">=</span><var>Fu</var></span>“. Hiermit erledigt sich Russells Paradox.\",\"pmc\":\"The reason why a function cannot be its own argument is that the sign for a function already contains the prototype of its argument, and it cannot contain itself. For let us suppose that the function <span class=\\\"mathmode\\\"><var>F</var>(<var>fx</var>)</span> could be its own argument: in that case there would be a proposition ‘<span class=\\\"mathmode\\\"><var>F</var>(<var>F</var>(<var>fx</var>))</span>’, in which the outer function <span class=\\\"mathmode\\\"><var>F</var></span> and the inner function <span class=\\\"mathmode\\\"><var>F</var></span> must have different meanings, since the inner one has the form <span class=\\\"mathmode\\\"><var>φ</var>(<var>fx</var>)</span> and the outer one has the form <span class=\\\"mathmode\\\"><var>ψ</var>(<var>φ</var>(<var>fx</var>))</span>. Only the letter ‘<span class=\\\"mathmode\\\"><var>F</var></span>’ is common to the two functions, but the letter by itself signifies nothing. This immediately becomes clear if instead of ‘<span class=\\\"mathmode\\\"><var>F</var>(<var>Fu</var>)</span>’ we write ‘<span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<span class=\\\"symbol\\\">∃</span><var>φ</var>):</span><var>F</var>(<var>φu</var>)<span class=\\\"mathrel\\\">.</span><var>φu</var><span class=\\\"mathrel\\\">=</span><var>Fu</var></span>’. That disposes of Russell’s paradox.\",\"ogd\":\"A function cannot be its own argument, because the functional sign already contains the prototype of its own argument and it cannot contain itself. If, for example, we suppose that the function <span class=\\\"mathmode\\\"><var>F</var>(<var>fx</var>)</span> could be its own argument, then there would be a proposition “<span class=\\\"mathmode\\\"><var>F</var>(<var>F</var>(<var>fx</var>))</span>”, and in this the outer function <span class=\\\"mathmode\\\"><var>F</var></span> and the inner function <span class=\\\"mathmode\\\"><var>F</var></span> must have different meanings; for the inner has the form <span class=\\\"mathmode\\\"><var>φ</var>(<var>fx</var>)</span>, the outer the form <span class=\\\"mathmode\\\"><var>ψ</var>(<var>φ</var>(<var>fx</var>))</span>. Common to both functions is only the letter “<span class=\\\"mathmode\\\"><var>F</var></span>”, which by itself signifies nothing. This is at once clear, if instead of “<span class=\\\"mathmode\\\"><var>F</var>(<var>Fu</var>)</span>” we write “<span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<span class=\\\"symbol\\\">∃</span><var>φ</var>):</span><var>F</var>(<var>φu</var>)<span class=\\\"mathrel\\\">.</span><var>φu</var><span class=\\\"mathrel\\\">=</span><var>Fu</var></span>”. Herewith Russell’s paradox vanishes.\",\"str\":\"\"},{\"label\":\"3.343\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":35,\"x_axis\":45,\"ger\":\"Definitionen sind Regeln der Übersetzung von einer Sprache in eine andere. Jede richtige Zeichensprache muss sich in jede andere nach solchen Regeln übersetzen lassen: <em class=\\\"germph\\\">Dies</em> ist, was sie alle gemeinsam haben.\",\"pmc\":\"Definitions are rules for translating from one language into another. Any correct sign-language must be translatable into any other in accordance with such rules: it is <em>this</em> that they all have in common.\",\"ogd\":\"Definitions are rules for the translation of one language into another. Every correct symbolism must be translatable into every other according to such rules. It is <em>this</em> which all have in common.\",\"str\":\"\"},{\"label\":\"4.116\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":35,\"x_axis\":53,\"ger\":\"Alles was überhaupt gedacht werden kann, kann klar gedacht werden. Alles, was sich aussprechen lässt, lässt sich klar aussprechen.\",\"pmc\":\"Everything that can be thought at all can be thought clearly. Everything that can be put into words can be put clearly.\",\"ogd\":\"Everything that can be thought at all can be thought clearly. Everything that can be said can be said clearly.\",\"str\":\"\"},{\"label\":\"4.126\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":35,\"x_axis\":59,\"ger\":\"In dem Sinne, in welchem wir von formalen Eigenschaften sprechen, können wir nun auch von formalen Begriffen reden. (Ich führe diesen Ausdruck ein, um den Grund der Verwechslung der formalen Begriffe mit den eigentlichen Begriffen, welche die ganze alte Logik durchzieht, klar zu machen.) Dass etwas unter einen formalen Begriff als dessen Gegenstand fällt, kann nicht durch einen Satz ausgedrückt werden. Sondern es zeigt sich an dem Zeichen dieses Gegenstandes selbst. (Der Name zeigt, dass er einen Gegenstand bezeichnet, das Zahlenzeichen, dass es eine Zahl bezeichnet etc.) Die formalen Begriffe können ja nicht, wie die eigentlichen Begriffe, durch eine Funktion dargestellt werden. Denn ihre Merkmale, die formalen Eigenschaften, werden nicht durch Funktionen ausgedrückt. Der Ausdruck der formalen Eigenschaft ist ein Zug gewisser Symbole. Das Zeichen der Merkmale eines formalen Begriffes ist also ein charakteristischer Zug aller Symbole, deren Bedeutungen unter den Begriff fallen. Der Ausdruck des formalen Begriffes also, eine Satzvariable, in welcher nur dieser charakteristische Zug konstant ist.\",\"pmc\":\"We can now talk about formal concepts, in the same sense that we speak of formal properties. (I introduce this expression in order to exhibit the source of the confusion between formal concepts and concepts proper, which pervades the whole of traditional logic.) When something falls under a formal concept as one of its objects, this cannot be expressed by means of a proposition. Instead it is shown in the very sign for this object. (A name shows that it signifies an object, a sign for a number that it signifies a number, etc.) Formal concepts cannot, in fact, be represented by means of a function, as concepts proper can. For their characteristics, formal properties, are not expressed by means of functions. The expression for a formal property is a feature of certain symbols. So the sign for the characteristics of a formal concept is a distinctive feature of all symbols whose meanings fall under the concept. So the expression for a formal concept is a propositional variable in which this distinctive feature alone is constant.\",\"ogd\":\"In the sense in which we speak of formal properties we can now speak also of formal concepts. (I introduce this expression in order to make clear the confusion of formal concepts with proper concepts which runs through the whole of the old logic.) That anything falls under a formal concept as an object belonging to it, cannot be expressed by a proposition. But it is shown in the symbol for the object itself. (The name shows that it signifies an object, the numerical sign that it signifies a number, etc.) Formal concepts, cannot, like proper concepts, be presented by a function. For their characteristics, the formal properties, are not expressed by the functions. The expression of a formal property is a feature of certain symbols. The sign that signifies the characteristics of a formal concept is, therefore, a characteristic feature of all symbols, whose meanings fall under the concept. The expression of the formal concept is therefore a propositional variable in which only this characteristic feature is constant.\",\"str\":\"\"},{\"label\":\"5.441\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":35,\"x_axis\":83,\"ger\":\"Dieses Verschwinden der scheinbaren logischen Konstanten tritt auch ein, wenn „<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><span class=\\\"quant\\\">(<span class=\\\"symbol\\\">∃</span><var>x</var>).</span><span class=\\\"mathop\\\">~</span><var>fx</var></span>“ dasselbe sagt wie „<span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<var>x</var>).</span><var>fx</var></span>“, oder „<span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<span class=\\\"symbol\\\">∃</span><var>x</var>).</span><var>fx</var><span class=\\\"mathrel\\\">.</span><var>x</var><span class=\\\"mathrel\\\">=</span><var>a</var></span>“ dasselbe wie „<span class=\\\"mathmode\\\"><var>fa</var></span>“.\",\"pmc\":\"This vanishing of the apparent logical constants also occurs in the case of ‘<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><span class=\\\"quant\\\">(<span class=\\\"symbol\\\">∃</span><var>x</var>).</span><span class=\\\"mathop\\\">~</span><var>fx</var></span>’, which says the same as ‘<span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<var>x</var>).</span><var>fx</var></span>’, and in the case of ‘<span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<span class=\\\"symbol\\\">∃</span><var>x</var>).</span><var>fx</var><span class=\\\"mathrel\\\">.</span><var>x</var><span class=\\\"mathrel\\\">=</span><var>a</var></span>’, which says the same as ‘<span class=\\\"mathmode\\\"><var>fa</var></span>’.\",\"ogd\":\"This disappearance of the apparent logical constants also occurs if “<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><span class=\\\"quant\\\">(<span class=\\\"symbol\\\">∃</span><var>x</var>).</span><span class=\\\"mathop\\\">~</span><var>fx</var></span>” says the same as “<span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<var>x</var>).</span><var>fx</var></span>”, or “<span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<span class=\\\"symbol\\\">∃</span><var>x</var>).</span><var>fx</var><span class=\\\"mathrel\\\">.</span><var>x</var><span class=\\\"mathrel\\\">=</span><var>a</var></span>” the same as “<span class=\\\"mathmode\\\"><var>fa</var></span>”.\",\"str\":\"\"},{\"label\":\"5.451\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":35,\"x_axis\":85,\"ger\":\"Hat die Logik Grundbegriffe, so müssen sie von einander unabhängig sein. Ist ein Grundbegriff eingeführt, so muss er in allen Verbindungen eingeführt sein, worin er überhaupt vorkommt. Man kann ihn also nicht zuerst für <em class=\\\"germph\\\">eine</em> Verbindung, dann noch einmal für eine andere einführen. Z. B.: Ist die Verneinung eingeführt, so müssen wir sie jetzt in Sätzen von der Form „<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><var>p</var></span>“ ebenso verstehen, wie in Sätzen wie „<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span>(<var>p</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">∨</span></span><var>q</var>)</span>“, „<span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<span class=\\\"symbol\\\">∃</span><var>x</var>).</span><span class=\\\"mathop\\\">~</span><var>fx</var></span>“ u.&nbsp;a. Wir dürfen sie nicht erst für die eine Klasse von Fällen, dann für die andere einführen, denn es bliebe dann zweifelhaft, ob ihre Bedeutung in beiden Fällen die gleiche wäre und es wäre kein Grund vorhanden, in beiden Fällen dieselbe Art der Zeichenverbindung zu benützen. (Kurz, für die Einführung der Urzeichen gilt, mutatis mutandis, dasselbe, was Frege („Grundgesetze der Arithmetik“) für die Einführung von Zeichen durch Definitionen gesagt hat.)\",\"pmc\":\"If logic has primitive ideas, they must be independent of one another. If a primitive idea has been introduced, it must have been introduced in all the combinations in which it ever occurs. It cannot, therefore, be introduced first for <em>one</em> combination and later reintroduced for another. For example, once negation has been introduced, we must understand it both in propositions of the form ‘<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><var>p</var></span>’ and in propositions like ‘<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span>(<var>p</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">∨</span></span><var>q</var>)</span>’, ‘<span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<span class=\\\"symbol\\\">∃</span><var>x</var>).</span><span class=\\\"mathop\\\">~</span><var>fx</var></span>’, etc. We must not introduce it first for the one class of cases and then for the other, since it would then be left in doubt whether its meaning were the same in both cases, and no reason would have been given for combining the signs in the same way in both cases. (In short, Frege’s remarks about introducing signs by means of definitions (in <em>The Fundamental Laws of Arithmetic</em>) also apply, <em>mutatis mutandis</em>, to the introduction of primitive signs.)\",\"ogd\":\"If logic has primitive ideas these must be independent of one another. If a primitive idea is introduced it must be introduced in all contexts in which it occurs at all. One cannot therefore introduce it for <em>one</em> context and then again for another. For example, if denial is introduced, we must understand it in propositions of the form “<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><var>p</var></span>”, just as in propositions like “<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span>(<var>p</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">∨</span></span><var>q</var>)</span>”, “<span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<span class=\\\"symbol\\\">∃</span><var>x</var>).</span><span class=\\\"mathop\\\">~</span><var>fx</var></span>” and others. We may not first introduce it for one class of cases and then for another, for it would then remain doubtful whether its meaning in the two cases was the same, and there would be no reason to use the same way of symbolizing in the two cases. (In short, what Frege (“Grundgesetze der Arithmetik”) has said about the introduction of signs by definitions holds, mutatis mutandis, for the introduction of primitive signs also.)\",\"str\":\"\"},{\"label\":\"5.461\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":35,\"x_axis\":87,\"ger\":\"Bedeutungsvoll ist die scheinbar unwichtige Tatsache, dass die logischen Scheinbeziehungen, wie ∨ und ⊃, der Klammern bedürfen – im Gegensatz zu den wirklichen Beziehungen. Die Benützung der Klammern mit jenen scheinbaren Urzeichen deutet ja schon darauf hin, dass diese nicht die wirklichen Urzeichen sind. Und es wird doch wohl niemand glauben, dass die Klammern eine selbständige Bedeutung haben.\",\"pmc\":\"Though it seems unimportant, it is in fact significant that the pseudo-relations of logic, such as ∨ and ⊃, need brackets—unlike real relations. Indeed, the use of brackets with these apparently primitive signs is itself an indication that they are not primitive signs. And surely no one is going to believe brackets have an independent meaning.\",\"ogd\":\"The apparently unimportant fact that the apparent relations like ∨ and ⊃ need brackets—unlike real relations—is of great importance. The use of brackets with these apparent primitive signs shows that these are not the real primitive signs; and nobody of course would believe that the brackets have meaning by themselves.\",\"str\":\"\"},{\"label\":\"5.4611\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":35,\"x_axis\":89,\"ger\":\"Die logischen Operationszeichen sind Interpunktionen.\",\"pmc\":\"Signs for logical operations are punctuation-marks.\",\"ogd\":\"Logical operation signs are punctuations.\",\"str\":\"\"},{\"label\":\"5.471\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":35,\"x_axis\":91,\"ger\":\"Die allgemeine Satzform ist das Wesen des Satzes.\",\"pmc\":\"The general propositional form is the essence of a proposition.\",\"ogd\":\"The general form of proposition is the essence of proposition.\",\"str\":\"\"},{\"label\":\"5.4711\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":35,\"x_axis\":93,\"ger\":\"Das Wesen des Satzes angeben, heißt, das Wesen aller Beschreibung angeben, also das Wesen der Welt.\",\"pmc\":\"To give the essence of a proposition means to give the essence of all description, and thus the essence of the world.\",\"ogd\":\"To give the essence of proposition means to give the essence of all description, therefore the essence of the world.\",\"str\":\"\"},{\"label\":\"6.234\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":35,\"x_axis\":113,\"ger\":\"Die Mathematik ist eine Methode der Logik.\",\"pmc\":\"Mathematics is a method of logic.\",\"ogd\":\"Mathematics is a method of logic.\",\"str\":\"\"},{\"label\":\"6.2341\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":35,\"x_axis\":115,\"ger\":\"Das Wesentliche der mathematischen Methode ist es, mit Gleichungen zu arbeiten. Auf dieser Methode beruht es nämlich, dass jeder Satz der Mathematik sich von selbst verstehen muss.\",\"pmc\":\"It is the essential characteristic of mathematical method that it employs equations. For it is because of this method that every proposition of mathematics must go without saying.\",\"ogd\":\"The essential of mathematical method is working with equations. On this method depends the fact that every proposition of mathematics must be self-evident.\",\"str\":\"\"},{\"label\":\"2.21\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":37,\"x_axis\":11,\"ger\":\"Das Bild stimmt mit der Wirklichkeit überein oder nicht; es ist richtig oder unrichtig, wahr oder falsch.\",\"pmc\":\"A picture agrees with reality or fails to agree; it is correct or incorrect, true or false.\",\"ogd\":\"The picture agrees with reality or not; it is right or wrong, true or false.\",\"str\":\"\"},{\"label\":\"2.22\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":37,\"x_axis\":13,\"ger\":\"Das Bild stellt dar, was es darstellt, unabhängig von seiner Wahr- oder Falschheit, durch die Form der Abbildung.\",\"pmc\":\"What a picture represents it represents independently of its truth or falsity, by means of its pictorial form.\",\"ogd\":\"The picture represents what it represents, independently of its truth or falsehood, through the form of representation.\",\"str\":\"\"},{\"label\":\"3.314\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":37,\"x_axis\":39,\"ger\":\"Der Ausdruck hat nur im Satz Bedeutung. Jede Variable lässt sich als Satzvariable auffassen. (Auch der variable Name.)\",\"pmc\":\"An expression has meaning only in a proposition. All variables can be construed as propositional variables. (Even variable names.)\",\"ogd\":\"An expression has meaning only in a proposition. Every variable can be conceived as a propositional variable. (Including the variable name.)\",\"str\":\"\"},{\"label\":\"3.324\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":37,\"x_axis\":41,\"ger\":\"So entstehen leicht die fundamentalsten Verwechslungen (deren die ganze Philosophie voll ist).\",\"pmc\":\"In this way the most fundamental confusions are easily produced (the whole of philosophy is full of them).\",\"ogd\":\"Thus there easily arise the most fundamental confusions (of which the whole of philosophy is full).\",\"str\":\"\"},{\"label\":\"3.334\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":37,\"x_axis\":43,\"ger\":\"Die Regeln der logischen Syntax müssen sich von selbst verstehen, wenn man nur weiß, wie ein jedes Zeichen bezeichnet.\",\"pmc\":\"The rules of logical syntax must go without saying, once we know how each individual sign signifies.\",\"ogd\":\"The rules of logical syntax must follow of themselves, if we only know how every single sign signifies.\",\"str\":\"\"},{\"label\":\"3.344\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":37,\"x_axis\":45,\"ger\":\"Das, was am Symbol bezeichnet, ist das Gemeinsame aller jener Symbole, durch die das erste den Regeln der logischen Syntax zufolge ersetzt werden kann.\",\"pmc\":\"What signifies in a symbol is what is common to all the symbols that the rules of logical syntax allow us to substitute for it.\",\"ogd\":\"What signifies in the symbol is what is common to all those symbols by which it can be replaced according to the rules of logical syntax.\",\"str\":\"\"},{\"label\":\"3.3441\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":37,\"x_axis\":47,\"ger\":\"Man kann z. B. das Gemeinsame aller Notationen für die Wahrheitsfunktionen so ausdrücken: Es ist ihnen gemeinsam, dass sich alle – z. B. – durch die Notation von „<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><var>p</var></span>“ („nicht <span class=\\\"mathmode\\\"><var>p</var></span>“) und „<span class=\\\"mathmode\\\"><var>p</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">∨</span></span><var>q</var></span>“ („<span class=\\\"mathmode\\\"><var>p</var></span> oder <span class=\\\"mathmode\\\"><var>q</var></span>“) <em class=\\\"germph\\\">ersetzen lassen</em>. (Hiermit ist die Art und Weise gekennzeichnet, wie eine spezielle mögliche Notation uns allgemeine Aufschlüsse geben kann.)\",\"pmc\":\"For instance, we can express what is common to all notations for truth-functions in the following way: they have in common that, for example, the notation that uses ‘<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><var>p</var></span>’ (‘not <span class=\\\"mathmode\\\"><var>p</var></span>’) and ‘<span class=\\\"mathmode\\\"><var>p</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">∨</span></span><var>q</var></span>’ (‘<span class=\\\"mathmode\\\"><var>p</var></span> or <span class=\\\"mathmode\\\"><var>q</var></span>’) <em>can be substituted</em> for any of them. (This serves to characterize the way in which something general can be disclosed by the possibility of a specific notation.)\",\"ogd\":\"We can, for example, express what is common to all notations for the truth-functions as follows: It is common to them that they all, for example, <em>can be replaced</em> by the notations of “<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><var>p</var></span>” (“not <span class=\\\"mathmode\\\"><var>p</var></span>”) and “<span class=\\\"mathmode\\\"><var>p</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">∨</span></span><var>q</var></span>” (“<span class=\\\"mathmode\\\"><var>p</var></span> or <span class=\\\"mathmode\\\"><var>q</var></span>”). (Herewith is indicated the way in which a special possible notation can give us general information.)\",\"str\":\"\"},{\"label\":\"3.3442\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":37,\"x_axis\":49,\"ger\":\"Das Zeichen des Komplexes löst sich auch bei der Analyse nicht willkürlich auf, so dass etwa seine Auflösung in jedem Satzgefüge eine andere wäre.\",\"pmc\":\"Nor does analysis resolve the sign for a complex in an arbitrary way, so that it would have a different resolution every time that it was incorporated in a different proposition.\",\"ogd\":\"The sign of the complex is not arbitrarily resolved in the analysis, in such a way that its resolution would be different in every propositional structure.\",\"str\":\"\"},{\"label\":\"4.127\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":37,\"x_axis\":59,\"ger\":\"Die Satzvariable bezeichnet den formalen Begriff und ihre Werte die Gegenstände, welche unter diesen Begriff fallen.\",\"pmc\":\"The propositional variable signifies the formal concept, and its values signify the objects that fall under the concept.\",\"ogd\":\"The propositional variable signifies the formal concept, and its values signify the objects which fall under this concept.\",\"str\":\"\"},{\"label\":\"4.1271\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":37,\"x_axis\":61,\"ger\":\"Jede Variable ist das Zeichen eines formalen Begriffes. Denn jede Variable stellt eine konstante Form dar, welche alle ihre Werte besitzen, und die als formale Eigenschaft dieser Werte aufgefasst werden kann.\",\"pmc\":\"Every variable is the sign for a formal concept. For every variable represents a constant form that all its values possess, and this can be regarded as a formal property of those values.\",\"ogd\":\"Every variable is the sign of a formal concept. For every variable presents a constant form, which all its values possess, and which can be conceived as a formal property of these values.\",\"str\":\"\"},{\"label\":\"4.1272\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":37,\"x_axis\":63,\"ger\":\"So ist der variable Name „<span class=\\\"mathmode\\\"><var>x</var></span>“ das eigentliche Zeichen des Scheinbegriffes <em class=\\\"germph\\\">Gegenstand</em>. Wo immer das Wort „Gegenstand“ („Ding“, „Sache“, etc.) richtig gebraucht wird, wird es in der Begriffsschrift durch den variablen Namen ausgedrückt. Zum Beispiel in dem Satz „es gibt 2 Gegenstände, welche …“ durch „<span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<span class=\\\"symbol\\\">∃</span><var>x</var>,<var>y</var>)</span><span class=\\\"mathrel\\\">…</span></span>“. Wo immer es anders, also als eigentliches Begriffswort gebraucht wird, entstehen unsinnige Scheinsätze. So kann man z. B. nicht sagen „Es gibt Gegenstände“, wie man etwa sagt: „Es gibt Bücher“. Und ebenso wenig: „Es gibt 100 Gegenstände“, oder „Es gibt <span class=\\\"mathmode\\\"><span class=\\\"symbol\\\">ℵ</span><sub>0</sub></span> Gegenstände“. Und es ist unsinnig, von der <em class=\\\"germph\\\">Anzahl aller Gegenstände</em> zu sprechen. Dasselbe gilt von den Worten „Komplex“, „Tatsache“, „Funktion“, „Zahl“, etc. Sie alle bezeichnen formale Begriffe und werden in der Begriffsschrift durch Variable, nicht durch Funktionen oder Klassen dargestellt. (Wie Frege und Russell glaubten.) Ausdrücke wie „1 ist eine Zahl“, „Es gibt nur Eine Null“ und alle ähnlichen sind unsinnig. (Es ist ebenso unsinnig zu sagen: „Es gibt nur Eine 1“, als es unsinnig wäre, zu sagen: „<span class=\\\"mathmode\\\">2<span class=\\\"mathrel\\\">+</span>2</span> ist um 3 Uhr gleich 4“.)\",\"pmc\":\"Thus the variable name ‘<span class=\\\"mathmode\\\"><var>x</var></span>’ is the proper sign for the pseudo-concept <em>object</em>. Wherever the word ‘object’ (‘thing’, etc.) is correctly used, it is expressed in conceptual notation by a variable name. For example, in the proposition, ‘There are 2 objects which …’, it is expressed by ‘<span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<span class=\\\"symbol\\\">∃</span><var>x</var>,<var>y</var>)</span><span class=\\\"mathrel\\\">…</span></span>’. Wherever it is used in a different way, that is as a proper concept-word, nonsensical pseudo-propositions are the result. So one cannot say, for example, ‘There are objects’, as one might say, ‘There are books’. And it is just as impossible to say, ‘There are 100 objects’, or, ‘There are <span class=\\\"mathmode\\\"><span class=\\\"symbol\\\">ℵ</span><sub>0</sub></span> objects’. And it is nonsensical to speak of the <em>total number of objects</em>. The same applies to the words ‘complex’, ‘fact’, ‘function’, ‘number’, etc. They all signify formal concepts, and are represented in conceptual notation by variables, not by functions or classes (as Frege and Russell believed). ‘1 is a number’, ‘There is only one zero’, and all similar expressions are nonsensical. (It is just as nonsensical to say, ‘There is only one 1’, as it would be to say, ‘<span class=\\\"mathmode\\\">2<span class=\\\"mathrel\\\">+</span>2</span> at 3 o’clock equals 4’.)\",\"ogd\":\"So the variable name “<span class=\\\"mathmode\\\"><var>x</var></span>” is the proper sign of the pseudo-concept <em>object</em>. Wherever the word “object” (“thing”, “entity”, etc.) is rightly used, it is expressed in logical symbolism by the variable name. For example in the proposition “there are two objects which …”, by “<span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<span class=\\\"symbol\\\">∃</span><var>x</var>,<var>y</var>)</span><span class=\\\"mathrel\\\">…</span></span>”. Wherever it is used otherwise, <em>i.e.</em> as a proper concept word, there arise senseless pseudo-propositions. So one cannot, <em>e.g.</em> say “There are objects” as one says “There are books”. Nor “There are 100 objects” or “There are <span class=\\\"mathmode\\\"><span class=\\\"symbol\\\">ℵ</span><sub>0</sub></span> objects”. And it is senseless to speak of the <em>number of all objects</em>. The same holds of the words “Complex”, “Fact”, “Function”, “Number”, etc. They all signify formal concepts and are presented in logical symbolism by variables, not by functions or classes (as Frege and Russell thought). Expressions like “1 is a number”, “there is only one number nought”, and all like them are senseless. (It is as senseless to say, “there is only one 1” as it would be to say: <span class=\\\"mathmode\\\">2<span class=\\\"mathrel\\\">+</span>2</span> is at 3 o’clock equal to 4.)\",\"str\":\"\"},{\"label\":\"4.1273\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":37,\"x_axis\":65,\"ger\":\"Wollen wir den allgemeinen Satz: „<span class=\\\"mathmode\\\"><var>b</var></span> ist ein Nachfolger von <span class=\\\"mathmode\\\"><var>a</var></span>“ in der Begriffsschrift ausdrücken, so brauchen wir hierzu einen Ausdruck für das allgemeine Glied der Formenreihe: <div class=\\\"centered\\\"><span class=\\\"mathmode\\\"><var>aRb</var></span>,<br />\\n<span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<span class=\\\"symbol\\\">∃</span><var>x</var>):</span><var>aRx</var><span class=\\\"mathrel\\\">.</span><var>xRb</var></span>,<br />\\n<span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<span class=\\\"symbol\\\">∃</span><var>x</var>,<var>y</var>):</span><var>aRx</var><span class=\\\"mathrel\\\">.</span><var>xRy</var><span class=\\\"mathrel\\\">.</span><var>yRb</var></span>,<br />\\n…&nbsp; .</div> <!-- noindent --> Das allgemeine Glied einer Formenreihe kann man nur durch eine Variable ausdrücken, denn der Begriff: Glied dieser Formenreihe, ist ein <em class=\\\"germph\\\">formaler</em> Begriff. (Dies haben Frege und Russell übersehen; die Art und Weise, wie sie allgemeine Sätze wie den obigen ausdrücken wollen, ist daher falsch; sie enthält einen circulus vitiosus.) Wir können das allgemeine Glied der Formenreihe bestimmen, indem wir ihr erstes Glied angeben und die allgemeine Form der Operation, welche das folgende Glied aus dem vorhergehenden Satz erzeugt.\",\"pmc\":\"If we want to express in conceptual notation the general proposition, ‘<span class=\\\"mathmode\\\"><var>b</var></span> is a successor of <span class=\\\"mathmode\\\"><var>a</var></span>’, then we require an expression for the general term of the series of forms <div class=\\\"centered\\\"><span class=\\\"mathmode\\\"><var>aRb</var></span>,<br />\\n<span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<span class=\\\"symbol\\\">∃</span><var>x</var>):</span><var>aRx</var><span class=\\\"mathrel\\\">.</span><var>xRb</var></span>,<br />\\n<span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<span class=\\\"symbol\\\">∃</span><var>x</var>,<var>y</var>):</span><var>aRx</var><span class=\\\"mathrel\\\">.</span><var>xRy</var><span class=\\\"mathrel\\\">.</span><var>yRb</var></span>,<br />\\n…&nbsp; .</div> <!-- noindent --> In order to express the general term of a series of forms, we must use a variable, because the concept ‘term of that series of forms’ is a <em>formal</em> concept. (This is what Frege and Russell overlooked: consequently the way in which they want to express general propositions like the one above is incorrect; it contains a vicious circle.) We can determine the general term of a series of forms by giving its first term and the general form of the operation that produces the next term out of the proposition that precedes it.\",\"ogd\":\"If we want to express in logical symbolism the general proposition “<span class=\\\"mathmode\\\"><var>b</var></span> is a successor of <span class=\\\"mathmode\\\"><var>a</var></span>” we need for this an expression for the general term of the formal series: <div class=\\\"centered\\\"><span class=\\\"mathmode\\\"><var>aRb</var></span>,<br />\\n<span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<span class=\\\"symbol\\\">∃</span><var>x</var>):</span><var>aRx</var><span class=\\\"mathrel\\\">.</span><var>xRb</var></span>,<br />\\n<span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<span class=\\\"symbol\\\">∃</span><var>x</var>,<var>y</var>):</span><var>aRx</var><span class=\\\"mathrel\\\">.</span><var>xRy</var><span class=\\\"mathrel\\\">.</span><var>yRb</var></span>,<br />\\n…&nbsp; .</div> <!-- noindent --> The general term of a formal series can only be expressed by a variable, for the concept symbolized by “term of this formal series” is a <em>formal</em> concept. (This Frege and Russell overlooked; the way in which they express general propositions like the above is, therefore, false; it contains a vicious circle.) We can determine the general term of the formal series by giving its first term and the general form of the operation, which generates the following term out of the preceding proposition.\",\"str\":\"\"},{\"label\":\"4.1274\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":37,\"x_axis\":67,\"ger\":\"Die Frage nach der Existenz eines formalen Begriffes ist unsinnig. Denn kein Satz kann eine solche Frage beantworten. (Man kann also z. B. nicht fragen: „Gibt es unanalysierbare Subjekt-Prädikatsätze?“)\",\"pmc\":\"To ask whether a formal concept exists is nonsensical. For no proposition can be the answer to such a question. (So, for example, the question, ‘Are there unanalysable subject-predicate propositions?’ cannot be asked.)\",\"ogd\":\"The question about the existence of a formal concept is senseless. For no proposition can answer such a question. (For example, one cannot ask: “Are there unanalysable subject-predicate propositions?”)\",\"str\":\"\"},{\"label\":\"5.442\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":37,\"x_axis\":83,\"ger\":\"Wenn uns ein Satz gegeben ist, so sind <em class=\\\"germph\\\">mit ihm</em> auch schon die Resultate aller Wahrheitsoperationen, die ihn zur Basis haben, gegeben.\",\"pmc\":\"If we are given a proposition, then <em>with it</em> we are also given the results of all truth-operations that have it as their base.\",\"ogd\":\"If a proposition is given to us then the results of all truth-operations which have it as their basis are given <em>with</em> it.\",\"str\":\"\"},{\"label\":\"5.452\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":37,\"x_axis\":85,\"ger\":\"Die Einführung eines neuen Behelfes in den Symbolismus der Logik muss immer ein folgenschweres Ereignis sein. Kein neuer Behelf darf in die Logik – sozusagen, mit ganz unschuldiger Miene – in Klammern oder unter dem Striche eingeführt werden. (So kommen in den „Principia Mathematica“ von Russell und Whitehead Definitionen und Grundgesetze in Worten vor. Warum hier plötzlich Worte? Dies bedürfte einer Rechtfertigung. Sie fehlt und muss fehlen, da das Vorgehen tatsächlich unerlaubt ist.) Hat sich aber die Einführung eines neuen Behelfes an einer Stelle als nötig erwiesen, so muss man sich nun sofort fragen: Wo muss dieser Behelf nun <em class=\\\"germph\\\">immer</em> angewandt werden? Seine Stellung in der Logik muss nun erklärt werden.\",\"pmc\":\"The introduction of any new device into the symbolism of logic is necessarily a momentous event. In logic a new device should not be introduced in brackets or in a footnote with what one might call a completely innocent air. (Thus in Russell and Whitehead’s <em>Principia Mathematica</em> there occur definitions and primitive propositions expressed in words. Why this sudden appearance of words? It would require a justification, but none is given, or could be given, since the procedure is in fact illicit.) But if the introduction of a new device has proved necessary at a certain point, we must immediately ask ourselves, ‘At what points is the employment of this device now <em>unavoidable</em>?’ and its place in logic must be made clear.\",\"ogd\":\"The introduction of a new expedient in the symbolism of logic must always be an event full of consequences. No new symbol may be introduced in logic in brackets or in the margin—with, so to speak, an entirely innocent face. (Thus in the “Principia Mathematica” of Russell and Whitehead there occur definitions and primitive propositions in words. Why suddenly words here? This would need a justification. There was none, and can be none for the process is actually not allowed.) But if the introduction of a new expedient has proved necessary in one place, we must immediately ask: Where is this expedient <em>always</em> to be used? Its position in logic must be made clear.\",\"str\":\"\"},{\"label\":\"5.472\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":37,\"x_axis\":91,\"ger\":\"Die Beschreibung der allgemeinsten Satzform ist die Beschreibung des einen und einzigen allgemeinen Urzeichens der Logik.\",\"pmc\":\"The description of the most general propositional form is the description of the one and only general primitive sign in logic.\",\"ogd\":\"The description of the most general propositional form is the description of the one and only general primitive sign in logic.\",\"str\":\"\"},{\"label\":\"6.3\",\"precision\":1,\"fontSize\":\"40px\",\"y_axis\":37,\"x_axis\":107,\"ger\":\"Die Erforschung der Logik bedeutet die Erforschung <em class=\\\"germph\\\">aller Gesetzmäßigkeit</em>. Und außerhalb der Logik ist alles Zufall.\",\"pmc\":\"The exploration of logic means the exploration of <em>everything that is subject to law</em>. And outside logic everything is accidental.\",\"ogd\":\"Logical research means the investigation of <em>all regularity</em>. And outside logic all is accident.\",\"str\":\"\"},{\"label\":\"6.31\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":37,\"x_axis\":109,\"ger\":\"Das sogenannte Gesetz der Induktion kann jedenfalls kein logisches Gesetz sein, denn es ist offenbar ein sinnvoller Satz. – Und darum kann es auch kein Gesetz a priori sein.\",\"pmc\":\"The so-called law of induction cannot possibly be a law of logic, since it is obviously a proposition with sense.—Nor, therefore, can it be an <em>a priori</em> law.\",\"ogd\":\"The so-called law of induction cannot in any case be a logical law, for it is obviously a significant proposition.—And therefore it cannot be a law a priori either.\",\"str\":\"\"},{\"label\":\"6.32\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":37,\"x_axis\":111,\"ger\":\"Das Kausalitätsgesetz ist kein Gesetz, sondern die Form eines Gesetzes.\",\"pmc\":\"The law of causality is not a law but the form of a law.\",\"ogd\":\"The law of causality is not a law but the form of a law.*\",\"str\":\"\"},{\"label\":\"6.33\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":37,\"x_axis\":113,\"ger\":\"Wir <em class=\\\"germph\\\">glauben</em> nicht a priori an ein Erhaltungsgesetz, sondern wir <em class=\\\"germph\\\">wissen</em> a priori die Möglichkeit einer logischen Form.\",\"pmc\":\"We do not have an <em>a priori belief</em> in a law of conservation, but rather <em>a priori knowledge</em> of the possibility of a logical form.\",\"ogd\":\"We do not <em>believe</em> a priori in a law of conservation, but we <em>know</em> a priori the possibility of a logical form.\",\"str\":\"\"},{\"label\":\"6.34\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":37,\"x_axis\":115,\"ger\":\"Alle jene Sätze, wie der Satz vom Grunde, von der Kontinuität in der Natur, vom kleinsten Aufwande in der Natur etc. etc., alle diese sind Einsichten a priori über die mögliche Formgebung der Sätze der Wissenschaft.\",\"pmc\":\"All such propositions, including the principle of sufficient reason, the laws of continuity in nature and of least effort in nature, etc. etc.—all these are <em>a priori</em> insights about the forms in which the propositions of science can be cast.\",\"ogd\":\"All propositions, such as the law of causation, the law of continuity in nature, the law of least expenditure in nature, etc. etc., all these are a priori intuitions of possible forms of the propositions of science.\",\"str\":\"\"},{\"label\":\"6.35\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":37,\"x_axis\":119,\"ger\":\"Obwohl die Flecke in unserem Bild geometrische Figuren sind, so kann doch selbstverständlich die Geometrie gar nichts über ihre tatsächliche Form und Lage sagen. Das Netz aber ist <em class=\\\"germph\\\">rein</em> geometrisch, alle seine Eigenschaften können a priori angegeben werden. Gesetze wie der Satz vom Grunde, etc. handeln vom Netz, nicht von dem, was das Netz beschreibt.\",\"pmc\":\"Although the spots in our picture are geometrical figures, nevertheless geometry can obviously say nothing at all about their actual form and position. The network, however, is <em>purely</em> geometrical; all its properties can be given <em>a priori</em>. Laws like the principle of sufficient reason, etc. are about the net and not about what the net describes.\",\"ogd\":\"Although the spots in our picture are geometrical figures, geometry can obviously say nothing about their actual form and position. But the network is <em>purely</em> geometrical, and all its properties can be given a priori. Laws, like the law of causation, etc., treat of the network and not what the network describes.\",\"str\":\"\"},{\"label\":\"6.36\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":37,\"x_axis\":121,\"ger\":\"Wenn es ein Kausalitätsgesetz gäbe, so könnte es lauten: „Es gibt Naturgesetze“. Aber freilich kann man das nicht sagen: es zeigt sich.\",\"pmc\":\"If there were a law of causality, it might be put in the following way: There are laws of nature. But of course that cannot be said: it makes itself manifest.\",\"ogd\":\"If there were a law of causality, it might run: “There are natural laws”. But that can clearly not be said: it shows itself.\",\"str\":\"\"},{\"label\":\"6.37\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":37,\"x_axis\":125,\"ger\":\"Einen Zwang, nach dem Eines geschehen müsste, weil etwas anderes geschehen ist, gibt es nicht. Es gibt nur eine <em class=\\\"germph\\\">logische</em> Notwendigkeit.\",\"pmc\":\"There is no compulsion making one thing happen because another has happened. The only necessity that exists is <em>logical</em> necessity\",\"ogd\":\"A necessity for one thing to happen because another has happened does not exist. There is only <em>logical</em> necessity.\",\"str\":\"\"},{\"label\":\"2.221\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":39,\"x_axis\":13,\"ger\":\"Was das Bild darstellt, ist sein Sinn.\",\"pmc\":\"What a picture represents is its sense.\",\"ogd\":\"What the picture represents is its sense.\",\"str\":\"\"},{\"label\":\"3.315\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":39,\"x_axis\":39,\"ger\":\"Verwandeln wir einen Bestandteil eines Satzes in eine Variable, so gibt es eine Klasse von Sätzen, welche sämtlich Werte des so entstandenen variablen Satzes sind. Diese Klasse hängt im allgemeinen noch davon ab, was wir, nach willkürlicher Übereinkunft, mit Teilen jenes Satzes meinen. Verwandeln wir aber alle jene Zeichen, deren Bedeutung willkürlich bestimmt wurde, in Variable, so gibt es nun noch immer eine solche Klasse. Diese aber ist nun von keiner Übereinkunft abhängig, sondern nur noch von der Natur des Satzes. Sie entspricht einer logischen Form – einem logischen Urbild.\",\"pmc\":\"If we turn a constituent of a proposition into a variable, there is a class of propositions all of which are values of the resulting variable proposition. In general, this class too will be dependent on the meaning that our arbitrary conventions have given to parts of the original proposition. But if all the signs in it that have arbitrarily determined meanings are turned into variables, we shall still get a class of this kind. This one, however, is not dependent on any convention, but solely on the nature of the proposition. It corresponds to a logical form—a logical prototype.\",\"ogd\":\"If we change a constituent part of a proposition into a variable, there is a class of propositions which are all the values of the resulting variable proposition. This class in general still depends on what, by arbitrary agreement, we mean by parts of that proposition. But if we change all those signs, whose meaning was arbitrarily determined, into variables, there always remains such a class. But this is now no longer dependent on any agreement; it depends only on the nature of the proposition. It corresponds to a logical form, to a logical prototype.\",\"str\":\"\"},{\"label\":\"3.325\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":39,\"x_axis\":41,\"ger\":\"Um diesen Irrtümern zu entgehen, müssen wir eine Zeichensprache verwenden, welche sie ausschließt, indem sie nicht das gleiche Zeichen in verschiedenen Symbolen, und Zeichen, welche auf verschiedene Art bezeichnen, nicht äußerlich auf die gleiche Art verwendet. Eine Zeichensprache also, die der <em class=\\\"germph\\\">logischen</em> Grammatik – der logischen Syntax – gehorcht. (Die Begriffsschrift Freges und Russells ist eine solche Sprache, die allerdings noch nicht alle Fehler ausschließt.)\",\"pmc\":\"In order to avoid such errors we must make use of a sign-language that excludes them by not using the same sign for different symbols and by not using in a superficially similar way signs that have different modes of signification: that is to say, a sign-language that is governed by <em>logical</em> grammar—by logical syntax. (The conceptual notation of Frege and Russell is such a language, though, it is true, it fails to exclude all mistakes.)\",\"ogd\":\"In order to avoid these errors, we must employ a symbolism which excludes them, by not applying the same sign in different symbols and by not applying signs in the same way which signify in different ways. A symbolism, that is to say, which obeys the rules of <em>logical</em> grammar—of logical syntax. (The logical symbolism of Frege and Russell is such a language, which, however, does still not exclude all errors.)\",\"str\":\"\"},{\"label\":\"4.128\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":39,\"x_axis\":59,\"ger\":\"Die logischen Formen sind zah<em class=\\\"germph\\\">llos</em>. Darum gibt es in der Logik keine ausgezeichneten Zahlen und darum gibt es keinen philosophischen Monismus oder Dualismus, etc.\",\"pmc\":\"Logical forms are <em>without</em> number. Hence there are no pre-eminent numbers in logic, and hence there is no possibility of philosophical monism or dualism, etc.\",\"ogd\":\"The logical forms are <em>anumerical</em>. Therefore there are in logic no pre-eminent numbers, and therefore there is no philosophical monism or dualism, etc.\",\"str\":\"\"},{\"label\":\"4.12721\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":39,\"x_axis\":63,\"ger\":\"Der formale Begriff ist mit einem Gegenstand, der unter ihn fällt, bereits gegeben. Man kann also nicht Gegenstände eines formalen Begriffes <em class=\\\"germph\\\">und</em> den formalen Begriff selbst als Grundbegriffe einführen. Man kann also z. B. nicht den Begriff der Funktion, und auch spezielle Funktionen (wie Russell) als Grundbegriffe einführen; oder den Begriff der Zahl und bestimmte Zahlen.\",\"pmc\":\"A formal concept is given immediately any object falling under it is given. It is not possible, therefore, to introduce as primitive ideas objects belonging to a formal concept <em>and</em> the formal concept itself. So it is impossible, for example, to introduce as primitive ideas both the concept of a function and specific functions, as Russell does; or the concept of a number and particular numbers.\",\"ogd\":\"The formal concept is already given with an object, which falls under it. One cannot, therefore, introduce both, the objects which fall under a formal concept <em>and</em> the formal concept itself, as primitive ideas. One cannot, therefore, <em>e.g.</em> introduce (as Russell does) the concept of function and also special functions as primitive ideas; or the concept of number and definite numbers.\",\"str\":\"\"},{\"label\":\"5.453\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":39,\"x_axis\":85,\"ger\":\"Alle Zahlen der Logik müssen sich rechtfertigen lassen. Oder vielmehr: Es muss sich herausstellen, dass es in der Logik keine Zahlen gibt. Es gibt keine ausgezeichneten Zahlen.\",\"pmc\":\"All numbers in logic stand in need of justification. Or rather, it must become evident that there are no numbers in logic. There are no privileged numbers.\",\"ogd\":\"All numbers in logic must be capable of justification. Or rather it must become plain that there are no numbers in logic. There are no pre-eminent numbers.\",\"str\":\"\"},{\"label\":\"5.473\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":39,\"x_axis\":91,\"ger\":\"Die Logik muss für sich selber sorgen. Ein <em class=\\\"germph\\\">mögliches</em> Zeichen muss auch bezeichnen können. Alles was in der Logik möglich ist, ist auch erlaubt. („Sokrates ist identisch“ heißt darum nichts, weil es keine Eigenschaft gibt, die „identisch“ heißt. Der Satz ist unsinnig, weil wir eine willkürliche Bestimmung nicht getroffen haben, aber nicht darum, weil das Symbol an und für sich unerlaubt wäre.) Wir können uns, in gewissem Sinne, nicht in der Logik irren.\",\"pmc\":\"Logic must look after itself. If a sign is <em>possible</em>, then it is also capable of signifying. Whatever is possible in logic is also permitted. (The reason why ‘Socrates is identical’ means nothing is that there is no property called ‘identical’. The proposition is nonsensical because we have failed to make an arbitrary determination, and not because the symbol, in itself, would be illegitimate.) In a certain sense, we cannot make mistakes in logic.\",\"ogd\":\"Logic must take care of itself. A <em>possible</em> sign must also be able to signify. Everything which is possible in logic is also permitted. (“Socrates is identical” means nothing because there is no property which is called “identical”. The proposition is senseless because we have not made some arbitrary determination, not because the symbol is in itself unpermissible.) In a certain sense we cannot make mistakes in logic.\",\"str\":\"\"},{\"label\":\"5.4731\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":39,\"x_axis\":93,\"ger\":\"Das Einleuchten, von dem Russell so viel sprach, kann nur dadurch in der Logik entbehrlich werden, dass die Sprache selbst jeden logischen Fehler verhindert. – Dass die Logik a priori ist, besteht darin, dass nicht unlogisch gedacht werden <em class=\\\"germph\\\">kann</em>.\",\"pmc\":\"Self-evidence, which Russell talked about so much, can become dispensable in logic, only because language itself prevents every logical mistake.—What makes logic <em>a priori</em> is the <em>impossibility</em> of illogical thought.\",\"ogd\":\"Self-evidence, of which Russell has said so much, can only be discard in logic by language itself preventing every logical mistake. That logic is a priori consists in the fact that we <em>cannot</em> think illogically.\",\"str\":\"\"},{\"label\":\"5.4732\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":39,\"x_axis\":95,\"ger\":\"Wir können einem Zeichen nicht den unrechten Sinn geben.\",\"pmc\":\"We cannot give a sign the wrong sense.\",\"ogd\":\"We cannot give a sign the wrong sense.\",\"str\":\"\"},{\"label\":\"5.4733\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":39,\"x_axis\":97,\"ger\":\"Frege sagt: Jeder rechtmäßig gebildete Satz muss einen Sinn haben; und ich sage: Jeder mögliche Satz ist rechtmäßig gebildet, und wenn er keinen Sinn hat, so kann das nur daran liegen, dass wir einigen seiner Bestandteile keine <em class=\\\"germph\\\">Bedeutung</em> gegeben haben. (Wenn wir auch glauben, es getan zu haben.) So sagt „Sokrates ist identisch“ darum nichts, weil wir dem Wort „identisch“ als <em class=\\\"germph\\\">Eigenschaftswort</em> <em class=\\\"germph\\\">keine</em> Bedeutung gegeben haben. Denn, wenn es als Gleichheitszeichen auftritt, so symbolisiert es auf ganz andere Art und Weise – die bezeichnende Beziehung ist eine andere, – also ist auch das Symbol in beiden Fällen ganz verschieden; die beiden Symbole haben nur das Zeichen zufällig miteinander gemein.\",\"pmc\":\"Frege says that any legitimately constructed proposition must have a sense. And I say that any possible proposition is legitimately constructed, and, if it has no sense, that can only be because we have failed to give a <em>meaning</em> to some of its constituents. (Even if we think that we have done so.) Thus the reason why ‘Socrates is identical’ says nothing is that we have <em>not</em> given any <em>adjectival</em> meaning to the word ‘identical’. For when it appears as a sign for identity, it symbolizes in an entirely different way—the signifying relation is a different one—therefore the symbols also are entirely different in the two cases: the two symbols have only the sign in common, and that is an accident.\",\"ogd\":\"Frege says: Every legitimately constructed proposition must have a sense; and I say: Every possible proposition is legitimately constructed, and if it has no sense this can only be because we have given no <em>meaning</em> to some of its constituent parts. (Even if we believe that we have done so.) Thus “Socrates is identical” says nothing, because we have given <em>no</em> meaning to the word “identical” as <em>adjective</em>. For when it occurs as the sign of equality it symbolizes in an entirely different way—the symbolizing relation is another—therefore the symbol is in the two cases entirely different; the two symbols have the sign in common with one another only by accident.\",\"str\":\"\"},{\"label\":\"6.321\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":39,\"x_axis\":111,\"ger\":\"„Kausalitätsgesetz“, das ist ein Gattungsname. Und wie es in der Mechanik, sagen wir, Minimum-Gesetze gibt – etwa der kleinsten Wirkung – so gibt es in der Physik Kausalitätsgesetze, Gesetze von der Kausalitätsform.\",\"pmc\":\"‘Law of causality’—that is a general name. And just as in mechanics, for example, there are ‘minimum-principles’, such as the law of least action, so too in physics there are causal laws, laws of the causal form.\",\"ogd\":\"“Law of Causality” is a class name. And as in mechanics there are, for instance, minimum-laws, such as that of least actions, so in physics there are causal laws, laws of the causality form.\",\"str\":\"\"},{\"label\":\"6.3211\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":39,\"x_axis\":113,\"ger\":\"Man hat ja auch davon eine Ahnung gehabt, dass es <em class=\\\"germph\\\">ein</em> „Gesetz der kleinsten Wirkung“ geben müsse, ehe man genau wusste, wie es lautete. (Hier, wie immer, stellt sich das a priori Gewisse als etwas rein Logisches heraus.)\",\"pmc\":\"Indeed people even surmised that there must be a ‘law of least action’ before they knew exactly how it went. (Here, as always, what is certain <em>a priori</em> proves to be something purely logical.)\",\"ogd\":\"Men had indeed an idea that there must be <em>a</em> “law of least action”, before they knew exactly how it ran. (Here, as always, the a priori certain proves to be something purely logical.)\",\"str\":\"\"},{\"label\":\"6.341\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":39,\"x_axis\":115,\"ger\":\"Die Newtonsche Mechanik z. B. bringt die Weltbeschreibung auf eine einheitliche Form. Denken wir uns eine weiße Fläche, auf der unregelmäßige schwarze Flecken wären. Wir sagen nun: Was für ein Bild immer hierdurch entsteht, immer kann ich seiner Beschreibung beliebig nahe kommen, indem ich die Fläche mit einem entsprechend feinen quadratischen Netzwerk bedecke und nun von jedem Quadrat sage, dass es weiß oder schwarz ist. Ich werde auf diese Weise die Beschreibung der Fläche auf eine einheitliche Form gebracht haben. Diese Form ist beliebig, denn ich hätte mit dem gleichen Erfolge ein Netz aus dreieckigen oder sechseckigen Maschen verwenden können. Es kann sein, dass die Beschreibung mit Hilfe eines Dreiecks-Netzes einfacher geworden wäre; das heißt, dass wir die Fläche mit einem gröberen Dreiecks-Netz genauer beschreiben könnten als mit einem feineren quadratischen (oder umgekehrt) usw. Den verschiedenen Netzen entsprechen verschiedene Systeme der Weltbeschreibung. Die Mechanik bestimmt eine Form der Weltbeschreibung, indem sie sagt: Alle Sätze der Weltbeschreibung müssen aus einer Anzahl gegebener Sätze – den mechanischen Axiomen – auf eine gegebene Art und Weise erhalten werden. Hierdurch liefert sie die Bausteine zum Bau des wissenschaftlichen Gebäudes und sagt: Welches Gebäude immer du aufführen willst, jedes musst du irgendwie mit diesen und nur diesen Bausteinen zusammenbringen. (Wie man mit dem Zahlensystem jede beliebige Anzahl, so muss man mit dem System der Mechanik jeden beliebigen Satz der Physik hinschreiben können.)\",\"pmc\":\"Newtonian mechanics, for example, imposes a unified form on the description of the world. Let us imagine a white surface with irregular black spots on it. We then say that whatever kind of picture these make, I can always approximate as closely as I wish to the description of it by covering the surface with a sufficiently fine square mesh, and then saying of every square whether it is black or white. In this way I shall have imposed a unified form on the description of the surface. The form is optional, since I could have achieved the same result by using a net with a triangular or hexagonal mesh. Possibly the use of a triangular mesh would have made the description simpler: that is to say, it might be that we could describe the surface more accurately with a coarse triangular mesh than with a fine square mesh (or conversely), and so on. The different nets correspond to different systems for describing the world. Mechanics determines one form of description of the world by saying that all propositions used in the description of the world must be obtained in a given way from a given set of propositions—the axioms of mechanics. It thus supplies the bricks for building the edifice of science, and it says, ‘Any building that you want to erect, whatever it may be, must somehow be constructed with these bricks, and with these alone.’ (Just as with the number-system we must be able to write down any number we wish, so with the system of mechanics we must be able to write down any proposition of physics that we wish.)\",\"ogd\":\"Newtonian mechanics, for example, brings the description of the universe to a unified form. Let us imagine a white surface with irregular black spots. We now say: Whatever kind of picture these make I can always get as near as I like to its description, if I cover the surface with a sufficiently fine square network and now say of every square that it is white or black. In this way I shall have brought the description of the surface to a unified form. This form is arbitrary, because I could have applied with equal success a net with a triangular or hexagonal mesh. It can happen that the description would have been simpler with the aid of a triangular mesh; that is to say we might have described the surface more accurately with a triangular, and coarser, than with the finer square mesh, or vice versa, and so on. To the different networks correspond different systems of describing the world. Mechanics determine a form of description by saying: All propositions in the description of the world must be obtained in a given way from a number of given propositions—the mechanical axioms. It thus provides the bricks for building the edifice of science, and says: Whatever building thou wouldst erect, thou shalt construct it in some manner with these bricks and these alone. (As with the system of numbers one must be able to write down any arbitrary number, so with the system of mechanics one must be able to write down any arbitrary physical proposition.)\",\"str\":\"\"},{\"label\":\"6.361\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":39,\"x_axis\":121,\"ger\":\"In der Ausdrucksweise Hertz’s  könnte man sagen: Nur <em class=\\\"germph\\\">gesetzmäßige</em> Zusammenhänge sind <em class=\\\"germph\\\">denkbar</em>.\",\"pmc\":\"One might say, using Hertz’s terminology, that only connexions that are <em>subject to law</em> are <em>thinkable</em>.\",\"ogd\":\"In the terminology of Hertz we might say: Only <em>uniform</em> connections are <em>thinkable</em>.\",\"str\":\"\"},{\"label\":\"6.3611\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":39,\"x_axis\":123,\"ger\":\"Wir können keinen Vorgang mit dem „Ablauf der Zeit“ vergleichen – diesen gibt es nicht –, sondern nur mit einem anderen Vorgang (etwa mit dem Gang des Chronometers). Daher ist die Beschreibung des zeitlichen Verlaufs nur so möglich, dass wir uns auf einen anderen Vorgang stützen. Ganz Analoges gilt für den Raum. Wo man z. B. sagt, es könne keines von zwei Ereignissen (die sich gegenseitig ausschließen) eintreten, weil <em class=\\\"germph\\\">keine Ursache</em> vorhanden sei, warum das eine eher als das andere eintreten solle, da handelt es sich in Wirklichkeit darum, dass man gar nicht <em class=\\\"germph\\\">eines</em> der beiden Ereignisse beschreiben kann, wenn nicht irgend eine Asymmetrie vorhanden ist. Und <em class=\\\"germph\\\">wenn</em> eine solche Asymmetrie vorhanden <em class=\\\"germph\\\">ist</em>, so können wir diese als <em class=\\\"germph\\\">Ursache</em> des Eintreffens des einen und Nicht-Eintreffens des anderen auffassen.\",\"pmc\":\"We cannot compare a process with ‘the passage of time’—there is no such thing—but only with another process (such as the working of a chronometer). Hence we can describe the lapse of time only by relying on some other process. Something exactly analogous applies to space: e.g. when people say that neither of two events (which exclude one another) can occur, because there is <em>nothing to cause</em> the one to occur rather than the other, it is really a matter of our being unable to describe <em>one</em> of the two events unless there is some sort of asymmetry to be found. And <em>if</em> such an asymmetry <em>is</em> to be found, we can regard it as the <em>cause</em> of the occurrence of the one and the non-occurrence of the other.\",\"ogd\":\"We cannot compare any process with the “passage of time”—there is no such thing—but only with another process (say, with the movement of the chronometer). Hence the description of the temporal sequence of events is only possible if we support ourselves on another process. It is exactly analogous for space. When, for example, we say that neither of two events (which mutually exclude one another) can occur, because there is <em>no cause</em> why the one should occur rather than the other, it is really a matter of our being unable to describe <em>one</em> of the two events unless there is some sort of asymmetry. And if there <em>is</em> such an asymmetry, we can regard this as the <em>cause</em> of the occurrence of the one and of the non-occurrence of the other.\",\"str\":\"\"},{\"label\":\"6.371\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":39,\"x_axis\":125,\"ger\":\"Der ganzen modernen Weltanschauung liegt die Täuschung zugrunde, dass die sogenannten Naturgesetze die Erklärungen der Naturerscheinungen seien.\",\"pmc\":\"The whole modern conception of the world is founded on the illusion that the so-called laws of nature are the explanations of natural phenomena.\",\"ogd\":\"At the basis of the whole modern view of the world lies the illusion that the so-called laws of nature are the explanations of natural phenomena.\",\"str\":\"\"},{\"label\":\"2.222\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":41,\"x_axis\":13,\"ger\":\"In der Übereinstimmung oder Nichtübereinstimmung seines Sinnes mit der Wirklichkeit, besteht seine Wahrheit oder Falschheit.\",\"pmc\":\"The agreement or disagreement of its sense with reality constitutes its truth or falsity.\",\"ogd\":\"In the agreement or disagreement of its sense with reality, its truth or falsity consists.\",\"str\":\"\"},{\"label\":\"3.316\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":41,\"x_axis\":39,\"ger\":\"Welche Werte die Satzvariable annehmen darf, wird festgesetzt. Die Festsetzung der Werte <em class=\\\"germph\\\">ist</em> die Variable.\",\"pmc\":\"What values a propositional variable may take is something that is stipulated. The stipulation of values <em>is</em> the variable.\",\"ogd\":\"What values the propositional variable can assume is determined. The determination of the values <em>is</em> the variable.\",\"str\":\"\"},{\"label\":\"3.326\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":41,\"x_axis\":41,\"ger\":\"Um das Symbol am Zeichen zu erkennen, muss man auf den sinnvollen Gebrauch achten.\",\"pmc\":\"In order to recognize a symbol by its sign we must observe how it is used with a sense.\",\"ogd\":\"In order to recognize the symbol in the sign we must consider the significant use.\",\"str\":\"\"},{\"label\":\"4.2\",\"precision\":1,\"fontSize\":\"40px\",\"y_axis\":41,\"x_axis\":51,\"ger\":\"Der Sinn des Satzes ist seine Übereinstimmung und Nichtübereinstimmung mit den Möglichkeiten des Bestehens und Nichtbestehens der Sachverhalte.\",\"pmc\":\"The sense of a proposition is its agreement and disagreement with possibilities of existence and non-existence of states of affairs.\",\"ogd\":\"The sense of a proposition is its agreement and disagreement with the possibilities of the existence and non-existence of the atomic facts.\",\"str\":\"\"},{\"label\":\"4.21\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":41,\"x_axis\":53,\"ger\":\"Der einfachste Satz, der Elementarsatz, behauptet das Bestehen eines Sachverhaltes.\",\"pmc\":\"The simplest kind of proposition, an elementary proposition, asserts the existence of a state of affairs.\",\"ogd\":\"The simplest proposition, the elementary proposition, asserts the existence of an atomic fact.\",\"str\":\"\"},{\"label\":\"4.22\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":41,\"x_axis\":55,\"ger\":\"Der Elementarsatz besteht aus Namen. Er ist ein Zusammenhang, eine Verkettung, von Namen.\",\"pmc\":\"An elementary proposition consists of names. It is a nexus, a concatenation, of names.\",\"ogd\":\"The elementary proposition consists of names. It is a connexion, a concatenation, of names.\",\"str\":\"\"},{\"label\":\"4.23\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":41,\"x_axis\":57,\"ger\":\"Der Name kommt im Satz nur im Zusammenhange des Elementarsatzes vor.\",\"pmc\":\"It is only in the nexus of an elementary proposition that a name occurs in a proposition.\",\"ogd\":\"The name occurs in the proposition only in the context of the elementary proposition.\",\"str\":\"\"},{\"label\":\"4.24\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":41,\"x_axis\":59,\"ger\":\"Die Namen sind die einfachen Symbole, ich deute sie durch einzelne Buchstaben („<span class=\\\"mathmode\\\"><var>x</var></span>“, „<span class=\\\"mathmode\\\"><var>y</var></span>“, „<span class=\\\"mathmode\\\"><var>z</var></span>“) an. Den Elementarsatz schreibe ich als Funktion der Namen in der Form: „<span class=\\\"mathmode\\\"><var>fx</var></span>“, „<span class=\\\"mathmode\\\"><var>φ</var>(<var>x</var>,<var>y</var>)</span>“, etc. Oder ich deute ihn durch die Buchstaben <span class=\\\"mathmode\\\"><var>p</var></span>, <span class=\\\"mathmode\\\"><var>q</var></span>, <span class=\\\"mathmode\\\"><var>r</var></span> an.\",\"pmc\":\"Names are the simple symbols: I indicate them by single letters (‘<span class=\\\"mathmode\\\"><var>x</var></span>’, ‘<span class=\\\"mathmode\\\"><var>y</var></span>’, ‘<span class=\\\"mathmode\\\"><var>z</var></span>’). I write elementary propositions as functions of names, so that they have the form ‘<span class=\\\"mathmode\\\"><var>fx</var></span>’, ‘<span class=\\\"mathmode\\\"><var>φ</var>(<var>x</var>,<var>y</var>)</span>’, etc. Or I indicate them by the letters ‘<span class=\\\"mathmode\\\"><var>p</var></span>’, ‘<span class=\\\"mathmode\\\"><var>q</var></span>’, ‘<span class=\\\"mathmode\\\"><var>r</var></span>’.\",\"ogd\":\"The names are the simple symbols, I indicate them by single letters (<span class=\\\"mathmode\\\"><var>x</var></span>, <span class=\\\"mathmode\\\"><var>y</var></span>, <span class=\\\"mathmode\\\"><var>z</var></span>). The elementary proposition I write as function of the names, in the form “<span class=\\\"mathmode\\\"><var>fx</var></span>”, “<span class=\\\"mathmode\\\"><var>φ</var>(<var>x</var>,<var>y</var>)</span>”, etc. Or I indicate it by the letters <span class=\\\"mathmode\\\"><var>p</var></span>, <span class=\\\"mathmode\\\"><var>q</var></span>, <span class=\\\"mathmode\\\"><var>r</var></span>.\",\"str\":\"\"},{\"label\":\"4.25\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":41,\"x_axis\":61,\"ger\":\"Ist der Elementarsatz wahr, so besteht der Sachverhalt; ist der Elementarsatz falsch, so besteht der Sachverhalt nicht.\",\"pmc\":\"If an elementary proposition is true, the state of affairs exists: if an elementary proposition is false, the state of affairs does not exist.\",\"ogd\":\"If the elementary proposition is true, the atomic fact exists; if it is false the atomic fact does not exist.\",\"str\":\"\"},{\"label\":\"4.26\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":41,\"x_axis\":63,\"ger\":\"Die Angabe aller wahren Elementarsätze beschreibt die Welt vollständig. Die Welt ist vollständig beschrieben durch die Angaben aller Elementarsätze plus der Angabe, welche von ihnen wahr und welche falsch sind.\",\"pmc\":\"If all true elementary propositions are given, the result is a complete description of the world. The world is completely described by giving all elementary propositions, and adding which of them are true and which false.\",\"ogd\":\"The specification of all true elementary propositions describes the world completely. The world is completely described by the specification of all elementary propositions plus the specification, which of them are true and which false.\",\"str\":\"\"},{\"label\":\"4.27\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":41,\"x_axis\":65,\"ger\":\"Bezüglich des Bestehens und Nichtbestehens von <span class=\\\"mathmode\\\"><var>n</var></span> Sachverhalten gibt es <table class=\\\"possibilities\\\"><tr><td rowspan=\\\"3\\\" class=\\\"middleright\\\"><span class=\\\"mathmode\\\">K<sub><var>n</var></sub> = </span></td><td class=\\\"summationtop\\\"><span class=\\\"mathmode\\\"><var class=\\\"smallvar\\\">n</var></span></td><td rowspan=\\\"3\\\" class=\\\"middleright\\\"><span class=\\\"largeparen\\\">(</span></td><td rowspan=\\\"3\\\" class=\\\"middlecenter\\\"><span class=\\\"mathmode\\\"><var>n</var></span><br /><span class=\\\"mathmode\\\"><var>ν</var></span></td><td rowspan=\\\"3\\\" class=\\\"middleleft\\\"><span class=\\\"largeparen\\\">)</span></td></tr><tr><td class=\\\"summationmiddle\\\"><span class=\\\"mathmode\\\"><span class=\\\"largeop\\\">∑</span></span></td></tr><tr><td class=\\\"summationbottom\\\"><span class=\\\"mathmode\\\"><span class=\\\"smallvar\\\"><var>ν</var> = 0</span></span></td></tr></table> Möglichkeiten. Es können alle Kombinationen der Sachverhalte bestehen, die andern nicht bestehen.\",\"pmc\":\"For <span class=\\\"mathmode\\\"><var>n</var></span> states of affairs, there are <table class=\\\"possibilities\\\"><tr><td rowspan=\\\"3\\\" class=\\\"middleright\\\"><span class=\\\"mathmode\\\">K<sub><var>n</var></sub> = </span></td><td class=\\\"summationtop\\\"><span class=\\\"mathmode\\\"><var class=\\\"smallvar\\\">n</var></span></td><td rowspan=\\\"3\\\" class=\\\"middleright\\\"><span class=\\\"largeparen\\\">(</span></td><td rowspan=\\\"3\\\" class=\\\"middlecenter\\\"><span class=\\\"mathmode\\\"><var>n</var></span><br /><span class=\\\"mathmode\\\"><var>ν</var></span></td><td rowspan=\\\"3\\\" class=\\\"middleleft\\\"><span class=\\\"largeparen\\\">)</span></td></tr><tr><td class=\\\"summationmiddle\\\"><span class=\\\"mathmode\\\"><span class=\\\"largeop\\\">∑</span></span></td></tr><tr><td class=\\\"summationbottom\\\"><span class=\\\"mathmode\\\"><span class=\\\"smallvar\\\"><var>ν</var> = 0</span></span></td></tr></table> possibilities of existence and non-existence. Of these states of affairs any combination can exist and the remainder not exist.\",\"ogd\":\"With regard to the existence of <span class=\\\"mathmode\\\"><var>n</var></span> atomic facts there are <table class=\\\"possibilities\\\"><tr><td rowspan=\\\"3\\\" class=\\\"middleright\\\"><span class=\\\"mathmode\\\">K<sub><var>n</var></sub> = </span></td><td class=\\\"summationtop\\\"><span class=\\\"mathmode\\\"><var class=\\\"smallvar\\\">n</var></span></td><td rowspan=\\\"3\\\" class=\\\"middleright\\\"><span class=\\\"largeparen\\\">(</span></td><td rowspan=\\\"3\\\" class=\\\"middlecenter\\\"><span class=\\\"mathmode\\\"><var>n</var></span><br /><span class=\\\"mathmode\\\"><var>ν</var></span></td><td rowspan=\\\"3\\\" class=\\\"middleleft\\\"><span class=\\\"largeparen\\\">)</span></td></tr><tr><td class=\\\"summationmiddle\\\"><span class=\\\"mathmode\\\"><span class=\\\"largeop\\\">∑</span></span></td></tr><tr><td class=\\\"summationbottom\\\"><span class=\\\"mathmode\\\"><span class=\\\"smallvar\\\"><var>ν</var> = 0</span></span></td></tr></table>  possibilities. It is possible for all combinations of atomic facts to exist, and the others not to exist.\",\"str\":\"\"},{\"label\":\"4.28\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":41,\"x_axis\":67,\"ger\":\"Diesen Kombinationen entsprechen ebenso viele Möglichkeiten der Wahrheit – und Falschheit – von <span class=\\\"mathmode\\\"><var>n</var></span> Elementarsätzen.\",\"pmc\":\"There correspond to these combinations the same number of possibilities of truth—and falsity—for <span class=\\\"mathmode\\\"><var>n</var></span> elementary propositions.\",\"ogd\":\"To these combinations correspond the same number of possibilities of the truth—and falsehood—of <span class=\\\"mathmode\\\"><var>n</var></span> elementary propositions.\",\"str\":\"\"},{\"label\":\"5.454\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":41,\"x_axis\":85,\"ger\":\"In der Logik gibt es kein Nebeneinander, kann es keine Klassifikation geben. In der Logik kann es nicht Allgemeineres und Spezielleres geben.\",\"pmc\":\"In logic there is no co-ordinate status, and there can be no classification. In logic there can be no distinction between the general and the specific.\",\"ogd\":\"In logic there is no side by side, there can be no classification. In logic there cannot be a more general and a more special.\",\"str\":\"\"},{\"label\":\"5.4541\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":41,\"x_axis\":87,\"ger\":\"Die Lösungen der logischen Probleme müssen einfach sein, denn sie setzen den Standard der Einfachheit. Die Menschen haben immer geahnt, dass es ein Gebiet von Fragen geben müsse, deren Antworten – a priori – symmetrisch, und zu einem abgeschlossenen, regelmäßigen Gebilde vereint liegen. Ein Gebiet, in dem der Satz gilt: simplex sigillum veri.\",\"pmc\":\"The solutions of the problems of logic must be simple, since they set the standard of simplicity. Men have always had a presentiment that there must be a realm in which the answers to questions are symmetrically combined—<em>a priori</em>—to form a self-contained system. A realm subject to the law: <em>Simplex sigillum veri</em>.\",\"ogd\":\"The solution of logical problems must be neat for they set the standard of neatness. Men have always thought that there must be a sphere of questions whose answers—a priori—are symmetrical and united into a closed regular structure. A sphere in which the proposition, simplex sigillum veri, is valid.\",\"str\":\"\"},{\"label\":\"5.474\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":41,\"x_axis\":91,\"ger\":\"Die Anzahl der nötigen Grundoperationen hängt <em class=\\\"germph\\\">nur</em> von unserer Notation ab.\",\"pmc\":\"The number of fundamental operations that are necessary depends <em>solely</em> on our notation.\",\"ogd\":\"The number of necessary fundamental operations depends <em>only</em> on our notation.\",\"str\":\"\"},{\"label\":\"5.47321\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":41,\"x_axis\":95,\"ger\":\"Occams Devise ist natürlich keine willkürliche, oder durch ihren praktischen Erfolg gerechtfertigte Regel: Sie besagt, dass <em class=\\\"germph\\\">unnötige</em> Zeicheneinheiten nichts bedeuten. Zeichen, die <em class=\\\"germph\\\">Einen</em> Zweck erfüllen, sind logisch äquivalent, Zeichen, die <em class=\\\"germph\\\">keinen</em> Zweck erfüllen, logisch bedeutungslos.\",\"pmc\":\"Occam’s maxim is, of course, not an arbitrary rule, nor one that is justified by its success in practice: its point is that <em>unnecessary</em> units in a sign-language mean nothing. Signs that serve <em>one</em> purpose are logically equivalent, and signs that serve <em>none</em> are logically meaningless.\",\"ogd\":\"Occam’s razor is, of course, not an arbitrary rule nor one justified by its practical success. It simply says that <em>unnecessary</em> elements in a symbolism mean nothing. Signs which serve <em>one</em> purpose are logically equivalent, signs\\nwhich serve <em>no</em> purpose are logically meaningless.\",\"str\":\"\"},{\"label\":\"6.342\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":41,\"x_axis\":115,\"ger\":\"Und nun sehen wir die gegenseitige Stellung von Logik und Mechanik. (Man könnte das Netz auch aus verschiedenartigen Figuren etwa aus Dreiecken und Sechsecken bestehen lassen.) Dass sich ein Bild, wie das vorhin erwähnte, durch ein Netz von gegebener Form beschreiben lässt, sagt über das Bild <em class=\\\"germph\\\">nichts</em> aus. (Denn dies gilt für jedes Bild dieser Art.) Das aber charakterisiert das Bild, dass es sich durch ein bestimmtes Netz von <em class=\\\"germph\\\">bestimmter</em> Feinheit <em class=\\\"germph\\\">vollständig</em> beschreiben lässt. So auch sagt es nichts über die Welt aus, dass sie sich durch die Newtonsche Mechanik beschreiben lässt; wohl aber, dass sie sich <em class=\\\"germph\\\">so</em> durch jene beschreiben lässt, wie dies eben der Fall ist. Auch das sagt etwas über die Welt, dass sie sich durch die eine Mechanik einfacher beschreiben lässt als durch die andere.\",\"pmc\":\"And now we can see the relative position of logic and mechanics. (The net might also consist of more than one kind of mesh: e.g. we could use both triangles and hexagons.) The possibility of describing a picture like the one mentioned above with a net of a given form tells us <em>nothing</em> about the picture. (For that is true of all such pictures.) But what <em>does</em> characterize the picture is that it can be described <em>completely</em> by a particular net with a <em>particular</em> size of mesh. Similarly the possibility of describing the world by means of Newtonian mechanics tells us nothing about the world: but what does tell us something about it is the precise <em>way</em> in which it is possible to describe it by these means. We are also told something about the world by the fact that it can be described more simply with one system of mechanics than with another.\",\"ogd\":\"And now we see the relative position of logic and mechanics. (We could construct the network out of figures of different kinds, as out of triangles and hexagons together.) That a picture like that instanced above can be described by a network of a given form asserts <em>nothing</em> about the picture. (For this holds of every picture of this kind.) But <em>this</em> does characterize the picture, the fact, namely, that it can be <em>completely</em> described by a definite net of <em>definite</em> fineness. So too the fact that it can be described by Newtonian mechanics asserts nothing about the world; but <em>this</em> asserts something, namely, that it can be described in that particular way in which as a matter of fact it is described. The fact, too, that it can be described more simply by one system of mechanics than by another says something about the world.\",\"str\":\"\"},{\"label\":\"6.362\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":41,\"x_axis\":121,\"ger\":\"Was sich beschreiben lässt, das kann auch geschehen, und was das Kausalitätsgesetz ausschließen soll, das lässt sich auch nicht beschreiben.\",\"pmc\":\"What can be described can happen too: and what the law of causality is meant to exclude cannot even be described.\",\"ogd\":\"What can be described can happen too, and what is excluded by the law of causality cannot be described.\",\"str\":\"\"},{\"label\":\"6.36111\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":41,\"x_axis\":123,\"ger\":\"Das Kant’sche Problem von der rechten und linken Hand, die man nicht zur Deckung bringen kann, besteht schon in der Ebene, ja im eindimensionalen Raum, wo die beiden kongruenten Figuren <span class=\\\"mathmode\\\"><var>a</var></span> und <span class=\\\"mathmode\\\"><var>b</var></span> auch nicht zur Deckung gebracht werden können, ohne aus diesem Raum <!-- noindent --><div class=\\\"centeredsqueeze\\\" ><b>–&nbsp;–&nbsp;–&nbsp;<span class=\\\"tight\\\"><span class=\\\"symbol\\\">○</span>————<span class=\\\"nudgedown\\\"><span class=\\\"symbol\\\">✕</span></span></span>&nbsp;–&nbsp;–&nbsp;<span class=\\\"tight\\\"><span class=\\\"nudgedown\\\"><span class=\\\"symbol\\\">✕</span></span>————<span class=\\\"symbol\\\">○</span></span>&nbsp;–&nbsp;–&nbsp;–</b><br /><var class=\\\"smallvar\\\">a</var>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<var class=\\\"smallvar\\\">b</var></div> <!-- noindent --> herausbewegt zu werden. Rechte und linke Hand sind tatsächlich vollkommen kongruent. Und dass man sie nicht zur Deckung bringen kann, hat damit nichts zu tun. Den rechten Handschuh könnte man an die linke Hand ziehen, wenn man ihn im vierdimensionalen Raum umdrehen könnte.\",\"pmc\":\"Kant’s problem about the right hand and the left hand, which cannot be made to coincide, exists even in two dimensions. Indeed, it exists in one-dimensional space <!-- noindent --><div class=\\\"centeredsqueeze\\\" ><b>–&nbsp;–&nbsp;–&nbsp;<span class=\\\"tight\\\"><span class=\\\"symbol\\\">○</span>————<span class=\\\"nudgedown\\\"><span class=\\\"symbol\\\">✕</span></span></span>&nbsp;–&nbsp;–&nbsp;<span class=\\\"tight\\\"><span class=\\\"nudgedown\\\"><span class=\\\"symbol\\\">✕</span></span>————<span class=\\\"symbol\\\">○</span></span>&nbsp;–&nbsp;–&nbsp;–</b><br /><var class=\\\"smallvar\\\">a</var>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<var class=\\\"smallvar\\\">b</var></div> <!-- noindent --> in which the two congruent figures, <span class=\\\"mathmode\\\"><var>a</var></span> and <span class=\\\"mathmode\\\"><var>b</var></span>, cannot be made to coincide unless they are moved out of this space. The right hand and the left hand are in fact completely congruent. It is quite irrelevant that they cannot be made to coincide. A right-hand glove could be put on the left hand, if it could be turned round in four-dimensional space.\",\"ogd\":\"The Kantian problem of the right and left hand which cannot be made to cover one another already exists in the plane, and even in one-dimensional space; where the two congruent figures <span class=\\\"mathmode\\\"><var>a</var></span> and <span class=\\\"mathmode\\\"><var>b</var></span> cannot be made to cover one another without  <!-- noindent --><div class=\\\"centeredsqueeze\\\" ><b>–&nbsp;–&nbsp;–&nbsp;<span class=\\\"tight\\\"><span class=\\\"symbol\\\">○</span>————<span class=\\\"nudgedown\\\"><span class=\\\"symbol\\\">✕</span></span></span>&nbsp;–&nbsp;–&nbsp;<span class=\\\"tight\\\"><span class=\\\"nudgedown\\\"><span class=\\\"symbol\\\">✕</span></span>————<span class=\\\"symbol\\\">○</span></span>&nbsp;–&nbsp;–&nbsp;–</b><br /><var class=\\\"smallvar\\\">a</var>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<var class=\\\"smallvar\\\">b</var></div> <!-- noindent --> moving them out of this space. The right and left hand are in fact completely congruent. And the fact that they cannot be made to cover one another has nothing to do with it. A right-hand glove could be put on a left hand if it could be turned round in four-dimensional space.\",\"str\":\"\"},{\"label\":\"6.372\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":41,\"x_axis\":125,\"ger\":\"So bleiben sie bei den Naturgesetzen als bei etwas Unantastbarem stehen, wie die Älteren bei Gott und dem Schicksal. Und sie haben ja beide Recht, und Unrecht. Die Alten sind allerdings insofern klarer, als sie einen klaren Abschluss anerkennen, während es bei dem neuen System scheinen soll, als sei <em class=\\\"germph\\\">alles</em> erklärt.\",\"pmc\":\"Thus people today stop at the laws of nature, treating them as something inviolable, just as God and Fate were treated in past ages. And in fact both are right and both wrong: though the view of the ancients is clearer in so far as they have a clear and acknowledged terminus, while the modern system tries to make it look as if <em>everything</em> were explained.\",\"ogd\":\"So people stop short at natural laws as something unassailable, as did the ancients at God and Fate. And they are both right and wrong. but the ancients were clearer, in so far as they recognized one clear terminus, whereas the modern system makes it appear as though <em>everything</em> were explained.\",\"str\":\"\"},{\"label\":\"2.223\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":43,\"x_axis\":13,\"ger\":\"Um zu erkennen, ob das Bild wahr oder falsch ist, müssen wir es mit der Wirklichkeit vergleichen.\",\"pmc\":\"In order to tell whether a picture is true or false we must compare it with reality.\",\"ogd\":\"In order to discover whether the picture is true or false we must compare it with reality.\",\"str\":\"\"},{\"label\":\"3.317\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":43,\"x_axis\":39,\"ger\":\"Die Festsetzung der Werte der Satzvariablen ist die <em class=\\\"germph\\\">Angabe der Sätze</em>, deren gemeinsames Merkmal die Variable ist. Die Festsetzung ist eine Beschreibung dieser Sätze. Die Festsetzung wird also nur von Symbolen, nicht von deren Bedeutung handeln. Und <em class=\\\"germph\\\">nur</em> dies ist der Festsetzung wesentlich, <em class=\\\"germph\\\">dass sie nur eine Beschreibung von Symbolen ist und nichts über das Bezeichnete aussagt</em>. Wie die Beschreibung der Sätze geschieht, ist unwesentlich.\",\"pmc\":\"To stipulate values for a propositional variable is to <em>give the propositions</em> whose common characteristic the variable is. The stipulation is a description of those propositions. The stipulation will therefore be concerned only with symbols, not with their meaning. And the <em>only</em> thing essential to the stipulation is <em>that it is merely a description of symbols and states nothing about what is signified</em>. How the description of the propositions is produced is not essential.\",\"ogd\":\"The determination of the values of the propositional variable is done by <em>indicating the propositions</em> whose common mark the variable is. The determination is a description of these propositions. The determination will therefore deal only with symbols not with their meaning. And <em>only</em> this is essential to the determination, <em>that it is only a description of symbols and asserts nothing about what is symbolized</em>. The way in which we describe the propositions is not essential.\",\"str\":\"\"},{\"label\":\"3.327\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":43,\"x_axis\":41,\"ger\":\"Das Zeichen bestimmt erst mit seiner logisch-syntaktischen Verwendung zusammen eine logische Form.\",\"pmc\":\"A sign does not determine a logical form unless it is taken together with its logico-syntactical employment.\",\"ogd\":\"The sign determines a logical form only together with its logical syntactic application.\",\"str\":\"\"},{\"label\":\"4.211\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":43,\"x_axis\":53,\"ger\":\"Ein Zeichen des Elementarsatzes ist es, dass kein Elementarsatz mit ihm in Widerspruch stehen kann.\",\"pmc\":\"It is a sign of a proposition’s being elementary that there can be no elementary proposition contradicting it.\",\"ogd\":\"It is a sign of an elementary proposition, that no elementary proposition can contradict it.\",\"str\":\"\"},{\"label\":\"4.221\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":43,\"x_axis\":55,\"ger\":\"Es ist offenbar, dass wir bei der Analyse der Sätze auf Elementarsätze kommen müssen, die aus Namen in unmittelbarer Verbindung bestehen. Es frägt sich hier, wie kommt der Satzverband zustande.\",\"pmc\":\"It is obvious that the analysis of propositions must bring us to elementary propositions which consist of names in immediate combination. This raises the question how such combination into propositions comes about.\",\"ogd\":\"It is obvious that in the analysis of propositions we must come to elementary propositions, which consist of names in immediate combination. The question arises here, how the propositional connexion comes to be.\",\"str\":\"\"},{\"label\":\"4.2211\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":43,\"x_axis\":57,\"ger\":\"Auch wenn die Welt unendlich komplex ist, so dass jede Tatsache aus unendlich vielen Sachverhalten besteht und jeder Sachverhalt aus unendlich vielen Gegenständen zusammengesetzt ist, auch dann müsste es Gegenstände und Sachverhalte geben.\",\"pmc\":\"Even if the world is infinitely complex, so that every fact consists of infinitely many states of affairs and every state of affairs is composed of infinitely many objects, there would still have to be objects and states of affairs.\",\"ogd\":\"Even if the world is infinitely complex, so that every fact consists of an infinite number of atomic facts and every atomic fact is composed of an infinite number of objects, even then there must be objects and atomic facts.\",\"str\":\"\"},{\"label\":\"4.241\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":43,\"x_axis\":59,\"ger\":\"Gebrauche ich zwei Zeichen in ein und derselben Bedeutung, so drücke ich dies aus, indem ich zwischen beide das Zeichen „=“ setze. „<span class=\\\"mathmode\\\"><var>a</var><span class=\\\"mathrel\\\">=</span><var>b</var></span>“ heißt also: das Zeichen „<span class=\\\"mathmode\\\"><var>a</var></span>“ ist durch das Zeichen „<span class=\\\"mathmode\\\"><var>b</var></span>“ ersetzbar. (Führe ich durch eine Gleichung ein neues Zeichen „<span class=\\\"mathmode\\\"><var>b</var></span>“ ein, indem ich bestimme, es solle ein bereits bekanntes Zeichen „<span class=\\\"mathmode\\\"><var>a</var></span>“ ersetzen, so schreibe ich die Gleichung – Definition – (wie Russell) in der Form „<span class=\\\"mathmode\\\"><var>a</var><span class=\\\"mathrel\\\">=</span><var>b</var></span> Def.“. Die Definition ist eine Zeichenregel.)\",\"pmc\":\"When I use two signs with one and the same meaning, I express this by putting the sign ‘=’ between them. So ‘<span class=\\\"mathmode\\\"><var>a</var><span class=\\\"mathrel\\\">=</span><var>b</var></span>’ means that the sign ‘<span class=\\\"mathmode\\\"><var>b</var></span>’ can be substituted for the sign ‘<span class=\\\"mathmode\\\"><var>a</var></span>’. (If I use an equation to introduce a new sign ‘<span class=\\\"mathmode\\\"><var>b</var></span>’, laying down that it shall serve as a substitute for a sign ‘<span class=\\\"mathmode\\\"><var>a</var></span>’ that is already known, then, like Russell, I write the equation—definition—in the form ‘<span class=\\\"mathmode\\\"><var>a</var><span class=\\\"mathrel\\\">=</span><var>b</var></span> Def.’ A definition is a rule dealing with signs.)\",\"ogd\":\"If I use two signs with one and the same meaning, I express this by putting between them the sign “=”. “<span class=\\\"mathmode\\\"><var>a</var><span class=\\\"mathrel\\\">=</span><var>b</var></span>” means then, that the sign “<span class=\\\"mathmode\\\"><var>a</var></span>” is replaceable by the sign “<span class=\\\"mathmode\\\"><var>b</var></span>”. (If I introduce by an equation a new sign “<span class=\\\"mathmode\\\"><var>b</var></span>”, by determining that it shall replace a previously known sign “<span class=\\\"mathmode\\\"><var>a</var></span>”, I write the equation—definition—(like Russell) in the form “<span class=\\\"mathmode\\\"><var>a</var><span class=\\\"mathrel\\\">=</span><var>b</var></span> Def.”. A definition is a symbolic rule.)\",\"str\":\"\"},{\"label\":\"5.475\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":43,\"x_axis\":91,\"ger\":\"Es kommt nur darauf an, ein Zeichensystem von einer bestimmten Anzahl von Dimensionen – von einer bestimmten mathematischen Mannigfaltigkeit – zu bilden.\",\"pmc\":\"All that is required is that we should construct a system of signs with a particular number of dimensions—with a particular mathematical multiplicity.\",\"ogd\":\"It is only a question of constructing a system of signs of a definite number of dimensions—of a definite mathematical multiplicity.\",\"str\":\"\"},{\"label\":\"6.343\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":43,\"x_axis\":115,\"ger\":\"Die Mechanik ist ein Versuch, alle <em class=\\\"germph\\\">wahren</em> Sätze, die wir zur Weltbeschreibung brauchen, nach Einem Plane zu konstruieren.\",\"pmc\":\"Mechanics is an attempt to construct according to a single plan all the <em>true</em> propositions that we need for the description of the world.\",\"ogd\":\"Mechanics is an attempt to construct according to a single plan all <em>true</em> propositions which we need for the description of the world.\",\"str\":\"\"},{\"label\":\"6.3431\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":43,\"x_axis\":117,\"ger\":\"Durch den ganzen logischen Apparat hindurch sprechen die physikalischen Gesetze doch von den Gegenständen der Welt.\",\"pmc\":\"The laws of physics, with all their logical apparatus, still speak, however indirectly, about the objects of the world.\",\"ogd\":\"Through their whole logical apparatus the physical laws still speak of the objects of the world.\",\"str\":\"\"},{\"label\":\"6.3432\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":43,\"x_axis\":119,\"ger\":\"Wir dürfen nicht vergessen, dass die Weltbeschreibung durch die Mechanik immer die ganz allgemeine ist. Es ist in ihr z. B. nie von <em class=\\\"germph\\\">bestimmten</em> materiellen Punkten die Rede, sondern immer nur von <em class=\\\"germph\\\">irgend welchen</em>.\",\"pmc\":\"We ought not to forget that any description of the world by means of mechanics will be of the completely general kind. For example, it will never mention <em>particular</em> point-masses: it will only talk about <em>any point-masses whatsoever</em>.\",\"ogd\":\"We must not forget that the description of the world by mechanics is always quite general. There is, for example, never any mention of <em>particular</em> material points in it, but always only of <em>some points or other</em>.\",\"str\":\"\"},{\"label\":\"6.363\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":43,\"x_axis\":121,\"ger\":\"Der Vorgang der Induktion besteht darin, dass wir das <em class=\\\"germph\\\">einfachste</em> Gesetz annehmen, das mit unseren Erfahrungen in Einklang zu bringen ist.\",\"pmc\":\"The procedure of induction consists in accepting as true the <em>simplest</em> law that can be reconciled with our experiences.\",\"ogd\":\"The process of induction is the process of assuming the <em>simplest</em> law that can be made to harmonize with our experience.\",\"str\":\"\"},{\"label\":\"6.3631\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":43,\"x_axis\":123,\"ger\":\"Dieser Vorgang hat aber keine logische, sondern nur eine psychologische Begründung. Es ist klar, dass kein Grund vorhanden ist, zu glauben, es werde nun auch wirklich der einfachste Fall eintreten.\",\"pmc\":\"This procedure, however, has no logical justification but only a psychological one. It is clear that there are no grounds for believing that the simplest eventuality will in fact be realized.\",\"ogd\":\"This process, however, has no logical foundation but only a psychological one. It is clear that there are no grounds for believing that the simplest course of events will really happen.\",\"str\":\"\"},{\"label\":\"6.373\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":43,\"x_axis\":125,\"ger\":\"Die Welt ist unabhängig von meinem Willen.\",\"pmc\":\"The world is independent of my will.\",\"ogd\":\"The world is independent of my will.\",\"str\":\"\"},{\"label\":\"2.224\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":45,\"x_axis\":13,\"ger\":\"Aus dem Bild allein ist nicht zu erkennen, ob es wahr oder falsch ist.\",\"pmc\":\"It is impossible to tell from the picture alone whether it is true or false.\",\"ogd\":\"It cannot be discovered from the picture alone whether it is true or false.\",\"str\":\"\"},{\"label\":\"3.318\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":45,\"x_axis\":39,\"ger\":\"Den Satz fasse ich – wie Frege und Russell – als Funktion der in ihm enthaltenen Ausdrücke auf.\",\"pmc\":\"Like Frege and Russell I construe a proposition as a function of the expressions contained in it.\",\"ogd\":\"I conceive the proposition—like Frege and Russell—as a function of the expressions contained in it.\",\"str\":\"\"},{\"label\":\"3.328\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":45,\"x_axis\":41,\"ger\":\"Wird ein Zeichen <em class=\\\"germph\\\">nicht gebraucht</em>, so ist es bedeutungslos. Das ist der Sinn der Devise Occams. (Wenn sich alles so verhält als hätte ein Zeichen Bedeutung, dann hat es auch Bedeutung.)\",\"pmc\":\"If a sign is <em>useless</em>, it is meaningless. That is the point of Occam’s maxim. (If everything behaves as if a sign had meaning, then it does have meaning.)\",\"ogd\":\"If a sign is <em>not necessary</em> then it is meaningless. That is the meaning of Occam’s razor. (If everything in the symbolism works as though a sign had meaning, then it has meaning.)\",\"str\":\"\"},{\"label\":\"4.242\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":45,\"x_axis\":59,\"ger\":\"Ausdrücke von der Form „<span class=\\\"mathmode\\\"><var>a</var><span class=\\\"mathrel\\\">=</span><var>b</var></span>“ sind also nur Behelfe der Darstellung; sie sagen nichts über die Bedeutung der Zeichen „<span class=\\\"mathmode\\\"><var>a</var></span>“, „<span class=\\\"mathmode\\\"><var>b</var></span>“ aus.\",\"pmc\":\"Expressions of the form ‘<span class=\\\"mathmode\\\"><var>a</var><span class=\\\"mathrel\\\">=</span><var>b</var></span>’ are, therefore, mere representational devices. They state nothing about the meaning of the signs ‘<span class=\\\"mathmode\\\"><var>a</var></span>’ and ‘<span class=\\\"mathmode\\\"><var>b</var></span>’.\",\"ogd\":\"Expressions of the form “<span class=\\\"mathmode\\\"><var>a</var><span class=\\\"mathrel\\\">=</span><var>b</var></span>” are therefore only expedients in presentation: They assert nothing about the meaning of the signs “<span class=\\\"mathmode\\\"><var>a</var></span>” and “<span class=\\\"mathmode\\\"><var>b</var></span>”.\",\"str\":\"\"},{\"label\":\"5.476\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":45,\"x_axis\":91,\"ger\":\"Es ist klar, dass es sich hier nicht um eine <em class=\\\"germph\\\">Anzahl von Grundbegriffen</em> handelt, die bezeichnet werden müssen, sondern um den Ausdruck einer Regel.\",\"pmc\":\"It is clear that this is not a question of a <em>number of primitive ideas</em> that have to be signified, but rather of the expression of a rule.\",\"ogd\":\"It is clear that we are not concerned here with a <em>number of primitive ideas</em> which must be signified but with the expression of a rule.\",\"str\":\"\"},{\"label\":\"6.36311\",\"precision\":5,\"fontSize\":\"18px\",\"y_axis\":45,\"x_axis\":123,\"ger\":\"Dass die Sonne morgen aufgehen wird, ist eine Hypothese; und das heißt: wir <em class=\\\"germph\\\">wissen</em> nicht, ob sie aufgehen wird.\",\"pmc\":\"It is an hypothesis that the sun will rise tomorrow: and this means that we do not <em>know</em> whether it will rise.\",\"ogd\":\"That the sun will rise to-morrow, is an hypothesis; and that means that we do not <em>know</em> whether it will rise.\",\"str\":\"\"},{\"label\":\"6.374\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":45,\"x_axis\":125,\"ger\":\"Auch wenn alles, was wir wünschen, geschähe, so wäre dies doch nur, sozusagen, eine Gnade des Schicksals, denn es ist kein <em class=\\\"germph\\\">logischer</em> Zusammenhang zwischen Willen und Welt, der dies verbürgte, und den angenommenen physikalischen Zusammenhang könnten wir doch nicht selbst wieder wollen.\",\"pmc\":\"Even if all that we wish for were to happen, still this would only be a favour granted by fate, so to speak: for there is no <em>logical</em> connexion between the will and the world, which would guarantee it, and the supposed physical connexion itself is surely not something that we could will.\",\"ogd\":\"Even if everything we wished were to happen, this would only be, so to speak, a favour of fate, for there is no <em>logical</em> connexion between will and world, which would guarantee this, and the assumed physical connexion itself we could not again will.\",\"str\":\"\"},{\"label\":\"2.225\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":47,\"x_axis\":13,\"ger\":\"Ein a priori wahres Bild gibt es nicht.\",\"pmc\":\"There are no pictures that are true <em>a priori</em>.\",\"ogd\":\"There is no picture which is a priori true.\",\"str\":\"\"},{\"label\":\"3.4\",\"precision\":1,\"fontSize\":\"40px\",\"y_axis\":47,\"x_axis\":37,\"ger\":\"Der Satz bestimmt einen Ort im logischen Raum. Die Existenz dieses logischen Ortes ist durch die Existenz der Bestandteile allein verbürgt, durch die Existenz des sinnvollen Satzes.\",\"pmc\":\"A proposition determines a place in logical space. The existence of this logical place is guaranteed by the mere existence of the constituents—by the existence of the proposition with a sense.\",\"ogd\":\"The proposition determines a place in logical space: the existence of this logical place is guaranteed by the existence of the constituent parts alone, by the existence of the significant proposition.\",\"str\":\"\"},{\"label\":\"3.41\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":47,\"x_axis\":39,\"ger\":\"Das Satzzeichen und die logischen Koordinaten: Das ist der logische Ort.\",\"pmc\":\"The propositional sign with logical co-ordinates—that is the logical place.\",\"ogd\":\"The propositional sign and the logical co-ordinates: that is the logical place.\",\"str\":\"\"},{\"label\":\"3.42\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":47,\"x_axis\":41,\"ger\":\"Obwohl der Satz nur einen Ort des logischen Raumes bestimmen darf, so muss doch durch ihn schon der ganze logische Raum gegeben sein. (Sonst würden durch die Verneinung, die logische Summe, das logische Produkt, etc. immer neue Elemente – in Koordination – eingeführt.) (Das logische Gerüst um das Bild herum bestimmt den logischen Raum. Der Satz durchgreift den ganzen logischen Raum.)\",\"pmc\":\"A proposition can determine only one place in logical space: nevertheless the whole of logical space must already be given by it. (Otherwise negation, logical sum, logical product, etc., would introduce more and more new elements—in co-ordination.) (The logical scaffolding surrounding a picture determines logical space. The force of a proposition reaches through the whole of logical space.)\",\"ogd\":\"Although a proposition may only determine one place in logical space, the whole logical space must already be given by it. (Otherwise denial, the logical sum, the logical product, etc., would always introduce new elements—in co-ordination.) (The logical scaffolding round the picture determines the logical space. The proposition reaches through the whole logical space.)\",\"str\":\"\"},{\"label\":\"4.243\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":47,\"x_axis\":59,\"ger\":\"Können wir zwei Namen verstehen, ohne zu wissen, ob sie dasselbe Ding oder zwei verschiedene Dinge bezeichnen? – Können wir einen Satz, worin zwei Namen vorkommen, verstehen, ohne zu wissen, ob sie Dasselbe oder Verschiedenes bedeuten? Kenne ich etwa die Bedeutung eines englischen und eines gleichbedeutenden deutschen Wortes, so ist es unmöglich, dass ich nicht weiß, dass die beiden gleichbedeutend sind; es ist unmöglich, dass ich sie nicht ineinander übersetzen kann. Ausdrücke wie „<span class=\\\"mathmode\\\"><var>a</var><span class=\\\"mathrel\\\">=</span><var>a</var></span>“, oder von diesen abgeleitete, sind weder Elementarsätze, noch sonst sinnvolle Zeichen. (Dies wird sich später zeigen.)\",\"pmc\":\"Can we understand two names without knowing whether they signify the same thing or two different things?—Can we understand a proposition in which two names occur without knowing whether their meaning is the same or different? Suppose I know the meaning of an English word and of a German word that means the same: then it is impossible for me to be unaware that they do mean the same; I must be capable of translating each into the other. Expressions like ‘<span class=\\\"mathmode\\\"><var>a</var><span class=\\\"mathrel\\\">=</span><var>a</var></span>’, and those derived from them, are neither elementary propositions nor is there any other way in which they have sense. (This will become evident later.)\",\"ogd\":\"Can we understand two names without knowing whether they signify the same thing or two different things? Can we understand a proposition in which two names occur, without knowing if they mean the same or different things? If I know the meaning of an English and a synonymous German word, it is impossible for me not to know that they are synonymous, it is impossible for me not to be able to translate them into one another. Expressions like “<span class=\\\"mathmode\\\"><var>a</var><span class=\\\"mathrel\\\">=</span><var>a</var></span>”, or expressions deduced from these are neither elementary propositions nor otherwise significant signs. (This will be shown later.)\",\"str\":\"\"},{\"label\":\"5.5\",\"precision\":1,\"fontSize\":\"40px\",\"y_axis\":47,\"x_axis\":75,\"ger\":\"Jede Wahrheitsfunktion ist ein Resultat der successiven Anwendung der Operation <span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">(−−−−−<span class=\\\"mathrm\\\">W</span>)</span> (<var>ξ</var>,&nbsp;.&nbsp;.&nbsp;.&nbsp;.&nbsp;.)</span> auf Elementarsätze. Diese Operation verneint sämtliche Sätze in der rechten Klammer, und ich nenne sie die Negation dieser Sätze.\",\"pmc\":\"Every truth-function is a result of successive applications to elementary propositions of the operation ‘<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">(−−−−−<span class=\\\"mathrm\\\">T</span>)</span></span> <span class=\\\"mathmode\\\">(<var>ξ</var>,&nbsp;.&nbsp;.&nbsp;.&nbsp;.&nbsp;.)</span>’. This operation negates all the propositions in the right-hand pair of brackets, and I call it the negation of those propositions.\",\"ogd\":\"Every truth-function is a result of the successive application of the operation <span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">(−−−−−<span class=\\\"mathrm\\\">T</span>)</span> (<var>ξ</var>,&nbsp;.&nbsp;.&nbsp;.&nbsp;.&nbsp;.)</span> to elementary propositions. This operation denies all the propositions in the right-hand bracket and I call it the negation of these propositions.\",\"str\":\"\"},{\"label\":\"5.501\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":47,\"x_axis\":77,\"ger\":\"Einen Klammerausdruck, dessen Glieder Sätze sind, deute ich – wenn die Reihenfolge der Glieder in der Klammer gleichgültig ist – durch ein Zeichen von der Form „<span class=\\\"mathmode\\\">(<span class=\\\"overlined\\\"><var>ξ</var></span>)</span>“ an. „<span class=\\\"mathmode\\\"><var>ξ</var></span>“ ist eine Variable, deren Werte die Glieder des Klammerausdruckes sind; und der Strich über der Variablen deutet an, dass sie ihre sämtlichen Werte in der Klammer vertritt. (Hat also <span class=\\\"mathmode\\\"><var>ξ</var></span> etwa die 3 Werte P, Q, R, so ist <span class=\\\"mathmode\\\">(<span class=\\\"overlined\\\"><var>ξ</var></span>)<span class=\\\"mathrel\\\">=</span>(<span class=\\\"mathrm\\\">P</span>, <span class=\\\"mathrm\\\">Q</span>, <span class=\\\"mathrm\\\">R</span>)</span>.) Die Werte der Variablen werden festgesetzt. Die Festsetzung ist die Beschreibung der Sätze, welche die Variable vertritt. Wie die Beschreibung der Glieder des Klammerausdruckes geschieht, ist unwesentlich. Wir <em class=\\\"germph\\\">können</em> drei Arten der Beschreibung unterscheiden: 1. Die direkte Aufzählung. In diesem Fall können wir statt der Variablen einfach ihre konstanten Werte setzen. 2. Die Angabe einer Funktion <span class=\\\"mathmode\\\"><var>fx</var></span>, deren Werte für alle Werte von <span class=\\\"mathmode\\\"><var>x</var></span> die zu beschreibenden Sätze sind. 3. Die Angabe eines formalen Gesetzes, nach welchem jene Sätze gebildet sind. In diesem Falle sind die Glieder des Klammerausdrucks sämtliche Glieder einer Formenreihe.\",\"pmc\":\"When a bracketed expression has propositions as its terms—and the order of the terms inside the brackets is indifferent—then I indicate it by a sign of the form ‘<span class=\\\"mathmode\\\">(<span class=\\\"overlined\\\"><var>ξ</var></span>)</span>’. ‘<span class=\\\"mathmode\\\"><var>ξ</var></span>’ is a variable whose values are terms of the bracketed expression and the bar over the variable indicates that it is the representative of all its values in the brackets. (E.g. if <span class=\\\"mathmode\\\"><var>ξ</var></span> has the three values P, Q, R, then <span class=\\\"mathmode\\\">(<span class=\\\"overlined\\\"><var>ξ</var></span>)<span class=\\\"mathrel\\\">=</span>(<span class=\\\"mathrm\\\">P</span>, <span class=\\\"mathrm\\\">Q</span>, <span class=\\\"mathrm\\\">R</span>)</span>. ) What the values of the variable are is something that is stipulated. The stipulation is a description of the propositions that have the variable as their representative. How the description of the terms of the bracketed expression is produced is not essential. We <em>can</em> distinguish three kinds of description: 1. direct enumeration, in which case we can simply substitute for the variable the constants that are its values; 2. giving a function <span class=\\\"mathmode\\\"><var>fx</var></span> whose values for all values of <span class=\\\"mathmode\\\"><var>x</var></span> are the propositions to be described; 3. giving a formal law that governs the construction of the propositions, in which case the bracketed expression has as its members all the terms of a series of forms.\",\"ogd\":\"An expression in brackets whose terms are propositions I indicate—if the order of the terms in the bracket is indifferent—by a sign of the form “<span class=\\\"mathmode\\\">(<span class=\\\"overlined\\\"><var>ξ</var></span>)</span>”. “<span class=\\\"mathmode\\\"><var>ξ</var></span>” is a variable whose values are the terms of the expression in brackets, and the line over the variable indicates that it stands for all its values in the bracket. (Thus if <span class=\\\"mathmode\\\"><var>ξ</var></span> has the 3 values P, Q, R, then <span class=\\\"mathmode\\\">(<span class=\\\"overlined\\\"><var>ξ</var></span>)<span class=\\\"mathrel\\\">=</span>(<span class=\\\"mathrm\\\">P</span>, <span class=\\\"mathrm\\\">Q</span>, <span class=\\\"mathrm\\\">R</span>)</span>.) The values of the variables must be determined. The determination is the description of the propositions which the variable stands for. How the description of the terms of the expression in brackets takes place is unessential. We may distinguish 3 kinds of description: 1. Direct enumeration. In this case we can place simply its constant values instead of the variable. 2. Giving a function <span class=\\\"mathmode\\\"><var>fx</var></span>, whose values for all values of <span class=\\\"mathmode\\\"><var>x</var></span> are the propositions to be described. 3. Giving a formal law, according to which those propositions are constructed. In this case the terms of the expression in brackets are all the terms of a formal series.\",\"str\":\"\"},{\"label\":\"5.502\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":47,\"x_axis\":79,\"ger\":\"Ich schreibe also statt „<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">(−−−−−<span class=\\\"mathrm\\\">W</span>)</span></span> <span class=\\\"mathmode\\\">(<var>ξ</var>,&nbsp;.&nbsp;.&nbsp;.&nbsp;.&nbsp;.)</span>“ „<span class=\\\"mathmode\\\"><span class=\\\"nop\\\">N</span>(<span class=\\\"overlined\\\"><var>ξ</var></span>)</span>“. <span class=\\\"mathmode\\\"><span class=\\\"nop\\\">N</span>(<span class=\\\"overlined\\\"><var>ξ</var></span>)</span> ist die Negation sämtlicher Werte der Satzvariablen <span class=\\\"mathmode\\\"><var>ξ</var></span>.\",\"pmc\":\"So instead of ‘<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">(−−−−−<span class=\\\"mathrm\\\">T</span>)</span></span> <span class=\\\"mathmode\\\">(<var>ξ</var>,&nbsp;.&nbsp;.&nbsp;.&nbsp;.&nbsp;.)</span>’, I write ‘<span class=\\\"mathmode\\\"><span class=\\\"nop\\\">N</span>(<span class=\\\"overlined\\\"><var>ξ</var></span>)</span>’. <span class=\\\"mathmode\\\"><span class=\\\"nop\\\">N</span>(<span class=\\\"overlined\\\"><var>ξ</var></span>)</span> is the negation of all the values of the propositional variable <span class=\\\"mathmode\\\"><var>ξ</var></span>.\",\"ogd\":\"Therefore I write instead of “<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">(−−−−−<span class=\\\"mathrm\\\">T</span>)</span></span> <span class=\\\"mathmode\\\">(<var>ξ</var>,&nbsp;.&nbsp;.&nbsp;.&nbsp;.&nbsp;.)</span>”, “<span class=\\\"mathmode\\\"><span class=\\\"nop\\\">N</span>(<span class=\\\"overlined\\\"><var>ξ</var></span>)</span>”. <span class=\\\"mathmode\\\"><span class=\\\"nop\\\">N</span>(<span class=\\\"overlined\\\"><var>ξ</var></span>)</span> is the negation of all the values of the propositional variable <span class=\\\"mathmode\\\"><var>ξ</var></span>.\",\"str\":\"\"},{\"label\":\"5.503\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":47,\"x_axis\":81,\"ger\":\"Da sich offenbar leicht ausdrücken lässt, wie mit dieser Operation Sätze gebildet werden können und wie Sätze mit ihr nicht zu bilden sind, so muss dies auch einen exakten Ausdruck finden können.\",\"pmc\":\"It is obvious that we can easily express how propositions may be constructed with this operation, and how they may not be constructed with it; so it must be possible to find an exact expression for this.\",\"ogd\":\"As it is obviously easy to express how propositions can be constructed by means of this operation and how propositions are not to be constructed by means of it, this must be capable of exact expression.\",\"str\":\"\"},{\"label\":\"6.375\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":47,\"x_axis\":125,\"ger\":\"Wie es nur eine <em class=\\\"germph\\\">logische</em> Notwendigkeit gibt, so gibt es auch nur eine <em class=\\\"germph\\\">logische</em> Unmöglichkeit.\",\"pmc\":\"Just as the only necessity that exists is <em>logical</em> necessity, so too the only impossibility that exists is <em>logical</em> impossibility.\",\"ogd\":\"As there is only a <em>logical</em> necessity, so there is only a <em>logical</em> impossibility.\",\"str\":\"\"},{\"label\":\"6.3751\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":47,\"x_axis\":127,\"ger\":\"Dass z. B. zwei Farben zugleich an einem Ort des Gesichtsfeldes sind, ist unmöglich, und zwar logisch unmöglich, denn es ist durch die logische Struktur der Farbe ausgeschlossen. Denken wir daran, wie sich dieser Widerspruch in der Physik darstellt: Ungefähr so, dass ein Teilchen nicht zu gleicher Zeit zwei Geschwindigkeiten haben kann; das heißt, dass es nicht zu gleicher Zeit an zwei Orten sein kann; das heißt, dass Teilchen an verschiedenen Orten zu Einer Zeit nicht identisch sein können. (Es ist klar, dass das logische Produkt zweier Elementarsätze weder eine Tautologie noch eine Kontradiktion sein kann. Die Aussage, dass ein Punkt des Gesichtsfeldes zu gleicher Zeit zwei verschiedene Farben hat, ist eine Kontradiktion.)\",\"pmc\":\"For example, the simultaneous presence of two colours at the same place in the visual field is impossible, in fact logically impossible, since it is ruled out by the logical structure of colour. Let us think how this contradiction appears in physics: more or less as follows—a particle cannot have two velocities at the same time; that is to say, it cannot be in two places at the same time; that is to say, particles that are in different places at the same time cannot be identical. (It is clear that the logical product of two elementary propositions can neither be a tautology nor a contradiction. The statement that a point in the visual field has two different colours at the same time is a contradiction.)\",\"ogd\":\"For two colours, <em>e.g.</em> to be at one place in the visual field, is impossible, logically impossible, for it is excluded by the logical structure of colour. Let us consider how this contradiction presents itself in physics. Somewhat as follows: That a particle cannot at the same time have two velocities, <em>i.e.</em> that at the same time it cannot be in two places, <em>i.e.</em> that particles in different places at the same time cannot be identical. It is clear that the logical product of two elementary propositions can neither be a tautology nor a contradiction. The assertion that a point in the visual field has two different colours at the same time, is a contradiction.\",\"str\":\"\"},{\"label\":\"3.5\",\"precision\":1,\"fontSize\":\"40px\",\"y_axis\":49,\"x_axis\":37,\"ger\":\"Das angewandte, gedachte Satzeichen ist der Gedanke.\",\"pmc\":\"A propositional sign, applied and thought out, is a thought.\",\"ogd\":\"The applied, thought, propositional sign, is the thought.\",\"str\":\"\"},{\"label\":\"3.411\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":49,\"x_axis\":39,\"ger\":\"Der geometrische und der logische Ort stimmen darin überein, dass beide die Möglichkeit einer Existenz sind.\",\"pmc\":\"In geometry and logic alike a place is a possibility: something can exist in it.\",\"ogd\":\"The geometrical and the logical place agree in that each is the possibility of an existence.\",\"str\":\"\"},{\"label\":\"4.3\",\"precision\":1,\"fontSize\":\"40px\",\"y_axis\":49,\"x_axis\":51,\"ger\":\"Die Wahrheitsmöglichkeiten der Elementarsätze bedeuten die Möglichkeiten des Bestehens und Nichtbestehens der Sachverhalte.\",\"pmc\":\"Truth-possibilities of elementary propositions mean possibilities of existence and non-existence of states of affairs.\",\"ogd\":\"The truth-possibilities of the elementary propositions mean the possibilities of the existence and non-existence of the atomic facts.\",\"str\":\"\"},{\"label\":\"4.31\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":49,\"x_axis\":53,\"ger\":\"Die Wahrheitsmöglichkeiten können wir durch Schemata folgender Art darstellen („W“ bedeutet „wahr“, „F“, „falsch“. Die Reihen der „W“ und „F“ unter der Reihe der Elementarsätze bedeuten in leichtverständlicher Symbolik deren Wahrheitsmöglichkeiten): <div class=\\\"centered\\\"><table class=\\\"truthtable\\\"><tr><th class=\\\"l\\\"><span class=\\\"mathmode\\\"><var>p</var></span></th><th class=\\\"m\\\"><span class=\\\"mathmode\\\"><var>q</var></span></th><th class=\\\"e\\\"><span class=\\\"mathmode\\\"><var>r</var></span></th></tr><tr><td class=\\\"l\\\">W</td><td class=\\\"m\\\">W</td><td class=\\\"e\\\">W</td></tr><tr><td class=\\\"l\\\">F</td><td class=\\\"m\\\">W</td><td class=\\\"e\\\">W</td></tr><tr><td class=\\\"l\\\">W</td><td class=\\\"m\\\">F</td><td class=\\\"e\\\">W</td></tr><tr><td class=\\\"l\\\">W</td><td class=\\\"m\\\">W</td><td class=\\\"e\\\">F</td></tr><tr><td class=\\\"l\\\">F</td><td class=\\\"m\\\">F</td><td class=\\\"e\\\">W</td></tr><tr><td class=\\\"l\\\">F</td><td class=\\\"m\\\">W</td><td class=\\\"e\\\">F</td></tr><tr><td class=\\\"l\\\">W</td><td class=\\\"m\\\">F</td><td class=\\\"e\\\">F</td></tr><tr><td class=\\\"l\\\">F</td><td class=\\\"m\\\">F</td><td class=\\\"e\\\">F</td></tr></table><span class=\\\"padrthree\\\"></span><table class=\\\"truthtable\\\"><tr><th class=\\\"l\\\"><span class=\\\"mathmode\\\"><var>p</var></span></th><th class=\\\"e\\\"><span class=\\\"mathmode\\\"><var>q</var></span></th></tr><tr><td class=\\\"l\\\">W</td><td class=\\\"e\\\">W</td></tr><tr><td class=\\\"l\\\">F</td><td class=\\\"e\\\">W</td></tr><tr><td class=\\\"l\\\">W</td><td class=\\\"e\\\">F</td></tr><tr><td class=\\\"l\\\">F</td><td class=\\\"e\\\">F</td></tr></table><span class=\\\"padrthree\\\"></span><table class=\\\"truthtable\\\"><tr><th class=\\\"e\\\"><span class=\\\"mathmode\\\"><var>p</var></span></th></tr><tr><td class=\\\"e\\\">W</td></tr><tr><td class=\\\"e\\\">F</td></tr></table></div>\",\"pmc\":\"We can represent truth-possibilities by schemata of the following kind (‘T’ means ‘true’, ‘F’ means ‘false’; the rows of ‘T’s’ and ‘F’s’ under the row of elementary propositions symbolize their truth-possibilities in a way that can easily be understood): <div class=\\\"centered\\\"><table class=\\\"truthtable\\\"><tr><th class=\\\"l\\\"><span class=\\\"mathmode\\\"><var>p</var></span></th><th class=\\\"m\\\"><span class=\\\"mathmode\\\"><var>q</var></span></th><th class=\\\"e\\\"><span class=\\\"mathmode\\\"><var>r</var></span></th></tr><tr><td class=\\\"l\\\">T</td><td class=\\\"m\\\">T</td><td class=\\\"e\\\">T</td></tr><tr><td class=\\\"l\\\">F</td><td class=\\\"m\\\">T</td><td class=\\\"e\\\">T</td></tr><tr><td class=\\\"l\\\">T</td><td class=\\\"m\\\">F</td><td class=\\\"e\\\">T</td></tr><tr><td class=\\\"l\\\">T</td><td class=\\\"m\\\">T</td><td class=\\\"e\\\">F</td></tr><tr><td class=\\\"l\\\">F</td><td class=\\\"m\\\">F</td><td class=\\\"e\\\">T</td></tr><tr><td class=\\\"l\\\">F</td><td class=\\\"m\\\">T</td><td class=\\\"e\\\">F</td></tr><tr><td class=\\\"l\\\">T</td><td class=\\\"m\\\">F</td><td class=\\\"e\\\">F</td></tr><tr><td class=\\\"l\\\">F</td><td class=\\\"m\\\">F</td><td class=\\\"e\\\">F</td></tr></table><span class=\\\"padrthree\\\"></span><table class=\\\"truthtable\\\"><tr><th class=\\\"l\\\"><span class=\\\"mathmode\\\"><var>p</var></span></th><th class=\\\"e\\\"><span class=\\\"mathmode\\\"><var>q</var></span></th></tr><tr><td class=\\\"l\\\">T</td><td class=\\\"e\\\">T</td></tr><tr><td class=\\\"l\\\">F</td><td class=\\\"e\\\">T</td></tr><tr><td class=\\\"l\\\">T</td><td class=\\\"e\\\">F</td></tr><tr><td class=\\\"l\\\">F</td><td class=\\\"e\\\">F</td></tr></table><span class=\\\"padrthree\\\"></span><table class=\\\"truthtable\\\"><tr><th class=\\\"e\\\"><span class=\\\"mathmode\\\"><var>p</var></span></th></tr><tr><td class=\\\"e\\\">T</td></tr><tr><td class=\\\"e\\\">F</td></tr></table></div>\",\"ogd\":\"The truth-possibilities can be presented by schemata of the following kind (“T” means “true”, “F” “false”. The rows of T’s and F’s under the row of the elementary propositions mean their truth-possibilities in an easily intelligible symbolism). <div class=\\\"centered\\\"><table class=\\\"truthtable\\\"><tr><th class=\\\"l\\\"><span class=\\\"mathmode\\\"><var>p</var></span></th><th class=\\\"m\\\"><span class=\\\"mathmode\\\"><var>q</var></span></th><th class=\\\"e\\\"><span class=\\\"mathmode\\\"><var>r</var></span></th></tr><tr><td class=\\\"l\\\">T</td><td class=\\\"m\\\">T</td><td class=\\\"e\\\">T</td></tr><tr><td class=\\\"l\\\">F</td><td class=\\\"m\\\">T</td><td class=\\\"e\\\">T</td></tr><tr><td class=\\\"l\\\">T</td><td class=\\\"m\\\">F</td><td class=\\\"e\\\">T</td></tr><tr><td class=\\\"l\\\">T</td><td class=\\\"m\\\">T</td><td class=\\\"e\\\">F</td></tr><tr><td class=\\\"l\\\">F</td><td class=\\\"m\\\">F</td><td class=\\\"e\\\">T</td></tr><tr><td class=\\\"l\\\">F</td><td class=\\\"m\\\">T</td><td class=\\\"e\\\">F</td></tr><tr><td class=\\\"l\\\">T</td><td class=\\\"m\\\">F</td><td class=\\\"e\\\">F</td></tr><tr><td class=\\\"l\\\">F</td><td class=\\\"m\\\">F</td><td class=\\\"e\\\">F</td></tr></table><span class=\\\"padrthree\\\"></span><table class=\\\"truthtable\\\"><tr><th class=\\\"l\\\"><span class=\\\"mathmode\\\"><var>p</var></span></th><th class=\\\"e\\\"><span class=\\\"mathmode\\\"><var>q</var></span></th></tr><tr><td class=\\\"l\\\">T</td><td class=\\\"e\\\">T</td></tr><tr><td class=\\\"l\\\">F</td><td class=\\\"e\\\">T</td></tr><tr><td class=\\\"l\\\">T</td><td class=\\\"e\\\">F</td></tr><tr><td class=\\\"l\\\">F</td><td class=\\\"e\\\">F</td></tr></table><span class=\\\"padrthree\\\"></span><table class=\\\"truthtable\\\"><tr><th class=\\\"e\\\"><span class=\\\"mathmode\\\"><var>p</var></span></th></tr><tr><td class=\\\"e\\\">T</td></tr><tr><td class=\\\"e\\\">F</td></tr></table></div>\",\"str\":\"\"},{\"label\":\"5.51\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":49,\"x_axis\":77,\"ger\":\"Hat <span class=\\\"mathmode\\\"><var>ξ</var></span> nur einen Wert, so ist <span class=\\\"mathmode\\\"><span class=\\\"nop\\\">N</span>(<span class=\\\"overlined\\\"><var>ξ</var></span>)<span class=\\\"mathrel\\\">=</span><span class=\\\"mathop\\\">~</span><var>p</var></span> (nicht <span class=\\\"mathmode\\\"><var>p</var></span>), hat es zwei Werte, so ist <span class=\\\"mathmode\\\"><span class=\\\"nop\\\">N</span> (<span class=\\\"overlined\\\"><var>ξ</var></span>)<span class=\\\"mathrel\\\">=</span><span class=\\\"mathop\\\">~</span><var>p</var><span class=\\\"mathrel\\\">.</span><span class=\\\"mathop\\\">~</span><var>q</var></span> (weder <span class=\\\"mathmode\\\"><var>p</var></span> noch <span class=\\\"mathmode\\\"><var>q</var></span>).\",\"pmc\":\"If <span class=\\\"mathmode\\\"><var>ξ</var></span> has only one value, then <span class=\\\"mathmode\\\"><span class=\\\"nop\\\">N</span>(<span class=\\\"overlined\\\"><var>ξ</var></span>)<span class=\\\"mathrel\\\">=</span><span class=\\\"mathop\\\">~</span><var>p</var></span> (not <span class=\\\"mathmode\\\"><var>p</var></span>); if it has two values, then <span class=\\\"mathmode\\\"><span class=\\\"nop\\\">N</span> (<span class=\\\"overlined\\\"><var>ξ</var></span>)<span class=\\\"mathrel\\\">=</span><span class=\\\"mathop\\\">~</span><var>p</var><span class=\\\"mathrel\\\">.</span><span class=\\\"mathop\\\">~</span><var>q</var></span> (neither <span class=\\\"mathmode\\\"><var>p</var></span> nor <span class=\\\"mathmode\\\"><var>q</var></span>).\",\"ogd\":\"If <span class=\\\"mathmode\\\"><var>ξ</var></span> has only one value, then <span class=\\\"mathmode\\\"><span class=\\\"nop\\\">N</span>(<span class=\\\"overlined\\\"><var>ξ</var></span>)<span class=\\\"mathrel\\\">=</span><span class=\\\"mathop\\\">~</span><var>p</var></span> (not <span class=\\\"mathmode\\\"><var>p</var></span>), if it has two values then <span class=\\\"mathmode\\\"><span class=\\\"nop\\\">N</span> (<span class=\\\"overlined\\\"><var>ξ</var></span>)<span class=\\\"mathrel\\\">=</span><span class=\\\"mathop\\\">~</span><var>p</var><span class=\\\"mathrel\\\">.</span><span class=\\\"mathop\\\">~</span><var>q</var></span> (neither <span class=\\\"mathmode\\\"><var>p</var></span> nor <span class=\\\"mathmode\\\"><var>q</var></span>).\",\"str\":\"\"},{\"label\":\"5.52\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":49,\"x_axis\":81,\"ger\":\"Sind die Werte von <span class=\\\"mathmode\\\"><var>ξ</var></span> sämtliche Werte einer Funktion <span class=\\\"mathmode\\\"><var>fx</var></span> für alle Werte von <span class=\\\"mathmode\\\"><var>x</var></span>, so wird <span class=\\\"mathmode\\\"><span class=\\\"nop\\\">N</span>(<span class=\\\"overlined\\\"><var>ξ</var></span>)<span class=\\\"mathrel\\\">=</span><span class=\\\"mathop\\\">~</span><span class=\\\"quant\\\">(<span class=\\\"symbol\\\">∃</span><var>x</var>).</span><var>fx</var></span>.\",\"pmc\":\"If <span class=\\\"mathmode\\\"><var>ξ</var></span> has as its values all the values of a function <span class=\\\"mathmode\\\"><var>fx</var></span> for all values of <span class=\\\"mathmode\\\"><var>x</var></span>, then <span class=\\\"mathmode\\\"><span class=\\\"nop\\\">N</span>(<span class=\\\"overlined\\\"><var>ξ</var></span>)<span class=\\\"mathrel\\\">=</span><span class=\\\"mathop\\\">~</span><span class=\\\"quant\\\">(<span class=\\\"symbol\\\">∃</span><var>x</var>).</span><var>fx</var></span>.\",\"ogd\":\"If the values of <span class=\\\"mathmode\\\"><var>ξ</var></span> are the total values of a function <span class=\\\"mathmode\\\"><var>fx</var></span> for all values of <span class=\\\"mathmode\\\"><var>x</var></span>, then <span class=\\\"mathmode\\\"><span class=\\\"nop\\\">N</span>(<span class=\\\"overlined\\\"><var>ξ</var></span>)<span class=\\\"mathrel\\\">=</span><span class=\\\"mathop\\\">~</span><span class=\\\"quant\\\">(<span class=\\\"symbol\\\">∃</span><var>x</var>).</span><var>fx</var></span>.\",\"str\":\"\"},{\"label\":\"5.53\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":49,\"x_axis\":83,\"ger\":\"Gleichheit des Gegenstandes drücke ich durch Gleichheit des Zeichens aus, und nicht mit Hilfe eines Gleichheitszeichens. Verschiedenheit der Gegenstände durch Verschiedenheit der Zeichen.\",\"pmc\":\"Identity of object I express by identity of sign, and not by using a sign for identity. Difference of objects I express by difference of signs.\",\"ogd\":\"Identity of the object I express by identity of the sign and not by means of a sign of identity. Difference of the objects by difference of the signs.\",\"str\":\"\"},{\"label\":\"5.54\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":49,\"x_axis\":91,\"ger\":\"In der allgemeinen Satzform kommt der Satz im Satze nur als Basis der Wahrheitsoperationen vor.\",\"pmc\":\"In the general propositional form propositions occur in other propositions only as bases of truth-operations.\",\"ogd\":\"In the general propositional form, propositions occur in a proposition only as bases of the truth-operations.\",\"str\":\"\"},{\"label\":\"5.55\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":49,\"x_axis\":99,\"ger\":\"Wir müssen nun die Frage nach allen möglichen Formen der Elementarsätze a priori beantworten. Der Elementarsatz besteht aus Namen. Da wir aber die Anzahl der Namen von verschiedener Bedeutung nicht angeben können, so können wir auch nicht die Zusammensetzung des Elementarsatzes angeben.\",\"pmc\":\"We now have to answer <em>a priori</em> the question about all the possible forms of elementary propositions. Elementary propositions consist of names. Since, however, we are unable to give the number of names with different meanings, we are also unable to give the composition of elementary propositions.\",\"ogd\":\"We must now answer a priori the question as to all possible forms of the elementary propositions. The elementary proposition consists of names. Since we cannot give the number of names with different meanings, we cannot give the composition of the elementary proposition.\",\"str\":\"\"},{\"label\":\"6.4\",\"precision\":1,\"fontSize\":\"40px\",\"y_axis\":49,\"x_axis\":107,\"ger\":\"Alle Sätze sind gleichwertig.\",\"pmc\":\"All propositions are of equal value.\",\"ogd\":\"All propositions are of equal value.\",\"str\":\"\"},{\"label\":\"6.41\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":49,\"x_axis\":109,\"ger\":\"Der Sinn der Welt muss außerhalb ihrer liegen. In der Welt ist alles, wie es ist, und geschieht alles, wie es geschieht; es gibt <em class=\\\"germph\\\">in</em> ihr keinen Wert – und wenn es ihn gäbe, so hätte er keinen Wert. Wenn es einen Wert gibt, der Wert hat, so muss er außerhalb alles Geschehens und So-Seins liegen. Denn alles Geschehen und So-Sein ist zufällig. Was es nichtzufällig macht, kann nicht <em class=\\\"germph\\\">in</em> der Welt liegen, denn sonst wäre dies wieder zufällig. Es muss außerhalb der Welt liegen.\",\"pmc\":\"The sense of the world must lie outside the world. In the world everything is as it is, and everything happens as it does happen: <em>in</em> it no value exists—and if it did exist, it would have no value. If there is any value that does have value, it must lie outside the whole sphere of what happens and is the case. For all that happens and is the case is accidental. What makes it non-accidental cannot lie <em>within</em> the world, since if it did it would itself be accidental. It must lie outside the world.\",\"ogd\":\"The sense of the world must lie outside the world. In the world everything is as it is and happens as it does happen. <em>In</em> it there is no value—and if there were, it would be of no value. If there is a value which is of value, it must lie outside all happening and being-so. For all happening and being-so is accidental. What makes it non-accidental cannot lie <em>in</em> the world, for otherwise this would again be accidental. It must lie outside the world.\",\"str\":\"\"},{\"label\":\"6.42\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":49,\"x_axis\":111,\"ger\":\"Darum kann es auch keine Sätze der Ethik geben. Sätze können nichts Höheres ausdrücken.\",\"pmc\":\"So too it is impossible for there to be propositions of ethics. Propositions can express nothing that is higher.\",\"ogd\":\"Hence also there can be no ethical propositions. Propositions cannot express anything higher.\",\"str\":\"\"},{\"label\":\"6.43\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":49,\"x_axis\":113,\"ger\":\"Wenn das gute oder böse Wollen die Welt ändert, so kann es nur die Grenzen der Welt ändern, nicht die Tatsachen; nicht das, was durch die Sprache ausgedrückt werden kann. Kurz, die Welt muss dann dadurch überhaupt eine andere werden. Sie muss sozusagen als Ganzes abnehmen oder zunehmen. Die Welt des Glücklichen ist eine andere als die des Unglücklichen.\",\"pmc\":\"If the good or bad exercise of the will does alter the world, it can alter only the limits of the world, not the facts—not what can be expressed by means of language. In short the effect must be that it becomes an altogether different world. It must, so to speak, wax and wane as a whole. The world of the happy man is a different one from that of the unhappy man.\",\"ogd\":\"If good or bad willing changes the world, it can only change the limits of the world, not the facts; not the things that can be expressed in language. In brief, the world must thereby become quite another, it must so to speak wax or wane as a whole. The world of the happy is quite another than that of the unhappy.\",\"str\":\"\"},{\"label\":\"6.44\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":49,\"x_axis\":115,\"ger\":\"Nicht <em class=\\\"germph\\\">wie</em> die Welt ist, ist das Mystische, sondern <em class=\\\"germph\\\">dass</em> sie ist.\",\"pmc\":\"It is not <em>how</em> things are in the world that is mystical, but <em>that</em> it exists.\",\"ogd\":\"Not <em>how</em> the world is, is the mystical, but <em>that</em> it is.\",\"str\":\"\"},{\"label\":\"6.45\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":49,\"x_axis\":117,\"ger\":\"Die Anschauung der Welt sub specie aeterni ist ihre Anschauung als – begrenztes – Ganzes. Das Gefühl der Welt als begrenztes Ganzes ist das mystische.\",\"pmc\":\"To view the world sub specie aeterni is to view it as a whole—a limited whole. Feeling the world as a limited whole—it is this that is mystical.\",\"ogd\":\"The contemplation of the world <em>sub specie aeterni</em> is its contemplation as a limited whole. The feeling that the world is a limited whole is the mystical feeling.\",\"str\":\"\"},{\"label\":\"4.4\",\"precision\":1,\"fontSize\":\"40px\",\"y_axis\":51,\"x_axis\":51,\"ger\":\"Der Satz ist der Ausdruck der Übereinstimmung und Nichtübereinstimmung mit den Wahrheitsmöglichkeiten der Elementarsätze.\",\"pmc\":\"A proposition is an expression of agreement and disagreement with truth-possibilities of elementary propositions.\",\"ogd\":\"A proposition is the expression of agreement and disagreement with the truth-possibilities of the elementary propositions.\",\"str\":\"\"},{\"label\":\"4.41\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":51,\"x_axis\":53,\"ger\":\"Die Wahrheitsmöglichkeiten der Elementarsätze sind die Bedingungen der Wahrheit und Falschheit der Sätze.\",\"pmc\":\"Truth-possibilities of elementary propositions are the conditions of the truth and falsity of propositions.\",\"ogd\":\"The truth-possibilities of the elementary propositions are the conditions of the truth and falsehood of the propositions.\",\"str\":\"\"},{\"label\":\"4.42\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":51,\"x_axis\":55,\"ger\":\"Bezüglich der Übereinstimmung und Nichtübereinstimmung eines Satzes mit den Wahrheitsmöglichkeiten von <span class=\\\"mathmode\\\"><var>n</var></span> Elementarsätzen gibt es <table class=\\\"possibilities\\\"><tr><td class=\\\"summationtop\\\"><span class=\\\"mathmode\\\"><span class=\\\"smallvar\\\">K<sub><var>n</var></sub></span></span></td><td class=\\\"middleright\\\" rowspan=\\\"3\\\"><span class=\\\"largeparen\\\">(</span></td><td class=\\\"middlecenter\\\" rowspan=\\\"3\\\"><span class=\\\"mathode\\\">K<sub><var>n</var></sub></span><br /><span class=\\\"mathmode\\\"><var>κ</var></span></td><td class=\\\"middleright\\\" rowspan=\\\"3\\\"><span class=\\\"mathomde\\\"><span class=\\\"largeparen\\\">)</span> = L<sub><var>n</var></sub></span></td></tr><tr><td class=\\\"summationmiddle\\\"><span class=\\\"mathmode\\\"><span class=\\\"largeop\\\">∑</span></span></td></tr><tr><td class=\\\"summationmiddle\\\"><span class=\\\"mathmode\\\"><span class=\\\"smallvar\\\"><var>κ</var> = 0</span></span></td></tr></table> Möglichkeiten.\",\"pmc\":\"For <span class=\\\"mathmode\\\"><var>n</var></span> elementary propositions there are <table class=\\\"possibilities\\\"><tr><td class=\\\"summationtop\\\"><span class=\\\"mathmode\\\"><span class=\\\"smallvar\\\">K<sub><var>n</var></sub></span></span></td><td class=\\\"middleright\\\" rowspan=\\\"3\\\"><span class=\\\"largeparen\\\">(</span></td><td class=\\\"middlecenter\\\" rowspan=\\\"3\\\"><span class=\\\"mathode\\\">K<sub><var>n</var></sub></span><br /><span class=\\\"mathmode\\\"><var>κ</var></span></td><td class=\\\"middleright\\\" rowspan=\\\"3\\\"><span class=\\\"mathomde\\\"><span class=\\\"largeparen\\\">)</span> = L<sub><var>n</var></sub></span></td></tr><tr><td class=\\\"summationmiddle\\\"><span class=\\\"mathmode\\\"><span class=\\\"largeop\\\">∑</span></span></td></tr><tr><td class=\\\"summationmiddle\\\"><span class=\\\"mathmode\\\"><span class=\\\"smallvar\\\"><var>κ</var> = 0</span></span></td></tr></table>  ways in which a proposition can agree and disagree with their truth possibilities.\",\"ogd\":\"With regard to the agreement and disagreement of a proposition with the truth-possibilities of <span class=\\\"mathmode\\\"><var>n</var></span> elementary propositions there are <table class=\\\"possibilities\\\"><tr><td class=\\\"summationtop\\\"><span class=\\\"mathmode\\\"><span class=\\\"smallvar\\\">K<sub><var>n</var></sub></span></span></td><td class=\\\"middleright\\\" rowspan=\\\"3\\\"><span class=\\\"largeparen\\\">(</span></td><td class=\\\"middlecenter\\\" rowspan=\\\"3\\\"><span class=\\\"mathode\\\">K<sub><var>n</var></sub></span><br /><span class=\\\"mathmode\\\"><var>κ</var></span></td><td class=\\\"middleright\\\" rowspan=\\\"3\\\"><span class=\\\"mathomde\\\"><span class=\\\"largeparen\\\">)</span> = L<sub><var>n</var></sub></span></td></tr><tr><td class=\\\"summationmiddle\\\"><span class=\\\"mathmode\\\"><span class=\\\"largeop\\\">∑</span></span></td></tr><tr><td class=\\\"summationmiddle\\\"><span class=\\\"mathmode\\\"><span class=\\\"smallvar\\\"><var>κ</var> = 0</span></span></td></tr></table>  possibilities.\",\"str\":\"\"},{\"label\":\"4.43\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":51,\"x_axis\":57,\"ger\":\"Die Übereinstimmung mit den Wahrheitsmöglichkeiten können wir dadurch ausdrücken, indem wir ihnen im Schema etwa das Abzeichen „W“ (wahr) zuordnen. Das Fehlen dieses Abzeichens bedeutet die Nichtübereinstimmung.\",\"pmc\":\"We can express agreement with truth-possibilities by correlating the mark ‘T’ (true) with them in the schema. The absence of this mark means disagreement.\",\"ogd\":\"Agreement with the truth-possibilities can be expressed by co-ordinating with them in the schema the mark “T” (true). Absence of this mark means disagreement.\",\"str\":\"\"},{\"label\":\"4.44\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":51,\"x_axis\":59,\"ger\":\"Das Zeichen, welches durch die Zuordnung jener Abzeichen „W“ und der Wahrheitsmöglichkeiten entsteht, ist ein Satzzeichen.\",\"pmc\":\"The sign that results from correlating the mark ‘T’ with truth-possibilities is a propositional sign.\",\"ogd\":\"The sign which arises from the co-ordination of that mark “T” with the truth-possibilities is a propositional sign.\",\"str\":\"\"},{\"label\":\"4.45\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":51,\"x_axis\":61,\"ger\":\"Für <span class=\\\"mathmode\\\"><var>n</var></span> Elementarsätze gibt es <span class=\\\"mathmode\\\"><span class=\\\"mathrm\\\">L</span><sub><var>n</var></sub></span> mögliche Gruppen von Wahrheitsbedingungen. Die Gruppen von Wahrheitsbedingungen, welche zu den Wahrheitsmöglichkeiten einer Anzahl von Elementarsätzen gehören, lassen sich in eine Reihe ordnen.\",\"pmc\":\"For <span class=\\\"mathmode\\\"><var>n</var></span> elementary propositions there are <span class=\\\"mathmode\\\"><span class=\\\"mathrm\\\">L</span><sub><var>n</var></sub></span> possible groups of truth-conditions. The groups of truth-conditions that are obtainable from the truth-possibilities of a given number of elementary propositions can be arranged in a series.\",\"ogd\":\"For <span class=\\\"mathmode\\\"><var>n</var></span> elementary propositions there are <span class=\\\"mathmode\\\"><span class=\\\"mathrm\\\">L</span><sub><var>n</var></sub></span> possible groups of truth-conditions. The groups of truth-conditions which belong to the truth-possibilities of a number of elementary propositions can be ordered in a series.\",\"str\":\"\"},{\"label\":\"4.46\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":51,\"x_axis\":63,\"ger\":\"Unter den möglichen Gruppen von Wahrheitsbedingungen gibt es zwei extreme Fälle. In dem einen Fall ist der Satz für sämtliche Wahrheitsmöglichkeiten der Elementarsätze wahr. Wir sagen, die Wahrheitsbedingungen sind <em class=\\\"germph\\\">tautologisch</em>. Im zweiten Fall ist der Satz für sämtliche Wahrheitsmöglichkeiten falsch: Die Wahrheitsbedingungen sind <em class=\\\"germph\\\">kontradiktorisch</em>. Im ersten Fall nennen wir den Satz eine Tautologie, im zweiten Fall eine Kontradiktion.\",\"pmc\":\"Among the possible groups of truth-conditions there are two extreme cases. In one of these cases the proposition is true for all the truth-possibilities of the elementary propositions. We say that the truth-conditions are <em>tautological</em>. In the second case the proposition is false for all the truth-possibilities: the truth-conditions are <em>contradictory</em>. In the first case we call the proposition a tautology; in the second, a contradiction.\",\"ogd\":\"Among the possible groups of truth-conditions there are two extreme cases. In the one case the proposition is true for all the truth-possibilities of the elementary propositions. We say that the truth-conditions are <em>tautological</em>. In the second case the proposition is false for all the truth-possibilities. The truth-conditions are <em>self-contradictory</em>. In the first case we call the proposition a tautology, in the second case a contradiction.\",\"str\":\"\"},{\"label\":\"5.511\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":51,\"x_axis\":77,\"ger\":\"Wie kann die allumfassende, weltspiegelnde Logik so spezielle Haken und Manipulationen gebrauchen? Nur, indem sich alle diese zu einem unendlich feinen Netzwerk, zu dem großen Spiegel, verknüpfen.\",\"pmc\":\"How can logic—all-embracing logic, which mirrors the world—use such peculiar crotchets and contrivances? Only because they are all connected with one another in an infinitely fine network, the great mirror.\",\"ogd\":\"How can the all-embracing logic which mirrors the world use such special catches and manipulations? Only because all these are connected into an infinitely fine network, to the great mirror.\",\"str\":\"\"},{\"label\":\"5.521\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":51,\"x_axis\":81,\"ger\":\"Ich trenne den Begriff <em class=\\\"germph\\\">Alle</em> von der Wahrheitsfunktion. Frege und Russell haben die Allgemeinheit in Verbindung mit dem logischen Produkt oder der logischen Summe eingeführt. So wurde es schwer, die Sätze „<span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<span class=\\\"symbol\\\">∃</span><var>x</var>).</span><var>fx</var></span>“ und „<span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<var>x</var>).</span><var>fx</var></span>“, in welchen beide Ideen beschlossen liegen, zu verstehen.\",\"pmc\":\"I dissociate the concept <em>all</em> from truth-functions. Frege and Russell introduced generality in association with logical product or logical sum. This made it difficult to understand the propositions ‘<span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<span class=\\\"symbol\\\">∃</span><var>x</var>).</span><var>fx</var></span>’ and ‘<span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<var>x</var>).</span><var>fx</var></span>’, in which both ideas are embedded.\",\"ogd\":\"I separate the concept <em>all</em> from the truth-function. Frege and Russell have introduced generality in connexion with the logical product or the logical sum. Then it would be difficult to understand the propositions “<span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<span class=\\\"symbol\\\">∃</span><var>x</var>).</span><var>fx</var></span>” and “<span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<var>x</var>).</span><var>fx</var></span>” in which both ideas lie concealed.\",\"str\":\"\"},{\"label\":\"5.5301\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":51,\"x_axis\":83,\"ger\":\"Dass die Identität keine Relation zwischen Gegenständen ist, leuchtet ein. Dies wird sehr klar, wenn man z. B. den Satz „<span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<var>x</var>):</span><var>fx</var><span class=\\\"mathrel\\\">.<span class=\\\"symbol\\\">⊃</span>.</span><var>x</var><span class=\\\"mathrel\\\">=</span><var>a</var></span>“ betrachtet. Was dieser Satz sagt, ist einfach, dass <em class=\\\"germph\\\">nur</em> <span class=\\\"mathmode\\\"><var>a</var></span> der Funktion <span class=\\\"mathmode\\\"><var>f</var></span> genügt, und nicht, dass nur solche Dinge der Funktion <span class=\\\"mathmode\\\"><var>f</var></span> genügen, welche eine gewisse Beziehung zu <span class=\\\"mathmode\\\"><var>a</var></span> haben. Man könnte nun freilich sagen, dass eben <em class=\\\"germph\\\">nur</em> <span class=\\\"mathmode\\\"><var>a</var></span> diese Beziehung zu <span class=\\\"mathmode\\\"><var>a</var></span> habe, aber, um dies auszudrücken, brauchten wir das Gleichheitszeichen selber.\",\"pmc\":\"It is self-evident that identity is not a relation between objects. This becomes very clear if one considers, for example, the proposition ‘<span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<var>x</var>):</span><var>fx</var><span class=\\\"mathrel\\\">.<span class=\\\"symbol\\\">⊃</span>.</span><var>x</var><span class=\\\"mathrel\\\">=</span><var>a</var></span>’. What this proposition says is simply that <em>only</em> <span class=\\\"mathmode\\\"><var>a</var></span> satisfies the function <span class=\\\"mathmode\\\"><var>f</var></span>, and not that only things that have a certain relation to <span class=\\\"mathmode\\\"><var>a</var></span> satisfy the function <span class=\\\"mathmode\\\"><var>f</var></span>. Of course, it might then be said that <em>only</em> <span class=\\\"mathmode\\\"><var>a</var></span> did have this relation to <span class=\\\"mathmode\\\"><var>a</var></span>; but in order to express that, we should need the identity-sign itself.\",\"ogd\":\"That identity is not a relation between objects is obvious. This becomes very clear if, for example, one considers the proposition “<span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<var>x</var>):</span><var>fx</var><span class=\\\"mathrel\\\">.<span class=\\\"symbol\\\">⊃</span>.</span><var>x</var><span class=\\\"mathrel\\\">=</span><var>a</var></span>”. What this proposition says is simply that <em>only</em> <span class=\\\"mathmode\\\"><var>a</var></span> satisfies the function <span class=\\\"mathmode\\\"><var>f</var></span>, and not that only such things satisfy the function <span class=\\\"mathmode\\\"><var>f</var></span> which have a certain relation to <span class=\\\"mathmode\\\"><var>a</var></span>. One could of course say that in fact <em>only</em> <span class=\\\"mathmode\\\"><var>a</var></span> has this relation to <span class=\\\"mathmode\\\"><var>a</var></span>, but in order to express this we should need the sign of identity itself.\",\"str\":\"\"},{\"label\":\"5.531\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":51,\"x_axis\":85,\"ger\":\"Ich schreibe also nicht „<span class=\\\"mathmode\\\"><var>f</var>(<var>a</var>,<var>b</var>)<span class=\\\"mathrel\\\">.</span><var>a</var><span class=\\\"mathrel\\\">=</span><var>b</var></span>“, sondern „<span class=\\\"mathmode\\\"><var>f</var>(<var>a</var>,<var>a</var>)</span>“ (oder „<span class=\\\"mathmode\\\"><var>f</var>(<var>b</var>,<var>b</var>)</span>“). Und nicht „<span class=\\\"mathmode\\\"><var>f</var>(<var>a</var>,<var>b</var>)<span class=\\\"mathrel\\\">.</span><span class=\\\"mathop\\\">~</span><var>a</var><span class=\\\"mathrel\\\">=</span><var>b</var></span>“, sondern „<span class=\\\"mathmode\\\"><var>f</var>(<var>a</var>,<var>b</var>)</span>“.\",\"pmc\":\"Thus I do not write ‘<span class=\\\"mathmode\\\"><var>f</var>(<var>a</var>,<var>b</var>)<span class=\\\"mathrel\\\">.</span><var>a</var><span class=\\\"mathrel\\\">=</span><var>b</var></span>’, but ‘<span class=\\\"mathmode\\\"><var>f</var>(<var>a</var>,<var>a</var>)</span>’ (or ‘<span class=\\\"mathmode\\\"><var>f</var>(<var>b</var>,<var>b</var>)</span>’); and not ‘<span class=\\\"mathmode\\\"><var>f</var>(<var>a</var>,<var>b</var>)<span class=\\\"mathrel\\\">.</span><span class=\\\"mathop\\\">~</span><var>a</var><span class=\\\"mathrel\\\">=</span><var>b</var></span>’, but ‘<span class=\\\"mathmode\\\"><var>f</var>(<var>a</var>,<var>b</var>)</span>’.\",\"ogd\":\"I write therefore not “<span class=\\\"mathmode\\\"><var>f</var>(<var>a</var>,<var>b</var>)<span class=\\\"mathrel\\\">.</span><var>a</var><span class=\\\"mathrel\\\">=</span><var>b</var></span>” but “<span class=\\\"mathmode\\\"><var>f</var>(<var>a</var>,<var>a</var>)</span>” (or “<span class=\\\"mathmode\\\"><var>f</var>(<var>b</var>,<var>b</var>)</span>”). And not “<span class=\\\"mathmode\\\"><var>f</var>(<var>a</var>,<var>b</var>)<span class=\\\"mathrel\\\">.</span><span class=\\\"mathop\\\">~</span><var>a</var><span class=\\\"mathrel\\\">=</span><var>b</var></span>”, but “<span class=\\\"mathmode\\\"><var>f</var>(<var>a</var>,<var>b</var>)</span>”.\",\"str\":\"\"},{\"label\":\"5.541\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":51,\"x_axis\":91,\"ger\":\"Auf den ersten Blick scheint es, als könne ein Satz in einem anderen auch auf andere Weise vorkommen. Besonders in gewissen Satzformen der Psychologie, wie „A glaubt, dass <span class=\\\"mathmode\\\"><var>p</var></span> der Fall ist“, oder „A denkt <span class=\\\"mathmode\\\"><var>p</var></span>“, etc. Hier scheint es nämlich oberflächlich, als stünde der Satz <span class=\\\"mathmode\\\"><var>p</var></span> zu einem Gegenstand A in einer Art von Relation. (Und in der modernen Erkenntnistheorie (Russell, Moore, etc.) sind jene Sätze auch so aufgefasst worden.)\",\"pmc\":\"At first sight it looks as if it were also possible for one proposition to occur in another in a different way. Particularly with certain forms of proposition in psychology, such as ‘A believes that <span class=\\\"mathmode\\\"><var>p</var></span> is the case’ and A has the thought <span class=\\\"mathmode\\\"><var>p</var></span>’, etc. For if these are considered superficially, it looks as if the proposition <span class=\\\"mathmode\\\"><var>p</var></span> stood in some kind of relation to an object A. (And in modern theory of knowledge (Russell, Moore, etc.) these propositions have actually been construed in this way.)\",\"ogd\":\"At first sight it appears as if there were also a different way in which one proposition could occur in another. Especially in certain propositional forms of psychology, like “A thinks, that <span class=\\\"mathmode\\\"><var>p</var></span> is the case”, or “A thinks <span class=\\\"mathmode\\\"><var>p</var></span>”, etc. Here it appears superficially as if the proposition <span class=\\\"mathmode\\\"><var>p</var></span> stood to the object A in a kind of relation. (And in modern epistemology (Russell, Moore, etc.) those propositions have been conceived in this way.)\",\"str\":\"\"},{\"label\":\"5.551\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":51,\"x_axis\":99,\"ger\":\"Unser Grundsatz ist, dass jede Frage, die sich überhaupt durch die Logik entscheiden lässt, sich ohne weiteres entscheiden lassen muss. (Und wenn wir in die Lage kommen, ein solches Problem durch Ansehen der Welt beantworten zu müssen, so zeigt dies, dass wir auf grundfalscher Fährte sind.)\",\"pmc\":\"Our fundamental principle is that whenever a question can be decided by logic at all it must be possible to decide it without more ado. (And if we get into a position where we have to look at the world for an answer to such a problem, that shows that we are on a completely wrong track.)\",\"ogd\":\"Our fundamental principle is that every question which can be decided at all by logic can be decided off-hand. (And if we get into a situation where we need to answer such a problem by looking at the world, this shows that we are on a fundamentally wrong track.)\",\"str\":\"\"},{\"label\":\"6.421\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":51,\"x_axis\":111,\"ger\":\"Es ist klar, dass sich die Ethik nicht aussprechen lässt. Die Ethik ist transzendental. (Ethik und Ästhetik sind Eins.)\",\"pmc\":\"It is clear that ethics cannot be put into words. Ethics is transcendental. (Ethics and aesthetics are one and the same.)\",\"ogd\":\"It is clear that ethics cannot be expressed. Ethics is transcendental. (Ethics and æsthetics are one.)\",\"str\":\"\"},{\"label\":\"6.431\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":51,\"x_axis\":113,\"ger\":\"Wie auch beim Tod die Welt sich nicht ändert, sondern aufhört.\",\"pmc\":\"So too at death the world does not alter, but comes to an end.\",\"ogd\":\"As in death, too, the world does not change, but ceases.\",\"str\":\"\"},{\"label\":\"6.4311\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":51,\"x_axis\":115,\"ger\":\"Der Tod ist kein Ereignis des Lebens. Den Tod erlebt man nicht. Wenn man unter Ewigkeit nicht unendliche Zeitdauer, sondern Unzeitlichkeit versteht, dann lebt der ewig, der in der Gegenwart lebt. Unser Leben ist ebenso endlos, wie unser Gesichtsfeld grenzenlos ist.\",\"pmc\":\"Death is not an event in life: we do not live to experience death. If we take eternity to mean not infinite temporal duration but timelessness, then eternal life belongs to those who live in the present. Our life has no end in just the way in which our visual field has no limits.\",\"ogd\":\"Death is not an event of life. Death is not lived through. If by eternity is understood not endless temporal duration but timelessness, then he lives eternally who lives in the present. Our life is endless in the way that our visual field is without limit.\",\"str\":\"\"},{\"label\":\"6.4312\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":51,\"x_axis\":117,\"ger\":\"Die zeitliche Unsterblichkeit der Seele des Menschen, das heißt also ihr ewiges Fortleben auch nach dem Tode, ist nicht nur auf keine Weise verbürgt, sondern vor allem leistet diese Annahme gar nicht das, was man immer mit ihr erreichen wollte. Wird denn dadurch ein Rätsel gelöst, dass ich ewig fortlebe? Ist denn dieses ewige Leben dann nicht ebenso rätselhaft wie das gegenwärtige? Die Lösung des Rätsels des Lebens in Raum und Zeit liegt <em class=\\\"germph\\\">außerhalb</em> von Raum und Zeit. (Nicht Probleme der Naturwissenschaft sind ja zu lösen.)\",\"pmc\":\"Not only is there no guarantee of the temporal immortality of the human soul, that is to say of its eternal survival after death; but, in any case, this assumption completely fails to accomplish the purpose for which it has always been intended. Or is some riddle solved by my surviving for ever? Is not this eternal life itself as much of a riddle as our present life? The solution of the riddle of life in space and time lies <em>outside</em> space and time. (It is certainly not the solution of any problems of natural science that is required.)\",\"ogd\":\"The temporal immortality of the human soul, that is to say, its eternal survival also after death, is not only in no way guaranteed, but this assumption in the first place will not do for us what we always tried to make it do. Is a riddle solved by the fact that I survive for ever? Is this eternal life not as enigmatic as our present one? The solution of the riddle of life in space and time lies <em>outside</em> space and time. (It is not problems of natural science which have to be solved.)\",\"str\":\"\"},{\"label\":\"4.411\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":53,\"x_axis\":53,\"ger\":\"Es ist von vornherein wahrscheinlich, dass die Einführung der Elementarsätze für das Verständnis aller anderen Satzarten grundlegend ist. Ja, das Verständnis der allgemeinen Sätze hängt <em class=\\\"germph\\\">fühlbar</em> von dem der Elementarsätze ab.\",\"pmc\":\"It immediately strikes one as probable that the introduction of elementary propositions provides the basis for understanding all other kinds of proposition. Indeed the understanding of general propositions <em>palpably</em> depends on the understanding of elementary propositions.\",\"ogd\":\"It seems probable even at first sight that the introduction of the elementary propositions is fundamental for the comprehension of the other kinds of propositions. Indeed the comprehension of the general propositions depends <em>palpably</em> on that of the elementary propositions.\",\"str\":\"\"},{\"label\":\"4.431\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":53,\"x_axis\":57,\"ger\":\"Der Ausdruck der Übereinstimmung und Nichtübereinstimmung mit den Wahrheitsmöglichkeiten der Elementarsätze drückt die Wahrheitsbedingungen des Satzes aus. Der Satz ist der Ausdruck seiner Wahrheitsbedingungen. (Frege hat sie daher ganz richtig als Erklärung der Zeichen seiner Begriffsschrift vorausgeschickt. Nur ist die Erklärung des Wahrheitsbegriffes bei Frege falsch: Wären „das Wahre“ und „das Falsche“ wirklich Gegenstände und die Argumente in <span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><var>p</var></span> etc. dann wäre nach Freges Bestimmung der Sinn von „<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><var>p</var></span>“ keineswegs bestimmt.)\",\"pmc\":\"The expression of agreement and disagreement with the truth possibilities of elementary propositions expresses the truth-conditions of a proposition. A proposition is the expression of its truth-conditions. (Thus Frege was quite right to use them as a starting point when he explained the signs of his conceptual notation. But the explanation of the concept of truth that Frege gives is mistaken: if ‘the true’ and ‘the false’ were really objects, and were the arguments in <span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><var>p</var></span> etc., then Frege’s method of determining the sense of ‘<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><var>p</var></span>’ would leave it absolutely undetermined.)\",\"ogd\":\"The expression of the agreement and disagreement with the truth-possibilities of the elementary propositions expresses the truth-conditions of the proposition. The proposition is the expression of its truth-conditions. (Frege has therefore quite rightly put them at the beginning, as explaining the signs of his logical symbolism. Only Frege’s explanation of the truth-concept is false: if “the true” and “the false” were real objects and the arguments in <span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><var>p</var></span>, etc., then the sense of <span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><var>p</var></span> would by no means be determined by Frege’s determination.)\",\"str\":\"\"},{\"label\":\"4.441\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":53,\"x_axis\":59,\"ger\":\"Es ist klar, dass dem Komplex der Zeichen „F“ und „W“ kein Gegenstand (oder Komplex von Gegenständen) entspricht; so wenig, wie den horizontalen und vertikalen Strichen oder den Klammern. – „Logische Gegenstände“ gibt es nicht. Analoges gilt natürlich für alle Zeichen, die dasselbe ausdrücken wie die Schemata der „W“ und „F“.\",\"pmc\":\"It is clear that a complex of the signs ‘F’ and ‘T’ has no object (or complex of objects) corresponding to it, just as there is none corresponding to the horizontal and vertical lines or to the brackets.—There are no ‘logical objects’. Of course the same applies to all signs that express what the schemata of ‘T’s’ and ‘F’s’ express.\",\"ogd\":\"It is clear that to the complex of the signs “F” and “T” no object (or complex of objects) corresponds; any more than to horizontal and vertical lines or to brackets. There are no “logical objects”. Something analogous holds of course for all signs, which express the same as the schemata of “T” and “F”.\",\"str\":\"\"},{\"label\":\"4.461\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":53,\"x_axis\":63,\"ger\":\"Der Satz zeigt was er sagt, die Tautologie und die Kontradiktion, dass sie nichts sagen. Die Tautologie hat keine Wahrheitsbedingungen, denn sie ist bedingungslos wahr; und die Kontradiktion ist unter keiner Bedingung wahr. Tautologie und Kontradiktion sind sinnlos. (Wie der Punkt, von dem zwei Pfeile in entgegengesetzter Richtung auseinandergehen.) (Ich weiß z. B. nichts über das Wetter, wenn ich weiß, dass es regnet oder nicht regnet.)\",\"pmc\":\"Propositions show what they say: tautologies and contradictions show that they say nothing. A tautology has no truth-conditions, since it is unconditionally true: and a contradiction is true on no condition. Tautologies and contradictions lack sense. (Like a point from which two arrows go out in opposite directions to one another.) (For example, I know nothing about the weather when I know that it is either raining or not raining.)\",\"ogd\":\"The proposition shows what it says, the tautology and the contradiction that they say nothing. The tautology has no truth-conditions, for it is unconditionally true; and the contradiction is on no condition true. Tautology and contradiction are without sense. (Like the point from which two arrows go out in opposite directions.) (I know, <em>e.g.</em> nothing about the weather, when I know that it rains or does not rain.)\",\"str\":\"\"},{\"label\":\"4.4611\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":53,\"x_axis\":65,\"ger\":\"Tautologie und Kontradiktion sind aber nicht unsinnig; sie gehören zum Symbolismus, und zwar ähnlich wie die „0“ zum Symbolismus der Arithmetik.\",\"pmc\":\"Tautologies and contradictions are not, however, nonsensical. They are part of the symbolism, much as ‘0’ is part of the symbolism of arithmetic.\",\"ogd\":\"Tautology and contradiction are, however, not nonsensical; they are part of the symbolism, in the same way that “0” is part of the symbolism of Arithmetic.\",\"str\":\"\"},{\"label\":\"5.512\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":53,\"x_axis\":77,\"ger\":\"„<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><var>p</var></span>“ ist wahr, wenn „<span class=\\\"mathmode\\\"><var>p</var></span>“ falsch ist. Also in dem wahren Satz „<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><var>p</var></span>“ ist „<span class=\\\"mathmode\\\"><var>p</var></span>“ ein falscher Satz. Wie kann ihn nun der Strich „~“ mit der Wirklichkeit zum Stimmen bringen? Das, was in „<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><var>p</var></span>“ verneint, ist aber nicht das „~“, sondern dasjenige, was allen Zeichen dieser Notation, welche <span class=\\\"mathmode\\\"><var>p</var></span> verneinen, gemeinsam ist. Also die gemeinsame Regel, nach welcher „<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><var>p</var></span>“, „<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><span class=\\\"mathop\\\">~</span><span class=\\\"mathop\\\">~</span><var>p</var></span>“, „<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><var>p</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">∨</span></span><span class=\\\"mathop\\\">~</span><var>p</var></span>“, „<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><var>p</var><span class=\\\"mathrel\\\">.</span><span class=\\\"mathop\\\">~</span><var>p</var></span>“, etc. etc. (ad inf.) gebildet werden. Und dies Gemeinsame spiegelt die Verneinung wieder.\",\"pmc\":\"‘<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><var>p</var></span>’ is true if ‘<span class=\\\"mathmode\\\"><var>p</var></span>’ is false. Therefore, in the proposition ‘<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><var>p</var></span>’, when it is true, ‘<span class=\\\"mathmode\\\"><var>p</var></span>’ is a false proposition. How then can the stroke ‘~’ make it agree with reality? But in ‘<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><var>p</var></span>’ it is not ‘~’ that negates, it is rather what is common to all the signs of this notation that negate <span class=\\\"mathmode\\\"><var>p</var></span>. That is to say the common rule that governs the construction of ‘<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><var>p</var></span>’, ‘<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><span class=\\\"mathop\\\">~</span><span class=\\\"mathop\\\">~</span><var>p</var></span>’, ‘<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><var>p</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">∨</span></span><span class=\\\"mathop\\\">~</span><var>p</var></span>’, ‘<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><var>p</var><span class=\\\"mathrel\\\">.</span><span class=\\\"mathop\\\">~</span><var>p</var></span>’, etc. etc. (ad inf.). And this common factor mirrors negation.\",\"ogd\":\"“<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><var>p</var></span>” is true if “<span class=\\\"mathmode\\\"><var>p</var></span>” is false. Therefore in the true proposition “<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><var>p</var></span>” “<span class=\\\"mathmode\\\"><var>p</var></span>” is a false proposition. How then can the stroke “~” bring it into agreement with reality? That which denies in “<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><var>p</var></span>” is however not “~”, but that which all signs of this notation, which deny <span class=\\\"mathmode\\\"><var>p</var></span>, have in common. Hence the common rule according to which “<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><var>p</var></span>”, “<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><span class=\\\"mathop\\\">~</span><span class=\\\"mathop\\\">~</span><var>p</var></span>”, “<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><var>p</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">∨</span></span><span class=\\\"mathop\\\">~</span><var>p</var></span>”, “<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><var>p</var><span class=\\\"mathrel\\\">.</span><span class=\\\"mathop\\\">~</span><var>p</var></span>”, etc. etc. (to infinity) are constructed. And this which is common to them all mirrors denial.\",\"str\":\"\"},{\"label\":\"5.522\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":53,\"x_axis\":81,\"ger\":\"Das Eigentümliche der Allgemeinheitsbezeichnung ist erstens, dass sie auf ein logisches Urbild hinweist, und zweitens, dass sie Konstante hervorhebt.\",\"pmc\":\"What is peculiar to the generality-sign is first, that it indicates a logical prototype, and secondly, that it gives prominence to constants.\",\"ogd\":\"That which is peculiar to the “symbolism of generality” is firstly, that it refers to a logical prototype, and secondly, that it makes constants prominent.\",\"str\":\"\"},{\"label\":\"5.5302\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":53,\"x_axis\":83,\"ger\":\"Russells Definition von „=“ genügt nicht; weil man nach ihr nicht sagen kann, dass zwei Gegenstände alle Eigenschaften gemeinsam haben. (Selbst wenn dieser Satz nie richtig ist, hat er doch <em class=\\\"germph\\\">Sinn</em>.)\",\"pmc\":\"Russell’s definition of ‘=’ is inadequate, because according to it we cannot say that two objects have all their properties in common. (Even if this proposition is never correct, it still has <em>sense</em>.)\",\"ogd\":\"Russell’s definition of “=” won’t do; because according to it one cannot say that two objects have all their properties in common. (Even if this proposition is never true, it is nevertheless <em>significant</em>.)\",\"str\":\"\"},{\"label\":\"5.532\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":53,\"x_axis\":85,\"ger\":\"Und analog: Nicht „<span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<span class=\\\"symbol\\\">∃</span><var>x</var>,<var>y</var>).</span><var>f</var>(<var>x</var>,<var>y</var>)<span class=\\\"mathrel\\\">.</span><var>x</var><span class=\\\"mathrel\\\">=</span><var>y</var></span>“, sondern „<span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<span class=\\\"symbol\\\">∃</span><var>x</var>).</span><var>f</var>(<var>x</var>,<var>x</var>)</span>“; und nicht „<span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<span class=\\\"symbol\\\">∃</span><var>x</var>,<var>y</var>).</span><var>f</var>(<var>x</var>,<var>y</var>)<span class=\\\"mathrel\\\">.</span><span class=\\\"mathop\\\">~</span><var>x</var><span class=\\\"mathrel\\\">=</span><var>y</var></span>“, sondern „<span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<span class=\\\"symbol\\\">∃</span><var>x</var>,<var>y</var>).</span><var>f</var>(<var>x</var>,<var>y</var>)</span>“. (Also statt des Russellschen „<span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<span class=\\\"symbol\\\">∃</span><var>x</var>,<var>y</var>).</span></span> <span class=\\\"mathmode\\\"><var>f</var>(<var>x</var>,<var>y</var>)</span>“: „<span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<span class=\\\"symbol\\\">∃</span><var>x</var>,<var>y</var>).</span><var>f</var>(<var>x</var>,<var>y</var>)<span class=\\\"mathrel\\\">.<span class=\\\"symbol\\\">∨</span>.</span><span class=\\\"quant\\\">(<span class=\\\"symbol\\\">∃</span><var>x</var>).</span><var>f</var>(<var>x</var>,<var>x</var>)</span>“.)\",\"pmc\":\"And analogously I do not write ‘<span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<span class=\\\"symbol\\\">∃</span><var>x</var>,<var>y</var>).</span><var>f</var>(<var>x</var>,<var>y</var>)<span class=\\\"mathrel\\\">.</span><var>x</var><span class=\\\"mathrel\\\">=</span><var>y</var></span>’, but ‘<span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<span class=\\\"symbol\\\">∃</span><var>x</var>).</span><var>f</var>(<var>x</var>,<var>x</var>)</span>’; and not ‘<span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<span class=\\\"symbol\\\">∃</span><var>x</var>,<var>y</var>).</span><var>f</var>(<var>x</var>,<var>y</var>)<span class=\\\"mathrel\\\">.</span><span class=\\\"mathop\\\">~</span><var>x</var><span class=\\\"mathrel\\\">=</span><var>y</var></span>’, but ‘<span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<span class=\\\"symbol\\\">∃</span><var>x</var>,<var>y</var>).</span><var>f</var>(<var>x</var>,<var>y</var>)</span>’. (So Russell’s ‘<span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<span class=\\\"symbol\\\">∃</span><var>x</var>,<var>y</var>).</span><var>f</var>(<var>x</var>,<var>y</var>)</span>’ becomes ‘<span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<span class=\\\"symbol\\\">∃</span><var>x</var>,<var>y</var>).</span><var>f</var>(<var>x</var>,<var>y</var>)<span class=\\\"mathrel\\\">.<span class=\\\"symbol\\\">∨</span>.</span><span class=\\\"quant\\\">(<span class=\\\"symbol\\\">∃</span><var>x</var>).</span><var>f</var>(<var>x</var>,<var>x</var>)</span>’.)\",\"ogd\":\"And analogously: not “<span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<span class=\\\"symbol\\\">∃</span><var>x</var>,<var>y</var>).</span><var>f</var>(<var>x</var>,<var>y</var>)<span class=\\\"mathrel\\\">.</span><var>x</var><span class=\\\"mathrel\\\">=</span><var>y</var></span>”, but “<span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<span class=\\\"symbol\\\">∃</span><var>x</var>).</span><var>f</var>(<var>x</var>,<var>x</var>)</span>”; and not “<span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<span class=\\\"symbol\\\">∃</span><var>x</var>,<var>y</var>).</span><var>f</var>(<var>x</var>,<var>y</var>)<span class=\\\"mathrel\\\">.</span><span class=\\\"mathop\\\">~</span><var>x</var><span class=\\\"mathrel\\\">=</span><var>y</var></span>”, but “<span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<span class=\\\"symbol\\\">∃</span><var>x</var>,<var>y</var>).</span><var>f</var>(<var>x</var>,<var>y</var>)</span>”. (Therefore instead of Russell’s “<span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<span class=\\\"symbol\\\">∃</span><var>x</var>,<var>y</var>).</span></span> <span class=\\\"mathmode\\\"><var>f</var>(<var>x</var>,<var>y</var>)</span>”: “<span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<span class=\\\"symbol\\\">∃</span><var>x</var>,<var>y</var>).</span><var>f</var>(<var>x</var>,<var>y</var>)<span class=\\\"mathrel\\\">.<span class=\\\"symbol\\\">∨</span>.</span><span class=\\\"quant\\\">(<span class=\\\"symbol\\\">∃</span><var>x</var>).</span><var>f</var>(<var>x</var>,<var>x</var>)</span>”.)\",\"str\":\"\"},{\"label\":\"5.5321\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":53,\"x_axis\":87,\"ger\":\"Statt „<span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<var>x</var>):</span><var>fx</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">⊃</span></span><var>x</var><span class=\\\"mathrel\\\">=</span><var>a</var></span>“ schreiben wir also z. B. „<span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<span class=\\\"symbol\\\">∃</span><var>x</var>).</span><var>fx</var><span class=\\\"mathrel\\\">.<span class=\\\"symbol\\\">⊃</span>.</span><var>fa</var><span class=\\\"mathrel\\\">:</span><span class=\\\"mathop\\\">~</span><span class=\\\"quant\\\">(<span class=\\\"symbol\\\">∃</span><var>x</var>,<var>y</var>).</span><var>fx</var><span class=\\\"mathrel\\\">.</span><var>fy</var></span>“. Und der Satz: „<em class=\\\"germph\\\">nur</em> Ein <span class=\\\"mathmode\\\"><var>x</var></span> befriedigt <span class=\\\"mathmode\\\"><var>f</var>(&nbsp;)</span>“ lautet: „<span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<span class=\\\"symbol\\\">∃</span><var>x</var>).</span><var>fx</var><span class=\\\"mathrel\\\">:</span><span class=\\\"mathop\\\">~</span><span class=\\\"quant\\\">(<span class=\\\"symbol\\\">∃</span><var>x</var>,<var>y</var>).</span><var>fx</var><span class=\\\"mathrel\\\">.</span><var>fy</var></span>“.\",\"pmc\":\"Thus, for example, instead of ‘<span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<var>x</var>):</span><var>fx</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">⊃</span></span><var>x</var><span class=\\\"mathrel\\\">=</span><var>a</var></span>’ we write ‘<span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<span class=\\\"symbol\\\">∃</span><var>x</var>).</span><var>fx</var><span class=\\\"mathrel\\\">.<span class=\\\"symbol\\\">⊃</span>.</span><var>fa</var><span class=\\\"mathrel\\\">:</span><span class=\\\"mathop\\\">~</span><span class=\\\"quant\\\">(<span class=\\\"symbol\\\">∃</span><var>x</var>,<var>y</var>).</span><var>fx</var><span class=\\\"mathrel\\\">.</span><var>fy</var></span>’. And the proposition, ‘<em>Only one</em> <span class=\\\"mathmode\\\"><var>x</var></span> satisfies <span class=\\\"mathmode\\\"><var>f</var>(&nbsp;)</span>’, will read ‘<span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<span class=\\\"symbol\\\">∃</span><var>x</var>).</span><var>fx</var><span class=\\\"mathrel\\\">:</span><span class=\\\"mathop\\\">~</span><span class=\\\"quant\\\">(<span class=\\\"symbol\\\">∃</span><var>x</var>,<var>y</var>).</span><var>fx</var><span class=\\\"mathrel\\\">.</span><var>fy</var></span>’.\",\"ogd\":\"Instead of “<span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<var>x</var>):</span><var>fx</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">⊃</span></span><var>x</var><span class=\\\"mathrel\\\">=</span><var>a</var></span>” we therefore write <em>e.g.</em> “<span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<span class=\\\"symbol\\\">∃</span><var>x</var>).</span><var>fx</var><span class=\\\"mathrel\\\">.<span class=\\\"symbol\\\">⊃</span>.</span><var>fa</var><span class=\\\"mathrel\\\">:</span><span class=\\\"mathop\\\">~</span><span class=\\\"quant\\\">(<span class=\\\"symbol\\\">∃</span><var>x</var>,<var>y</var>).</span><var>fx</var><span class=\\\"mathrel\\\">.</span><var>fy</var></span>”. And if the proposition “<em>only</em> one <span class=\\\"mathmode\\\"><var>x</var></span> satisfies <span class=\\\"mathmode\\\"><var>f</var>(&nbsp;)</span>” reads: “<span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<span class=\\\"symbol\\\">∃</span><var>x</var>).</span><var>fx</var><span class=\\\"mathrel\\\">:</span><span class=\\\"mathop\\\">~</span><span class=\\\"quant\\\">(<span class=\\\"symbol\\\">∃</span><var>x</var>,<var>y</var>).</span><var>fx</var><span class=\\\"mathrel\\\">.</span><var>fy</var></span>”.\",\"str\":\"\"},{\"label\":\"5.542\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":53,\"x_axis\":91,\"ger\":\"Es ist aber klar, dass „A glaubt, dass <span class=\\\"mathmode\\\"><var>p</var></span>“, „A denkt <span class=\\\"mathmode\\\"><var>p</var></span>“, „A sagt <span class=\\\"mathmode\\\"><var>p</var></span>“ von der Form „‚<span class=\\\"mathmode\\\"><var>p</var></span>‘ sagt <span class=\\\"mathmode\\\"><var>p</var></span>“ sind: Und hier handelt es sich nicht um eine Zuordnung von einer Tatsache und einem Gegenstand, sondern um die Zuordnung von Tatsachen durch Zuordnung ihrer Gegenstände.\",\"pmc\":\"It is clear, however, that ‘A believes that <span class=\\\"mathmode\\\"><var>p</var></span>’, ‘A has the thought <span class=\\\"mathmode\\\"><var>p</var></span>’, and ‘A says <span class=\\\"mathmode\\\"><var>p</var></span>’ are of the form ‘“<span class=\\\"mathmode\\\"><var>p</var></span>” says <span class=\\\"mathmode\\\"><var>p</var></span>’: and this does not involve a correlation of a fact with an object, but rather the correlation of facts by means of the correlation of their objects.\",\"ogd\":\"But it is clear that “A believes that <span class=\\\"mathmode\\\"><var>p</var></span>”, “A thinks <span class=\\\"mathmode\\\"><var>p</var></span>”, “A says <span class=\\\"mathmode\\\"><var>p</var></span>”, are of the form “‘<span class=\\\"mathmode\\\"><var>p</var></span>’ says <span class=\\\"mathmode\\\"><var>p</var></span>”: and here we have no co-ordination of a fact and an object, but a co-ordination of facts by means of a co-ordination of their objects.\",\"str\":\"\"},{\"label\":\"5.5421\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":53,\"x_axis\":93,\"ger\":\"Dies zeigt auch, dass die Seele – das Subjekt etc. – wie sie in der heutigen oberflächlichen Psychologie aufgefasst wird, ein Unding ist. Eine zusammengesetzte Seele wäre nämlich keine Seele mehr.\",\"pmc\":\"This shows too that there is no such thing as the soul—the subject, etc.—as it is conceived in the superficial psychology of the present day. Indeed a composite soul would no longer be a soul.\",\"ogd\":\"This shows that there is no such thing as the soul—the subject, etc.—as it is conceived in superficial psychology. A composite soul would not be a soul any longer.\",\"str\":\"\"},{\"label\":\"5.5422\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":53,\"x_axis\":95,\"ger\":\"Die richtige Erklärung der Form des Satzes „A urteilt <span class=\\\"mathmode\\\"><var>p</var></span>“ muss zeigen, dass es unmöglich ist, einen Unsinn zu urteilen. (Russells Theorie genügt dieser Bedingung nicht.)\",\"pmc\":\"The correct explanation of the form of the proposition, ‘A makes the judgement <span class=\\\"mathmode\\\"><var>p</var></span>’, must show that it is impossible for a judgement to be a piece of nonsense. (Russell’s theory does not satisfy this requirement.)\",\"ogd\":\"The correct explanation of the form of the proposition “A judges <span class=\\\"mathmode\\\"><var>p</var></span>” must show that it is impossible to judge a nonsense. (Russell’s theory does not satisfy this condition.)\",\"str\":\"\"},{\"label\":\"5.5423\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":53,\"x_axis\":97,\"ger\":\"Einen Komplex wahrnehmen heißt wahrnehmen, dass sich seine Bestandteile so und so zu einander verhalten. Dies erklärt wohl auch, dass man die Figur  <!-- noindent --><div class=\\\"centered\\\"><object data=\\\"../images/thecube.svg\\\" type=\\\"image/svg+xml\\\" class=\\\"thecubesvg\\\" ><img src=\\\"images/thecube.png\\\" alt=\\\"Cube with a face and b face\\\" class=\\\"thecubepng\\\" /></object></div> <!-- noindent --> auf zweierlei Art als Würfel sehen kann; und alle ähnlichen Erscheinungen. Denn wir sehen eben wirklich zwei verschiedene Tatsachen. (Sehe ich erst auf die Ecken <span class=\\\"mathmode\\\"><var>a</var></span> und nur flüchtig auf <span class=\\\"mathmode\\\"><var>b</var></span>, so erscheint <span class=\\\"mathmode\\\"><var>a</var></span> vorne; und umgekehrt.)\",\"pmc\":\"To perceive a complex means to perceive that its constituents are related to one another in such and such a way. This no doubt also explains why there are two possible ways of seeing the figure  <!-- noindent --><div class=\\\"centered\\\"><object data=\\\"../images/thecube.svg\\\" type=\\\"image/svg+xml\\\" class=\\\"thecubesvg\\\" ><img src=\\\"images/thecube.png\\\" alt=\\\"Cube with a face and b face\\\" class=\\\"thecubepng\\\" /></object></div> <!-- noindent --> as a cube; and all similar phenomena. For we really see two different facts. (If I look in the first place at the corners marked <span class=\\\"mathmode\\\"><var>a</var></span> and only glance at the <span class=\\\"mathmode\\\"><var>b</var></span>’s, then the <span class=\\\"mathmode\\\"><var>a</var></span>’s appear to be in front, and <em>vice versa</em>).\",\"ogd\":\"To perceive a complex means to perceive that its constituents are combined in such and such a way. This perhaps explains that the figure  <!-- noindent --><div class=\\\"centered\\\"><object data=\\\"../images/thecube.svg\\\" type=\\\"image/svg+xml\\\" class=\\\"thecubesvg\\\" ><img src=\\\"images/thecube.png\\\" alt=\\\"Cube with a face and b face\\\" class=\\\"thecubepng\\\" /></object></div> <!-- noindent --> can be seen in two ways as a cube; and all similar phenomena. For we really see two different facts. (If I fix my eyes first on the corners <span class=\\\"mathmode\\\"><var>a</var></span> and only glance at <span class=\\\"mathmode\\\"><var>b</var></span>, <span class=\\\"mathmode\\\"><var>a</var></span> appears in front and <span class=\\\"mathmode\\\"><var>b</var></span> behind, and vice versa.)\",\"str\":\"\"},{\"label\":\"5.552\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":53,\"x_axis\":99,\"ger\":\"Die „Erfahrung“, die wir zum Verstehen der Logik brauchen, ist nicht die, dass sich etwas so und so verhält, sondern, dass etwas <em class=\\\"germph\\\">ist</em>: aber das ist eben <em class=\\\"germph\\\">keine</em> Erfahrung. Die Logik ist <em class=\\\"germph\\\">vor</em> jeder Erfahrung – dass etwas <em class=\\\"germph\\\">so</em> ist. Sie ist vor dem Wie, nicht vor dem Was.\",\"pmc\":\"The ‘experience’ that we need in order to understand logic is not that something or other is the state of things, but that something <em>is</em>: that, however, is <em>not</em> an experience. Logic is <em>prior</em> to every experience—that something <em>is so</em>. It is prior to the question ‘How?’, not prior to the question ‘What?’\",\"ogd\":\"The “experience” which we need to understand logic is not that such and such is the case, but that something <em>is</em>; but that is <em>no</em> experience. Logic <em>precedes</em> every experience—that something is <em>so</em>. It is before the How, not before the What.\",\"str\":\"\"},{\"label\":\"5.5521\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":53,\"x_axis\":101,\"ger\":\"Und wenn dies nicht so wäre, wie könnten wir die Logik anwenden? Man könnte sagen: Wenn es eine Logik gäbe, auch wenn es keine Welt gäbe, wie könnte es dann eine Logik geben, da es eine Welt gibt?\",\"pmc\":\"And if this were not so, how could we apply logic? We might put it in this way: if there would be a logic even if there were no world, how then could there be a logic given that there is a world?\",\"ogd\":\"And if this were not the case, how could we apply logic? We could say: if there were a logic, even if there were no world, how then could there be a logic, since there is a world?\",\"str\":\"\"},{\"label\":\"6.422\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":53,\"x_axis\":111,\"ger\":\"Der erste Gedanke bei der Aufstellung eines ethischen Gesetzes von der Form „Du sollst …“ ist: Und was dann, wenn ich es nicht tue? Es ist aber klar, dass die Ethik nichts mit Strafe und Lohn im gewöhnlichen Sinne zu tun hat. Also muss diese Frage nach den <em class=\\\"germph\\\">Folgen</em> einer Handlung belanglos sein. – Zum Mindesten dürfen diese Folgen nicht Ereignisse sein. Denn etwas muss doch an jener Fragestellung richtig sein. Es muss zwar eine Art von ethischem Lohn und ethischer Strafe geben, aber diese müssen in der Handlung selbst liegen. (Und das ist auch klar, dass der Lohn etwas Angenehmes, die Strafe etwas Unangenehmes sein muss.)\",\"pmc\":\"When an ethical law of the form, ‘Thou shalt …’ is laid down, one’s first thought is, ‘And what if I do not do it?’ It is clear, however, that ethics has nothing to do with punishment and reward in the usual sense of the terms. So our question about the <em>consequences</em> of an action must be unimportant.—At least those consequences should not be events. For there must be something right about the question we posed. There must indeed be some kind of ethical reward and ethical punishment, but they must reside in the action itself. (And it is also clear that the reward must be something pleasant and the punishment something unpleasant.)\",\"ogd\":\"The first thought in setting up an ethical law of the form “thou shalt …” is: And what if I do not do it? But it is clear that ethics has nothing to do with punishment and reward in the ordinary sense. This question as to the <em>consequences</em> of an action must therefore be irrelevant. At least these consequences will not be events. For there must be something right in that formulation of the question. There must be some sort of ethical reward and ethical punishment, but this must lie in the action itself. (And this is clear also that the reward must be something acceptable, and the punishment something unacceptable.)\",\"str\":\"\"},{\"label\":\"6.432\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":53,\"x_axis\":113,\"ger\":\"<em class=\\\"germph\\\">Wie</em> die Welt ist, ist für das Höhere vollkommen gleichgültig. Gott offenbart sich nicht <em class=\\\"germph\\\">in</em> der Welt.\",\"pmc\":\"<em>How</em> things are in the world is a matter of complete indifference for what is higher. God does not reveal himself <em>in</em> the world.\",\"ogd\":\"<em>How</em> the world is, is completely indifferent for what is higher. God does not reveal himself <em>in</em> the world.\",\"str\":\"\"},{\"label\":\"6.4321\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":53,\"x_axis\":115,\"ger\":\"Die Tatsachen gehören alle nur zur Aufgabe, nicht zur Lösung.\",\"pmc\":\"The facts all contribute only to setting the problem, not to its solution.\",\"ogd\":\"The facts all belong only to the task and not to its performance.\",\"str\":\"\"},{\"label\":\"4.442\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":55,\"x_axis\":59,\"ger\":\"Es ist z. B.: <!-- noindent --><div class=\\\"centered\\\"><table class=\\\"truthtable\\\"><tr><th></th><th class=\\\"l\\\"><span class=\\\"mathmode\\\"><var>p</var></span></th><th class=\\\"m\\\"><span class=\\\"mathmode\\\"><var>q</var></span></th><th class=\\\"e\\\"></th><th>“</th></tr><tr><td></td><td class=\\\"l\\\">W</td><td class=\\\"m\\\">W</td><td class=\\\"e\\\">W</td><td></td></tr><tr><td></td><td class=\\\"l\\\">F</td><td class=\\\"m\\\">W</td><td class=\\\"e\\\">W</td><td></td></tr><tr><td></td><td class=\\\"l\\\">W</td><td class=\\\"m\\\">F</td><td class=\\\"e\\\"></td><td></td></tr><tr><td>„</td><td class=\\\"l\\\">F</td><td class=\\\"m\\\">F</td><td class=\\\"e\\\">W</td><td></td></tr></table></div> <!-- flushright --> ein Satzzeichen. (Frege’s „Urteilsstrich“ „<span class=\\\"mathmode\\\">⊢</span>“ ist logisch ganz bedeutunglos; er zeigt bei Frege (und Russell) nur an, dass diese Autoren die so bezeichneten Sätze für wahr halten. \\n„<span class=\\\"mathmode\\\">⊢</span>“ gehört daher ebenso wenig zum Satzgefüge, wie etwa die Nummer des Satzes. Ein Satz kann unmöglich von sich selbst aussagen, dass er wahr ist.) Ist die Reihenfolge der Wahrheitsmöglichkeiten im Schema durch eine Kombinationsregel ein für allemal festgesetzt, dann ist die letzte Kolonne allein schon ein Ausdruck der Wahrheitsbedingungen. Schreiben wir diese Kolonne als Reihe hin, so wird das Satzzeichen zu <div class=\\\"centered\\\"><span class=\\\"mathmode\\\"> „ <span class=\\\"mathop\\\">(<span class=\\\"mathrm\\\">WW–W</span>)</span>&nbsp; (<var>p</var>, <var>q</var>)“ </span></div><span class=\\\"mathmode\\\"></span> <!-- noindent --> oder deutlicher <div class=\\\"centered\\\"><span class=\\\"mathmode\\\"> „ <span class=\\\"mathop\\\">(<span class=\\\"mathrm\\\">WWFW</span>)</span>&nbsp; (<var>p</var>, <var>q</var>)“. </span></div><span class=\\\"mathmode\\\"></span> (Die Anzahl der Stellen in der linken Klammer ist durch die Anzahl der Glieder in der rechten bestimmt.)\",\"pmc\":\"For example, the following is a propositional sign: <!-- noindent --><div class=\\\"centered\\\"><table class=\\\"truthtable\\\"><tr><th>‘</th><th class=\\\"l\\\"><span class=\\\"mathmode\\\"><var>p</var></span></th><th class=\\\"m\\\"><span class=\\\"mathmode\\\"><var>q</var></span></th><th class=\\\"e\\\"></th><th>’</th></tr><tr><td></td><td class=\\\"l\\\">T</td><td class=\\\"m\\\">T</td><td class=\\\"e\\\">T</td><td></td></tr><tr><td></td><td class=\\\"l\\\">F</td><td class=\\\"m\\\">T</td><td class=\\\"e\\\">T</td><td></td></tr><tr><td></td><td class=\\\"l\\\">T</td><td class=\\\"m\\\">F</td><td class=\\\"e\\\"></td><td></td></tr><tr><td></td><td class=\\\"l\\\">F</td><td class=\\\"m\\\">F</td><td class=\\\"e\\\">T</td><td></td></tr></table></div>  (Frege’s ‘judgement stroke’ ‘<span class=\\\"mathmode\\\">⊢</span>’ is logically quite meaningless: in the works of Frege (and Russell) it simply indicates that these authors hold the propositions marked with this sign to be true. Thus ‘<span class=\\\"mathmode\\\">⊢</span>’ is no more a component part of a proposition than is, for instance, the proposition’s number. It is quite impossible for a proposition to state that it itself is true.) If the order or the truth-possibilities in a schema is fixed once and for all by a combinatory rule, then the last column by itself will be an expression of the truth-conditions. If we now write this column as a row, the propositional sign will become <div class=\\\"centered\\\"><span class=\\\"mathmode\\\"> “<span class=\\\"mathop\\\">(<span class=\\\"mathrm\\\">TT–T</span>)</span>&nbsp; (<var>p</var>, <var>q</var>)”, </span></div><span class=\\\"mathmode\\\"></span> <!-- noindent --> or more explicitly <div class=\\\"centered\\\"><span class=\\\"mathmode\\\">“<span class=\\\"mathop\\\">(<span class=\\\"mathrm\\\">TTFT</span>)</span>&nbsp; (<var>p</var>, <var>q</var>)”.</span></div><span class=\\\"mathmode\\\"></span> (The number of places in the left-hand pair of brackets is determined by the number of terms in the right-hand pair.)\",\"ogd\":\"Thus <em>e.g.</em> <!-- noindent --><div class=\\\"centered\\\"><table class=\\\"truthtable\\\"><tr><th>“</th><th class=\\\"l\\\"><span class=\\\"mathmode\\\"><var>p</var></span></th><th class=\\\"m\\\"><span class=\\\"mathmode\\\"><var>q</var></span></th><th class=\\\"e\\\"></th><th></th></tr><tr><td></td><td class=\\\"l\\\">T</td><td class=\\\"m\\\">T</td><td class=\\\"e\\\">T</td><td></td></tr><tr><td></td><td class=\\\"l\\\">F</td><td class=\\\"m\\\">T</td><td class=\\\"e\\\">T</td><td></td></tr><tr><td></td><td class=\\\"l\\\">T</td><td class=\\\"m\\\">F</td><td class=\\\"e\\\"></td><td></td></tr><tr><td></td><td class=\\\"l\\\">F</td><td class=\\\"m\\\">F</td><td class=\\\"e\\\">T</td><td>”</td></tr></table></div> <!-- flushright --> is a propositional sign. (Frege’s assertion sign “<span class=\\\"mathmode\\\">⊢</span>” is logically altogether meaningless; in Frege (and Russell) it only shows that these authors hold as true the propositions marked in this way. “<span class=\\\"mathmode\\\">⊢</span>” belongs therefore to the propositions no more than does the number of the proposition. A proposition cannot possibly assert of itself that it is true.) If the sequence of the truth-possibilities in the schema is once for all determined by a rule of combination, then the last column is by itself an expression of the truth-conditions. If we write this column as a row the propositional sign becomes: <div class=\\\"centered\\\"><span class=\\\"mathmode\\\"> “<span class=\\\"mathop\\\">(<span class=\\\"mathrm\\\">TT–T</span>)</span>&nbsp; (<var>p</var>, <var>q</var>)”, </span></div><span class=\\\"mathmode\\\"></span> <!-- noindent --> or more plainly: <div class=\\\"centered\\\"><span class=\\\"mathmode\\\">“<span class=\\\"mathop\\\">(<span class=\\\"mathrm\\\">TTFT</span>)</span>&nbsp; (<var>p</var>, <var>q</var>)”.</span></div><span class=\\\"mathmode\\\"></span> (The number of places in the left-hand bracket is determined by the number of terms in the right-hand bracket.)\",\"str\":\"\"},{\"label\":\"4.462\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":55,\"x_axis\":63,\"ger\":\"Tautologie und Kontradiktion sind nicht Bilder der Wirklichkeit. Sie stellen keine mögliche Sachlage dar. Denn jene lässt <em class=\\\"germph\\\">jede</em> mögliche Sachlage zu, diese <em class=\\\"germph\\\">keine</em>. In der Tautologie heben die Bedingungen der Übereinstimmung mit der Welt – die darstellenden Beziehungen – einander auf, so dass sie in keiner darstellenden Beziehung zur Wirklichkeit steht.\",\"pmc\":\"Tautologies and contradictions are not pictures of reality. They do not represent any possible situations. For the former admit <em>all</em> possible situations, and latter <em>none</em>. In a tautology the conditions of agreement with the world—the representational relations—cancel one another, so that it does not stand in any representational relation to reality.\",\"ogd\":\"Tautology and contradiction are not pictures of the reality. They present no possible state of affairs. For the one allows <em>every</em> possible state of affairs, the other <em>none</em>. In the tautology the conditions of agreement with the world—the presenting relations—cancel one another, so that it stands in no presenting relation to reality.\",\"str\":\"\"},{\"label\":\"5.513\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":55,\"x_axis\":77,\"ger\":\"Man könnte sagen: Das Gemeinsame aller Symbole, die sowohl <span class=\\\"mathmode\\\"><var>p</var></span> als <span class=\\\"mathmode\\\"><var>q</var></span> bejahen, ist der Satz „<span class=\\\"mathmode\\\"><var>p</var><span class=\\\"mathrel\\\">.</span><var>q</var></span>“. Das Gemeinsame aller Symbole, die entweder <span class=\\\"mathmode\\\"><var>p</var></span> oder <span class=\\\"mathmode\\\"><var>q</var></span> bejahen, ist der Satz „<span class=\\\"mathmode\\\"><var>p</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">∨</span></span><var>q</var></span>“. Und so kann man sagen: Zwei Sätze sind einander entgegengesetzt, wenn sie nichts miteinander gemein haben, und: Jeder Satz hat nur ein Negativ, weil es nur einen Satz gibt, der ganz außerhalb seiner liegt. Es zeigt sich so auch in Russells Notation, dass „<span class=\\\"mathmode\\\"><var>q</var><span class=\\\"mathrel\\\">:</span><var>p</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">∨</span></span><span class=\\\"mathop\\\">~</span><var>p</var></span>“ dasselbe sagt wie „<span class=\\\"mathmode\\\"><var>q</var></span>“; dass „<span class=\\\"mathmode\\\"><var>p</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">∨</span></span><span class=\\\"mathop\\\">~</span><var>p</var></span>“ nichts sagt.\",\"pmc\":\"We might say that what is common to all symbols that affirm both <span class=\\\"mathmode\\\"><var>p</var></span> and <span class=\\\"mathmode\\\"><var>q</var></span> is the proposition ‘<span class=\\\"mathmode\\\"><var>p</var><span class=\\\"mathrel\\\">.</span><var>q</var></span>’; and that what is common to all symbols that affirm either <span class=\\\"mathmode\\\"><var>p</var></span> or <span class=\\\"mathmode\\\"><var>q</var></span> is the proposition ‘<span class=\\\"mathmode\\\"><var>p</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">∨</span></span><var>q</var></span>’. And similarly we can say that two propositions are opposed to one another if they have nothing in common with one another, and that every proposition has only one negative, since there is only one proposition that lies completely outside it. Thus in Russell’s notation too it is manifest that ‘<span class=\\\"mathmode\\\"><var>q</var><span class=\\\"mathrel\\\">:</span><var>p</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">∨</span></span><span class=\\\"mathop\\\">~</span><var>p</var></span>’ says the same thing as ‘<span class=\\\"mathmode\\\"><var>q</var></span>’, that ‘<span class=\\\"mathmode\\\"><var>p</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">∨</span></span><span class=\\\"mathop\\\">~</span><var>p</var></span>’ says nothing.\",\"ogd\":\"We could say: What is common to all symbols, which assert both <span class=\\\"mathmode\\\"><var>p</var></span> and <span class=\\\"mathmode\\\"><var>q</var></span>, is the proposition “<span class=\\\"mathmode\\\"><var>p</var><span class=\\\"mathrel\\\">.</span><var>q</var></span>”. What is common to all symbols, which asserts either <span class=\\\"mathmode\\\"><var>p</var></span> or <span class=\\\"mathmode\\\"><var>q</var></span>, is the proposition “<span class=\\\"mathmode\\\"><var>p</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">∨</span></span><var>q</var></span>”. And similarly we can say: Two propositions are opposed to one another when they have nothing in common with one another; and every proposition has only one negative, because there is only one proposition which lies altogether outside it. Thus in Russell’s notation also it appears evident that “<span class=\\\"mathmode\\\"><var>q</var><span class=\\\"mathrel\\\">:</span><var>p</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">∨</span></span><span class=\\\"mathop\\\">~</span><var>p</var></span>” says the same thing as “<span class=\\\"mathmode\\\"><var>q</var></span>”; that “<span class=\\\"mathmode\\\"><var>p</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">∨</span></span><span class=\\\"mathop\\\">~</span><var>p</var></span>” says nothing.\",\"str\":\"\"},{\"label\":\"5.523\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":55,\"x_axis\":81,\"ger\":\"Die Allgemeinheitsbezeichnung tritt als Argument auf.\",\"pmc\":\"The generality-sign occurs as an argument.\",\"ogd\":\"The generality symbol occurs as an argument.\",\"str\":\"\"},{\"label\":\"5.5303\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":55,\"x_axis\":83,\"ger\":\"Beiläufig gesprochen: Von <em class=\\\"germph\\\">zwei</em> Dingen zu sagen, sie seien identisch, ist ein Unsinn, und von <em class=\\\"germph\\\">Einem</em> zu sagen, es sei identisch mit sich selbst, sagt gar nichts.\",\"pmc\":\"Roughly speaking, to say of <em>two</em> things that they are identical is nonsense, and to say of <em>one</em> thing that it is identical with itself is to say nothing at all.\",\"ogd\":\"Roughly speaking: to say of <em>two</em> things that they are identical is nonsense, and to say of <em>one</em> thing that it is identical with itself is to say nothing.\",\"str\":\"\"},{\"label\":\"5.533\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":55,\"x_axis\":85,\"ger\":\"Das Gleichheitszeichen ist also kein wesentlicher Bestandteil der Begriffsschrift.\",\"pmc\":\"The identity-sign, therefore, is not an essential constituent of conceptual notation.\",\"ogd\":\"The identity sign is therefore not an essential constituent of logical notation.\",\"str\":\"\"},{\"label\":\"5.553\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":55,\"x_axis\":99,\"ger\":\"Russell sagte, es gäbe einfache Relationen zwischen verschiedenen Anzahlen von Dingen (Individuals). Aber zwischen welchen Anzahlen? Und wie soll sich das entscheiden? – Durch die Erfahrung? (Eine ausgezeichnete Zahl gibt es nicht.)\",\"pmc\":\"Russell said that there were simple relations between different numbers of things (individuals). But between what numbers? And how is this supposed to be decided?—By experience? (There is no privileged number.)\",\"ogd\":\"Russell said that there were simple relations between different numbers of things (individuals). But between what numbers? And how should this be decided—by experience? (There is no pre-eminent number.)\",\"str\":\"\"},{\"label\":\"6.423\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":55,\"x_axis\":111,\"ger\":\"Vom Willen als dem Träger des Ethischen kann nicht gesprochen werden. Und der Wille als Phänomen interessiert nur die Psychologie.\",\"pmc\":\"It is impossible to speak about the will in so far as it is the subject of ethical attributes. And the will as a phenomenon is of interest only to psychology.\",\"ogd\":\"Of the will as the subject of the ethical we cannot speak. And the will as a phenomenon is only of interest to psychology.\",\"str\":\"\"},{\"label\":\"4.5\",\"precision\":1,\"fontSize\":\"40px\",\"y_axis\":57,\"x_axis\":51,\"ger\":\"Nun scheint es möglich zu sein, die allgemeinste Satzform anzugeben: das heißt, eine Beschreibung der Sätze <em class=\\\"germph\\\">irgend einer</em> Zeichensprache zu geben, so dass jeder mögliche Sinn durch ein Symbol, auf welches die Beschreibung passt, ausgedrückt werden kann, und dass jedes Symbol, worauf die Beschreibung passt, einen Sinn ausdrücken kann, wenn die Bedeutungen der Namen entsprechend gewählt werden. Es ist klar, dass bei der Beschreibung der allgemeinsten Satzform <em class=\\\"germph\\\">nur</em> ihr Wesentliches beschrieben werden darf, – sonst wäre sie nämlich nicht die allgemeinste. Dass es eine allgemeine Satzform gibt, wird dadurch bewiesen, dass es keinen Satz geben darf, dessen Form man nicht hätte voraussehen (d. h. konstruieren) können. Die allgemeine Form des Satzes ist: Es verhält sich so und so.\",\"pmc\":\"It now seems possible to give the most general propositional form: that is, to give a description of the propositions of <em>any</em> sign-language <em>whatsoever</em> in such a way that every possible sense can be expressed by a symbol satisfying the description, and every symbol satisfying the description can express a sense, provided that the meanings of the names are suitably chosen. It is clear that <em>only</em> what is essential to the most general propositional form may be included in its description—for otherwise it would not be the most general form. The existence of a general propositional form is proved by the fact that there cannot be a proposition whose form could not have been foreseen (i.e. constructed). The general form of a proposition is: This is how things stand.\",\"ogd\":\"Now it appears to be possible to give the most general form of proposition; <em>i.e.</em> to give a description of the propositions of some one sign language, so that every possible sense can be expressed by a symbol, which falls under the description, and so that every symbol which falls under the description can express a sense, if the meanings of the names are chosen accordingly. It is clear that in the description of the most general form of proposition <em>only</em> what is essential to it may be described—otherwise it would not be the most general form. That there is a general form is proved by the fact that there cannot be a proposition whose form could not have been foreseen (<em>i.e.</em> constructed). The general form of proposition is: Such and such is the case.\",\"str\":\"\"},{\"label\":\"4.51\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":57,\"x_axis\":53,\"ger\":\"Angenommen, mir wären <em class=\\\"germph\\\">alle</em> Elementarsätze gegeben: Dann lässt sich einfach fragen: Welche Sätze kann ich aus ihnen bilden? Und das sind <em class=\\\"germph\\\">alle</em> Sätze und <em class=\\\"germph\\\">so</em> sind sie begrenzt.\",\"pmc\":\"Suppose that I am given <em>all</em> elementary propositions: then I can simply ask what propositions I can construct out of them. And there I have <em>all</em> propositions, and <em>that</em> fixes their limits.\",\"ogd\":\"Suppose <em>all</em> elementary propositions were given me: then we can simply ask: what propositions I can build out of them. And these are <em>all</em> propositions and <em>so</em> are they limited.\",\"str\":\"\"},{\"label\":\"4.52\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":57,\"x_axis\":55,\"ger\":\"Die Sätze sind alles, was aus der Gesamtheit aller Elementarsätze folgt (natürlich auch daraus, dass es die <em class=\\\"germph\\\">Gesamtheit aller</em> ist). (So könnte man in gewissem Sinne sagen, dass <em class=\\\"germph\\\">alle</em> Sätze Verallgemeinerungen der Elementarsätze sind.)\",\"pmc\":\"Propositions comprise all that follows from the totality of all elementary propositions (and, of course, from its being the <em>totality</em> of them <em>all</em>). (Thus, in a certain sense, it could be said that <em>all</em> propositions were generalizations of elementary propositions.)\",\"ogd\":\"The propositions are everything which follows from the totality of all elementary propositions (of course also from the fact that it is the <em>totality of them all</em>). (So, in some sense, one could say, that <em>all</em> propositions are generalizations of the elementary propositions.)\",\"str\":\"\"},{\"label\":\"4.53\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":57,\"x_axis\":57,\"ger\":\"Die allgemeine Satzform ist eine Variable.\",\"pmc\":\"The general propositional form is a variable.\",\"ogd\":\"The general proposition form is a variable.\",\"str\":\"\"},{\"label\":\"4.463\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":57,\"x_axis\":63,\"ger\":\"Die Wahrheitsbedingungen bestimmen den Spielraum, der den Tatsachen durch den Satz gelassen wird. (Der Satz, das Bild, das Modell, sind im negativen Sinne wie ein fester Körper, der die Bewegungsfreiheit der anderen beschränkt; im positiven Sinne, wie der von fester Substanz begrenzte Raum, worin ein Körper Platz hat.) Die Tautologie lässt der Wirklichkeit den ganzen – unendlichen – logischen Raum; die Kontradiktion erfüllt den ganzen logischen Raum und lässt der Wirklichkeit keinen Punkt. Keine von beiden kann daher die Wirklichkeit irgendwie bestimmen.\",\"pmc\":\"The truth-conditions of a proposition determine the range that it leaves open to the facts. (A proposition, a picture, or a model is, in the negative sense, like a solid body that restricts the freedom of movement of others, and, in the positive sense, like a space bounded by solid substance in which there is room for a body.) A tautology leaves open to reality the whole—the infinite whole—of logical space: a contradiction fills the whole of logical space leaving no point of it for reality. Thus neither of them can determine reality in any way.\",\"ogd\":\"The truth-conditions determine the range, which is left to the facts by the proposition. (The proposition, the picture, the model, are in a negative sense like a solid body, which restricts the free movement of another: in a positive sense, like the space limited by solid substance, in which a body may be placed.) Tautology leaves to reality the whole infinite logical space; contradiction fills the whole logical space and leaves no point to reality. Neither of them, therefore, can in any way determine reality.\",\"str\":\"\"},{\"label\":\"5.514\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":57,\"x_axis\":77,\"ger\":\"Ist eine Notation festgelegt, so gibt es in ihr eine Regel, nach der alle <span class=\\\"mathmode\\\"><var>p</var></span> verneinenden Sätze gebildet werden, eine Regel, nach der alle <span class=\\\"mathmode\\\"><var>p</var></span> bejahenden Sätze gebildet werden, eine Regel, nach der alle <span class=\\\"mathmode\\\"><var>p</var></span> oder <span class=\\\"mathmode\\\"><var>q</var></span> bejahenden Sätze gebildet werden, u.&nbsp;s.&nbsp;f. Diese Regeln sind den Symbolen äquivalent und in ihnen spiegelt sich ihr Sinn wieder.\",\"pmc\":\"Once a notation has been established, there will be in it a rule governing the construction of all propositions that negate <span class=\\\"mathmode\\\"><var>p</var></span>, a rule governing the construction of all propositions that affirm <span class=\\\"mathmode\\\"><var>p</var></span>, and a rule governing the construction of all propositions that affirm <span class=\\\"mathmode\\\"><var>p</var></span> or <span class=\\\"mathmode\\\"><var>q</var></span>; and so on. These rules are equivalent to the symbols; and in them their sense is mirrored.\",\"ogd\":\"If a notation is fixed, there is in it a rule according to which all the propositions denying <span class=\\\"mathmode\\\"><var>p</var></span> are constructed, a rule according to which all the propositions asserting <span class=\\\"mathmode\\\"><var>p</var></span> are constructed, a rule according to which all the propositions asserting <span class=\\\"mathmode\\\"><var>p</var></span> or <span class=\\\"mathmode\\\"><var>q</var></span> are constructed, and so on. These rules are equivalent to the symbols and in them their sense is mirrored.\",\"str\":\"\"},{\"label\":\"5.524\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":57,\"x_axis\":81,\"ger\":\"Wenn die Gegenstände gegeben sind, so sind uns damit auch schon <em class=\\\"germph\\\">alle</em> Gegenstände gegeben. Wenn die Elementarsätze gegeben sind, so sind damit auch <em class=\\\"germph\\\">alle</em> Elementarsätze gegeben.\",\"pmc\":\"If objects are given, then at the same time we are given <em>all</em> objects. If elementary propositions are given, then at the same time <em>all</em> elementary propositions are given.\",\"ogd\":\"If the objects are given, therewith are <em>all</em> objects also given. If the elementary propositions are given, then therewith <em>all</em> elementary propositions are also given.\",\"str\":\"\"},{\"label\":\"5.534\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":57,\"x_axis\":85,\"ger\":\"Und nun sehen wir, dass Scheinsätze wie: „<span class=\\\"mathmode\\\"><var>a</var><span class=\\\"mathrel\\\">=</span><var>a</var></span>“, „<span class=\\\"mathmode\\\"><var>a</var><span class=\\\"mathrel\\\">=</span><var>b</var><span class=\\\"mathrel\\\">.</span><var>b</var><span class=\\\"mathrel\\\">=</span><var>c</var><span class=\\\"mathrel\\\">.<span class=\\\"symbol\\\">⊃</span></span><var>a</var><span class=\\\"mathrel\\\">=</span><var>c</var></span>“, „<span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<var>x</var>).</span><var>x</var><span class=\\\"mathrel\\\">=</span><var>x</var></span>“, „<span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<span class=\\\"symbol\\\">∃</span><var>x</var>).</span><var>x</var><span class=\\\"mathrel\\\">=</span><var>a</var></span>“, etc. sich in einer richtigen Begriffsschrift gar nicht hinschreiben lassen.\",\"pmc\":\"And now we see that in a correct conceptual notation pseudo-propositions like ‘<span class=\\\"mathmode\\\"><var>a</var><span class=\\\"mathrel\\\">=</span><var>a</var></span>’, ‘<span class=\\\"mathmode\\\"><var>a</var><span class=\\\"mathrel\\\">=</span><var>b</var><span class=\\\"mathrel\\\">.</span><var>b</var><span class=\\\"mathrel\\\">=</span><var>c</var><span class=\\\"mathrel\\\">.<span class=\\\"symbol\\\">⊃</span></span><var>a</var><span class=\\\"mathrel\\\">=</span><var>c</var></span>’, ‘<span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<var>x</var>).</span><var>x</var><span class=\\\"mathrel\\\">=</span><var>x</var></span>’, ‘<span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<span class=\\\"symbol\\\">∃</span><var>x</var>).</span><var>x</var><span class=\\\"mathrel\\\">=</span><var>a</var></span>’, etc. cannot even be written down.\",\"ogd\":\"And we see that the apparent propositions like: “<span class=\\\"mathmode\\\"><var>a</var><span class=\\\"mathrel\\\">=</span><var>a</var></span>”, “<span class=\\\"mathmode\\\"><var>a</var><span class=\\\"mathrel\\\">=</span><var>b</var><span class=\\\"mathrel\\\">.</span><var>b</var><span class=\\\"mathrel\\\">=</span><var>c</var><span class=\\\"mathrel\\\">.<span class=\\\"symbol\\\">⊃</span></span><var>a</var><span class=\\\"mathrel\\\">=</span><var>c</var></span>”, “<span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<var>x</var>).</span><var>x</var><span class=\\\"mathrel\\\">=</span><var>x</var></span>”. “<span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<span class=\\\"symbol\\\">∃</span><var>x</var>).</span><var>x</var><span class=\\\"mathrel\\\">=</span><var>a</var></span>”, etc. cannot be written in a correct logical notation at all.\",\"str\":\"\"},{\"label\":\"5.554\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":57,\"x_axis\":99,\"ger\":\"Die Angabe jeder speziellen Form wäre vollkommen willkürlich.\",\"pmc\":\"It would be completely arbitrary to give any specific form.\",\"ogd\":\"The enumeration of any special forms would be entirely arbitrary.\",\"str\":\"\"},{\"label\":\"5.5541\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":57,\"x_axis\":101,\"ger\":\"Es soll sich a priori angeben lassen, ob ich z. B. in die Lage kommen kann, etwas mit dem Zeichen einer 27-stelligen Relation bezeichnen zu müssen.\",\"pmc\":\"It is supposed to be possible to answer <em>a priori</em> the question whether I can get into a position in which I need the sign for a 27-termed relation in order to signify something.\",\"ogd\":\"How could we decide a priori whether, for example, I can get into a situation in which I need to symbolize with a sign of a 27-termed relation?\",\"str\":\"\"},{\"label\":\"5.5542\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":57,\"x_axis\":103,\"ger\":\"Dürfen wir denn aber überhaupt so fragen? Können wir eine Zeichenform aufstellen und nicht wissen, ob ihr etwas entsprechen könne? Hat die Frage einen Sinn: Was muss <em class=\\\"germph\\\">sein</em>, damit etwas der-Fall-sein kann?\",\"pmc\":\"But is it really legitimate even to ask such a question? Can we set up a form of sign without knowing whether anything can correspond to it? Does it make sense to ask what there must <em>be</em> in order that something can be the case?\",\"ogd\":\"May we then ask this at all? Can we set out a sign form and not know whether anything can correspond to it? Has the question sense: what must there <em>be</em> in order that anything can be the case?\",\"str\":\"\"},{\"label\":\"6.5\",\"precision\":1,\"fontSize\":\"40px\",\"y_axis\":57,\"x_axis\":107,\"ger\":\"Zu einer Antwort, die man nicht aussprechen kann, kann man auch die Frage nicht aussprechen. <em class=\\\"germph\\\">Das Rätsel</em> gibt es nicht. Wenn sich eine Frage überhaupt stellen lässt, so <em class=\\\"germph\\\">kann</em> sie auch beantwortet werden.\",\"pmc\":\"When the answer cannot be put into words, neither can the question be put into words. <em>The riddle</em> does not exist. If a question can be framed at all, it is also <em>possible</em> to answer it.\",\"ogd\":\"For an answer which cannot be expressed the question too cannot be expressed. <em>The riddle</em> does not exist. If a question can be put at all, then it <em>can</em> also be answered.\",\"str\":\"\"},{\"label\":\"6.51\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":57,\"x_axis\":109,\"ger\":\"Skeptizismus ist <em class=\\\"germph\\\">nicht</em> unwiderleglich, sondern offenbar unsinnig, wenn er bezweifeln will, wo nicht gefragt werden kann. Denn Zweifel kann nur bestehen, wo eine Frage besteht; eine Frage nur, wo eine Antwort besteht, und diese nur, wo etwas <em class=\\\"germph\\\">gesagt</em> werden <em class=\\\"germph\\\">kann</em>.\",\"pmc\":\"Scepticism is <em>not</em> irrefutable, but obviously nonsensical, when it tries to raise doubts where no questions can be asked. For doubt can exist only where a question exists, a question only where an answer exists, and an answer only where something <em>can be said</em>.\",\"ogd\":\"Scepticism is <em>not</em> irrefutable, but palpably senseless, if it would doubt where a question cannot be asked. For doubt can only exist where there is a question; a question only where there is an answer, and this only where something <em>can</em> be <em>said</em>.\",\"str\":\"\"},{\"label\":\"6.52\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":57,\"x_axis\":111,\"ger\":\"Wir fühlen, dass, selbst wenn alle <em class=\\\"germph\\\">möglichen</em> wissenschaftlichen Fragen beantwortet sind, unsere Lebensprobleme noch gar nicht berührt sind. Freilich bleibt dann eben keine Frage mehr; und eben dies ist die Antwort.\",\"pmc\":\"We feel that even when <em>all possible</em> scientific questions have been answered, the problems of life remain completely untouched. Of course there are then no questions left, and this itself is the answer.\",\"ogd\":\"We feel that even if <em>all possible</em> scientific questions be answered, the problems of life have still not been touched at all. Of course there is then no question left, and just this is the answer.\",\"str\":\"\"},{\"label\":\"6.53\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":57,\"x_axis\":113,\"ger\":\"Die richtige Methode der Philosophie wäre eigentlich die: Nichts zu sagen, als was sich sagen lässt, also Sätze der Naturwissenschaft – also etwas, was mit Philosophie nichts zu tun hat –&nbsp;, und dann immer, wenn ein anderer etwas Metaphysisches sagen wollte, ihm nachzuweisen, dass er gewissen Zeichen in seinen Sätzen keine Bedeutung gegeben hat. Diese Methode wäre für den anderen unbefriedigend – er hätte nicht das Gefühl, dass wir ihn Philosophie lehrten – aber <em class=\\\"germph\\\">sie</em> wäre die einzig streng richtige.\",\"pmc\":\"The correct method in philosophy would really be the following: to say nothing except what can be said, i.e. propositions of natural science—i.e. something that has nothing to do with philosophy—and then, whenever someone else wanted to say something metaphysical, to demonstrate to him that he had failed to give a meaning to certain signs in his propositions. Although it would not be satisfying to the other person—he would not have the feeling that we were teaching him philosophy—<em>this</em> method would be the only strictly correct one.\",\"ogd\":\"The right method of philosophy would be this: To say nothing except what can be said, <em>i.e.</em> the propositions of natural science, <em>i.e.</em> something that has nothing to do with philosophy: and then always, when someone else wished to say something metaphysical, to demonstrate to him that he had given no meaning to certain signs in his propositions. This method would be unsatisfying to the other—he would not have the feeling that we were teaching him philosophy—but it would be the only strictly correct method.\",\"str\":\"\"},{\"label\":\"6.54\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":57,\"x_axis\":115,\"ger\":\"Meine Sätze erläutern dadurch, dass sie der, welcher mich versteht, am Ende als unsinnig erkennt, wenn er durch sie – auf ihnen – über sie hinausgestiegen ist. (Er muss sozusagen die Leiter wegwerfen, nachdem er auf ihr hinaufgestiegen ist.) Er muss diese Sätze überwinden, dann sieht er die Welt richtig.\",\"pmc\":\"My propositions serve as elucidations in the following way: anyone who understands me eventually recognizes them as nonsensical, when he has used them—as steps—to climb up beyond them. (He must, so to speak, throw away the ladder after he has climbed up it.) He must transcend these propositions, and then he will see the world aright.\",\"ogd\":\"My propositions are elucidatory in this way: he who understands me finally recognizes them as senseless, when he has climbed out through them, on them, over them. (He must so to speak throw away the ladder, after he has climbed up on it.) He must surmount these propositions; then he sees the world rightly.\",\"str\":\"\"},{\"label\":\"4.464\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":59,\"x_axis\":63,\"ger\":\"Die Wahrheit der Tautologie ist gewiss, des Satzes möglich, der Kontradiktion unmöglich. (Gewiss, möglich, unmöglich: Hier haben wir das Anzeichen jener Gradation, die wir in der Wahrscheinlichkeitslehre brauchen.)\",\"pmc\":\"A tautology’s truth is certain, a proposition’s possible, a contradiction’s impossible. (Certain, possible, impossible: here we have the first indication of the scale that we need in the theory of probability.)\",\"ogd\":\"The truth of tautology is certain, of propositions possible, of contradiction impossible. (Certain, possible, impossible: here we have an indication of that gradation which we need in the theory of probability.)\",\"str\":\"\"},{\"label\":\"5.515\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":59,\"x_axis\":77,\"ger\":\"Es muss sich an unseren Symbolen zeigen, dass das, was durch „∨“, „.“, etc. miteinander verbunden ist, Sätze sein müssen. Und dies ist auch der Fall, denn das Symbol „<span class=\\\"mathmode\\\"><var>p</var></span>“ und „<span class=\\\"mathmode\\\"><var>q</var></span>“ setzt ja selbst das „∨“, „~“, etc. voraus. Wenn das Zeichen „<span class=\\\"mathmode\\\"><var>p</var></span>“ in „<span class=\\\"mathmode\\\"><var>p</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">∨</span></span><var>q</var></span>“ nicht für ein komplexes Zeichen steht, dann kann es allein nicht Sinn haben; dann können aber auch die mit „<span class=\\\"mathmode\\\"><var>p</var></span>“ gleichsinnigen Zeichen „<span class=\\\"mathmode\\\"><var>p</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">∨</span></span><var>p</var></span>“, „<span class=\\\"mathmode\\\"><var>p</var><span class=\\\"mathrel\\\">.</span><var>p</var></span>“, etc. keinen Sinn haben. Wenn aber „<span class=\\\"mathmode\\\"><var>p</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">∨</span></span><var>p</var></span>“ keinen Sinn hat, dann kann auch „<span class=\\\"mathmode\\\"><var>p</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">∨</span></span><var>q</var></span>“ keinen Sinn haben.\",\"pmc\":\"It must be manifest in our symbols that it can only be propositions that are combined with one another by ‘∨’, ‘.’, etc. And this is indeed the case, since the symbol in ‘<span class=\\\"mathmode\\\"><var>p</var></span>’ and ‘<span class=\\\"mathmode\\\"><var>q</var></span>’ itself presupposes ‘∨’, ‘~’, etc. If the sign ‘<span class=\\\"mathmode\\\"><var>p</var></span>’ in ‘<span class=\\\"mathmode\\\"><var>p</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">∨</span></span><var>q</var></span>’ does not stand for a complex sign, then it cannot have sense by itself: but in that case the signs ‘<span class=\\\"mathmode\\\"><var>p</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">∨</span></span><var>p</var></span>’, ‘<span class=\\\"mathmode\\\"><var>p</var><span class=\\\"mathrel\\\">.</span><var>p</var></span>’, etc., which have the same sense as <span class=\\\"mathmode\\\"><var>p</var></span>, must also lack sense. But if ‘<span class=\\\"mathmode\\\"><var>p</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">∨</span></span><var>p</var></span>’ has no sense, then ‘<span class=\\\"mathmode\\\"><var>p</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">∨</span></span><var>q</var></span>’ cannot have a sense either.\",\"ogd\":\"It must be recognized in our symbols that what is connected by “∨”, “.”, etc., must be propositions. And this is the case, for the symbols “<span class=\\\"mathmode\\\"><var>p</var></span>” and “<span class=\\\"mathmode\\\"><var>q</var></span>” presuppose “∨”, “~”, etc. If the sign “<span class=\\\"mathmode\\\"><var>p</var></span>” in “<span class=\\\"mathmode\\\"><var>p</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">∨</span></span><var>q</var></span>” does not stand for a complex sign, then by itself it cannot have sense; but then also the signs “<span class=\\\"mathmode\\\"><var>p</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">∨</span></span><var>p</var></span>”, “<span class=\\\"mathmode\\\"><var>p</var><span class=\\\"mathrel\\\">.</span><var>p</var></span>”, etc. which have the same sense as “<span class=\\\"mathmode\\\"><var>p</var></span>” have no sense. If, however, “<span class=\\\"mathmode\\\"><var>p</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">∨</span></span><var>p</var></span>” has no sense, then also “<span class=\\\"mathmode\\\"><var>p</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">∨</span></span><var>q</var></span>” can have no sense.\",\"str\":\"\"},{\"label\":\"5.5151\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":59,\"x_axis\":79,\"ger\":\"Muss das Zeichen des negativen Satzes mit dem Zeichen des positiven gebildet werden? Warum sollte man den negativen Satz nicht durch eine negative Tatsache ausdrücken können. (Etwa: Wenn „<span class=\\\"mathmode\\\"><var>a</var></span>“ nicht in einer bestimmten Beziehung zu „<span class=\\\"mathmode\\\"><var>b</var></span>“ steht, könnte das ausdrücken, dass <span class=\\\"mathmode\\\"><var>aRb</var></span> nicht der Fall ist.) Aber auch hier ist ja der negative Satz indirekt durch den positiven gebildet. Der positive <em class=\\\"germph\\\">Satz</em> muss die Existenz des negativen <em class=\\\"germph\\\">Satzes</em> voraussetzen und umgekehrt.\",\"pmc\":\"Must the sign of a negative proposition be constructed with that of the positive proposition? Why should it not be possible to express a negative proposition by means of a negative fact? (E.g. suppose that ‘<span class=\\\"mathmode\\\"><var>a</var></span>’ does not stand in a certain relation to ‘<span class=\\\"mathmode\\\"><var>b</var></span>’; then this might be used to say that <span class=\\\"mathmode\\\"><var>aRb</var></span> was not the case.) But really even in this case the negative proposition is constructed by an indirect use of the positive. The positive <em>proposition</em> necessarily presupposes the existence of the negative <em>proposition</em> and <em>vice versa</em>.\",\"ogd\":\"Must the sign of the negative proposition be constructed by means of the sign of the positive? Why should one not be able to express the negative proposition by means of a negative fact? (Like: if “<span class=\\\"mathmode\\\"><var>a</var></span>” does not stand in a certain relation to “<span class=\\\"mathmode\\\"><var>b</var></span>”, it could express that <span class=\\\"mathmode\\\"><var>aRb</var></span> is not the case.) But here also the negative proposition is indirectly constructed with the positive. The positive <em>proposition</em> must presuppose the existence of the negative <em>proposition</em> and conversely.\",\"str\":\"\"},{\"label\":\"5.525\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":59,\"x_axis\":81,\"ger\":\"Es ist unrichtig, den Satz „<span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<span class=\\\"symbol\\\">∃</span><var>x</var>).</span><var>fx</var></span>“ – wie Russell dies tut – in Worten durch „<span class=\\\"mathmode\\\"><var>fx</var></span> ist <em class=\\\"germph\\\">möglich</em>“ wiederzugeben. Gewissheit, Möglichkeit oder Unmöglichkeit einer Sachlage wird nicht durch einen Satz ausgedrückt, sondern dadurch, dass ein Ausdruck eine Tautologie, ein sinnvoller Satz oder eine Kontradiktion ist. Jener Präzedenzfall, auf den man sich immer berufen möchte, muss schon im Symbol selber liegen.\",\"pmc\":\"It is incorrect to render the proposition ‘<span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<span class=\\\"symbol\\\">∃</span><var>x</var>).</span><var>fx</var></span>’ in the words, ‘<span class=\\\"mathmode\\\"><var>fx</var></span> is <em>possible</em>’ as Russell does. The certainty, possibility, or impossibility of a situation is not expressed by a proposition, but by an expression’s being a tautology, a proposition with a sense, or a contradiction. The precedent to which we are constantly inclined to appeal must reside in the symbol itself.\",\"ogd\":\"It is not correct to render the proposition “<span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<span class=\\\"symbol\\\">∃</span><var>x</var>).</span><var>fx</var></span>”—as Russell does—in the words “<span class=\\\"mathmode\\\"><var>fx</var></span> is <em>possible</em>”. Certainty, possibility or impossibility of a state of affairs are not expressed by a proposition but by the fact that an expression is a tautology, a significant proposition or a contradiction. That precedent to which one would always appeal, must be present in the symbol itself.\",\"str\":\"\"},{\"label\":\"5.535\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":59,\"x_axis\":85,\"ger\":\"Damit erledigen sich auch alle Probleme, die an solche Scheinsätze geknüpft waren. Alle Probleme, die Russells „Axiom of Infinity“ mit sich bringt, sind schon hier zu lösen. Das, was das Axiom of Infinity sagen soll, würde sich in der Sprache dadurch ausdrücken, dass es unendlich viele Namen mit verschiedener Bedeutung gäbe.\",\"pmc\":\"This also disposes of all the problems that were connected with such pseudo-propositions. All the problems that Russell’s ‘axiom of infinity’ brings with it can be solved at this point. What the axiom of infinity is intended to say would express itself in language through the existence of infinitely many names with different meanings.\",\"ogd\":\"So all problems disappear which are connected with such pseudo-propositions. This is the place to solve all the problems with arise through Russell’s “Axiom of Infinity”. What the axiom of infinity is meant to say would be expressed in language by the fact that there is an infinite number of names with different meanings.\",\"str\":\"\"},{\"label\":\"5.5351\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":59,\"x_axis\":87,\"ger\":\"Es gibt gewisse Fälle, wo man in Versuchung gerät, Ausdrücke von der Form „<span class=\\\"mathmode\\\"><var>a</var><span class=\\\"mathrel\\\">=</span><var>a</var></span>“ oder „<span class=\\\"mathmode\\\"><var>p</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">⊃</span></span><var>p</var></span>“ u. dgl. zu benützen. Und zwar geschieht dies, wenn man von dem Urbild: Satz, Ding, etc. reden möchte. So hat Russell in den „Principles of Mathematics“ den Unsinn „<span class=\\\"mathmode\\\"><var>p</var></span> ist ein Satz“ in Symbolen durch „<span class=\\\"mathmode\\\"><var>p</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">⊃</span></span><var>p</var></span>“ wiedergegeben und als Hypothese vor gewisse Sätze gestellt, damit deren Argumentstellen nur von Sätzen besetzt werden könnten. (Es ist schon darum Unsinn, die Hypothese <span class=\\\"mathmode\\\"><var>p</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">⊃</span></span><var>p</var></span> vor einen Satz zu stellen, um ihm Argumente der richtigen Form zu sichern, weil die Hypothese für einen Nicht-Satz als Argument nicht falsch, sondern unsinnig wird, und weil der Satz selbst durch die unrichtige Gattung von Argumenten unsinnig wird, also sich selbst ebenso gut, oder so schlecht, vor den unrechten Argumenten bewahrt wie die zu diesem Zweck angehängte sinnlose Hypothese.)\",\"pmc\":\"There are certain cases in which one is tempted to use expressions of the form ‘<span class=\\\"mathmode\\\"><var>a</var><span class=\\\"mathrel\\\">=</span><var>a</var></span>’ or ‘<span class=\\\"mathmode\\\"><var>p</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">⊃</span></span><var>p</var></span>’ and the like. In fact, this happens when one wants to talk about prototypes, e.g. about proposition, thing, etc. Thus in Russell’s <em>Principles of Mathematics</em> ‘<span class=\\\"mathmode\\\"><var>p</var></span> is a proposition’—which is nonsense—was given the symbolic rendering ‘<span class=\\\"mathmode\\\"><var>p</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">⊃</span></span><var>p</var></span>’ and placed as an hypothesis in front of certain propositions in order to exclude from their argument-places everything but propositions. (It is nonsense to place the hypothesis ‘<span class=\\\"mathmode\\\"><var>p</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">⊃</span></span><var>p</var></span>’ in front of a proposition, in order to ensure that its arguments shall have the right form, if only because with a non-proposition as argument the hypothesis becomes not false but nonsensical, and because arguments of the wrong kind make the proposition itself nonsensical, so that it preserves itself from wrong arguments just as well, or as badly, as the hypothesis without sense that was appended for that purpose.)\",\"ogd\":\"There are certain cases in which one is tempted to use expressions of the form “<span class=\\\"mathmode\\\"><var>a</var><span class=\\\"mathrel\\\">=</span><var>a</var></span>” or “<span class=\\\"mathmode\\\"><var>p</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">⊃</span></span><var>p</var></span>”. As, for instance, when one would speak of the archetype Proposition, Thing, etc. So Russell in the <em>Principles of Mathematics</em> has rendered the nonsense “<span class=\\\"mathmode\\\"><var>p</var></span> is a proposition” in symbols by “<span class=\\\"mathmode\\\"><var>p</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">⊃</span></span><var>p</var></span>” and has put it as hypothesis before certain propositions to show that their places for arguments could only be occupied by propositions. (It is nonsense to place the hypothesis <span class=\\\"mathmode\\\"><var>p</var><span class=\\\"mathrel\\\"><span class=\\\"symbol\\\">⊃</span></span><var>p</var></span> before a proposition in order to ensure that its arguments have the right form, because the hypotheses for a non-proposition as argument becomes not false but meaningless, and because the proposition itself becomes senseless for arguments of the wrong kind, and therefore it survives the wrong arguments no better and no worse than the senseless hypothesis attached for this purpose.)\",\"str\":\"\"},{\"label\":\"5.5352\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":59,\"x_axis\":89,\"ger\":\"Ebenso wollte man „Es gibt keine <em class=\\\"germph\\\">Dinge</em>“ ausdrücken durch „<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><span class=\\\"quant\\\">(<span class=\\\"symbol\\\">∃</span><var>x</var>).</span><var>x</var><span class=\\\"mathrel\\\">=</span><var>x</var></span>“. Aber selbst wenn dies ein Satz wäre – wäre er nicht auch wahr, wenn es zwar „Dinge gäbe“, aber diese nicht mit sich selbst identisch wären?\",\"pmc\":\"In the same way people have wanted to express, ‘There are no <em>things</em>’, by writing ‘<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><span class=\\\"quant\\\">(<span class=\\\"symbol\\\">∃</span><var>x</var>).</span><var>x</var><span class=\\\"mathrel\\\">=</span><var>x</var></span>’. But even if this were a proposition, would it not be equally true if in fact ‘there were things’ but they were not identical with themselves?\",\"ogd\":\"Similarly it was proposed to express “There are no things” by “<span class=\\\"mathmode\\\"><span class=\\\"mathop\\\">~</span><span class=\\\"quant\\\">(<span class=\\\"symbol\\\">∃</span><var>x</var>).</span><var>x</var><span class=\\\"mathrel\\\">=</span><var>x</var></span>”. But even if this were a proposition—would it not be true if indeed “There were things”, but these were not identical with themselves?\",\"str\":\"\"},{\"label\":\"5.555\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":59,\"x_axis\":99,\"ger\":\"Es ist klar, wir haben vom Elementarsatz einen Begriff, abgesehen von seiner besonderen logischen Form. Wo man aber Symbole nach einem System bilden kann, dort ist dieses System das logisch wichtige und nicht die einzelnen Symbole. Und wie wäre es auch möglich, dass ich es in der Logik mit Formen zu tun hätte, die ich erfinden kann; sondern mit dem muss ich es zu tun haben, was es mir möglich macht, sie zu erfinden.\",\"pmc\":\"Clearly we have some concept of elementary propositions quite apart from their particular logical forms. But when there is a system by which we can create symbols, the system is what is important for logic and not the individual symbols. And anyway, is it really possible that in logic I should have to deal with forms that I can invent? What I have to deal with must be that which makes it possible for me to invent them.\",\"ogd\":\"It is clear that we have a concept of the elementary proposition apart from its special logical form. Where, however, we can build symbols according to a system, there this system is the logically important thing and not the single symbols. And how would it be possible that I should have to deal with forms in logic which I can invent: but I must have to deal with that which makes it possible for me to invent them.\",\"str\":\"\"},{\"label\":\"6.521\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":59,\"x_axis\":111,\"ger\":\"Die Lösung des Problems des Lebens merkt man am Verschwinden dieses Problems. (Ist nicht dies der Grund, warum Menschen, denen der Sinn des Lebens nach langen Zweifeln klar wurde, warum diese dann nicht sagen konnten, worin dieser Sinn bestand?)\",\"pmc\":\"The solution of the problem of life is seen in the vanishing of the problem. (Is not this the reason why those who have found after a long period of doubt that the sense of life became clear to them have then been unable to say what constituted that sense?)\",\"ogd\":\"The solution of the problem of life is seen in the vanishing of this problem. (Is not this the reason why men to whom after long doubting the sense of life became clear, could not then say wherein this sense consisted?)\",\"str\":\"\"},{\"label\":\"4.465\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":61,\"x_axis\":63,\"ger\":\"Das logische Produkt einer Tautologie und eines Satzes sagt dasselbe, wie der Satz. Also ist jenes Produkt identisch mit dem Satz. Denn man kann das Wesentliche des Symbols nicht ändern, ohne seinen Sinn zu ändern.\",\"pmc\":\"The logical product of a tautology and a proposition says the same thing as the proposition. This product, therefore, is identical with the proposition. For it is impossible to alter what is essential to a symbol without altering its sense.\",\"ogd\":\"The logical product of a tautology and a proposition says the same as the proposition. Therefore that product is identical with the proposition. For the essence of the symbol cannot be altered without altering its sense.\",\"str\":\"\"},{\"label\":\"5.526\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":61,\"x_axis\":81,\"ger\":\"Man kann die Welt vollständig durch vollkommen verallgemeinerte Sätze beschreiben, das heißt also, ohne irgendeinen Namen von vornherein einem bestimmten Gegenstand zuzuordnen. Um dann auf die gewöhnliche Ausdrucksweise zu kommen, muss man einfach nach einem Ausdruck: „Es gibt ein und nur ein <span class=\\\"mathmode\\\"><var>x</var></span>, welches …“ sagen: Und dies <span class=\\\"mathmode\\\"><var>x</var></span> ist <span class=\\\"mathmode\\\"><var>a</var></span>.\",\"pmc\":\"We can describe the world completely by means of fully generalized propositions, i.e. without first correlating any name with a particular object. Then, in order to arrive at the customary mode of expression, we simply need to add, after an expression like, ‘There is one and only one <span class=\\\"mathmode\\\"><var>x</var></span> such that …’, the words, ‘and that <span class=\\\"mathmode\\\"><var>x</var></span> is <span class=\\\"mathmode\\\"><var>a</var></span>’.\",\"ogd\":\"One can describe the world completely by completely generalized propositions, <em>i.e.</em> without from the outset co-ordinating any name with a definite object. In order then to arrive at the customary way of expression we need simply say after an expression “there is one and only one <span class=\\\"mathmode\\\"><var>x</var></span>, which …”: and this <span class=\\\"mathmode\\\"><var>x</var></span> is <span class=\\\"mathmode\\\"><var>a</var></span>.\",\"str\":\"\"},{\"label\":\"5.5261\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":61,\"x_axis\":83,\"ger\":\"Ein vollkommen verallgemeinerter Satz ist, wie jeder andere Satz, zusammengesetzt. (Dies zeigt sich daran, dass wir in „<span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<span class=\\\"symbol\\\">∃</span><var>x</var>, <var>φ</var>).</span><var>φx</var></span>“ „<span class=\\\"mathmode\\\"><var>φ</var></span>“ und „<span class=\\\"mathmode\\\"><var>x</var></span>“ getrennt erwähnen müssen. Beide stehen unabhängig in bezeichnenden Beziehungen zur Welt, wie im unverallgemeinerten Satz.) Kennzeichen des zusammengesetzten Symbols: Es hat etwas mit <em class=\\\"germph\\\">anderen</em> Symbolen gemeinsam.\",\"pmc\":\"A fully generalized proposition, like every other proposition, is composite. (This is shown by the fact that in ‘<span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<span class=\\\"symbol\\\">∃</span><var>x</var>, <var>φ</var>).</span><var>φx</var></span>’ we have to mention ‘<span class=\\\"mathmode\\\"><var>φ</var></span>’ and ‘<span class=\\\"mathmode\\\"><var>x</var></span>’ separately. They both, independently, stand in signifying relations to the world, just as is the case in ungeneralized propositions.) It is a mark of a composite symbol that it has something in common with <em>other</em> symbols.\",\"ogd\":\"A completely generalized proposition is like every other proposition composite. (This is shown by the fact that in “<span class=\\\"mathmode\\\"><span class=\\\"quant\\\">(<span class=\\\"symbol\\\">∃</span><var>x</var>, <var>φ</var>).</span><var>φx</var></span>” we must mention “<span class=\\\"mathmode\\\"><var>φ</var></span>” and “<span class=\\\"mathmode\\\"><var>x</var></span>” separately. Both stand independently in signifying relations to the world as in the ungeneralized proposition.) A characteristic of a composite symbol: it has something in common with <em>other</em> symbols.\",\"str\":\"\"},{\"label\":\"5.5262\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":61,\"x_axis\":85,\"ger\":\"Es verändert ja die Wahr- oder Falschheit <em class=\\\"germph\\\">jedes</em> Satzes etwas am allgemeinen Bau der Welt. Und der Spielraum, welcher ihrem Bau durch die Gesamtheit der Elementarsätze gelassen wird, ist eben derjenige, welchen die ganz allgemeinen Sätze begrenzen. (Wenn ein Elementarsatz wahr ist, so ist damit doch jedenfalls Ein Elementarsatz <em class=\\\"germph\\\">mehr</em> wahr.)\",\"pmc\":\"The truth or falsity of <em>every</em> proposition does make some alteration in the general construction of the world. And the range that the totality of elementary propositions leaves open for its construction is exactly the same as that which is delimited by entirely general propositions. (If an elementary proposition is true, that means, at any rate, one <em>more</em> true elementary proposition.)\",\"ogd\":\"The truth or falsehood of <em>every</em> proposition alters something in the general structure of the world. And the range which is allowed to its structure by the totality of elementary propositions is exactly that which the completely general propositions delimit. (If an elementary proposition is true, then, at any rate, there is one <em>more</em> elementary proposition true.)\",\"str\":\"\"},{\"label\":\"5.556\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":61,\"x_axis\":99,\"ger\":\"Eine Hierarchie der Formen der Elementarsätze kann es nicht geben. Nur was wir selbst konstruieren, können wir voraussehen.\",\"pmc\":\"There cannot be a hierarchy of the forms of elementary propositions. We can foresee only what we ourselves construct.\",\"ogd\":\"There cannot be a hierarchy of the forms of the elementary propositions. Only that which we ourselves construct can we foresee.\",\"str\":\"\"},{\"label\":\"5.5561\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":61,\"x_axis\":101,\"ger\":\"Die empirische Realität ist begrenzt durch die Gesamtheit der Gegenstände. Die Grenze zeigt sich wieder in der Gesamtheit der Elementarsätze. Die Hierarchien sind, und müssen unabhängig von der Realität sein.\",\"pmc\":\"Empirical reality is limited by the totality of objects. The limit also makes itself manifest in the totality of elementary propositions. Hierarchies are and must be independent of reality.\",\"ogd\":\"Empirical reality is limited by the totality of objects. The boundary appears again in the totality of elementary propositions. The hierarchies are and must be independent of reality.\",\"str\":\"\"},{\"label\":\"5.5562\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":61,\"x_axis\":103,\"ger\":\"Wissen wir aus rein logischen Gründen, dass es Elementarsätze geben muss, dann muss es jeder wissen, der die Sätze in ihrer unanalysierten Form versteht.\",\"pmc\":\"If we know on purely logical grounds that there must be elementary propositions, then everyone who understands propositions in their unanalyzed form must know it.\",\"ogd\":\"If we know on purely logical grounds, that there must be elementary propositions, then this must be known by everyone who understands propositions in their unanalysed form.\",\"str\":\"\"},{\"label\":\"5.5563\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":61,\"x_axis\":105,\"ger\":\"Alle Sätze unserer Umgangssprache sind tatsächlich, so wie sie sind, logisch vollkommen geordnet. – Jenes Einfachste, was wir hier angeben sollen, ist nicht ein Gleichnis der Wahrheit, sondern die volle Wahrheit selbst. (Unsere Probleme sind nicht abstrakt, sondern vielleicht die konkretesten, die es gibt.)\",\"pmc\":\"In fact, all the propositions of our everyday language, just as they stand, are in perfect logical order.—That utterly simple thing, which we have to formulate here, is not an image of the truth, but the truth itself in its entirety. (Our problems are not abstract, but perhaps the most concrete that there are.)\",\"ogd\":\"All propositions of our colloquial language are actually, just as they are, logically completely in order. That simple thing which we ought to give here is not a model of the truth but the complete truth itself. (Our problems are not abstract but perhaps the most concrete that there are.)\",\"str\":\"\"},{\"label\":\"6.522\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":61,\"x_axis\":111,\"ger\":\"Es gibt allerdings Unaussprechliches. Dies <em class=\\\"germph\\\">zeigt</em> sich, es ist das Mystische.\",\"pmc\":\"There are, indeed, things that cannot be put into words. They <em>make themselves manifest</em>. They are what is mystical.\",\"ogd\":\"There is indeed the inexpressible. This <em>shows</em> itself; it is the mystical.\",\"str\":\"\"},{\"label\":\"4.466\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":63,\"x_axis\":63,\"ger\":\"Einer bestimmten logischen Verbindung von Zeichen entspricht eine bestimmte logische Verbindung ihrer Bedeutungen; <em class=\\\"germph\\\">jede beliebige</em> Verbindung entspricht nur den unverbundenen Zeichen. Das heißt, Sätze, die für jede Sachlage wahr sind, können überhaupt keine Zeichenverbindungen sein, denn sonst könnten ihnen nur bestimmte Verbindungen von Gegenständen entsprechen. (Und keiner logischen Verbindung entspricht <em class=\\\"germph\\\">keine</em> Verbindung der Gegenstände.) Tautologie und Kontradiktion sind die Grenzfälle der Zeichenverbindung, nämlich ihre Auflösung.\",\"pmc\":\"What corresponds to a determinate logical combination of signs is a determinate logical combination of their meanings. It is only to the uncombined signs that <em>absolutely any</em> combination corresponds. In other words, propositions that are true for every situation cannot be combinations of signs at all, since, if they were, only determinate combinations of objects could correspond to them. (And what is not a logical combination has <em>no</em> combination of objects corresponding to it.) Tautology and contradiction are the limiting cases—indeed the disintegration—of the combination of signs.\",\"ogd\":\"To a definite logical combination of signs corresponds a definite logical combination of their meanings; <em>every arbitrary</em> combination only corresponds to the unconnected signs. That is, propositions which are true for every state of affairs cannot be combinations of signs at all, for otherwise there could only correspond to them definite combinations of objects. (And to no logical combination corresponds <em>no</em> combination of the objects.) Tautology and contradiction are the limiting cases of the combination of symbols, namely their dissolution.\",\"str\":\"\"},{\"label\":\"4.4661\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":63,\"x_axis\":65,\"ger\":\"Freilich sind auch in der Tautologie und Kontradiktion die Zeichen noch mit einander verbunden, d. h. sie stehen in Beziehungen zu einander, aber diese Beziehungen sind bedeutungslos, dem <em class=\\\"germph\\\">Symbol</em> unwesentlich.\",\"pmc\":\"Admittedly the signs are still combined with one another even in tautologies and contradictions—i.e. they stand in certain relations to one another: but these relations have no meaning, they are not essential to the <em>symbol</em>.\",\"ogd\":\"Of course the signs are also combined with one another in the tautology and contradiction, <em>i.e.</em> they stand in relations to one another, but these relations are meaningless, unessential to the <em>symbol</em>.\",\"str\":\"\"},{\"label\":\"5.6\",\"precision\":1,\"fontSize\":\"40px\",\"y_axis\":63,\"x_axis\":75,\"ger\":\"<em class=\\\"germph\\\">Die Grenzen meiner Sprache</em> bedeuten die Grenzen meiner Welt.\",\"pmc\":\"<em>The limits of my language</em> mean the limits of my world.\",\"ogd\":\"<em>The limits of my language</em> mean the limits of my world.\",\"str\":\"\"},{\"label\":\"5.61\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":63,\"x_axis\":77,\"ger\":\"Die Logik erfüllt die Welt; die Grenzen der Welt sind auch ihre Grenzen. Wir können also in der Logik nicht sagen: Das und das gibt es in der Welt, jenes nicht. Das würde nämlich scheinbar voraussetzen, dass wir gewisse Möglichkeiten ausschließen, und dies kann nicht der Fall sein, da sonst die Logik über die Grenzen der Welt hinaus müsste; wenn sie nämlich diese Grenzen auch von der anderen Seite betrachten könnte. Was wir nicht denken können, das können wir nicht denken; wir können also auch nicht <em class=\\\"germph\\\">sagen</em>, was wir nicht denken können.\",\"pmc\":\"Logic pervades the world: the limits of the world are also its limits. So we cannot say in logic, ‘The world has this in it, and this, but not that.’ For that would appear to presuppose that we were excluding certain possibilities, and this cannot be the case, since it would require that logic should go beyond the limits of the world; for only in that way could it view those limits from the other side as well. We cannot think what we cannot think; so what we cannot think we cannot <em>say</em> either.\",\"ogd\":\"Logic fills the world: the limits of the world are also its limits. We cannot therefore say in logic: This and this there is in the world, that there is not. For that would apparently presuppose that we exclude certain possibilities, and this cannot be the case since otherwise logic must get outside the limits of the world: that is, if it could consider these limits from the other side also. What we cannot think, that we cannot think: we cannot therefore <em>say</em> what we cannot think.\",\"str\":\"\"},{\"label\":\"5.62\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":63,\"x_axis\":79,\"ger\":\"Diese Bemerkung gibt den Schlüssel zur Entscheidung der Frage, inwieweit der Solipsismus eine Wahrheit ist. Was der Solipsismus nämlich <em class=\\\"germph\\\">meint</em>, ist ganz richtig, nur lässt es sich nicht <em class=\\\"germph\\\">sagen</em>, sondern es zeigt sich. Dass die Welt <em class=\\\"germph\\\">meine</em> Welt ist, das zeigt sich darin, dass die Grenzen <em class=\\\"germph\\\">der</em> Sprache (der Sprache, die allein ich verstehe) die Grenzen <em class=\\\"germph\\\">meiner</em> Welt bedeuten.\",\"pmc\":\"This remark provides the key to the problem, how much truth there is in solipsism. For what the solipsist <em>means</em> is quite correct; only it cannot be <em>said</em>, but makes itself manifest. The world is <em>my</em> world: this is manifest in the fact that the limits of <em>language</em> (of that language which alone I understand) mean the limits of <em>my</em> world.\",\"ogd\":\"This remark provides a key to the question, to what extent solipsism is a truth. In fact what solipsism <em>means</em>, is quite correct, only it cannot be <em>said</em>, but it shows itself. That the world is <em>my</em> world, shows itself in the fact that the limits of the language (<em>the</em> language which I understand) mean the limits of <em>my</em> world.\",\"str\":\"\"},{\"label\":\"5.63\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":63,\"x_axis\":81,\"ger\":\"Ich bin meine Welt. (Der Mikrokosmos.)\",\"pmc\":\"I am my world. (The microcosm.)\",\"ogd\":\"I am my world. (The microcosm.)\",\"str\":\"\"},{\"label\":\"5.64\",\"precision\":2,\"fontSize\":\"40px\",\"y_axis\":63,\"x_axis\":83,\"ger\":\"Hier sieht man, dass der Solipsismus, streng durchgeführt, mit dem reinen Realismus zusammenfällt. Das Ich des Solipsismus schrumpft zum ausdehnungslosen Punkt zusammen, und es bleibt die ihm koordinierte Realität.\",\"pmc\":\"Here it can be seen that solipsism, when its implications are followed out strictly, coincides with pure realism. The self of solipsism shrinks to a point without extension, and there remains the reality co-ordinated with it.\",\"ogd\":\"Here we see that solipsism strictly carried out coincides with pure realism. The I in solipsism shrinks to an extensionless point and there remains the reality co-ordinated with it.\",\"str\":\"\"},{\"label\":\"5.557\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":63,\"x_axis\":99,\"ger\":\"Die <em class=\\\"germph\\\">Anwendung</em> der Logik entscheidet darüber, welche Elementarsätze es gibt. Was in der Anwendung liegt, kann die Logik nicht vorausnehmen. Das ist klar: Die Logik darf mit ihrer Anwendung nicht kollidieren. Aber die Logik muss sich mit ihrer Anwendung berühren. Also dürfen die Logik und ihre Anwendung einander nicht übergreifen.\",\"pmc\":\"The <em>application</em> of logic decides what elementary propositions there are. What belongs to its application, logic cannot anticipate. It is clear that logic must not clash with its application. But logic has to be in contact with its application. Therefore logic and its application must not overlap.\",\"ogd\":\"The <em>application</em> of logic decides what elementary propositions there are. What lies in its application logic cannot anticipate. It is clear that logic may not conflict with its application. But logic must have contact with its application. Therefore logic and its application may not overlap one another.\",\"str\":\"\"},{\"label\":\"5.5571\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":63,\"x_axis\":101,\"ger\":\"Wenn ich die Elementarsätze nicht a priori angeben kann, dann muss es zu offenbarem Unsinn führen, sie angeben zu wollen.\",\"pmc\":\"If I cannot say <em>a priori</em> what elementary propositions there are, then the attempt to do so must lead to obvious nonsense.\",\"ogd\":\"If I cannot give elementary propositions a priori then it must lead to obvious nonsense to try to give them.\",\"str\":\"\"},{\"label\":\"5.621\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":65,\"x_axis\":79,\"ger\":\"Die Welt und das Leben sind Eins.\",\"pmc\":\"The world and life are one.\",\"ogd\":\"The world and life are one.\",\"str\":\"\"},{\"label\":\"5.631\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":65,\"x_axis\":81,\"ger\":\"Das denkende, vorstellende, Subjekt gibt es nicht. Wenn ich ein Buch schriebe „Die Welt, wie ich sie vorfand“, so wäre darin auch über meinen Leib zu berichten und zu sagen, welche Glieder meinem Willen unterstehen und welche nicht, etc., dies ist nämlich eine Methode, das Subjekt zu isolieren, oder vielmehr zu zeigen, dass es in einem wichtigen Sinne kein Subjekt gibt: Von ihm allein nämlich könnte in diesem Buche <em class=\\\"germph\\\">nicht</em> die Rede sein.—\",\"pmc\":\"There is no such thing as the subject that thinks or entertains ideas. If I wrote a book called <em>The World as I found it</em>, I should have to include a report on my body, and should have to say which parts were subordinate to my will, and which were not, etc., this being a method of isolating the subject, or rather of showing that in an important sense there is no subject; for it alone could <em>not</em> be mentioned in that book.—\",\"ogd\":\"The thinking, presenting subject; there is no such thing. If I wrote a book “The world as I found it”, I should also have therein to report on my body and say which members obey my will and which do not, etc. This then would be a method of isolating the subject or rather of showing that in an important sense there is no subject: that is to say, of it alone in this book mention could <em>not</em> be made.\",\"str\":\"\"},{\"label\":\"5.641\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":65,\"x_axis\":83,\"ger\":\"Es gibt also wirklich einen Sinn, in welchem in der Philosophie nichtpsychologisch vom Ich die Rede sein kann. Das Ich tritt in die Philosophie dadurch ein, dass „die Welt meine Welt ist“. Das philosophische Ich ist nicht der Mensch, nicht der menschliche Körper, oder die menschliche Seele, von der die Psychologie handelt, sondern das metaphysische Subjekt, die Grenze –nicht ein Teil – der Welt.\",\"pmc\":\"Thus there really is a sense in which philosophy can talk about the self in a non-psychological way. What brings the self into philosophy is the fact that ‘the world is my world’. The philosophical self is not the human being, not the human body, or the human soul, with which psychology deals, but rather the metaphysical subject, the limit of the world—not a part of it.\",\"ogd\":\"There is therefore really a sense in which the philosophy we can talk of a non-psychological I. The I occurs in philosophy through the fact that the “world is my world”. The philosophical I is not the man, not the human body or the human soul of which psychology treats, but the metaphysical subject, the limit—not a part of the world.\",\"str\":\"\"},{\"label\":\"5.632\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":67,\"x_axis\":81,\"ger\":\"Das Subjekt gehört nicht zur Welt, sondern es ist eine Grenze der Welt.\",\"pmc\":\"The subject does not belong to the world: rather, it is a limit of the world.\",\"ogd\":\"The subject does not belong to the world but it is a limit of the world.\",\"str\":\"\"},{\"label\":\"5.633\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":69,\"x_axis\":81,\"ger\":\"Wo <em class=\\\"germph\\\">in</em> der Welt ist ein metaphysisches Subjekt zu merken? Du sagst, es verhält sich hier ganz wie mit Auge und Gesichtsfeld. Aber das Auge siehst du wirklich <em class=\\\"germph\\\">nicht</em>. Und nichts <em class=\\\"germph\\\">am Gesichtsfeld</em> lässt darauf schließen, dass es von einem Auge gesehen wird.\",\"pmc\":\"Where <em>in</em> the world is a metaphysical subject to be found? You will say that this is exactly like the case of the eye and the visual field. But really you do <em>not</em> see the eye. And nothing <em>in the visual field</em> allows you to infer that it is seen by an eye.\",\"ogd\":\"<em>Where in</em> the world is a metaphysical subject to be noted? You say that this case is altogether like that of the eye and the field of sight. But you do <em>not</em> really see the eye. And from nothing <em>in the field of sight</em> can it be concluded that it is seen from an eye.\",\"str\":\"\"},{\"label\":\"5.6331\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":69,\"x_axis\":83,\"ger\":\"Das Gesichtsfeld hat nämlich nicht etwa eine solche Form: <!-- noindent --><div class=\\\"centered\\\"><span class=\\\"sfmiddle\\\"><span class=\\\"lowered\\\">Auge —</span><object data=\\\"../images/theeye.svg\\\" type=\\\"image/svg+xml\\\" class=\\\"theeyesvg\\\"><img src=\\\"images/theeye.png\\\" alt=\\\"Eye image\\\" class=\\\"theeyepng\\\" /></object></span></div>\",\"pmc\":\"For the form of the visual field is surely not like this <!-- noindent --><div class=\\\"centered\\\"><span class=\\\"sfmiddle\\\"><span class=\\\"lowered\\\">Eye —</span><object data=\\\"../images/theeye.svg\\\" type=\\\"image/svg+xml\\\" class=\\\"theeyesvg\\\"><img src=\\\"images/theeye.png\\\" alt=\\\"Eye image\\\" class=\\\"theeyepng\\\" /></object></span></div>\",\"ogd\":\"For the field of sight has not a form like this: <!-- noindent --><div class=\\\"centered\\\"><span class=\\\"sfmiddle\\\"><span class=\\\"lowered\\\">Eye —</span><object data=\\\"../images/theeye.svg\\\" type=\\\"image/svg+xml\\\" class=\\\"theeyesvg\\\"><img src=\\\"images/theeye.png\\\" alt=\\\"Eye image\\\" class=\\\"theeyepng\\\" /></object></span></div>\",\"str\":\"\"},{\"label\":\"5.634\",\"precision\":3,\"fontSize\":\"18px\",\"y_axis\":71,\"x_axis\":81,\"ger\":\"Das hängt damit zusammen, dass kein Teil unserer Erfahrung auch a priori ist. Alles, was wir sehen, könnte auch anders sein. Alles, was wir überhaupt beschreiben können, könnte auch anders sein. Es gibt keine Ordnung der Dinge a priori.\",\"pmc\":\"This is connected with the fact that no part of our experience is at the same time <em>a priori</em>. Whatever we see could be other than it is. Whatever we can describe at all could be other than it is. There is no <em>a priori</em> order of things.\",\"ogd\":\"This is connected with the fact that no part of our experience is also a priori. Everything we see could also be otherwise. Everything we describe at all could also be otherwise. There is no order of things a priori.\",\"str\":\"\"},{\"label\":\"6.0121\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":7,\"x_axis\":111,\"ger\":\"\",\"ogd\":\"\",\"str\":\"\"},{\"label\":\"6.2311\",\"precision\":4,\"fontSize\":\"18px\",\"y_axis\":29,\"x_axis\":115,\"ger\":\"\",\"ogd\":\"\",\"str\":\"\"}]};\n\n//# sourceURL=webpack:///./src/data/sections.json?");

/***/ }),

/***/ "./src/line.js":
/*!*********************!*\
  !*** ./src/line.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Line = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _point = __webpack_require__(/*! ./point */ \"./src/point.js\");\n\nvar _section = __webpack_require__(/*! ./section */ \"./src/section.js\");\n\nvar _lodash = __webpack_require__(/*! lodash */ \"./node_modules/lodash/lodash.js\");\n\nvar _ = _interopRequireWildcard(_lodash);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Line = exports.Line = function () {\n    function Line(label, sections, start, end, precision, color) {\n        _classCallCheck(this, Line);\n\n        this._label = label;\n        this._sections = sections;\n        this._start = start;\n        this._end = end;\n        this._precision = precision;\n        this._color = color;\n    }\n\n    _createClass(Line, [{\n        key: \"findPoints\",\n        value: function findPoints(container) {\n            var start = this._start,\n                end = this._end,\n                startPoint = _.filter(container.sectionList.sections, {\n                \"label\": start.toString()\n            }),\n                endPoint = _.filter(container.sectionList.sections, {\n                \"label\": end.toString()\n            });\n            var point = new _point.Point(startPoint[0].x_axis, endPoint[0].x_axis, startPoint[0].y_axis, endPoint[0].y_axis, this._color);\n            return point;\n        }\n    }, {\n        key: \"buildGroup\",\n        value: function buildGroup(container) {\n            var sectionList = container.sectionList;\n            var sectionAr = [];\n            var sections = this.sections;\n            var line = this;\n            var color = this.checkLineColor(container.pageFilteredPTList, line.start, line.end, line.color);\n            $.each(sectionList.sections, function () {\n                var o = $(this)[0];\n                if (container.template == 'tlp' || color == '#E8E8EE' || o.page >= container.startPage && o.page <= container.endPage || o.stroke == '#E8E8EE') {\n                    var section = new _section.Section(o.label, o.fontSize, o.precision, o.x_axis, o.y_axis, o.ger, o.ogd, o.pmc, o.str);\n                    sectionAr.push(section);\n                }\n            });\n            //loop through list of line section array, as well as all sections and if the labels match, display the text\n            for (var j = 0; j < sections.length; j++) {\n                for (var k = 0; k < sectionAr.length; k++) {\n                    if (sections[j].toString() == sectionAr[k].label) {\n                        container.divCounter = sectionAr[k].displayText(false, container.version, container.divCounter, container.template, container.util);\n                    }\n                }\n            }\n        }\n        // if the line is in the current start and end range, use its original color. If not, make it grey\n\n    }, {\n        key: \"checkLineColor\",\n        value: function checkLineColor(sections, startValue, endValue, color) {\n            var startVal = startValue;\n            var endVal = endValue;\n            var resultStart = _.includes(sections, parseFloat(startVal));\n            var resultEnd = _.includes(sections, parseFloat(endVal));\n            var finalColor = void 0;\n            if (resultStart == true && resultEnd === true) {\n                finalColor = color;\n            } else {\n                finalColor = '#E8E8EE';\n            }\n            return finalColor;\n        }\n    }, {\n        key: \"label\",\n        get: function get() {\n            return this._label;\n        },\n        set: function set(value) {\n            this._label = value;\n        }\n    }, {\n        key: \"sections\",\n        get: function get() {\n            return this._sections;\n        },\n        set: function set(value) {\n            this._sections = value;\n        }\n    }, {\n        key: \"start\",\n        get: function get() {\n            return this._start;\n        },\n        set: function set(value) {\n            this._start = value;\n        }\n    }, {\n        key: \"end\",\n        get: function get() {\n            return this._end;\n        },\n        set: function set(value) {\n            this._end = value;\n        }\n    }, {\n        key: \"precision\",\n        get: function get() {\n            return this._precision;\n        },\n        set: function set(value) {\n            this._precision = value;\n        }\n    }, {\n        key: \"color\",\n        get: function get() {\n            return this._color;\n        },\n        set: function set(value) {\n            this._color = value;\n        }\n    }, {\n        key: \"sectionList\",\n        get: function get() {\n            return this._sectionList;\n        },\n        set: function set(value) {\n            this._sectionList = value;\n        }\n    }]);\n\n    return Line;\n}();\n\n//# sourceURL=webpack:///./src/line.js?");

/***/ }),

/***/ "./src/point.js":
/*!**********************!*\
  !*** ./src/point.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Point = exports.Point = function () {\n    function Point(x1, x2, y1, y2, color) {\n        _classCallCheck(this, Point);\n\n        this._x1 = x1;\n        this._x2 = x2;\n        this._y1 = y1;\n        this._y2 = y2;\n        this._color = color;\n    }\n\n    _createClass(Point, [{\n        key: \"x1\",\n        get: function get() {\n            return this._x1;\n        },\n        set: function set(value) {\n            this._x1 = value;\n        }\n    }, {\n        key: \"x2\",\n        get: function get() {\n            return this._x2;\n        },\n        set: function set(value) {\n            this._x2 = value;\n        }\n    }, {\n        key: \"y1\",\n        get: function get() {\n            return this._y1;\n        },\n        set: function set(value) {\n            this._y1 = value;\n        }\n    }, {\n        key: \"y2\",\n        get: function get() {\n            return this._y2;\n        },\n        set: function set(value) {\n            this._y2 = value;\n        }\n    }, {\n        key: \"color\",\n        get: function get() {\n            return this._color;\n        },\n        set: function set(value) {\n            this._color = value;\n        }\n    }]);\n\n    return Point;\n}();\n\n//# sourceURL=webpack:///./src/point.js?");

/***/ }),

/***/ "./src/pt-section.js":
/*!***************************!*\
  !*** ./src/pt-section.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar PTSection = exports.PTSection = function PTSection(label, page, tlp, pmc, ger, str) {\n    _classCallCheck(this, PTSection);\n\n    this.label = label;\n    this.page = page;\n    this.tlp = tlp;\n    this.pmc = pmc;\n    this.ger = ger;\n    this.str = str;\n};\n\n//# sourceURL=webpack:///./src/pt-section.js?");

/***/ }),

/***/ "./src/reference.js":
/*!**************************!*\
  !*** ./src/reference.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar sectionsJson = __webpack_require__(/*! ./data/sections.json */ \"./src/data/sections.json\");\nvar ptSectionsJson = __webpack_require__(/*! ./data/ptSections.json */ \"./src/data/ptSections.json\");\nvar linesJson = __webpack_require__(/*! ./data/lines.json */ \"./src/data/lines.json\");\nvar ptLinesJson = __webpack_require__(/*! ./data/ptLines.json */ \"./src/data/ptLines.json\");\n//todo - add more references here that are imported on each page\nvar Reference = exports.Reference = undefined;\n(function (Reference) {\n    var Ref = function () {\n        function Ref() {\n            _classCallCheck(this, Ref);\n\n            this._sectionsJson = sectionsJson;\n            this._ptSectionsJson = ptSectionsJson;\n            this._linesJson = linesJson;\n            this._ptLinesJson = ptLinesJson;\n        }\n\n        _createClass(Ref, [{\n            key: 'sectionsJson',\n            get: function get() {\n                return this._sectionsJson;\n            },\n            set: function set(value) {\n                this._sectionsJson = value;\n            }\n        }, {\n            key: 'ptSectionsJson',\n            get: function get() {\n                return this._ptSectionsJson;\n            },\n            set: function set(value) {\n                this._ptSectionsJson = value;\n            }\n        }, {\n            key: 'linesJson',\n            get: function get() {\n                return this._linesJson;\n            },\n            set: function set(value) {\n                this._linesJson = value;\n            }\n        }, {\n            key: 'ptLinesJson',\n            get: function get() {\n                return this._ptLinesJson;\n            },\n            set: function set(value) {\n                this._ptLinesJson = value;\n            }\n        }]);\n\n        return Ref;\n    }();\n\n    Reference.Ref = Ref;\n})(Reference || (exports.Reference = Reference = {}));\n\n//# sourceURL=webpack:///./src/reference.js?");

/***/ }),

/***/ "./src/section.js":
/*!************************!*\
  !*** ./src/section.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Section = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _lodash = __webpack_require__(/*! lodash */ \"./node_modules/lodash/lodash.js\");\n\nvar _ = _interopRequireWildcard(_lodash);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Section = exports.Section = function () {\n    function Section(label, fontSize, precision, x_axis, y_axis, ger, ogd, pmc, str) {\n        _classCallCheck(this, Section);\n\n        this.label = label;\n        this.fontSize = fontSize;\n        this.precision = precision;\n        this.x_axis = x_axis;\n        this.y_axis = y_axis;\n        this.ger = ger;\n        this.ogd = ogd;\n        this.pmc = pmc;\n        this.str = str;\n    }\n\n    _createClass(Section, [{\n        key: \"getTextForSelectedVersion\",\n        value: function getTextForSelectedVersion(version) {\n            var v = void 0;\n            if (version == \"ger\") {\n                v = this.ger;\n            } else if (version == \"ogd\") {\n                v = this.ogd;\n            } else if (version == \"pmc\") {\n                v = this.pmc;\n            } else if (version == \"str\") {\n                v = this.str;\n            }\n            return v;\n        }\n    }, {\n        key: \"displayText\",\n        value: function displayText(showSelector, version, divCounter, template, util) {\n            var div = \"collapse\" + divCounter;\n            //create a new div and append to accordion div. Add 'Section ' + to line 48 for optional label\n            var element = $('<div class=\"panel panel-default\">' + '<div class=\"panel-heading\" data-toggle=\"collapse\" href=\"#' + div + '\" class=\"accordion-toggle\" >' + '<h4 class=\"panel-title\">' + '<a class=\"accordion-header\">' + this.label + '<span class=\"glyphicon glyphicon-remove close-panel\" style=\"float:right\"></span></a>' + '</h4>' + '</div>' + '<div id=\"' + div + '\" class=\"panel-collapse collapse in\"><div class=\"panel-body\" value=\"' + this.label + '\"></div>').appendTo('#accordion');\n            var text = this.getTextForSelectedVersion(version);\n            //showSelector will be true when an individual Section/Circle is clicked.  Will be false when a line is clicked.\n            if (showSelector) {\n                //append the language selector\n                var langVersion = template == \"pt\" ? 'pt-lang-version.html' : 'lang-version.html';\n                $('#' + div + ' .panel-body').append($('<div>').load(langVersion, function () {\n                    $('.version-selector').val(version);\n                }));\n                element.addClass(\"individual-section\");\n            }\n            $('#' + div + ' .panel-body').attr('ger', this.getTextForSelectedVersion('ger'));\n            $('#' + div + ' .panel-body').attr('ogd', this.getTextForSelectedVersion('ogd'));\n            $('#' + div + ' .panel-body').attr('pmc', this.getTextForSelectedVersion('pmc'));\n            $('#' + div + ' .panel-body').attr('str', this.getTextForSelectedVersion('str'));\n            $('#' + div + ' .panel-body').append($('<li class=\"text-display-li\">' + text + '</li>').load(text, function () {\n                MathJax.Hub.Queue([\"Typeset\", MathJax.Hub, div]);\n            }));\n            $(\".accordion-column\").show();\n            //the Collapseable panels will now show, and the tractatus map will move over to the right.\n            $(\".map-column\").removeClass('col-md-12').addClass('col-md-9');\n            //check if page is pt\n            if (template == 'pt') {\n                var label = this.label;\n                var textLabel = label.toString();\n                var returnVal = util.findDiff(textLabel, version);\n                $('#' + div).append('<br /><div class=\"pnum\">text difference when compared to TLP ' + util.ptToTlp(textLabel) + '</div>');\n                $('#' + div).append(returnVal);\n            }\n            return divCounter + 1;\n        }\n        // if the circle is in the current start and end range, use its original color. If not, make it grey\n\n    }, {\n        key: \"checkCircleColor\",\n        value: function checkCircleColor(sections, startValue, color) {\n            var startVal = Number(startValue);\n            var resultStart = _.includes(sections, startVal);\n            if (resultStart === true) {\n                return color;\n            } else {\n                return '#E8E8EE';\n            }\n        }\n    }]);\n\n    return Section;\n}();\n\n//# sourceURL=webpack:///./src/section.js?");

/***/ }),

/***/ "./src/util.js":
/*!*********************!*\
  !*** ./src/util.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Utility = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _lodash = __webpack_require__(/*! lodash */ \"./node_modules/lodash/lodash.js\");\n\nvar _ = _interopRequireWildcard(_lodash);\n\nvar _diff = __webpack_require__(/*! diff */ \"./node_modules/diff/dist/diff.js\");\n\nvar JsDiff = _interopRequireWildcard(_diff);\n\nvar _section = __webpack_require__(/*! ./section */ \"./src/section.js\");\n\nvar _ptSection = __webpack_require__(/*! ./pt-section */ \"./src/pt-section.js\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Utility = exports.Utility = undefined;\n(function (Utility) {\n    var Utils = function () {\n        function Utils() {\n            _classCallCheck(this, Utils);\n        }\n\n        _createClass(Utils, [{\n            key: 'setup',\n            value: function setup() {\n                //populate the ptSectionAr array\n                var ptSectionAr = [];\n                $.each(this.container.ref.ptSectionsJson.sections, function () {\n                    var o = $(this)[0];\n                    var ptSection = new _ptSection.PTSection(o.label, o.page, o.tlp, o.pmc, o.ger, o.str);\n                    ptSectionAr.push(ptSection);\n                });\n                this._ptSectionAr = ptSectionAr;\n            }\n            //find the tlp sections that correspond to the pt label\n\n        }, {\n            key: 'ptToTlp',\n            value: function ptToTlp(textLabel) {\n                var ptsec = void 0,\n                    sectionNum = void 0;\n                ptsec = _.find(this.container.ref.ptSectionsJson.sections, function (obj) {\n                    return obj.label == textLabel;\n                });\n                sectionNum = ptsec.tlp;\n                return sectionNum;\n            }\n            // create an HTML fragment of color-coded text differences between a specified PT number and its corresponding TLP section\n\n        }, {\n            key: 'findDiff',\n            value: function findDiff(textLabel, lang) {\n                var _this = this;\n\n                var sectionNum = this.ptToTlp(textLabel),\n                    sectionContent = this.createHTML(textLabel),\n                    sectionText = $(sectionContent).find(\".\" + lang).text(),\n                    diff = void 0,\n                    fragment = $('<div class=\"diff\"></div>');\n\n                var _loop = function _loop(i) {\n                    _this.container.ref.sectionsJson.sections.forEach(function (d) {\n                        var sec = new _section.Section(d.label, d.fontSize, d.precision, d.x_axis, d.y_axis, d.ger, d.ogd, d.pmc, d.str);\n                        if (d.label == sectionNum[i]) {\n                            var result = sec.getTextForSelectedVersion(lang);\n                            result = result.replace(/<\\/?[^>]+(>|$)/g, \"\");\n                            sectionText = sectionText.replace(/<\\/?[^>]+(>|$)/g, \"\");\n                            diff = JsDiff.diffWords(result, sectionText);\n                            diff.forEach(function (part) {\n                                // blue for additions, red for deletions\n                                // grey for common parts\n                                var color = part.added ? 'red' : part.removed ? 'blue' : 'grey';\n                                var span = document.createElement('span');\n                                span.style.color = color;\n                                span.appendChild(document.createTextNode(part.value));\n                                $(fragment).append(span);\n                            });\n                            $(fragment).append(\"</br/><br/>\");\n                        }\n                    });\n                };\n\n                for (var i = 0; i < sectionNum.length; i++) {\n                    _loop(i);\n                }\n                return fragment;\n            }\n        }, {\n            key: 'createHTML',\n            value: function createHTML(textLabel) {\n                var ptsec = _.find(this._ptSectionAr, function (obj) {\n                    return obj.label.toString() == textLabel;\n                });\n                var html = '<div class=\"sections\"><div class=\"pnum\" id=\"p' + ptsec.label + '\">' + ptsec.label + '</div>\\n            <div class=\"ger\">' + ptsec.ger + '</div>\\n            <div class=\"pmc\">' + ptsec.pmc + '</div></div>;\\n            <div class=\"str\">' + ptsec.str + '</div></div>';\n                return html;\n            }\n        }, {\n            key: 'ptSectionAr',\n            get: function get() {\n                return this._ptSectionAr;\n            },\n            set: function set(value) {\n                this._ptSectionAr = value;\n            }\n        }, {\n            key: 'container',\n            get: function get() {\n                return this._container;\n            },\n            set: function set(value) {\n                this._container = value;\n            }\n        }]);\n\n        return Utils;\n    }();\n\n    Utility.Utils = Utils;\n})(Utility || (exports.Utility = Utility = {}));\n\n//# sourceURL=webpack:///./src/util.js?");

/***/ })

/******/ });